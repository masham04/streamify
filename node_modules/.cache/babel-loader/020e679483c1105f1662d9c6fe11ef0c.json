{"ast":null,"code":"import { PathElement } from '../core/elements/path-element';\nimport { ImageElement } from '../core/elements/image-element';\nimport { TextElement } from '../core/elements/text-element';\nimport { Container } from '../core/containers/container';\nimport { rotateMatrix, identityMatrix, transformPointByMatrix } from '../primitives/matrix';\nimport { Size } from '../primitives/size';\nimport { wordBreakToString, whiteSpaceToString, textAlignToString, randomId } from '../utility/base-util';\nimport { getUserHandlePosition, canShowCorner, getInterval, getSpaceValue } from '../utility/diagram-util';\nimport { getDiagramElement, getAdornerLayer, getGridLayer, getHTMLLayer, updatePath } from '../utility/dom-util';\nimport { measurePath, getBackgroundLayerSvg, getBackgroundImageLayer, setAttributeSvg } from '../utility/dom-util';\nimport { SnapConstraints, RendererAction } from '../enum/enum';\nimport { ThumbsConstraints, SelectorConstraints, ElementAction } from '../enum/enum';\nimport { SvgRenderer } from './svg-renderer';\nimport { CanvasRenderer } from './canvas-renderer';\nimport { processPathData, splitArrayCollection, transformPath } from '../utility/path-util';\nimport { isDiagramChild } from '../utility/diagram-util';\nimport { DiagramNativeElement } from '../core/elements/native-element';\nimport { DiagramHtmlElement } from '../core/elements/html-element';\nimport { Point } from '../primitives/point';\nimport { canDrawThumbs, avoidDrawSelector } from '../utility/constraints-util';\nimport { Diagram } from '../diagram';\n/**\n * Renderer module is used to render basic diagram elements\n */\n\n/** @private */\n\nvar DiagramRenderer =\n/** @class */\nfunction () {\n  function DiagramRenderer(name, svgRender, isSvgMode) {\n    /**   @private  */\n    this.renderer = null;\n    /** @private */\n\n    this.isSvgMode = true;\n    this.transform = {\n      x: 0,\n      y: 0\n    };\n    this.diagramId = name;\n    this.element = getDiagramElement(this.diagramId);\n    this.svgRenderer = svgRender;\n    this.isSvgMode = isSvgMode;\n    this.renderer = isSvgMode ? new SvgRenderer() : new CanvasRenderer();\n  }\n  /**\n   * Method used to set the cur \\\n   *\n   *  @param {HTMLElement} canvas - Provide the canvas .\n   *  @param {string} cursor - Provide the element .\n   * @returns {void }   Method used to set the layer  .\\\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.setCursor = function (canvas, cursor) {\n    canvas.style.cursor = cursor;\n  };\n  /**\n   * Method used to set the layer \\\n   *\n   * @returns {void }   Method used to set the layer  .\\\n   *\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.setLayers = function () {\n    this.iconSvgLayer = this.element.getElementsByClassName('e-ports-expand-layer')[0];\n    this.adornerSvgLayer = this.element.getElementsByClassName('e-adorner-layer')[0];\n    this.nativeSvgLayer = this.element.getElementsByClassName('e-native-layer')[0];\n    this.diagramSvgLayer = this.element.getElementsByClassName('e-diagram-layer')[0];\n  };\n\n  DiagramRenderer.prototype.getAdornerLayer = function () {\n    var adornerLayer = getAdornerLayer(this.diagramId);\n    return adornerLayer;\n  };\n\n  DiagramRenderer.prototype.getParentSvg = function (element, targetElement, canvas) {\n    if (this.diagramId && element && element.id) {\n      if (element.id.split('_icon_content').length > 1 || element.id.split('_nodeport').length > 1 || element.elementActions & ElementAction.ElementIsPort) {\n        return this.iconSvgLayer;\n      }\n\n      if (targetElement && targetElement === 'selector') {\n        return this.adornerSvgLayer;\n      } else if (element instanceof DiagramNativeElement) {\n        return this.nativeSvgLayer;\n      } else {\n        return this.diagramSvgLayer;\n      }\n    }\n\n    return canvas;\n  };\n\n  DiagramRenderer.prototype.getParentElement = function (element, defaultParent, svgElement, indexValue) {\n    var layerGElement = defaultParent;\n\n    if (svgElement && this.diagramId && element && element.id) {\n      if (element.id.split('_icon_content').length > 1) {\n        layerGElement = svgElement.getElementById(this.diagramId + '_diagramExpander');\n        defaultParent = null;\n      } else if (element.id.split('_nodeport').length > 1) {\n        layerGElement = svgElement.getElementById(this.diagramId + '_diagramPorts');\n      } else if (element instanceof DiagramNativeElement) {\n        layerGElement = svgElement.getElementById(this.diagramId + '_nativeLayer');\n        defaultParent = null;\n      } else if (element.elementActions & ElementAction.ElementIsPort) {\n        layerGElement = svgElement.getElementById(this.diagramId + '_diagramPorts');\n        defaultParent = null;\n      } else {\n        layerGElement = svgElement.getElementById(this.diagramId + '_diagramLayer');\n      }\n\n      var groupElement = this.getGroupElement(element, defaultParent || layerGElement, indexValue);\n      layerGElement = groupElement.g;\n\n      if (groupElement.svg) {\n        svgElement = groupElement.svg;\n      }\n    }\n\n    return {\n      g: layerGElement,\n      svg: svgElement\n    };\n  };\n\n  DiagramRenderer.prototype.getGroupElement = function (element, canvas, indexValue) {\n    var gElement;\n    var parentSvg = this.getParentSvg(element);\n    var svgElement;\n\n    if (canvas && parentSvg) {\n      if (parentSvg) {\n        gElement = parentSvg.getElementById(element.id + '_groupElement');\n\n        if (!gElement && parentSvg !== this.nativeSvgLayer) {\n          //code added\n          var nativeSvg = this.nativeSvgLayer;\n          gElement = nativeSvg.getElementById(element.id + '_groupElement');\n          svgElement = nativeSvg;\n        }\n      }\n\n      if (!gElement) {\n        gElement = this.svgRenderer.createGElement('g', {\n          id: element.id + '_groupElement'\n        });\n\n        if (indexValue !== undefined && canvas.childNodes.length > indexValue) {\n          canvas.insertBefore(gElement, canvas.childNodes[indexValue]);\n        } else {\n          canvas.appendChild(gElement);\n        }\n      }\n    }\n\n    return {\n      g: gElement,\n      svg: svgElement\n    };\n  };\n  /**\n   * Method used to render the diagram element \\\n   *\n   * @returns {void }   Method used to render the diagram element  .\\\n   *\n   * @param {DiagramElement} element - Provide the DiagramElement value.\n   * @param {HTMLCanvasElement | SVGElement } canvas - Provide the canvas value.\n   * @param {HTMLElement } htmlLayer - Provide the HTMLElement value.\n   * @param {Transforms } transform - Provide the Transforms value.\n   * @param {SVGSVGElement} parentSvg - Provide the SVGSVGElement value.\n   * @param {boolean } createParent - Provide the boolean value.\n   * @param {boolean } fromPalette - Provide the boolean value.\n   * @param {number } indexValue - Provide the indexValue value.\n   * @param {boolean } isPreviewNode - Provide the isPreviewNode value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderElement = function (element, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint) {\n    var isElement = true;\n\n    if (element instanceof Container) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      isElement = false;\n      element.id = element.id ? element.id : randomId();\n      this.renderContainer(element, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint);\n    } else if (element instanceof ImageElement) {\n      this.renderImageElement(element, canvas, transform, parentSvg, fromPalette);\n    } else if (element instanceof PathElement) {\n      this.renderPathElement(element, canvas, transform, parentSvg, fromPalette, isPreviewNode);\n    } else if (element instanceof TextElement) {\n      this.renderTextElement(element, canvas, transform, parentSvg, fromPalette, centerPoint);\n    } else if (element instanceof DiagramNativeElement) {\n      this.renderNativeElement(element, canvas, transform, parentSvg, fromPalette);\n    } else if (element instanceof DiagramHtmlElement) {\n      this.renderHTMLElement(element, canvas, htmlLayer, transform, parentSvg, fromPalette, indexValue);\n    } else {\n      this.renderRect(element, canvas, transform, parentSvg, isPreviewNode);\n    }\n  };\n  /**\n   * Method used to draw the selection rectangle for the node \\\n   *\n   * @returns {void }  Method used to draw the selection rectangle for the node  .\\\n   *\n   * @param {number} x - Provide the DiagramElement value.\n   * @param {number } y - Provide the SVGElement value.\n   * @param {number } w - Provide the Transforms value.\n   * @param {number } h - Provide the Transforms value.\n   * @param {HTMLCanvasElement | SVGElement } canvas - Provide the Transforms value.\n   * @param {number } t - Provide the Transforms value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.drawSelectionRectangle = function (x, y, w, h, canvas, t) {\n    x = (x + t.tx) * t.scale;\n    y = (y + t.ty) * t.scale;\n    var options = {\n      width: w * t.scale,\n      height: h * t.scale,\n      x: x + 0.5,\n      y: y + 0.5,\n      fill: 'transparent',\n      stroke: 'gray',\n      angle: 0,\n      pivotX: 0.5,\n      pivotY: 0.5,\n      strokeWidth: 1,\n      dashArray: '6 3',\n      opacity: 1,\n      visible: true,\n      id: canvas.id + '_selected_region'\n    };\n    var adornerLayer = this.getAdornerLayer();\n    this.svgRenderer.updateSelectionRegion(adornerLayer, options);\n  };\n  /**\n   * Method used to render the highlighter \\\n   *\n   * @returns {void }  Method used to render the highlighter  .\\\n   *\n   * @param {DiagramElement} element - Provide the DiagramElement value.\n   * @param {SVGElement } canvas - Provide the SVGElement value.\n   * @param {Transforms } transform - Provide the Transforms value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderHighlighter = function (element, canvas, transform) {\n    var width = element.actualSize.width || 2;\n    var height = element.actualSize.height || 2;\n    var x = element.offsetX - width * element.pivot.x;\n    var y = element.offsetY - height * element.pivot.y;\n    x = (x + transform.tx) * transform.scale;\n    y = (y + transform.ty) * transform.scale;\n    var options = {\n      width: width * transform.scale,\n      height: height * transform.scale,\n      x: x,\n      y: y,\n      fill: 'transparent',\n      stroke: '#8CC63F',\n      angle: element.rotateAngle,\n      pivotX: element.pivot.x,\n      pivotY: element.pivot.y,\n      strokeWidth: 4,\n      dashArray: '',\n      opacity: 1,\n      cornerRadius: 0,\n      visible: true,\n      id: canvas.id + '_highlighter',\n      class: 'e-diagram-highlighter'\n    };\n    this.svgRenderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, canvas);\n  };\n  /**\n   * Method used to render the stack highlighter \\\n   *\n   * @returns {void }  Method used to render the stack highlighter  .\\\n   *\n   * @param {DiagramElement} element - Provide the DiagramElement value.\n   * @param {SVGElement } canvas - Provide the SVGElement value.\n   * @param {Transforms } transform - Provide the Transforms value.\n   * @param {boolean} isVertical - Provide the Boolean value.\n   * @param {PointModel } position - Provide the PointModel value.\n   * @param {boolean } isUml - Provide the boolean value.\n   * @param {boolean } isSwimlane - Provide the boolean value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderStackHighlighter = function (element, canvas, transform, isVertical, position, isUml, isSwimlane) {\n    var width = element.actualSize.width || 2;\n    var x = element.offsetX - width * element.pivot.x;\n    var height = element.actualSize.height || 2;\n    var y = element.offsetY - height * element.pivot.y;\n    x = (x + transform.tx) * transform.scale;\n    var data;\n    var bounds = element.bounds;\n    var newPathString = '';\n    y = (y + transform.ty) * transform.scale;\n\n    if (!isVertical) {\n      var d = height * transform.scale;\n      data = 'M 10 -10 L 0 0 Z M -10 -10 L 0 0 Z M 0 0 L 0 ' + d + ' Z M 0  ' + d + ' L -10  ' + (d + 10) + ' Z L 10  ' + (d + 10) + ' Z';\n\n      if (position.x >= element.offsetX) {\n        x += width;\n      }\n    } else {\n      if (isUml) {\n        var d = width * transform.scale;\n        data = 'M 0 0 L ' + (d + 2) + ' 0 Z';\n        var scaleX = -bounds.x;\n        var scaleY = -bounds.y;\n        var arrayCollection = [];\n        scaleX = element.actualSize.width / Number(bounds.width ? bounds.width : 1) * transform.scale;\n        scaleY = element.actualSize.height / Number(bounds.height ? bounds.height : 1) * transform.scale;\n        var umlData = 'M7,4 L8,4 8,7 11,7 11,8 8,8 8,11 7,11 7,8 4,8 4,7 7,7 z M7.5,0.99999994' + 'C3.9160004,1 1,3.9160004 0.99999994,7.5 1,11.084 3.9160004,14 7.5,14 11.084,14 14,11.084 14,7.5 14,' + '3.9160004 11.084,1 7.5,0.99999994 z M7.5,0 C11.636002,0 15,3.3639984 15,7.5 15,11.636002 11.636002,15 7.5,' + '15 3.3640003,15 0,11.636002 0,7.5 0,3.3639984 3.3640003,0 7.5,0 z';\n        arrayCollection = processPathData(umlData);\n        arrayCollection = splitArrayCollection(arrayCollection);\n        newPathString = transformPath(arrayCollection, scaleX + d + 2, scaleY - 8, false, bounds.x, bounds.y, 0, 0);\n\n        if (position.y >= element.offsetY) {\n          y += height;\n        }\n      } else {\n        if (isSwimlane) {\n          if (position.y >= element.offsetY) {\n            y += height;\n          }\n        }\n\n        var d = width * transform.scale;\n        data = 'M -10 -10 L 0 0 Z M -10 10 L 0 0 Z M 0 0 L ' + d + ' 0 Z M ' + d + ' 0 L ' + (d + 10) + ' 10 Z L ' + (d + 10) + ' -10 Z';\n      }\n    }\n\n    var options = {\n      data: data + newPathString,\n      width: width * transform.scale,\n      height: height * transform.scale,\n      x: x,\n      y: y,\n      fill: 'transparent',\n      stroke: '#8CC63F',\n      angle: element.rotateAngle,\n      pivotX: element.pivot.x,\n      pivotY: element.pivot.y,\n      strokeWidth: 1,\n      dashArray: '',\n      opacity: 1,\n      visible: true,\n      id: canvas.id + '_stack_highlighter',\n      class: 'e-diagram-highlighter'\n    };\n    this.svgRenderer.drawPath(canvas, options, this.diagramId);\n  };\n  /**\n   * Method used to draw the line \\\n   *\n   * @returns {void }  Method used to draw the line  .\\\n   *\n   * @param {SVGElement} canvas - Provide the SVGElement value.\n   * @param {LineAttributes } options - Provide the LineAttributes value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.drawLine = function (canvas, options) {\n    this.svgRenderer.drawLine(canvas, options);\n  };\n  /**\n   * Method used to draw the path \\\n   *\n   * @returns {void }  Method used to draw the path  .\\\n   *\n   * @param {SVGElement} canvas - Provide the canvas value.\n   * @param {PathAttributes } options - Provide the PathAttributes value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.drawPath = function (canvas, options) {\n    this.svgRenderer.drawPath(canvas, options, this.diagramId);\n  };\n  /**\n   * Method used to render the resize handle \\\n   *\n   * @returns {void }  Method used to render the resize handle  .\\\n   *\n   * @param {DiagramElement} element - Provide the DiagramElement value.\n   * @param {HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n   * @param {  ThumbsConstraints } constraints - Provide the constraints value  .\n   * @param { number} currentZoom - Provide the currentZoom value.\n   * @param { SelectorConstraints } selectorConstraints - Provide the selectorConstraints value .\n   * @param { Transforms } transform - Provide the transform  value.\n   * @param { boolean } canMask - Provide the canMask boolean value.\n   * @param { number } enableNode - Provide the enableNode value.\n   * @param { boolean } nodeConstraints - Provide the nodeConstraints  value.\n   * @param { boolean } isSwimlane - Provide the isSwimlane boolean value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderResizeHandle = function (element, canvas, constraints, currentZoom, selectorConstraints, transform, canMask, enableNode, nodeConstraints, isSwimlane) {\n    var left = element.offsetX - element.actualSize.width * element.pivot.x;\n    var top = element.offsetY - element.actualSize.height * element.pivot.y;\n    var height = element.actualSize.height;\n    var width = element.actualSize.width;\n\n    if (!isSwimlane && constraints & ThumbsConstraints.Rotate && canDrawThumbs(this.rendererActions) && !avoidDrawSelector(this.rendererActions)) {\n      this.renderPivotLine(element, canvas, transform, selectorConstraints, canMask);\n      this.renderRotateThumb(element, canvas, transform, selectorConstraints, canMask);\n    }\n\n    this.renderBorder(element, canvas, transform, enableNode, nodeConstraints, isSwimlane);\n    var nodeWidth = element.actualSize.width * currentZoom;\n    var nodeHeight = element.actualSize.height * currentZoom;\n\n    if (!nodeConstraints && canDrawThumbs(this.rendererActions) && !avoidDrawSelector(this.rendererActions)) {\n      if (nodeWidth >= 40 && nodeHeight >= 40) {\n        //Hide corners when the size is less than 40\n        if (selectorConstraints & SelectorConstraints.ResizeNorthWest) {\n          this.renderCircularHandle('resizeNorthWest', element, left, top, canvas, canShowCorner(selectorConstraints, 'ResizeNorthWest'), constraints & ThumbsConstraints.ResizeNorthWest, transform, undefined, canMask, {\n            'aria-label': 'Thumb to resize the selected object on top left side direction'\n          }, undefined, 'e-diagram-resize-handle e-northwest');\n        }\n\n        if (selectorConstraints & SelectorConstraints.ResizeNorthEast) {\n          this.renderCircularHandle('resizeNorthEast', element, left + width, top, canvas, canShowCorner(selectorConstraints, 'ResizeNorthEast'), constraints & ThumbsConstraints.ResizeNorthEast, transform, undefined, canMask, {\n            'aria-label': 'Thumb to resize the selected object on top right side direction'\n          }, undefined, 'e-diagram-resize-handle e-northeast');\n        }\n\n        if (selectorConstraints & SelectorConstraints.ResizeSouthWest) {\n          this.renderCircularHandle('resizeSouthWest', element, left, top + height, canvas, canShowCorner(selectorConstraints, 'ResizeSouthWest'), constraints & ThumbsConstraints.ResizeSouthWest, transform, undefined, canMask, {\n            'aria-label': 'Thumb to resize the selected object on bottom left side direction'\n          }, undefined, 'e-diagram-resize-handle e-southwest');\n        }\n\n        if (selectorConstraints & SelectorConstraints.ResizeSouthEast) {\n          this.renderCircularHandle('resizeSouthEast', element, left + width, top + height, canvas, canShowCorner(selectorConstraints, 'ResizeSouthEast'), constraints & ThumbsConstraints.ResizeSouthEast, transform, undefined, canMask, {\n            'aria-label': 'Thumb to resize the selected object on bottom right side direction'\n          }, undefined, 'e-diagram-resize-handle e-southeast');\n        }\n      }\n\n      if (selectorConstraints & SelectorConstraints.ResizeNorth) {\n        this.renderCircularHandle('resizeNorth', element, left + width / 2, top, canvas, canShowCorner(selectorConstraints, 'ResizeNorth'), constraints & ThumbsConstraints.ResizeNorth, transform, undefined, canMask, {\n          'aria-label': 'Thumb to resize the selected object on top side direction'\n        }, undefined, 'e-diagram-resize-handle e-north');\n      }\n\n      if (selectorConstraints & SelectorConstraints.ResizeSouth) {\n        this.renderCircularHandle('resizeSouth', element, left + width / 2, top + height, canvas, canShowCorner(selectorConstraints, 'ResizeSouth'), constraints & ThumbsConstraints.ResizeSouth, transform, undefined, canMask, {\n          'aria-label': 'Thumb to resize the selected object on bottom side direction'\n        }, undefined, 'e-diagram-resize-handle e-south');\n      }\n\n      if (selectorConstraints & SelectorConstraints.ResizeWest) {\n        this.renderCircularHandle('resizeWest', element, left, top + height / 2, canvas, canShowCorner(selectorConstraints, 'ResizeWest'), constraints & ThumbsConstraints.ResizeWest, transform, undefined, canMask, {\n          'aria-label': 'Thumb to resize the selected object on left side direction'\n        }, undefined, 'e-diagram-resize-handle e-west');\n      }\n\n      if (selectorConstraints & SelectorConstraints.ResizeEast) {\n        this.renderCircularHandle('resizeEast', element, left + width, top + height / 2, canvas, canShowCorner(selectorConstraints, 'ResizeEast'), constraints & ThumbsConstraints.ResizeEast, transform, undefined, canMask, {\n          'aria-label': 'Thumb to resize the selected object on right side direction'\n        }, undefined, 'e-diagram-resize-handle e-east');\n      }\n    }\n  };\n  /**\n   * Method used to render the end point of the handle \\\n   *\n   * @returns {void }  Method used to render the end point of the handle  .\\\n   *\n   * @param {ConnectorModel} selector - Provide the ConnectorModel.\n   * @param {HTMLCanvasElement | SVGElement } canvas - Provide the element.\n   * @param {  ThumbsConstraints } constraints - Provide the constraints value  .\n   * @param { SelectorConstraints} selectorConstraints - Provide the selectorConstraints value.\n   * @param { Transforms } transform - Provide the transform value .\n   * @param { boolean } connectedSource - Provide the connectedSource boolean value.\n   * @param { boolean } connectedTarget - Provide the connectedTarget boolean value.\n   * @param { boolean } isSegmentEditing - Provide the isSegmentEditing boolean value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderEndPointHandle = function (selector, canvas, constraints, selectorConstraints, transform, connectedSource, connectedTarget, isSegmentEditing) {\n    var sourcePoint = selector.sourcePoint;\n    var targetPoint = selector.targetPoint;\n    var wrapper = selector.wrapper;\n    var i;\n    var segment;\n    this.renderCircularHandle('connectorSourceThumb', wrapper, sourcePoint.x, sourcePoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorSourceThumb'), constraints & ThumbsConstraints.ConnectorSource, transform, connectedSource, undefined, {\n      'aria-label': 'Thumb to move the source point of the connector'\n    }, undefined, 'e-diagram-endpoint-handle e-targetend');\n    this.renderCircularHandle('connectorTargetThumb', wrapper, targetPoint.x, targetPoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorTargetThumb'), constraints & ThumbsConstraints.ConnectorTarget, transform, connectedTarget, undefined, {\n      'aria-label': 'Thumb to move the target point of the connector'\n    }, undefined, 'e-diagram-endpoint-handle e-targetend');\n\n    if (isSegmentEditing) {\n      if ((selector.type === 'Straight' || selector.type === 'Bezier') && selector.segments.length > 0) {\n        for (i = 0; i < selector.segments.length - 1; i++) {\n          segment = selector.segments[i];\n          this.renderCircularHandle('segementThumb_' + (i + 1), wrapper, segment.point.x, segment.point.y, canvas, true, constraints & ThumbsConstraints.ConnectorSource, transform, connectedSource, null, null, i);\n        }\n      } else {\n        for (i = 0; i < selector.segments.length; i++) {\n          var seg = selector.segments[i];\n          this.renderOrthogonalThumbs('orthoThumb_' + (i + 1), wrapper, seg, canvas, canShowCorner(selectorConstraints, 'ConnectorSourceThumb'), transform);\n        }\n      }\n    }\n\n    if (selector.type === 'Bezier') {\n      for (i = 0; i < selector.segments.length; i++) {\n        var segment_1 = selector.segments[i];\n        var bezierPoint = !Point.isEmptyPoint(segment_1.point1) ? segment_1.point1 : segment_1.bezierPoint1;\n        this.renderCircularHandle('bezierPoint_' + (i + 1) + '_1', wrapper, bezierPoint.x, bezierPoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorSourceThumb'), constraints & ThumbsConstraints.ConnectorSource, transform, undefined, undefined, {\n          'aria-label': 'Thumb to move the source point of the connector'\n        }, undefined, 'e-diagram-bezier-handle e-source');\n\n        if (canShowCorner(selectorConstraints, 'ConnectorSourceThumb')) {\n          this.renderBezierLine('bezierLine_' + (i + 1) + '_1', wrapper, canvas, segment_1.points[0], !Point.isEmptyPoint(segment_1.point1) ? segment_1.point1 : segment_1.bezierPoint1, transform);\n        }\n\n        bezierPoint = !Point.isEmptyPoint(segment_1.point2) ? segment_1.point2 : segment_1.bezierPoint2;\n        this.renderCircularHandle('bezierPoint_' + (i + 1) + '_2', wrapper, bezierPoint.x, bezierPoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorTargetThumb'), constraints & ThumbsConstraints.ConnectorTarget, transform, undefined, undefined, {\n          'aria-label': 'Thumb to move the target point of the connector'\n        }, undefined, 'e-diagram-bezier-handle e-target');\n\n        if (canShowCorner(selectorConstraints, 'ConnectorTargetThumb')) {\n          this.renderBezierLine('bezierLine_' + (i + 1) + '_2', wrapper, canvas, segment_1.points[1], !Point.isEmptyPoint(segment_1.point2) ? segment_1.point2 : segment_1.bezierPoint2, transform);\n        }\n      }\n    }\n  };\n  /**\n   * Method used to render the orthogonal thumb \\\n   *\n   * @returns {void }  Method used to render the orthogonal thumb  .\\\n   *\n   * @param {string} id - Provide the id for the element.\n   * @param {DiagramElement } selector - Provide the selector element.\n   * @param {  OrthogonalSegment } segment - Provide the segment value  .\n   * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n   * @param { boolean } visibility - Provide the visibility value .\n   * @param { Transforms } t - Provide the Transforms value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderOrthogonalThumbs = function (id, selector, segment, canvas, visibility, t) {\n    var orientation;\n    var visible;\n    var length;\n    var j = 0;\n\n    for (j = 0; j < segment.points.length - 1; j++) {\n      length = Point.distancePoints(segment.points[j], segment.points[j + 1]);\n      orientation = segment.points[j].y.toFixed(2) === segment.points[j + 1].y.toFixed(2) ? 'horizontal' : 'vertical';\n      visible = length >= 50 && segment.allowDrag ? true : false;\n      this.renderOrthogonalThumb(id + '_' + (j + 1), selector, (segment.points[j].x + segment.points[j + 1].x) / 2, (segment.points[j].y + segment.points[j + 1].y) / 2, canvas, visible, orientation, t);\n    }\n  };\n  /**\n   * Method used to render the orthogonal thumb \\\n   *\n   * @returns {void }  Method used to render the orthogonal thumb  .\\\n   *\n   * @param {string} id - Provide the id for the element.\n   * @param {DiagramElement } selector - Provide the selector element.\n   * @param {  Transforms } x - Provide the x value  .\n   * @param { Transforms } y - Provide the y value.\n   * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n   * @param { boolean } visible - Provide the visible boolean value.\n   * @param { string } orientation - Provide the orientation value.\n   * @param { Transforms } t - Provide the Transforms value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderOrthogonalThumb = function (id, selector, x, y, canvas, visible, orientation, t) {\n    var path;\n    var h;\n    var v;\n\n    if (orientation === 'horizontal') {\n      path = 'M0,7 L15,0 L30,7 L15,14 z';\n      h = -15;\n      v = -7;\n    } else {\n      path = 'M7,0 L0,15 L7,30 L14,15 z';\n      h = -7;\n      v = -15;\n    }\n\n    var options = {\n      x: (x + t.tx) * t.scale + h,\n      y: (y + t.ty) * t.scale + v,\n      angle: 0,\n      fill: '#e2e2e2',\n      stroke: 'black',\n      strokeWidth: 1,\n      dashArray: '',\n      data: path,\n      width: 20,\n      height: 20,\n      pivotX: 0,\n      pivotY: 0,\n      opacity: 1,\n      visible: visible,\n      id: id\n    };\n    this.svgRenderer.drawPath(canvas, options, this.diagramId);\n  };\n  /**\n   * Method used to render the pivot line line\\\n   *\n   * @returns {void } Method used to render the pivot line line .\\\n   *\n   * @param {DiagramElement} element - Provide the diagram element value.\n   * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n   * @param {  Transforms } transform - Provide the transform value  .\n   * @param { SelectorConstraints } selectorConstraints - Provide the selector constraints value.\n   * @param { boolean } canMask - Provide the canMask boolean value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderPivotLine = function (element, canvas, transform, selectorConstraints, canMask) {\n    var wrapper = element;\n    var dashArray = '2,3';\n    var visible = selectorConstraints & SelectorConstraints.Rotate ? true : false;\n\n    if (canMask) {\n      visible = false;\n    }\n\n    var options = this.getBaseAttributes(wrapper, transform);\n    options.fill = 'None';\n    options.stroke = 'black';\n    options.strokeWidth = 1;\n    options.dashArray = dashArray;\n    options.visible = visible;\n    var scale = transform.scale;\n    options.x *= scale;\n    options.y *= scale;\n    options.width *= scale;\n    options.height *= scale;\n    options.id = 'pivotLine';\n    options.class = 'e-diagram-pivot-line';\n    var startPoint = {\n      x: wrapper.actualSize.width * wrapper.pivot.x * scale,\n      y: -20\n    };\n    var endPoint = {\n      x: wrapper.actualSize.width * wrapper.pivot.x * scale,\n      y: 0\n    };\n    options.startPoint = startPoint;\n    options.endPoint = endPoint;\n    this.svgRenderer.drawLine(canvas, options);\n  };\n  /**\n   * Method used to render the bezier line for the connector  \\\n   *\n   * @returns {void } Method used to render the bezier line for the connector .\\\n   *\n   * @param {string} id - Provide the id value for the bezier line.\n   * @param { DiagramElement } wrapper - Provide the wrapper for the element.\n   * @param {  HTMLCanvasElement | SVGElement } canvas - Provide the canvas element  .\n   * @param { PointModel } start - Provide the pointmodel value.\n   * @param { PointModel } end - Provide the pointmodel value.\n   * @param { Transforms } transform - Provide the itransform value .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderBezierLine = function (id, wrapper, canvas, start, end, transform) {\n    var dashArray = '3,3';\n    var options = this.getBaseAttributes(wrapper, transform);\n    options.id = id;\n    options.stroke = 'black';\n    options.strokeWidth = 1;\n    options.dashArray = dashArray;\n    options.fill = 'None';\n    options.class = 'e-diagram-bezier-line';\n    options.x = 0;\n    options.y = 0;\n    var scale = transform.scale;\n    var x1 = (start.x + transform.tx) * scale;\n    var y1 = (start.y + transform.ty) * scale;\n    var x2 = (end.x + transform.tx) * scale;\n    var y2 = (end.y + transform.ty) * scale;\n    var startPoint = {\n      x: x1,\n      y: y1\n    };\n    var endPoint = {\n      x: x2,\n      y: y2\n    };\n    options.startPoint = startPoint;\n    options.endPoint = endPoint;\n    this.svgRenderer.drawLine(canvas, options);\n  };\n  /**\n   * Method used to render the circular handle for the node element  \\\n   *\n   * @returns {void } Method used to render the circular handle for the node element .\\\n   *\n   * @param {string} id - Provide the id value.\n   * @param { DiagramElement } selector - Provide the selector element value.\n   * @param { number } cx - Provide cx value  .\n   * @param { number } cy - Provide cx value.\n   * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n   * @param { boolean } visible - Provide the visible property for the handle .\n   * @param { number } enableSelector - Provide the value for the enableSelector .\n   * @param { Transforms } t - Provide the transform value .\n   * @param { boolean } connected - Provide the connected boolean value .\n   * @param { boolean } canMask - Provide the canMask boolean value .\n   * @param { Object } ariaLabel - Provide the label properties .\n   * @param { number } count - Provide the count value  .\n   * @param { string } className - Provide the class name for this element .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderCircularHandle = function (id, selector, cx, cy, canvas, visible, enableSelector, t, connected, canMask, ariaLabel, count, className) {\n    var wrapper = selector;\n    var radius = 7;\n    var newPoint = {\n      x: cx,\n      y: cy\n    };\n\n    if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {\n      var matrix = identityMatrix();\n      rotateMatrix(matrix, wrapper.rotateAngle + wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY);\n      newPoint = transformPointByMatrix(matrix, newPoint);\n    }\n\n    var options = this.getBaseAttributes(wrapper);\n    options.stroke = 'black';\n    options.strokeWidth = 1;\n\n    if (count !== undefined) {\n      radius = 5;\n      options.id = 'segmentEnd_' + count;\n      options.fill = '#e2e2e2';\n    } else {\n      radius = 7;\n      options.fill = connected ? '#8CC63F' : 'white';\n    }\n\n    options.centerX = (newPoint.x + t.tx) * t.scale;\n    options.centerY = (newPoint.y + t.ty) * t.scale;\n    options.radius = radius;\n    options.angle = 0;\n    options.id = id;\n    options.visible = visible;\n    options.class = className;\n\n    if (connected) {\n      options.class += ' e-connected';\n    }\n\n    if (canMask) {\n      options.visible = false;\n    }\n\n    this.svgRenderer.drawCircle(canvas, options, enableSelector, ariaLabel);\n  };\n  /**\n   * Method used to render border for the node element  \\\n   *\n   * @returns {void } Method used to render border for the node element .\\\n   *\n   * @param {SelectorModel} selector - Provide the selector model instance.\n   * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n   * @param { Transforms } transform - Provide the transform value  .\n   * @param { number } enableNode - Provide enableNode boolean value.\n   * @param { boolean } isBorderTickness - Provide the thickness value for the node.\n   * @param { boolean } isSwimlane - Provide the isSwimlane boolean value .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderBorder = function (selector, canvas, transform, enableNode, isBorderTickness, isSwimlane) {\n    var wrapper = selector;\n    var options = this.getBaseAttributes(wrapper, transform);\n    options.x *= transform.scale;\n    options.y *= transform.scale;\n    options.width *= transform.scale;\n    options.height *= transform.scale;\n    options.fill = 'transparent';\n    options.stroke = '#097F7F';\n    options.strokeWidth = 1.2;\n    options.gradient = null;\n    options.dashArray = '6,3';\n    options.class = 'e-diagram-border';\n\n    if (isSwimlane) {\n      options.class += ' e-diagram-lane';\n    }\n\n    options.id = 'borderRect';\n    options.id = this.rendererActions & RendererAction.DrawSelectorBorder ? 'borderRect_symbol' : 'borderRect';\n\n    if (!enableNode) {\n      options.class += ' e-disabled';\n    }\n\n    if (isBorderTickness) {\n      options.class += ' e-thick-border';\n    }\n\n    options.cornerRadius = 0;\n    var parentSvg = this.getParentSvg(selector, 'selector');\n    this.svgRenderer.drawRectangle(canvas, options, this.diagramId, undefined, true, parentSvg);\n  };\n  /**\n   * Method used to render user handle for the node element  \\\n   *\n   * @returns {void } Method used to render user handle for the node element .\\\n   *\n   * @param {SelectorModel} selectorItem - Provide the selector model instance.\n   * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n   * @param { Transforms } transform - Provide the transform value  .\n   * @param { HTMLElement } diagramUserHandlelayer - Provide the HTMLElement value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderUserHandler = function (selectorItem, canvas, transform, diagramUserHandlelayer) {\n    var wrapper = selectorItem.wrapper;\n    var canDraw;\n\n    for (var _i = 0, _a = selectorItem.userHandles; _i < _a.length; _i++) {\n      var obj = _a[_i];\n      canDraw = true;\n\n      if (obj.disableConnectors && selectorItem.connectors.length > 0 || obj.disableNodes && selectorItem.nodes.length > 0) {\n        canDraw = false;\n      }\n\n      var div = document.getElementById(obj.name + '_template_hiddenUserHandle');\n\n      if (div) {\n        obj.template = div.childNodes[0].cloneNode(true);\n      } //const newPoint: PointModel;\n\n\n      var newPoint = getUserHandlePosition(selectorItem, obj, transform);\n      newPoint.x = (newPoint.x + transform.tx) * transform.scale;\n      newPoint.y = (newPoint.y + transform.ty) * transform.scale;\n\n      if (obj.visible) {\n        obj.visible = selectorItem.constraints & SelectorConstraints.UserHandle ? true : false;\n      }\n\n      if (canDraw) {\n        if (obj.pathData) {\n          var data = obj.pathData ? obj.pathData : obj.content;\n          var option = this.getBaseAttributes(wrapper);\n          option.id = obj.name + '_userhandle';\n          option.fill = obj.backgroundColor;\n          option.stroke = obj.borderColor;\n          option.strokeWidth = obj.borderWidth;\n          option.centerX = newPoint.x;\n          option.centerY = newPoint.y;\n          option.radius = obj.size * 0.5;\n          option.class = 'e-diagram-userhandle-circle';\n          option.angle = 0;\n          option.visible = obj.visible;\n          option.opacity = 1;\n          this.svgRenderer.drawCircle(canvas, option, 1, {\n            'aria-label': obj.name + 'user handle'\n          });\n          var pathPading = 5;\n          var arrayCollection = [];\n          arrayCollection = processPathData(data);\n          arrayCollection = splitArrayCollection(arrayCollection);\n          var pathSize = measurePath(data); //requiredSize/contentSize\n\n          var scaleX = (obj.size - 0.45 * obj.size) / pathSize.width;\n          var scaleY = (obj.size - 0.45 * obj.size) / pathSize.height;\n          var newData = transformPath(arrayCollection, scaleX, scaleY, true, pathSize.x, pathSize.y, 0, 0);\n          pathSize = measurePath(newData);\n          var options = {\n            x: newPoint.x - pathSize.width / 2,\n            y: newPoint.y - pathSize.height / 2,\n            angle: 0,\n            id: '',\n            class: 'e-diagram-userhandle-path',\n            fill: obj.pathColor,\n            stroke: obj.backgroundColor,\n            strokeWidth: 0.5,\n            dashArray: '',\n            data: newData,\n            width: obj.size - pathPading,\n            height: obj.size - pathPading,\n            pivotX: 0,\n            pivotY: 0,\n            opacity: 1,\n            visible: obj.visible\n          };\n          this.svgRenderer.drawPath(canvas, options, this.diagramId, undefined, undefined, {\n            'aria-label': obj.name + 'user handle'\n          });\n        } else if (obj.content) {\n          //const handleContent: DiagramNativeElement;\n          var handleContent = new DiagramNativeElement(obj.name, this.diagramId);\n          handleContent.content = obj.content;\n          handleContent.offsetX = newPoint.x;\n          handleContent.offsetY = newPoint.y;\n          handleContent.id = obj.name + '_shape';\n          handleContent.horizontalAlignment = 'Center';\n          handleContent.verticalAlignment = 'Center';\n          handleContent.visible = obj.visible;\n          handleContent.setOffsetWithRespectToBounds(newPoint.x, newPoint.y, 'Fraction');\n          handleContent.relativeMode = 'Object';\n          handleContent.description = obj.name || 'User handle';\n          handleContent.measure(new Size(obj.size, obj.size));\n          handleContent.arrange(handleContent.desiredSize);\n          this.svgRenderer.drawNativeContent(handleContent, canvas, obj.size, obj.size, this.adornerSvgLayer);\n        } else if (obj.source) {\n          var element = new ImageElement();\n          var options = this.getBaseAttributes(element, transform);\n          options.width = obj.size;\n          options.height = obj.size;\n          options.x = newPoint.x - obj.size / 2;\n          options.y = newPoint.y - obj.size / 2;\n          options.sourceWidth = obj.size;\n          options.sourceHeight = obj.size;\n          options.alignment = element.imageAlign;\n          options.source = obj.source;\n          options.scale = element.imageScale;\n          options.visible = obj.visible;\n          options.description = obj.name || 'User handle';\n          options.id = obj.name + '_';\n          this.renderer.drawImage(canvas, options, this.adornerSvgLayer, false);\n        } else {\n          //const templateContent: DiagramHtmlElement;\n          var templateContent = new DiagramHtmlElement(obj.name, this.diagramId);\n          templateContent.offsetX = newPoint.x;\n          templateContent.offsetY = newPoint.y;\n          templateContent.id = obj.name + '_shape';\n          templateContent.visible = obj.visible;\n          templateContent.relativeMode = 'Object';\n          templateContent.template = obj.template;\n          templateContent.measure(new Size(obj.size, obj.size));\n          templateContent.arrange(templateContent.desiredSize);\n          this.svgRenderer.drawHTMLContent(templateContent, diagramUserHandlelayer, undefined, true, undefined);\n        }\n      }\n    }\n  };\n  /**\n   * Method used to render rotate thumb of the diagramnode element  \\\n   *\n   * @returns {void } Method used to render rotate thumb of the diagramnode element .\\\n   *\n   * @param {DiagramElement} wrapper - Provide the wrapper  element value.\n   * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n   * @param { Transforms } transform - Provide the transform value  .\n   * @param { SelectorConstraints } selectorConstraints - Provide the selectorConstraints value.\n   * @param { boolean } canMask - Provide the boolean value .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderRotateThumb = function (wrapper, canvas, transform, selectorConstraints, canMask) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    var element = new PathElement();\n    var newPoint;\n    var size = new Size();\n    size.width = 18;\n    size.height = 16;\n    var top = wrapper.offsetY - wrapper.actualSize.height * wrapper.pivot.y;\n    var left = wrapper.offsetX - wrapper.actualSize.width * wrapper.pivot.x;\n    var visible = selectorConstraints & SelectorConstraints.Rotate ? true : false;\n\n    if (canMask) {\n      visible = false;\n    }\n\n    var data = 'M 16.856144362449648 10.238890446662904 L 18.000144362449646 3.437890446662903' + 'L 15.811144362449646 4.254890446662903 C 14.837144362449646 2.5608904466629028 13.329144362449647 ' + ' 1.2598904466629026 11.485144362449645 0.5588904466629026 C 9.375144362449646 - 0.24510955333709716 7.071144362449646 ' + ' - 0.18010955333709716 5.010144362449646 0.7438904466629028 C 2.942144362449646 1.6678904466629028 1.365144362449646' + ' 3.341890446662903 0.558144362449646 5.452890446662903 C - 0.244855637550354 7.567890446662903 - 0.17985563755035394' + ' 9.866890446662904 0.7431443624496461 11.930890446662904 C 1.6681443624496461 13.994890446662904 3.343144362449646' + ' 15.575890446662903 5.457144362449647 16.380890446662903 C 6.426144362449647 16.7518904466629 7.450144362449647' + ' 16.9348904466629 8.470144362449647 16.9348904466629 C 9.815144362449647 16.9348904466629 11.155144362449647 ' + '16.6178904466629 12.367144362449647 15.986890446662901 L 11.351144362449647 14.024890446662901 C 9.767144362449647' + ' 14.8468904466629 7.906144362449647 14.953890446662902 6.237144362449647 14.3178904466629 C 4.677144362449647' + ' 13.7218904466629 3.444144362449647 12.5558904466629 2.758144362449647 11.028890446662901 C 2.078144362449646 ' + '9.501890446662903 2.031144362449646 7.802890446662903 2.622144362449646 6.243890446662903 C 3.216144362449646' + ' 4.6798904466629025 4.387144362449646 3.442890446662903 5.914144362449646 2.760890446662903 C 7.437144362449646 ' + '2.078890446662903 9.137144362449646 2.0298904466629026 10.700144362449645 2.6258904466629027 C 11.946144362449646 ' + '3.100890446662903 12.971144362449646 3.9538904466629026 13.686144362449646 5.049890446662903 L 11.540144362449645 ' + '5.850890446662903 L 16.856144362449648 10.238890446662904 Z';\n    var pivotX = left + wrapper.pivot.x * wrapper.actualSize.width;\n    var pivotY = top;\n    pivotX = (pivotX + transform.tx) * transform.scale;\n    pivotY = (pivotY + transform.ty) * transform.scale;\n    newPoint = {\n      x: pivotX - size.width * 0.5,\n      y: pivotY - 30 - size.height * 0.5\n    };\n\n    if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {\n      var matrix = identityMatrix();\n      rotateMatrix(matrix, wrapper.rotateAngle + wrapper.parentTransform, (transform.tx + wrapper.offsetX) * transform.scale, (transform.ty + wrapper.offsetY) * transform.scale);\n      newPoint = transformPointByMatrix(matrix, newPoint);\n    }\n\n    var options = {\n      x: newPoint.x,\n      y: newPoint.y,\n      angle: wrapper.rotateAngle + wrapper.parentTransform,\n      fill: '#231f20',\n      stroke: 'black',\n      strokeWidth: 0.5,\n      dashArray: '',\n      data: data,\n      width: 20,\n      height: 20,\n      pivotX: 0,\n      pivotY: 0,\n      opacity: 1,\n      visible: visible,\n      id: wrapper.id,\n      class: 'e-diagram-rotate-handle'\n    };\n    options.id = 'rotateThumb';\n    this.svgRenderer.drawPath(canvas, options, this.diagramId, true, undefined, {\n      'aria-label': 'Thumb to rotate the selected object'\n    });\n  };\n  /**\n   * Method used to render the path element for the diagram  \\\n   *\n   * @returns {void } Method used to render the path element for the diagram .\\\n   *\n   * @param {PathElement} element - Provide the path element of the diagram .\n   * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n   * @param { Transforms } transform - Provide the transform value  .\n   * @param { SVGSVGElement } parentSvg - Provide the parent SVG element .\n   * @param { boolean } fromPalette - Provide the boolean value .\n   * @param { boolean } isPreviewNode - Provide the boolean value .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderPathElement = function (element, canvas, transform, parentSvg, fromPalette, isPreviewNode) {\n    var options = this.getBaseAttributes(element, transform, isPreviewNode);\n    options.data = element.absolutePath;\n    options.data = element.absolutePath;\n    var ariaLabel = element.description ? element.description : element.id;\n\n    if (!this.isSvgMode) {\n      options.x = element.flipOffset.x ? element.flipOffset.x : options.x;\n      options.y = element.flipOffset.y ? element.flipOffset.y : options.y;\n    }\n\n    if (element.isExport) {\n      var pathBounds = element.absoluteBounds;\n      options.data = updatePath(element, pathBounds, undefined, options);\n    }\n\n    this.renderer.drawPath(canvas, options, this.diagramId, undefined, parentSvg, ariaLabel);\n  };\n  /**\n   * Method used to update the grid line for the diagram  \\\n   *\n   * @returns {void } Method used to update the grid line for the diagram .\\\n   *\n   * @param {SnapSettingsModel} snapSettings - Provide the snapsetting value of the diagram .\n   * @param { SVGSVGElement } gridSvg - Provide the SVG grid  element value.\n   * @param { Transforms } t - Provide the transform value  .\n   * @param { RulerSettingsModel } rulerSettings - Provide the ruler setting property .\n   * @param { RulerModel } hRuler - Provide the horizontal ruler property value .\n   * @param { RulerModel } vRuler - Provide the vertical ruler property value .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderSvgGridlines = function (snapSettings, gridSvg, t, rulerSettings, hRuler, vRuler) {\n    var pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');\n    var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n    defs.setAttribute('id', this.diagramId + '_grid_pattern_defn');\n\n    if (snapSettings.constraints & SnapConstraints.ShowHorizontalLines || snapSettings.constraints & SnapConstraints.ShowVerticalLines) {\n      pattern.setAttribute('id', this.diagramId + '_pattern');\n    }\n\n    var hWidth = 0;\n    var hHeight = 0;\n    var hSegmentwidth = 0;\n    var vSegmentwidth = 0;\n    var scale = 1;\n    var isRulerGrid = false;\n    var isLine = snapSettings.gridType === 'Lines';\n    var verticalLineIntervals = isLine ? snapSettings.verticalGridlines.lineIntervals : snapSettings.verticalGridlines.dotIntervals;\n    var horizontalLineIntervals = isLine ? snapSettings.horizontalGridlines.lineIntervals : snapSettings.horizontalGridlines.dotIntervals;\n\n    if (rulerSettings.showRulers && rulerSettings.dynamicGrid && hRuler && vRuler) {\n      hSegmentwidth = vRuler.updateSegmentWidth(t.scale);\n      vSegmentwidth = hRuler.updateSegmentWidth(t.scale);\n      snapSettings.horizontalGridlines.scaledIntervals = [hSegmentwidth / hRuler.interval];\n      snapSettings.verticalGridlines.scaledIntervals = [vSegmentwidth / vRuler.interval];\n      isRulerGrid = true;\n    } else {\n      for (var i = 0; i < verticalLineIntervals.length; i = i + 1) {\n        hWidth += verticalLineIntervals[i];\n      }\n\n      for (var i = 0; i < horizontalLineIntervals.length; i = i + 1) {\n        hHeight += horizontalLineIntervals[i];\n      }\n\n      scale = this.scaleSnapInterval(snapSettings, t.scale);\n    }\n\n    hWidth = isRulerGrid ? vSegmentwidth : hWidth * scale;\n    hHeight = isRulerGrid ? hSegmentwidth : hHeight * scale;\n    var attr = {\n      id: this.diagramId + '_pattern',\n      x: 0,\n      y: 0,\n      width: hWidth,\n      height: hHeight,\n      patternUnits: 'userSpaceOnUse'\n    };\n    setAttributeSvg(pattern, attr);\n    this.horizontalSvgGridlines(pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, horizontalLineIntervals);\n    this.verticalSvgGridlines(pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, verticalLineIntervals);\n    defs.appendChild(pattern);\n    gridSvg.appendChild(defs);\n  };\n\n  DiagramRenderer.prototype.horizontalSvgGridlines = function (pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, intervals) {\n    var space = 0;\n    var dashArray = [];\n    var hLine;\n\n    if (snapSettings.constraints & SnapConstraints.ShowHorizontalLines) {\n      if (snapSettings.horizontalGridlines.lineDashArray) {\n        dashArray = this.renderer.parseDashArray(snapSettings.horizontalGridlines.lineDashArray);\n      }\n\n      if (rulerSettings.showRulers && rulerSettings.dynamicGrid && vRuler) {\n        intervals = this.updateLineIntervals(intervals, rulerSettings, vRuler, hHeight, isLine);\n      }\n\n      intervals = getInterval(intervals, isLine);\n\n      for (var i = 0; i < intervals.length; i = i + 2) {\n        space = getSpaceValue(intervals, isLine, i, space);\n        var spaceY = 0;\n        hLine = document.createElementNS('http://www.w3.org/2000/svg', isLine ? 'path' : 'circle');\n        var attr = void 0;\n        var d = isLine ? space + intervals[i] / 2 : space;\n        d = isRulerGrid ? d : d * scale;\n\n        if (isLine) {\n          if (dashArray.toString() === '') {\n            attr = {\n              'stroke-width': intervals[i],\n              'd': 'M0,' + d + ' L' + hWidth + ',' + d + ' Z',\n              'class': intervals[i] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n              'stroke': snapSettings.horizontalGridlines.lineColor\n            };\n          } else {\n            attr = {\n              'stroke-width': intervals[i],\n              'stroke': snapSettings.horizontalGridlines.lineColor,\n              'd': 'M0,' + d + ' L' + hWidth + ',' + d + ' Z',\n              'class': intervals[i] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n              'dashArray': dashArray.toString()\n            };\n          }\n\n          setAttributeSvg(hLine, attr);\n          pattern.appendChild(hLine);\n          space += intervals[i + 1] + intervals[i];\n        } else {\n          this.renderDotGrid(i, pattern, snapSettings, spaceY, d, scale, true);\n          space += intervals[i];\n        }\n      }\n    }\n  };\n\n  DiagramRenderer.prototype.renderDotGrid = function (i, pattern, snapSettings, spacey, d, scale, isHorizontal) {\n    var intervals = !isHorizontal ? snapSettings.horizontalGridlines.dotIntervals : snapSettings.verticalGridlines.dotIntervals;\n    intervals = getInterval(intervals, false);\n    var r;\n    var hLine; //const doubleRadius: boolean;\n\n    var dy;\n    var attr;\n\n    for (var j = 1; j < intervals.length; j = j + 2) {\n      r = j === intervals.length - 1 ? intervals[0] : intervals[j - 1];\n      hLine = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n      dy = spacey;\n      dy = dy * scale;\n      attr = {\n        'cx': isHorizontal ? dy : d,\n        'cy': isHorizontal ? d : dy,\n        'fill': snapSettings.horizontalGridlines.lineColor,\n        'r': r\n      };\n      setAttributeSvg(hLine, attr);\n      pattern.appendChild(hLine);\n      spacey += intervals[j] + intervals[j - 1];\n    }\n  };\n\n  DiagramRenderer.prototype.verticalSvgGridlines = function (pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, intervals) {\n    var space = 0;\n    var dashArray = [];\n    var vLine;\n\n    if (snapSettings.constraints & SnapConstraints.ShowVerticalLines) {\n      if (snapSettings.verticalGridlines.lineDashArray) {\n        dashArray = this.renderer.parseDashArray(snapSettings.verticalGridlines.lineDashArray);\n      }\n\n      if (rulerSettings.showRulers && rulerSettings.dynamicGrid && hRuler) {\n        intervals = this.updateLineIntervals(intervals, rulerSettings, hRuler, hWidth, isLine);\n      }\n\n      var spaceY = 0;\n      intervals = getInterval(intervals, isLine);\n\n      for (var i = 0; i < intervals.length; i = i + 2) {\n        space = getSpaceValue(intervals, isLine, i, space);\n        var d = isLine ? space + intervals[i] / 2 : space;\n        d = isRulerGrid ? d : d * scale;\n        vLine = document.createElementNS('http://www.w3.org/2000/svg', isLine ? 'path' : 'circle');\n        var attr = void 0;\n\n        if (isLine) {\n          if (dashArray.toString() === '') {\n            attr = {\n              'stroke-width': intervals[i],\n              'd': 'M' + d + ',0 L' + d + ',' + hHeight + ' Z',\n              'class': intervals[i] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n              'stroke': snapSettings.verticalGridlines.lineColor\n            };\n          } else {\n            attr = {\n              'stroke-width': intervals[i],\n              'class': intervals[i] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n              'stroke': snapSettings.verticalGridlines.lineColor,\n              'd': 'M' + d + ',0 L' + d + ',' + hHeight + ' Z',\n              'dashArray': dashArray.toString()\n            };\n          }\n\n          setAttributeSvg(vLine, attr);\n          pattern.appendChild(vLine);\n          space += intervals[i + 1] + intervals[i];\n        } else {\n          this.renderDotGrid(i, pattern, snapSettings, spaceY, d, scale, false);\n          space += intervals[i];\n        }\n      }\n    }\n  };\n  /**\n   * Method used to update the grid line for the diagram  \\\n   *\n   * @returns {void } Method used to update the grid line for the diagram .\\\n   *\n   * @param {SnapSettingsModel} snapSettings - Provide the snapsetting value of the diagram .\n   * @param { SVGSVGElement } svgGrid - Provide the SVG grid  element value.\n   * @param { Transforms } transform - Provide the transform value  .\n   * @param { RulerSettingsModel } rulerSettings - Provide the ruler setting property .\n   * @param { RulerModel } hRuler - Provide the horizontal ruler property value .\n   * @param { RulerModel } vRuler - Provide the vertical ruler property value .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.updateGrid = function (snapSettings, svgGrid, transform, rulerSettings, hRuler, vRuler) {\n    var grid = svgGrid.getElementById(this.diagramId + '_grid_rect'); //let i: number;\n\n    var isRulerGrid = false;\n\n    if (grid) {\n      var pattern = svgGrid.getElementById(this.diagramId + '_pattern');\n\n      if (pattern) {\n        pattern.parentNode.removeChild(pattern);\n      }\n\n      var hSegmentwidth = 0;\n      var vSegmentwidth = 0;\n      var scale = 1;\n      var isLine = snapSettings.gridType === 'Lines';\n      var verticalLineIntervals = isLine ? snapSettings.verticalGridlines.lineIntervals : snapSettings.verticalGridlines.dotIntervals;\n      var horizontalLineIntervals = isLine ? snapSettings.horizontalGridlines.lineIntervals : snapSettings.horizontalGridlines.dotIntervals;\n\n      if (rulerSettings.showRulers && rulerSettings.dynamicGrid && vRuler && hRuler) {\n        hSegmentwidth = vRuler.updateSegmentWidth(transform.scale);\n        vSegmentwidth = hRuler.updateSegmentWidth(transform.scale);\n        isRulerGrid = true;\n        snapSettings.horizontalGridlines.scaledIntervals = [hSegmentwidth / hRuler.interval];\n        snapSettings.verticalGridlines.scaledIntervals = [vSegmentwidth / vRuler.interval];\n      } else {\n        scale = this.scaleSnapInterval(snapSettings, transform.scale);\n      }\n\n      var height = 0;\n\n      for (var j = 0; j < horizontalLineIntervals.length; j = j + 1) {\n        height += horizontalLineIntervals[j];\n      }\n\n      var width = 0;\n\n      for (var j = 0; j < verticalLineIntervals.length; j = j + 1) {\n        width += verticalLineIntervals[j];\n      }\n\n      var attr = {\n        x: -transform.tx * transform.scale,\n        y: -transform.ty * transform.scale\n      };\n      setAttributeSvg(grid, attr);\n      width = isRulerGrid ? vSegmentwidth : width * scale;\n      height = isRulerGrid ? hSegmentwidth : height * scale;\n      attr = {\n        id: this.diagramId + '_pattern',\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        patternUnits: 'userSpaceOnUse'\n      };\n      pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');\n      setAttributeSvg(pattern, attr);\n      this.horizontalSvgGridlines(pattern, width, height, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, horizontalLineIntervals);\n      this.verticalSvgGridlines(pattern, width, height, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, verticalLineIntervals);\n      var defs = svgGrid.getElementById(this.diagramId + '_grid_pattern_defn');\n\n      if (defs) {\n        defs.appendChild(pattern);\n      }\n    }\n  };\n\n  DiagramRenderer.prototype.updateLineIntervals = function (intervals, rulerSettings, ruler, segmentWidth, isLine) {\n    var newInterval = [];\n    var tickInterval = segmentWidth / ruler.interval;\n    var interval = isLine ? ruler.interval : ruler.interval + 1;\n\n    for (var i = 0; i < interval * 2; i++) {\n      if (i % 2 === 0) {\n        newInterval[i] = isLine ? i === 0 ? 1.25 : 0.25 : 0;\n      } else {\n        newInterval[i] = isLine ? tickInterval - newInterval[i - 1] : tickInterval;\n      }\n    }\n\n    return newInterval;\n  };\n\n  DiagramRenderer.prototype.scaleSnapInterval = function (snapSettings, scale) {\n    if (scale >= 2) {\n      while (scale >= 2) {\n        scale /= 2;\n      }\n    } else if (scale <= 0.5) {\n      while (scale <= 0.5) {\n        scale *= 2;\n      }\n    }\n\n    var i;\n    snapSettings.horizontalGridlines.scaledIntervals = snapSettings.horizontalGridlines.snapIntervals;\n    snapSettings.verticalGridlines.scaledIntervals = snapSettings.verticalGridlines.snapIntervals;\n\n    if (scale !== 1) {\n      var gridlines = snapSettings.horizontalGridlines;\n      gridlines.scaledIntervals = [];\n\n      for (i = 0; i < gridlines.snapIntervals.length; i++) {\n        gridlines.scaledIntervals[i] = gridlines.snapIntervals[i] * scale;\n      }\n\n      gridlines = snapSettings.verticalGridlines;\n      gridlines.scaledIntervals = [];\n\n      for (i = 0; i < gridlines.snapIntervals.length; i++) {\n        gridlines.scaledIntervals[i] = gridlines.snapIntervals[i] * scale;\n      }\n    }\n\n    return scale;\n  };\n  /**\n   * Method used to render the text element  \\\n   *\n   * @returns {void }Method used to render the text element  .\\\n   *\n   * @param {TextElement} element - Provide the text element .\n   * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .\n   * @param { Transforms } transform - Provide the transform value  .\n   * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .\n   * @param { boolean } fromPalette - Provide the boolean value .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderTextElement = function (element, canvas, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  transform, parentSvg, fromPalette, centerPoint) {\n    var options = this.getBaseAttributes(element, transform);\n\n    if (centerPoint) {\n      options.x = centerPoint.cx - 2;\n      options.y = centerPoint.cy - 2;\n    }\n\n    options.cornerRadius = 0;\n    options.whiteSpace = whiteSpaceToString(element.style.whiteSpace, element.style.textWrapping);\n    options.content = element.content;\n    options.breakWord = wordBreakToString(element.style.textWrapping);\n    options.textAlign = textAlignToString(element.style.textAlign);\n    options.color = element.style.color;\n    options.italic = element.style.italic;\n    options.bold = element.style.bold;\n    options.fontSize = element.style.fontSize;\n    options.fontFamily = element.style.fontFamily;\n    options.textOverflow = element.style.textOverflow;\n    options.textWrapping = element.style.textWrapping;\n    options.textDecoration = element.style.textDecoration;\n    options.doWrap = element.doWrap;\n    options.wrapBounds = element.wrapBounds;\n    options.childNodes = element.childNodes;\n    options.isHorizontalLane = element.isLaneOrientation;\n    options.id = element.id ? element.id : randomId();\n\n    if (element.isLaneOrientation) {\n      options.parentOffsetX = this.groupElement.offsetX;\n      options.parentOffsetY = this.groupElement.offsetY;\n      options.parentWidth = this.groupElement.actualSize.width;\n      options.parentHeight = this.groupElement.actualSize.height;\n    }\n\n    options.dashArray = '';\n    options.strokeWidth = 0;\n    options.fill = element.style.fill;\n    var ariaLabel = element.description ? element.description : element.content ? element.content : element.id;\n\n    if ((element.style.textWrapping === 'Wrap' || element.style.textWrapping === 'WrapWithOverflow') && this.groupElement && options.height > this.groupElement.actualSize.height && (element.style.textOverflow === 'Clip' || element.style.textOverflow === 'Ellipsis')) {\n      options.y = options.y + (options.height - this.groupElement.actualSize.height) / 2;\n    }\n\n    this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n    this.renderer.drawText(canvas, options, parentSvg, ariaLabel, this.diagramId, element.isExport && Math.min(element.exportScaleValue.x || element.exportScaleValue.y), this.groupElement);\n\n    if (this.isSvgMode) {\n      element.doWrap = false;\n    }\n  };\n\n  DiagramRenderer.prototype.renderNativeElement = function (element, canvas, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  transform, parentSvg, fromPalette) {\n    var templateWidth;\n    var templateHeight;\n    var nativeSvg = this.getParentSvg(element, undefined, canvas) || parentSvg;\n    var nativeLayer = this.getParentElement(element, canvas, nativeSvg).g || canvas;\n    var options = this.getBaseAttributes(element, transform);\n    options.fill = 'transparent';\n    options.cornerRadius = element.cornerRadius;\n    options.stroke = 'transparent';\n    this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n\n    switch (element.scale) {\n      case 'None':\n        templateWidth = element.contentSize.width;\n        templateHeight = element.contentSize.height;\n        break;\n\n      case 'Stretch':\n        templateWidth = element.actualSize.width;\n        templateHeight = element.actualSize.height;\n        break;\n\n      case 'Meet':\n        if (element.actualSize.width <= element.actualSize.height) {\n          templateWidth = templateHeight = element.actualSize.width;\n        } else {\n          templateWidth = templateHeight = element.actualSize.height;\n        }\n\n        break;\n\n      case 'Slice':\n        if (element.actualSize.width >= element.actualSize.height) {\n          templateWidth = templateHeight = element.actualSize.width;\n        } else {\n          templateWidth = templateHeight = element.actualSize.height;\n        }\n\n        break;\n    }\n\n    if (this.svgRenderer) {\n      this.svgRenderer.drawNativeContent(element, nativeLayer, templateHeight, templateWidth, nativeSvg);\n    }\n  };\n\n  DiagramRenderer.prototype.renderHTMLElement = function (element, canvas, htmlLayer, transform, parentSvg, fromPalette, indexValue) {\n    var options = this.getBaseAttributes(element, transform);\n    options.fill = 'transparent';\n    options.cornerRadius = element.cornerRadius;\n    options.stroke = 'transparent';\n    this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n\n    if (this.svgRenderer) {\n      this.svgRenderer.drawHTMLContent(element, htmlLayer.children[0], transform, isDiagramChild(htmlLayer), indexValue);\n    }\n  };\n  /**\n   * Method used to render the image element  \\\n   *\n   * @returns {void }Method used to render the image element  .\\\n   *\n   * @param {ImageElement} element - Provide the image element .\n   * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .\n   * @param { Transforms } transform - Provide the transform value  .\n   * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .\n   * @param { boolean } fromPalette - Provide the boolean value .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderImageElement = function (element, canvas, transform, parentSvg, fromPalette) {\n    var options = this.getBaseAttributes(element, transform);\n    options.cornerRadius = 0;\n    this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg); // let sx: number; let sy: number;\n\n    var imageWidth;\n    var imageHeight;\n    var sourceWidth;\n    var sourceHeight;\n\n    if (element.stretch === 'Stretch') {\n      imageWidth = element.actualSize.width;\n      imageHeight = element.actualSize.height;\n    } else {\n      var contentWidth = element.contentSize.width;\n      var contentHeight = element.contentSize.height;\n      var widthRatio = options.width / contentWidth;\n      var heightRatio = options.height / contentHeight;\n      var ratio = void 0;\n\n      switch (element.stretch) {\n        case 'Meet':\n          ratio = Math.min(widthRatio, heightRatio);\n          imageWidth = contentWidth * ratio;\n          imageHeight = contentHeight * ratio;\n          options.x += Math.abs(options.width - imageWidth) / 2;\n          options.y += Math.abs(options.height - imageHeight) / 2;\n          break;\n\n        case 'Slice':\n          widthRatio = options.width / contentWidth;\n          heightRatio = options.height / contentHeight;\n          ratio = Math.max(widthRatio, heightRatio);\n          imageWidth = contentWidth * ratio;\n          imageHeight = contentHeight * ratio;\n          sourceWidth = options.width / imageWidth * contentWidth;\n          sourceHeight = options.height / imageHeight * contentHeight;\n          break;\n\n        case 'None':\n          imageWidth = contentWidth;\n          imageHeight = contentHeight;\n          break;\n      }\n    }\n\n    options.width = imageWidth;\n    options.height = imageHeight; //Commented for code coverage\n    //(options as ImageAttributes).sourceX = sx;\n    //(options as ImageAttributes).sourceY = sy;\n\n    options.sourceWidth = sourceWidth;\n    options.sourceHeight = sourceHeight;\n    options.source = element.source;\n    options.alignment = element.imageAlign;\n    options.scale = element.imageScale;\n    options.description = element.description ? element.description : element.id;\n    this.renderer.drawImage(canvas, options, parentSvg, fromPalette);\n  };\n  /**\n   * Method used to render the container  \\\n   *\n   * @returns {void} Method used to render the container .\\\n   *\n   * @param {Container} group - Provide the container .\n   * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .\n   * @param { HTMLElement } htmlLayer - Provide the html layer element  .\n   * @param { Transforms } transform - Provide the transform value .\n   * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .\n   * @param { boolean } createParent - Provide the boolean value .\n   * @param { boolean } fromPalette - Provide the boolean value  .\n   * @param { number } indexValue - Provide the indexValue value .\n   * @param { boolean } isPreviewNode - Provide the boolean value .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderContainer = function (group, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint) {\n    var svgParent = {\n      svg: parentSvg,\n      g: canvas\n    };\n    var diagramElement = document.getElementById(this.diagramId);\n    var instance = 'ej2_instances';\n    var diagram;\n\n    if (diagramElement) {\n      diagram = diagramElement[instance][0];\n    }\n\n    if (this.diagramId) {\n      parentSvg = this.getParentSvg(group) || parentSvg;\n\n      if (this.isSvgMode) {\n        //const groupElement: HTMLCanvasElement | SVGElement;\n        // eslint-disable-next-line max-len\n        var groupElement = this.getParentElement(group, canvas, parentSvg, indexValue).g || canvas;\n        parentSvg = this.getParentSvg(this.hasNativeParent(group.children)) || parentSvg;\n        var svgNativeParent = this.getParentElement(this.hasNativeParent(group.children), groupElement, parentSvg, indexValue);\n        svgParent.svg = svgNativeParent.svg || parentSvg;\n        svgParent.g = svgNativeParent.g || groupElement;\n\n        if (createParent) {\n          if (parentSvg) {\n            if (!parentSvg.getElementById(svgParent.g.id)) {\n              canvas.appendChild(svgParent.g);\n            }\n          }\n\n          canvas = svgParent.g;\n        } else {\n          canvas = svgParent.g;\n        }\n      }\n    }\n\n    this.renderRect(group, canvas, transform, parentSvg);\n    this.groupElement = group;\n\n    if (group.hasChildren()) {\n      var parentG = void 0;\n      var svgParent_1;\n\n      for (var _i = 0, _a = group.children; _i < _a.length; _i++) {\n        var child = _a[_i];\n        parentSvg = this.getParentSvg(this.hasNativeParent(group.children) || child) || parentSvg;\n\n        if (this.isSvgMode) {\n          svgParent_1 = this.getParentElement(this.hasNativeParent(group.children) || child, canvas, parentSvg);\n          parentG = svgParent_1.g || canvas;\n\n          if (svgParent_1.svg) {\n            parentSvg = svgParent_1.svg;\n          }\n        }\n\n        if (!this.isSvgMode) {\n          child.flip = group.flip;\n        }\n\n        this.renderElement(child, parentG || canvas, htmlLayer, transform, parentSvg, true, fromPalette, indexValue, isPreviewNode, centerPoint);\n\n        if (child instanceof TextElement && parentG && !(group.elementActions & ElementAction.ElementIsGroup)) {\n          this.renderFlipElement(child, parentG, child.flip);\n        }\n\n        if (child.elementActions & ElementAction.ElementIsPort && parentG) {\n          this.renderFlipElement(group, parentG, child.flip);\n        }\n\n        if (!(child instanceof TextElement) && group.flip !== 'None' && group.elementActions & ElementAction.ElementIsGroup) {\n          this.renderFlipElement(child, parentG || canvas, group.flip);\n        }\n      }\n\n      var selectedNode = void 0;\n\n      if (diagram && diagram.selectedItems && diagram.selectedItems.nodes && diagram.selectedItems.nodes.length > 0) {\n        selectedNode = diagram.selectedItems.nodes[0];\n      }\n\n      var innerNodeContent = void 0;\n      var innerLabelContent = void 0;\n\n      if (group.flip !== 'None' && selectedNode && selectedNode.flipMode !== 'Label' && selectedNode.flipMode !== 'All' && selectedNode.flipMode !== 'None') {\n        group.flip = 'None';\n\n        for (var k = 0; k < group.children.length; k++) {\n          group.children[k].flip = 'None';\n        }\n      }\n\n      if (!(group.elementActions & ElementAction.ElementIsGroup) && diagram instanceof Diagram && diagram.nameTable[group.id] && diagram.nameTable[group.id].propName !== 'connectors') {\n        if (selectedNode) {\n          innerNodeContent = document.getElementById(selectedNode.id + '_content_groupElement');\n        }\n\n        if (group.flip !== 'None' && selectedNode && selectedNode.flipMode && selectedNode.flipMode === 'None') {\n          this.renderFlipElement(group, innerNodeContent, group.flip);\n        } else if (group.flip !== 'None' && selectedNode && selectedNode.flipMode && selectedNode.flipMode === 'Label') {\n          for (var i = 0; i < selectedNode.wrapper.children.length; i++) {\n            if (selectedNode.wrapper.children[i] instanceof TextElement) {\n              innerLabelContent = document.getElementById(selectedNode.wrapper.children[i].id + '_groupElement');\n              this.renderFlipElement(group, innerLabelContent, group.flip);\n              return;\n            }\n          }\n        } else {\n          this.renderFlipElement(group, canvas, group.flip);\n        }\n      }\n    }\n  };\n\n  DiagramRenderer.prototype.renderFlipElement = function (element, canvas, flip) {\n    var attr = {};\n    var scaleX = 1;\n    var scaleY = 1;\n    var posX = 0;\n    var posY = 0;\n    var offsetX = 0;\n    var offsetY = 0;\n\n    if (flip !== 'None') {\n      if (flip === 'Horizontal' || flip === 'Both') {\n        posX = element.bounds.center.x;\n        offsetX = -element.bounds.center.x;\n        scaleX = -1;\n      }\n\n      if (flip === 'Vertical' || flip === 'Both') {\n        posY = element.bounds.center.y;\n        offsetY = -element.bounds.center.y;\n        scaleY = -1;\n      }\n\n      attr = {\n        'transform': 'translate(' + posX + ',' + posY + ') scale(' + scaleX + ',' + scaleY + ') translate(' + offsetX + ',' + offsetY + ')'\n      };\n    } else {\n      attr = {\n        'transform': 'translate(' + 0 + ',' + 0 + ')'\n      };\n    }\n\n    if (attr) {\n      if (element && element.children && element.children.length && element.children[0] instanceof DiagramHtmlElement) {\n        var id = canvas.id.split('_preview');\n        var layer = document.getElementById(id[0] + '_html_div') || getHTMLLayer(this.diagramId).children[0];\n        canvas = layer.querySelector('#' + element.id + '_content_html_element');\n\n        if (canvas) {\n          canvas.style.transform = 'scale(' + scaleX + ',' + scaleY + ')' + 'rotate(' + (element.rotateAngle + element.parentTransform) + 'deg)';\n        }\n      } else {\n        setAttributeSvg(canvas, attr);\n      }\n    }\n  };\n  /**\n   * Method used to check the native parent  \\\n   *\n   * @returns {void} Method used to check the native parent .\\\n   *\n   * @param { DiagramElement[]} children - Provide the diagram element .\n   * @param { number} count - Provide the count value .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.hasNativeParent = function (children, count) {\n    if (children && children.length > 0 && (count || 0 < 3)) {\n      var child = children[0];\n\n      if (child instanceof DiagramNativeElement) {\n        return child;\n      } else if (child.children && child.children.length) {\n        this.hasNativeParent(child.children, count++ || 0);\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * Method used the draw the reactangle for the diagram  \\\n   *\n   * @returns {void} Method used the draw the reactangle for the diagram .\\\n   *\n   * @param { SVGElement} element - Provide the SVG elements .\n   * @param { RectAttributes} canvas - Provide the Canvas element  .\n   * @param { RectAttributes} transform - Provide transform value for the node  .\n   * @param { RectAttributes} parentSvg -provide the parent SVG  .\n   * @param { RectAttributes} isPreviewNode - Provide the preview boolean value  .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.renderRect = function (element, canvas, transform, parentSvg, isPreviewNode) {\n    var options = this.getBaseAttributes(element, transform, isPreviewNode);\n    options.cornerRadius = element.cornerRadius || 0;\n\n    if (element.isExport) {\n      options.cornerRadius *= element.exportScaleValue.x;\n    }\n\n    var ariaLabel = element.description ? element.description : element.id;\n    this.renderer.drawRectangle(canvas, options, this.diagramId, element.isExport, undefined, parentSvg, ariaLabel);\n  };\n  /**\n   * Method used the draw the reactangle for the diagram  \\\n   *\n   * @returns {void} Method used the draw the reactangle for the diagram .\\\n   *\n   * @param { SVGElement} canvas - Provide the SVG elements .\n   * @param { RectAttributes} options - Provide the attributes to draw the rectangle  .\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.drawRect = function (canvas, options) {\n    options.cornerRadius = 0;\n    this.svgRenderer.drawRectangle(canvas, options, this.diagramId);\n  };\n  /**\n   * Will get the base attributes for all the elements  \\\n   *\n   * @returns {BaseAttributes} Will get the base attributes for all the elements .\\\n   *\n   * @param { DiagramElement} element - Provide the diagram elements .\n   * @param { Transforms} transform - Provide the transform value for the  elements .\n   * @param { boolean} isPreviewNode - Provide the preview boolean value.\n   * @private\n   */\n\n\n  DiagramRenderer.prototype.getBaseAttributes = function (element, transform, isPreviewNode) {\n    var options = {\n      width: element.actualSize.width,\n      height: element.actualSize.height,\n      x: element.offsetX - element.actualSize.width * element.pivot.x + 0.5,\n      y: element.offsetY - element.actualSize.height * element.pivot.y + 0.5,\n      fill: element.style.fill,\n      stroke: element.style.strokeColor,\n      angle: element.rotateAngle + element.parentTransform,\n      pivotX: element.pivot.x,\n      pivotY: element.pivot.y,\n      strokeWidth: element.style.strokeWidth,\n      dashArray: element.style.strokeDashArray || '',\n      opacity: element.style.opacity,\n      shadow: element.shadow,\n      gradient: element.style.gradient,\n      visible: element.visible,\n      id: element.id,\n      description: element.description,\n      canApplyStyle: element.canApplyStyle\n    };\n\n    if (isPreviewNode) {\n      options.x = options.x - .5;\n      options.y = options.y - .5;\n    }\n\n    if (element.isExport) {\n      options.width *= element.exportScaleValue.x;\n      options.height *= element.exportScaleValue.y;\n      options.x *= element.exportScaleValue.x;\n      options.y *= element.exportScaleValue.y;\n      options.strokeWidth *= element.exportScaleValue.x;\n    }\n\n    if (element.flip) {\n      options.flip = element.flip;\n    }\n\n    if (transform) {\n      options.x += transform.tx;\n      options.y += transform.ty;\n    }\n\n    return options;\n  };\n  /**\n   * Will render the SVG background image  \\\n   *\n   * @returns {void} Will render the SVG background image  .\\\n   *\n   * @param { Transforms} background - Provide the transforms values .\n   * @param { boolean} diagramElement - Provide element for the daigram.\n   * @param { boolean} x - Provide the rendering mode of the daigram.\n   * @param { boolean} y - Provide the rendering mode of the daigram.\n   * @param { boolean} width - Provide the rendering mode of the daigram.\n   * @param { boolean} height - Provide the rendering mode of the daigram.\n   * @private\n   */\n\n\n  DiagramRenderer.renderSvgBackGroundImage = function (background, diagramElement, x, y, width, height) {\n    if (background.source) {\n      var backgroundLayer = getBackgroundLayerSvg(diagramElement.id);\n      var target = backgroundLayer.getElementById(diagramElement.id + '_image');\n\n      if (!target) {\n        var bgimageLayer = getBackgroundImageLayer(diagramElement.id);\n        target = document.createElementNS('http://www.w3.org/2000/svg', 'image');\n        target.setAttribute('id', diagramElement.id + '_image');\n        bgimageLayer.appendChild(target);\n      }\n\n      var imageObj = new Image();\n      imageObj.src = background.source;\n      target.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', imageObj.src.toString());\n      var scale = background.scale !== 'None' ? background.scale : '';\n      var imgAlign = background.align;\n      var aspectRatio = imgAlign.charAt(0).toLowerCase() + imgAlign.slice(1);\n\n      if (scale) {\n        aspectRatio += ' ' + scale.charAt(0).toLowerCase() + scale.slice(1);\n      }\n\n      var attr = {\n        'id': diagramElement.id + '_image',\n        'x': x,\n        'y': y,\n        'width': width,\n        'height': height,\n        'preserveAspectRatio': aspectRatio\n      };\n      setAttributeSvg(target, attr);\n    }\n  };\n  /**\n   * Method used to transform the layer  \\\n   *\n   *  @returns {boolean} Method used to transform the layer  .\\\n   *  @param { Transforms} transform - Provide the transforms values .\n   *  @param { boolean} svgMode - Provide the rendering mode of the daigram.\n   *  @private\n   */\n\n\n  DiagramRenderer.prototype.transformLayers = function (transform, svgMode) {\n    var tx = transform.tx * transform.scale;\n    var ty = transform.ty * transform.scale;\n    var domTable = 'domTable';\n\n    if (tx !== this.transform.x || ty !== this.transform.y || tx === 0 || ty === 0) {\n      //diagram layer\n      if (svgMode) {\n        if (!window[domTable][this.diagramId + '_diagramLayer']) {\n          window[domTable][this.diagramId + '_diagramLayer'] = this.diagramSvgLayer.getElementById(this.diagramId + '_diagramLayer');\n        }\n\n        var diagramLayer = window[domTable][this.diagramId + '_diagramLayer'];\n        diagramLayer.setAttribute('transform', 'translate(' + transform.tx * transform.scale + ',' + transform.ty * transform.scale + '),scale(' + transform.scale + ')');\n      } //background\n      //gridline\n\n\n      var gridLayer = getGridLayer(this.diagramId);\n      gridLayer.setAttribute('transform', 'translate(' + transform.tx * transform.scale + ',' + transform.ty * transform.scale + ')'); //portslayer\n\n      if (!window[domTable][this.diagramId + '_diagramPorts']) {\n        window[domTable][this.diagramId + '_diagramPorts'] = this.iconSvgLayer.getElementById(this.diagramId + '_diagramPorts');\n      }\n\n      var portsLayer = window[domTable][this.diagramId + '_diagramPorts'];\n      portsLayer.setAttribute('transform', 'translate(' + transform.tx * transform.scale + ',' + transform.ty * transform.scale + '),scale(' + transform.scale + ')'); //expandlayer\n\n      if (!window[domTable][this.diagramId + '_diagramExpander']) {\n        window[domTable][this.diagramId + '_diagramExpander'] = this.iconSvgLayer.getElementById(this.diagramId + '_diagramExpander');\n      }\n\n      var expandLayer = window[domTable][this.diagramId + '_diagramExpander'];\n      expandLayer.setAttribute('transform', 'translate(' + transform.tx * transform.scale + ',' + transform.ty * transform.scale + '),scale(' + transform.scale + ')'); //nativelayer\n\n      if (!window[domTable][this.diagramId + '_nativeLayer']) {\n        window[domTable][this.diagramId + '_nativeLayer'] = this.nativeSvgLayer.getElementById(this.diagramId + '_nativeLayer');\n      }\n\n      var nativeLayer = window[domTable][this.diagramId + '_nativeLayer'];\n      nativeLayer.setAttribute('transform', 'translate(' + transform.tx * transform.scale + ',' + transform.ty * transform.scale + '),scale(' + transform.scale + ')'); //htmlLayer\n\n      var htmlLayer = getHTMLLayer(this.diagramId).children[0];\n      htmlLayer.style.transform = 'translate(' + transform.tx * transform.scale + 'px,' + transform.ty * transform.scale + 'px)scale(' + transform.scale + ')';\n      this.transform = {\n        x: transform.tx * transform.scale,\n        y: transform.ty * transform.scale\n      };\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Method used to update the nodes in the diagram  \\\n   *\n   *  @returns {void} Method used to update the nodes in the diagram  .\\\n   *  @param { HTMLCanvasElement} element - Provide the diagram element .\n   *  @param { HTMLCanvasElement} diagramElementsLayer - Provide the diagram layer element .\n   *  @param { HTMLCanvasElement} htmlLayer -Provide the html element .\n   *  @param { HTMLCanvasElement} transform - Provide the transform value .\n   *  @param { HTMLCanvasElement} insertIndex - Provide the index value.\n   *  @private\n   */\n\n\n  DiagramRenderer.prototype.updateNode = function (element, diagramElementsLayer, htmlLayer, transform, insertIndex, centerPoint) {\n    this.renderElement(element, diagramElementsLayer, htmlLayer, transform, this.getParentSvg(element), undefined, undefined, insertIndex, null, centerPoint);\n  };\n\n  return DiagramRenderer;\n}();\n\nexport { DiagramRenderer };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/renderer.js"],"names":["PathElement","ImageElement","TextElement","Container","rotateMatrix","identityMatrix","transformPointByMatrix","Size","wordBreakToString","whiteSpaceToString","textAlignToString","randomId","getUserHandlePosition","canShowCorner","getInterval","getSpaceValue","getDiagramElement","getAdornerLayer","getGridLayer","getHTMLLayer","updatePath","measurePath","getBackgroundLayerSvg","getBackgroundImageLayer","setAttributeSvg","SnapConstraints","RendererAction","ThumbsConstraints","SelectorConstraints","ElementAction","SvgRenderer","CanvasRenderer","processPathData","splitArrayCollection","transformPath","isDiagramChild","DiagramNativeElement","DiagramHtmlElement","Point","canDrawThumbs","avoidDrawSelector","Diagram","DiagramRenderer","name","svgRender","isSvgMode","renderer","transform","x","y","diagramId","element","svgRenderer","prototype","setCursor","canvas","cursor","style","setLayers","iconSvgLayer","getElementsByClassName","adornerSvgLayer","nativeSvgLayer","diagramSvgLayer","adornerLayer","getParentSvg","targetElement","id","split","length","elementActions","ElementIsPort","getParentElement","defaultParent","svgElement","indexValue","layerGElement","getElementById","groupElement","getGroupElement","g","svg","gElement","parentSvg","nativeSvg","createGElement","undefined","childNodes","insertBefore","appendChild","renderElement","htmlLayer","createParent","fromPalette","isPreviewNode","centerPoint","isElement","renderContainer","renderImageElement","renderPathElement","renderTextElement","renderNativeElement","renderHTMLElement","renderRect","drawSelectionRectangle","w","h","t","tx","scale","ty","options","width","height","fill","stroke","angle","pivotX","pivotY","strokeWidth","dashArray","opacity","visible","updateSelectionRegion","renderHighlighter","actualSize","offsetX","pivot","offsetY","rotateAngle","cornerRadius","class","drawRectangle","renderStackHighlighter","isVertical","position","isUml","isSwimlane","data","bounds","newPathString","d","scaleX","scaleY","arrayCollection","Number","umlData","drawPath","drawLine","renderResizeHandle","constraints","currentZoom","selectorConstraints","canMask","enableNode","nodeConstraints","left","top","Rotate","rendererActions","renderPivotLine","renderRotateThumb","renderBorder","nodeWidth","nodeHeight","ResizeNorthWest","renderCircularHandle","ResizeNorthEast","ResizeSouthWest","ResizeSouthEast","ResizeNorth","ResizeSouth","ResizeWest","ResizeEast","renderEndPointHandle","selector","connectedSource","connectedTarget","isSegmentEditing","sourcePoint","targetPoint","wrapper","i","segment","ConnectorSource","ConnectorTarget","type","segments","point","seg","renderOrthogonalThumbs","segment_1","bezierPoint","isEmptyPoint","point1","bezierPoint1","renderBezierLine","points","point2","bezierPoint2","visibility","orientation","j","distancePoints","toFixed","allowDrag","renderOrthogonalThumb","path","v","getBaseAttributes","startPoint","endPoint","start","end","x1","y1","x2","y2","cx","cy","enableSelector","connected","ariaLabel","count","className","radius","newPoint","parentTransform","matrix","centerX","centerY","drawCircle","isBorderTickness","gradient","DrawSelectorBorder","renderUserHandler","selectorItem","diagramUserHandlelayer","canDraw","_i","_a","userHandles","obj","disableConnectors","connectors","disableNodes","nodes","div","document","template","cloneNode","UserHandle","pathData","content","option","backgroundColor","borderColor","borderWidth","size","pathPading","pathSize","newData","pathColor","handleContent","horizontalAlignment","verticalAlignment","setOffsetWithRespectToBounds","relativeMode","description","measure","arrange","desiredSize","drawNativeContent","source","sourceWidth","sourceHeight","alignment","imageAlign","imageScale","drawImage","templateContent","drawHTMLContent","absolutePath","flipOffset","isExport","pathBounds","absoluteBounds","renderSvgGridlines","snapSettings","gridSvg","rulerSettings","hRuler","vRuler","pattern","createElementNS","defs","setAttribute","ShowHorizontalLines","ShowVerticalLines","hWidth","hHeight","hSegmentwidth","vSegmentwidth","isRulerGrid","isLine","gridType","verticalLineIntervals","verticalGridlines","lineIntervals","dotIntervals","horizontalLineIntervals","horizontalGridlines","showRulers","dynamicGrid","updateSegmentWidth","scaledIntervals","interval","scaleSnapInterval","attr","patternUnits","horizontalSvgGridlines","verticalSvgGridlines","intervals","space","hLine","lineDashArray","parseDashArray","updateLineIntervals","spaceY","toString","lineColor","renderDotGrid","spacey","isHorizontal","r","dy","vLine","updateGrid","svgGrid","grid","parentNode","removeChild","ruler","segmentWidth","newInterval","tickInterval","snapIntervals","gridlines","whiteSpace","textWrapping","breakWord","textAlign","color","italic","bold","fontSize","fontFamily","textOverflow","textDecoration","doWrap","wrapBounds","isHorizontalLane","isLaneOrientation","parentOffsetX","parentOffsetY","parentWidth","parentHeight","drawText","Math","min","exportScaleValue","templateWidth","templateHeight","nativeLayer","contentSize","children","imageWidth","imageHeight","stretch","contentWidth","contentHeight","widthRatio","heightRatio","ratio","abs","max","group","svgParent","diagramElement","instance","diagram","hasNativeParent","svgNativeParent","hasChildren","parentG","svgParent_1","child","flip","ElementIsGroup","renderFlipElement","selectedNode","selectedItems","innerNodeContent","innerLabelContent","flipMode","k","nameTable","propName","posX","posY","center","layer","querySelector","drawRect","strokeColor","strokeDashArray","shadow","canApplyStyle","renderSvgBackGroundImage","background","backgroundLayer","target","bgimageLayer","imageObj","Image","src","setAttributeNS","imgAlign","align","aspectRatio","charAt","toLowerCase","slice","transformLayers","svgMode","domTable","window","diagramLayer","gridLayer","portsLayer","expandLayer","updateNode","diagramElementsLayer","insertIndex"],"mappings":"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","sourcesContent":["import { PathElement } from '../core/elements/path-element';\nimport { ImageElement } from '../core/elements/image-element';\nimport { TextElement } from '../core/elements/text-element';\nimport { Container } from '../core/containers/container';\nimport { rotateMatrix, identityMatrix, transformPointByMatrix } from '../primitives/matrix';\nimport { Size } from '../primitives/size';\nimport { wordBreakToString, whiteSpaceToString, textAlignToString, randomId } from '../utility/base-util';\nimport { getUserHandlePosition, canShowCorner, getInterval, getSpaceValue } from '../utility/diagram-util';\nimport { getDiagramElement, getAdornerLayer, getGridLayer, getHTMLLayer, updatePath } from '../utility/dom-util';\nimport { measurePath, getBackgroundLayerSvg, getBackgroundImageLayer, setAttributeSvg } from '../utility/dom-util';\nimport { SnapConstraints, RendererAction } from '../enum/enum';\nimport { ThumbsConstraints, SelectorConstraints, ElementAction } from '../enum/enum';\nimport { SvgRenderer } from './svg-renderer';\nimport { CanvasRenderer } from './canvas-renderer';\nimport { processPathData, splitArrayCollection, transformPath } from '../utility/path-util';\nimport { isDiagramChild } from '../utility/diagram-util';\nimport { DiagramNativeElement } from '../core/elements/native-element';\nimport { DiagramHtmlElement } from '../core/elements/html-element';\nimport { Point } from '../primitives/point';\nimport { canDrawThumbs, avoidDrawSelector } from '../utility/constraints-util';\nimport { Diagram } from '../diagram';\n/**\n * Renderer module is used to render basic diagram elements\n */\n/** @private */\nvar DiagramRenderer = /** @class */ (function () {\n    function DiagramRenderer(name, svgRender, isSvgMode) {\n        /**   @private  */\n        this.renderer = null;\n        /** @private */\n        this.isSvgMode = true;\n        this.transform = { x: 0, y: 0 };\n        this.diagramId = name;\n        this.element = getDiagramElement(this.diagramId);\n        this.svgRenderer = svgRender;\n        this.isSvgMode = isSvgMode;\n        this.renderer = isSvgMode ? new SvgRenderer() : new CanvasRenderer();\n    }\n    /**\n     * Method used to set the cur \\\n     *\n     *  @param {HTMLElement} canvas - Provide the canvas .\n     *  @param {string} cursor - Provide the element .\n     * @returns {void }   Method used to set the layer  .\\\n     * @private\n     */\n    DiagramRenderer.prototype.setCursor = function (canvas, cursor) {\n        canvas.style.cursor = cursor;\n    };\n    /**\n     * Method used to set the layer \\\n     *\n     * @returns {void }   Method used to set the layer  .\\\n     *\n     * @private\n     */\n    DiagramRenderer.prototype.setLayers = function () {\n        this.iconSvgLayer = this.element.getElementsByClassName('e-ports-expand-layer')[0];\n        this.adornerSvgLayer = this.element.getElementsByClassName('e-adorner-layer')[0];\n        this.nativeSvgLayer = this.element.getElementsByClassName('e-native-layer')[0];\n        this.diagramSvgLayer = this.element.getElementsByClassName('e-diagram-layer')[0];\n    };\n    DiagramRenderer.prototype.getAdornerLayer = function () {\n        var adornerLayer = getAdornerLayer(this.diagramId);\n        return adornerLayer;\n    };\n    DiagramRenderer.prototype.getParentSvg = function (element, targetElement, canvas) {\n        if (this.diagramId && element && element.id) {\n            if (element.id.split('_icon_content').length > 1 || element.id.split('_nodeport').length > 1 ||\n                (element.elementActions & ElementAction.ElementIsPort)) {\n                return this.iconSvgLayer;\n            }\n            if (targetElement && targetElement === 'selector') {\n                return this.adornerSvgLayer;\n            }\n            else if (element instanceof DiagramNativeElement) {\n                return this.nativeSvgLayer;\n            }\n            else {\n                return this.diagramSvgLayer;\n            }\n        }\n        return canvas;\n    };\n    DiagramRenderer.prototype.getParentElement = function (element, defaultParent, svgElement, indexValue) {\n        var layerGElement = defaultParent;\n        if (svgElement && this.diagramId && element && element.id) {\n            if (element.id.split('_icon_content').length > 1) {\n                layerGElement = svgElement.getElementById(this.diagramId + '_diagramExpander');\n                defaultParent = null;\n            }\n            else if (element.id.split('_nodeport').length > 1) {\n                layerGElement = svgElement.getElementById(this.diagramId + '_diagramPorts');\n            }\n            else if (element instanceof DiagramNativeElement) {\n                layerGElement = svgElement.getElementById(this.diagramId + '_nativeLayer');\n                defaultParent = null;\n            }\n            else if (element.elementActions & ElementAction.ElementIsPort) {\n                layerGElement = svgElement.getElementById(this.diagramId + '_diagramPorts');\n                defaultParent = null;\n            }\n            else {\n                layerGElement = svgElement.getElementById(this.diagramId + '_diagramLayer');\n            }\n            var groupElement = this.getGroupElement(element, defaultParent || layerGElement, indexValue);\n            layerGElement = groupElement.g;\n            if (groupElement.svg) {\n                svgElement = groupElement.svg;\n            }\n        }\n        return { g: layerGElement, svg: svgElement };\n    };\n    DiagramRenderer.prototype.getGroupElement = function (element, canvas, indexValue) {\n        var gElement;\n        var parentSvg = this.getParentSvg(element);\n        var svgElement;\n        if (canvas && parentSvg) {\n            if (parentSvg) {\n                gElement = parentSvg.getElementById(element.id + '_groupElement');\n                if (!gElement && parentSvg !== this.nativeSvgLayer) { //code added\n                    var nativeSvg = this.nativeSvgLayer;\n                    gElement = nativeSvg.getElementById(element.id + '_groupElement');\n                    svgElement = nativeSvg;\n                }\n            }\n            if (!gElement) {\n                gElement = this.svgRenderer.createGElement('g', { id: element.id + '_groupElement' });\n                if (indexValue !== undefined && canvas.childNodes.length > indexValue) {\n                    canvas.insertBefore(gElement, canvas.childNodes[indexValue]);\n                }\n                else {\n                    canvas.appendChild(gElement);\n                }\n            }\n        }\n        return { g: gElement, svg: svgElement };\n    };\n    /**\n     * Method used to render the diagram element \\\n     *\n     * @returns {void }   Method used to render the diagram element  .\\\n     *\n     * @param {DiagramElement} element - Provide the DiagramElement value.\n     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the canvas value.\n     * @param {HTMLElement } htmlLayer - Provide the HTMLElement value.\n     * @param {Transforms } transform - Provide the Transforms value.\n     * @param {SVGSVGElement} parentSvg - Provide the SVGSVGElement value.\n     * @param {boolean } createParent - Provide the boolean value.\n     * @param {boolean } fromPalette - Provide the boolean value.\n     * @param {number } indexValue - Provide the indexValue value.\n     * @param {boolean } isPreviewNode - Provide the isPreviewNode value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderElement = function (element, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint) {\n        var isElement = true;\n        if (element instanceof Container) {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            isElement = false;\n            element.id = element.id ? element.id : randomId();\n            this.renderContainer(element, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint);\n        }\n        else if (element instanceof ImageElement) {\n            this.renderImageElement(element, canvas, transform, parentSvg, fromPalette);\n        }\n        else if (element instanceof PathElement) {\n            this.renderPathElement(element, canvas, transform, parentSvg, fromPalette, isPreviewNode);\n        }\n        else if (element instanceof TextElement) {\n            this.renderTextElement(element, canvas, transform, parentSvg, fromPalette, centerPoint);\n        }\n        else if (element instanceof DiagramNativeElement) {\n            this.renderNativeElement(element, canvas, transform, parentSvg, fromPalette);\n        }\n        else if (element instanceof DiagramHtmlElement) {\n            this.renderHTMLElement(element, canvas, htmlLayer, transform, parentSvg, fromPalette, indexValue);\n        }\n        else {\n            this.renderRect(element, canvas, transform, parentSvg, isPreviewNode);\n        }\n    };\n    /**\n     * Method used to draw the selection rectangle for the node \\\n     *\n     * @returns {void }  Method used to draw the selection rectangle for the node  .\\\n     *\n     * @param {number} x - Provide the DiagramElement value.\n     * @param {number } y - Provide the SVGElement value.\n     * @param {number } w - Provide the Transforms value.\n     * @param {number } h - Provide the Transforms value.\n     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the Transforms value.\n     * @param {number } t - Provide the Transforms value.\n     * @private\n     */\n    DiagramRenderer.prototype.drawSelectionRectangle = function (x, y, w, h, canvas, t) {\n        x = (x + t.tx) * t.scale;\n        y = (y + t.ty) * t.scale;\n        var options = {\n            width: w * t.scale, height: h * t.scale,\n            x: x + 0.5, y: y + 0.5, fill: 'transparent', stroke: 'gray', angle: 0,\n            pivotX: 0.5, pivotY: 0.5, strokeWidth: 1,\n            dashArray: '6 3', opacity: 1,\n            visible: true, id: canvas.id + '_selected_region'\n        };\n        var adornerLayer = this.getAdornerLayer();\n        this.svgRenderer.updateSelectionRegion(adornerLayer, options);\n    };\n    /**\n     * Method used to render the highlighter \\\n     *\n     * @returns {void }  Method used to render the highlighter  .\\\n     *\n     * @param {DiagramElement} element - Provide the DiagramElement value.\n     * @param {SVGElement } canvas - Provide the SVGElement value.\n     * @param {Transforms } transform - Provide the Transforms value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderHighlighter = function (element, canvas, transform) {\n        var width = element.actualSize.width || 2;\n        var height = element.actualSize.height || 2;\n        var x = element.offsetX - width * element.pivot.x;\n        var y = element.offsetY - height * element.pivot.y;\n        x = (x + transform.tx) * transform.scale;\n        y = (y + transform.ty) * transform.scale;\n        var options = {\n            width: width * transform.scale, height: height * transform.scale,\n            x: x, y: y, fill: 'transparent', stroke: '#8CC63F', angle: element.rotateAngle,\n            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: 4,\n            dashArray: '', opacity: 1, cornerRadius: 0,\n            visible: true, id: canvas.id + '_highlighter', class: 'e-diagram-highlighter'\n        };\n        this.svgRenderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, canvas);\n    };\n    /**\n     * Method used to render the stack highlighter \\\n     *\n     * @returns {void }  Method used to render the stack highlighter  .\\\n     *\n     * @param {DiagramElement} element - Provide the DiagramElement value.\n     * @param {SVGElement } canvas - Provide the SVGElement value.\n     * @param {Transforms } transform - Provide the Transforms value.\n     * @param {boolean} isVertical - Provide the Boolean value.\n     * @param {PointModel } position - Provide the PointModel value.\n     * @param {boolean } isUml - Provide the boolean value.\n     * @param {boolean } isSwimlane - Provide the boolean value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderStackHighlighter = function (element, canvas, transform, isVertical, position, isUml, isSwimlane) {\n        var width = element.actualSize.width || 2;\n        var x = element.offsetX - width * element.pivot.x;\n        var height = element.actualSize.height || 2;\n        var y = element.offsetY - height * element.pivot.y;\n        x = (x + transform.tx) * transform.scale;\n        var data;\n        var bounds = element.bounds;\n        var newPathString = '';\n        y = (y + transform.ty) * transform.scale;\n        if (!isVertical) {\n            var d = height * transform.scale;\n            data = 'M 10 -10 L 0 0 Z M -10 -10 L 0 0 Z M 0 0 L 0 ' + (d) + ' Z M 0  ' + (d) +\n                ' L -10  ' + (d + 10) + ' Z L 10  ' + (d + 10) + ' Z';\n            if (position.x >= element.offsetX) {\n                x += width;\n            }\n        }\n        else {\n            if (isUml) {\n                var d = width * transform.scale;\n                data = 'M 0 0 L ' + (d + 2) + ' 0 Z';\n                var scaleX = -bounds.x;\n                var scaleY = -bounds.y;\n                var arrayCollection = [];\n                scaleX = element.actualSize.width / Number(bounds.width ? bounds.width : 1) * transform.scale;\n                scaleY = element.actualSize.height / Number(bounds.height ? bounds.height : 1) * transform.scale;\n                var umlData = 'M7,4 L8,4 8,7 11,7 11,8 8,8 8,11 7,11 7,8 4,8 4,7 7,7 z M7.5,0.99999994' +\n                    'C3.9160004,1 1,3.9160004 0.99999994,7.5 1,11.084 3.9160004,14 7.5,14 11.084,14 14,11.084 14,7.5 14,' +\n                    '3.9160004 11.084,1 7.5,0.99999994 z M7.5,0 C11.636002,0 15,3.3639984 15,7.5 15,11.636002 11.636002,15 7.5,' +\n                    '15 3.3640003,15 0,11.636002 0,7.5 0,3.3639984 3.3640003,0 7.5,0 z';\n                arrayCollection = processPathData(umlData);\n                arrayCollection = splitArrayCollection(arrayCollection);\n                newPathString = transformPath(arrayCollection, scaleX + d + 2, scaleY - 8, false, bounds.x, bounds.y, 0, 0);\n                if (position.y >= element.offsetY) {\n                    y += height;\n                }\n            }\n            else {\n                if (isSwimlane) {\n                    if (position.y >= element.offsetY) {\n                        y += height;\n                    }\n                }\n                var d = width * transform.scale;\n                data = 'M -10 -10 L 0 0 Z M -10 10 L 0 0 Z M 0 0 L ' + (d) + ' 0 Z M ' + (d) + ' 0 L ' +\n                    (d + 10) + ' 10 Z L ' + (d + 10) + ' -10 Z';\n            }\n        }\n        var options = {\n            data: data + newPathString,\n            width: width * transform.scale, height: height * transform.scale,\n            x: x, y: y, fill: 'transparent', stroke: '#8CC63F', angle: element.rotateAngle,\n            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: 1,\n            dashArray: '', opacity: 1,\n            visible: true, id: canvas.id + '_stack_highlighter', class: 'e-diagram-highlighter'\n        };\n        this.svgRenderer.drawPath(canvas, options, this.diagramId);\n    };\n    /**\n     * Method used to draw the line \\\n     *\n     * @returns {void }  Method used to draw the line  .\\\n     *\n     * @param {SVGElement} canvas - Provide the SVGElement value.\n     * @param {LineAttributes } options - Provide the LineAttributes value.\n     * @private\n     */\n    DiagramRenderer.prototype.drawLine = function (canvas, options) {\n        this.svgRenderer.drawLine(canvas, options);\n    };\n    /**\n     * Method used to draw the path \\\n     *\n     * @returns {void }  Method used to draw the path  .\\\n     *\n     * @param {SVGElement} canvas - Provide the canvas value.\n     * @param {PathAttributes } options - Provide the PathAttributes value.\n     * @private\n     */\n    DiagramRenderer.prototype.drawPath = function (canvas, options) {\n        this.svgRenderer.drawPath(canvas, options, this.diagramId);\n    };\n    /**\n     * Method used to render the resize handle \\\n     *\n     * @returns {void }  Method used to render the resize handle  .\\\n     *\n     * @param {DiagramElement} element - Provide the DiagramElement value.\n     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n     * @param {  ThumbsConstraints } constraints - Provide the constraints value  .\n     * @param { number} currentZoom - Provide the currentZoom value.\n     * @param { SelectorConstraints } selectorConstraints - Provide the selectorConstraints value .\n     * @param { Transforms } transform - Provide the transform  value.\n     * @param { boolean } canMask - Provide the canMask boolean value.\n     * @param { number } enableNode - Provide the enableNode value.\n     * @param { boolean } nodeConstraints - Provide the nodeConstraints  value.\n     * @param { boolean } isSwimlane - Provide the isSwimlane boolean value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderResizeHandle = function (element, canvas, constraints, currentZoom, selectorConstraints, transform, canMask, enableNode, nodeConstraints, isSwimlane) {\n        var left = element.offsetX - element.actualSize.width * element.pivot.x;\n        var top = element.offsetY - element.actualSize.height * element.pivot.y;\n        var height = element.actualSize.height;\n        var width = element.actualSize.width;\n        if (!isSwimlane &&\n            (constraints & ThumbsConstraints.Rotate && canDrawThumbs(this.rendererActions) && (!avoidDrawSelector(this.rendererActions)))) {\n            this.renderPivotLine(element, canvas, transform, selectorConstraints, canMask);\n            this.renderRotateThumb(element, canvas, transform, selectorConstraints, canMask);\n        }\n        this.renderBorder(element, canvas, transform, enableNode, nodeConstraints, isSwimlane);\n        var nodeWidth = element.actualSize.width * currentZoom;\n        var nodeHeight = element.actualSize.height * currentZoom;\n        if (!nodeConstraints && canDrawThumbs(this.rendererActions) && (!avoidDrawSelector(this.rendererActions))) {\n            if (nodeWidth >= 40 && nodeHeight >= 40) {\n                //Hide corners when the size is less than 40\n                if (selectorConstraints & SelectorConstraints.ResizeNorthWest) {\n                    this.renderCircularHandle('resizeNorthWest', element, left, top, canvas, canShowCorner(selectorConstraints, 'ResizeNorthWest'), constraints & ThumbsConstraints.ResizeNorthWest, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on top left side direction' }, undefined, 'e-diagram-resize-handle e-northwest');\n                }\n                if (selectorConstraints & SelectorConstraints.ResizeNorthEast) {\n                    this.renderCircularHandle('resizeNorthEast', element, left + width, top, canvas, canShowCorner(selectorConstraints, 'ResizeNorthEast'), constraints & ThumbsConstraints.ResizeNorthEast, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on top right side direction' }, undefined, 'e-diagram-resize-handle e-northeast');\n                }\n                if (selectorConstraints & SelectorConstraints.ResizeSouthWest) {\n                    this.renderCircularHandle('resizeSouthWest', element, left, top + height, canvas, canShowCorner(selectorConstraints, 'ResizeSouthWest'), constraints & ThumbsConstraints.ResizeSouthWest, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on bottom left side direction' }, undefined, 'e-diagram-resize-handle e-southwest');\n                }\n                if (selectorConstraints & SelectorConstraints.ResizeSouthEast) {\n                    this.renderCircularHandle('resizeSouthEast', element, left + width, top + height, canvas, canShowCorner(selectorConstraints, 'ResizeSouthEast'), constraints & ThumbsConstraints.ResizeSouthEast, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on bottom right side direction' }, undefined, 'e-diagram-resize-handle e-southeast');\n                }\n            }\n            if (selectorConstraints & SelectorConstraints.ResizeNorth) {\n                this.renderCircularHandle('resizeNorth', element, left + width / 2, top, canvas, canShowCorner(selectorConstraints, 'ResizeNorth'), constraints & ThumbsConstraints.ResizeNorth, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on top side direction' }, undefined, 'e-diagram-resize-handle e-north');\n            }\n            if (selectorConstraints & SelectorConstraints.ResizeSouth) {\n                this.renderCircularHandle('resizeSouth', element, left + width / 2, top + height, canvas, canShowCorner(selectorConstraints, 'ResizeSouth'), constraints & ThumbsConstraints.ResizeSouth, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on bottom side direction' }, undefined, 'e-diagram-resize-handle e-south');\n            }\n            if (selectorConstraints & SelectorConstraints.ResizeWest) {\n                this.renderCircularHandle('resizeWest', element, left, top + height / 2, canvas, canShowCorner(selectorConstraints, 'ResizeWest'), constraints & ThumbsConstraints.ResizeWest, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on left side direction' }, undefined, 'e-diagram-resize-handle e-west');\n            }\n            if (selectorConstraints & SelectorConstraints.ResizeEast) {\n                this.renderCircularHandle('resizeEast', element, left + width, top + height / 2, canvas, canShowCorner(selectorConstraints, 'ResizeEast'), constraints & ThumbsConstraints.ResizeEast, transform, undefined, canMask, { 'aria-label': 'Thumb to resize the selected object on right side direction' }, undefined, 'e-diagram-resize-handle e-east');\n            }\n        }\n    };\n    /**\n     * Method used to render the end point of the handle \\\n     *\n     * @returns {void }  Method used to render the end point of the handle  .\\\n     *\n     * @param {ConnectorModel} selector - Provide the ConnectorModel.\n     * @param {HTMLCanvasElement | SVGElement } canvas - Provide the element.\n     * @param {  ThumbsConstraints } constraints - Provide the constraints value  .\n     * @param { SelectorConstraints} selectorConstraints - Provide the selectorConstraints value.\n     * @param { Transforms } transform - Provide the transform value .\n     * @param { boolean } connectedSource - Provide the connectedSource boolean value.\n     * @param { boolean } connectedTarget - Provide the connectedTarget boolean value.\n     * @param { boolean } isSegmentEditing - Provide the isSegmentEditing boolean value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderEndPointHandle = function (selector, canvas, constraints, selectorConstraints, transform, connectedSource, connectedTarget, isSegmentEditing) {\n        var sourcePoint = selector.sourcePoint;\n        var targetPoint = selector.targetPoint;\n        var wrapper = selector.wrapper;\n        var i;\n        var segment;\n        this.renderCircularHandle('connectorSourceThumb', wrapper, sourcePoint.x, sourcePoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorSourceThumb'), constraints & ThumbsConstraints.ConnectorSource, transform, connectedSource, undefined, { 'aria-label': 'Thumb to move the source point of the connector' }, undefined, 'e-diagram-endpoint-handle e-targetend');\n        this.renderCircularHandle('connectorTargetThumb', wrapper, targetPoint.x, targetPoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorTargetThumb'), constraints & ThumbsConstraints.ConnectorTarget, transform, connectedTarget, undefined, { 'aria-label': 'Thumb to move the target point of the connector' }, undefined, 'e-diagram-endpoint-handle e-targetend');\n        if (isSegmentEditing) {\n            if ((selector.type === 'Straight' || selector.type === 'Bezier') && selector.segments.length > 0) {\n                for (i = 0; i < selector.segments.length - 1; i++) {\n                    segment = selector.segments[i];\n                    this.renderCircularHandle(('segementThumb_' + (i + 1)), wrapper, segment.point.x, segment.point.y, canvas, true, constraints & ThumbsConstraints.ConnectorSource, transform, connectedSource, null, null, i);\n                }\n            }\n            else {\n                for (i = 0; i < selector.segments.length; i++) {\n                    var seg = selector.segments[i];\n                    this.renderOrthogonalThumbs('orthoThumb_' + (i + 1), wrapper, seg, canvas, canShowCorner(selectorConstraints, 'ConnectorSourceThumb'), transform);\n                }\n            }\n        }\n        if (selector.type === 'Bezier') {\n            for (i = 0; i < selector.segments.length; i++) {\n                var segment_1 = selector.segments[i];\n                var bezierPoint = !Point.isEmptyPoint(segment_1.point1) ? segment_1.point1\n                    : segment_1.bezierPoint1;\n                this.renderCircularHandle('bezierPoint_' + (i + 1) + '_1', wrapper, bezierPoint.x, bezierPoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorSourceThumb'), constraints & ThumbsConstraints.ConnectorSource, transform, undefined, undefined, { 'aria-label': 'Thumb to move the source point of the connector' }, undefined, 'e-diagram-bezier-handle e-source');\n                if (canShowCorner(selectorConstraints, 'ConnectorSourceThumb')) {\n                    this.renderBezierLine('bezierLine_' + (i + 1) + '_1', wrapper, canvas, segment_1.points[0], !Point.isEmptyPoint(segment_1.point1) ? segment_1.point1 : segment_1.bezierPoint1, transform);\n                }\n                bezierPoint = !Point.isEmptyPoint(segment_1.point2) ? segment_1.point2 : segment_1.bezierPoint2;\n                this.renderCircularHandle('bezierPoint_' + (i + 1) + '_2', wrapper, bezierPoint.x, bezierPoint.y, canvas, canShowCorner(selectorConstraints, 'ConnectorTargetThumb'), constraints & ThumbsConstraints.ConnectorTarget, transform, undefined, undefined, { 'aria-label': 'Thumb to move the target point of the connector' }, undefined, 'e-diagram-bezier-handle e-target');\n                if (canShowCorner(selectorConstraints, 'ConnectorTargetThumb')) {\n                    this.renderBezierLine('bezierLine_' + (i + 1) + '_2', wrapper, canvas, segment_1.points[1], !Point.isEmptyPoint(segment_1.point2) ? segment_1.point2 : segment_1.bezierPoint2, transform);\n                }\n            }\n        }\n    };\n    /**\n     * Method used to render the orthogonal thumb \\\n     *\n     * @returns {void }  Method used to render the orthogonal thumb  .\\\n     *\n     * @param {string} id - Provide the id for the element.\n     * @param {DiagramElement } selector - Provide the selector element.\n     * @param {  OrthogonalSegment } segment - Provide the segment value  .\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { boolean } visibility - Provide the visibility value .\n     * @param { Transforms } t - Provide the Transforms value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderOrthogonalThumbs = function (id, selector, segment, canvas, visibility, t) {\n        var orientation;\n        var visible;\n        var length;\n        var j = 0;\n        for (j = 0; j < segment.points.length - 1; j++) {\n            length = Point.distancePoints(segment.points[j], segment.points[j + 1]);\n            orientation = (segment.points[j].y.toFixed(2) === segment.points[j + 1].y.toFixed(2)) ? 'horizontal' : 'vertical';\n            visible = (length >= 50 && segment.allowDrag) ? true : false;\n            this.renderOrthogonalThumb((id + '_' + (j + 1)), selector, (((segment.points[j].x + segment.points[j + 1].x) / 2)), (((segment.points[j].y + segment.points[j + 1].y) / 2)), canvas, visible, orientation, t);\n        }\n    };\n    /**\n     * Method used to render the orthogonal thumb \\\n     *\n     * @returns {void }  Method used to render the orthogonal thumb  .\\\n     *\n     * @param {string} id - Provide the id for the element.\n     * @param {DiagramElement } selector - Provide the selector element.\n     * @param {  Transforms } x - Provide the x value  .\n     * @param { Transforms } y - Provide the y value.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n     * @param { boolean } visible - Provide the visible boolean value.\n     * @param { string } orientation - Provide the orientation value.\n     * @param { Transforms } t - Provide the Transforms value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderOrthogonalThumb = function (id, selector, x, y, canvas, visible, orientation, t) {\n        var path;\n        var h;\n        var v;\n        if (orientation === 'horizontal') {\n            path = 'M0,7 L15,0 L30,7 L15,14 z';\n            h = -15;\n            v = -7;\n        }\n        else {\n            path = 'M7,0 L0,15 L7,30 L14,15 z';\n            h = -7;\n            v = -15;\n        }\n        var options = {\n            x: ((x + t.tx) * t.scale) + h, y: ((y + t.ty) * t.scale) + v, angle: 0,\n            fill: '#e2e2e2', stroke: 'black', strokeWidth: 1, dashArray: '', data: path,\n            width: 20, height: 20, pivotX: 0, pivotY: 0, opacity: 1, visible: visible, id: id\n        };\n        this.svgRenderer.drawPath(canvas, options, this.diagramId);\n    };\n    /**\n     * Method used to render the pivot line line\\\n     *\n     * @returns {void } Method used to render the pivot line line .\\\n     *\n     * @param {DiagramElement} element - Provide the diagram element value.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n     * @param {  Transforms } transform - Provide the transform value  .\n     * @param { SelectorConstraints } selectorConstraints - Provide the selector constraints value.\n     * @param { boolean } canMask - Provide the canMask boolean value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderPivotLine = function (element, canvas, transform, selectorConstraints, canMask) {\n        var wrapper = element;\n        var dashArray = '2,3';\n        var visible = (selectorConstraints & SelectorConstraints.Rotate) ? true : false;\n        if (canMask) {\n            visible = false;\n        }\n        var options = this.getBaseAttributes(wrapper, transform);\n        options.fill = 'None';\n        options.stroke = 'black';\n        options.strokeWidth = 1;\n        options.dashArray = dashArray;\n        options.visible = visible;\n        var scale = transform.scale;\n        options.x *= scale;\n        options.y *= scale;\n        options.width *= scale;\n        options.height *= scale;\n        options.id = 'pivotLine';\n        options.class = 'e-diagram-pivot-line';\n        var startPoint = { x: wrapper.actualSize.width * wrapper.pivot.x * scale, y: -20 };\n        var endPoint = { x: wrapper.actualSize.width * wrapper.pivot.x * scale, y: 0 };\n        options.startPoint = startPoint;\n        options.endPoint = endPoint;\n        this.svgRenderer.drawLine(canvas, options);\n    };\n    /**\n     * Method used to render the bezier line for the connector  \\\n     *\n     * @returns {void } Method used to render the bezier line for the connector .\\\n     *\n     * @param {string} id - Provide the id value for the bezier line.\n     * @param { DiagramElement } wrapper - Provide the wrapper for the element.\n     * @param {  HTMLCanvasElement | SVGElement } canvas - Provide the canvas element  .\n     * @param { PointModel } start - Provide the pointmodel value.\n     * @param { PointModel } end - Provide the pointmodel value.\n     * @param { Transforms } transform - Provide the itransform value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderBezierLine = function (id, wrapper, canvas, start, end, transform) {\n        var dashArray = '3,3';\n        var options = this.getBaseAttributes(wrapper, transform);\n        options.id = id;\n        options.stroke = 'black';\n        options.strokeWidth = 1;\n        options.dashArray = dashArray;\n        options.fill = 'None';\n        options.class = 'e-diagram-bezier-line';\n        options.x = 0;\n        options.y = 0;\n        var scale = transform.scale;\n        var x1 = (start.x + transform.tx) * scale;\n        var y1 = (start.y + transform.ty) * scale;\n        var x2 = (end.x + transform.tx) * scale;\n        var y2 = (end.y + transform.ty) * scale;\n        var startPoint = { x: x1, y: y1 };\n        var endPoint = { x: x2, y: y2 };\n        options.startPoint = startPoint;\n        options.endPoint = endPoint;\n        this.svgRenderer.drawLine(canvas, options);\n    };\n    /**\n     * Method used to render the circular handle for the node element  \\\n     *\n     * @returns {void } Method used to render the circular handle for the node element .\\\n     *\n     * @param {string} id - Provide the id value.\n     * @param { DiagramElement } selector - Provide the selector element value.\n     * @param { number } cx - Provide cx value  .\n     * @param { number } cy - Provide cx value.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element.\n     * @param { boolean } visible - Provide the visible property for the handle .\n     * @param { number } enableSelector - Provide the value for the enableSelector .\n     * @param { Transforms } t - Provide the transform value .\n     * @param { boolean } connected - Provide the connected boolean value .\n     * @param { boolean } canMask - Provide the canMask boolean value .\n     * @param { Object } ariaLabel - Provide the label properties .\n     * @param { number } count - Provide the count value  .\n     * @param { string } className - Provide the class name for this element .\n     * @private\n     */\n    DiagramRenderer.prototype.renderCircularHandle = function (id, selector, cx, cy, canvas, visible, enableSelector, t, connected, canMask, ariaLabel, count, className) {\n        var wrapper = selector;\n        var radius = 7;\n        var newPoint = { x: cx, y: cy };\n        if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {\n            var matrix = identityMatrix();\n            rotateMatrix(matrix, wrapper.rotateAngle + wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY);\n            newPoint = transformPointByMatrix(matrix, newPoint);\n        }\n        var options = this.getBaseAttributes(wrapper);\n        options.stroke = 'black';\n        options.strokeWidth = 1;\n        if (count !== undefined) {\n            radius = 5;\n            options.id = 'segmentEnd_' + count;\n            options.fill = '#e2e2e2';\n        }\n        else {\n            radius = 7;\n            options.fill = connected ? '#8CC63F' : 'white';\n        }\n        options.centerX = (newPoint.x + t.tx) * t.scale;\n        options.centerY = (newPoint.y + t.ty) * t.scale;\n        options.radius = radius;\n        options.angle = 0;\n        options.id = id;\n        options.visible = visible;\n        options.class = className;\n        if (connected) {\n            options.class += ' e-connected';\n        }\n        if (canMask) {\n            options.visible = false;\n        }\n        this.svgRenderer.drawCircle(canvas, options, enableSelector, ariaLabel);\n    };\n    /**\n     * Method used to render border for the node element  \\\n     *\n     * @returns {void } Method used to render border for the node element .\\\n     *\n     * @param {SelectorModel} selector - Provide the selector model instance.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { number } enableNode - Provide enableNode boolean value.\n     * @param { boolean } isBorderTickness - Provide the thickness value for the node.\n     * @param { boolean } isSwimlane - Provide the isSwimlane boolean value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderBorder = function (selector, canvas, transform, enableNode, isBorderTickness, isSwimlane) {\n        var wrapper = selector;\n        var options = this.getBaseAttributes(wrapper, transform);\n        options.x *= transform.scale;\n        options.y *= transform.scale;\n        options.width *= transform.scale;\n        options.height *= transform.scale;\n        options.fill = 'transparent';\n        options.stroke = '#097F7F';\n        options.strokeWidth = 1.2;\n        options.gradient = null;\n        options.dashArray = '6,3';\n        options.class = 'e-diagram-border';\n        if (isSwimlane) {\n            options.class += ' e-diagram-lane';\n        }\n        options.id = 'borderRect';\n        options.id = (this.rendererActions & RendererAction.DrawSelectorBorder) ? 'borderRect_symbol' : 'borderRect';\n        if (!enableNode) {\n            options.class += ' e-disabled';\n        }\n        if (isBorderTickness) {\n            options.class += ' e-thick-border';\n        }\n        options.cornerRadius = 0;\n        var parentSvg = this.getParentSvg(selector, 'selector');\n        this.svgRenderer.drawRectangle(canvas, options, this.diagramId, undefined, true, parentSvg);\n    };\n    /**\n     * Method used to render user handle for the node element  \\\n     *\n     * @returns {void } Method used to render user handle for the node element .\\\n     *\n     * @param {SelectorModel} selectorItem - Provide the selector model instance.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { HTMLElement } diagramUserHandlelayer - Provide the HTMLElement value.\n     * @private\n     */\n    DiagramRenderer.prototype.renderUserHandler = function (selectorItem, canvas, transform, diagramUserHandlelayer) {\n        var wrapper = selectorItem.wrapper;\n        var canDraw;\n        for (var _i = 0, _a = selectorItem.userHandles; _i < _a.length; _i++) {\n            var obj = _a[_i];\n            canDraw = true;\n            if ((obj.disableConnectors && selectorItem.connectors.length > 0) ||\n                (obj.disableNodes && selectorItem.nodes.length > 0)) {\n                canDraw = false;\n            }\n            var div = document.getElementById(obj.name + '_template_hiddenUserHandle');\n            if (div) {\n                obj.template = (div.childNodes[0]).cloneNode(true);\n            }\n            //const newPoint: PointModel;\n            var newPoint = getUserHandlePosition(selectorItem, obj, transform);\n            newPoint.x = (newPoint.x + transform.tx) * transform.scale;\n            newPoint.y = (newPoint.y + transform.ty) * transform.scale;\n            if (obj.visible) {\n                obj.visible = (selectorItem.constraints & SelectorConstraints.UserHandle) ? true : false;\n            }\n            if (canDraw) {\n                if (obj.pathData) {\n                    var data = obj.pathData ? obj.pathData : obj.content;\n                    var option = this.getBaseAttributes(wrapper);\n                    option.id = obj.name + '_userhandle';\n                    option.fill = obj.backgroundColor;\n                    option.stroke = obj.borderColor;\n                    option.strokeWidth = obj.borderWidth;\n                    option.centerX = newPoint.x;\n                    option.centerY = newPoint.y;\n                    option.radius = obj.size * 0.5;\n                    option.class = 'e-diagram-userhandle-circle';\n                    option.angle = 0;\n                    option.visible = obj.visible;\n                    option.opacity = 1;\n                    this.svgRenderer.drawCircle(canvas, option, 1, { 'aria-label': obj.name + 'user handle' });\n                    var pathPading = 5;\n                    var arrayCollection = [];\n                    arrayCollection = processPathData(data);\n                    arrayCollection = splitArrayCollection(arrayCollection);\n                    var pathSize = measurePath(data);\n                    //requiredSize/contentSize\n                    var scaleX = (obj.size - 0.45 * obj.size) / pathSize.width;\n                    var scaleY = (obj.size - 0.45 * obj.size) / pathSize.height;\n                    var newData = transformPath(arrayCollection, scaleX, scaleY, true, pathSize.x, pathSize.y, 0, 0);\n                    pathSize = measurePath(newData);\n                    var options = {\n                        x: newPoint.x - pathSize.width / 2,\n                        y: newPoint.y - pathSize.height / 2, angle: 0, id: '',\n                        class: 'e-diagram-userhandle-path', fill: obj.pathColor,\n                        stroke: obj.backgroundColor, strokeWidth: 0.5, dashArray: '', data: newData,\n                        width: obj.size - pathPading, height: obj.size - pathPading, pivotX: 0, pivotY: 0, opacity: 1, visible: obj.visible\n                    };\n                    this.svgRenderer.drawPath(canvas, options, this.diagramId, undefined, undefined, { 'aria-label': obj.name + 'user handle' });\n                }\n                else if (obj.content) {\n                    //const handleContent: DiagramNativeElement;\n                    var handleContent = new DiagramNativeElement(obj.name, this.diagramId);\n                    handleContent.content = obj.content;\n                    handleContent.offsetX = newPoint.x;\n                    handleContent.offsetY = newPoint.y;\n                    handleContent.id = obj.name + '_shape';\n                    handleContent.horizontalAlignment = 'Center';\n                    handleContent.verticalAlignment = 'Center';\n                    handleContent.visible = obj.visible;\n                    handleContent.setOffsetWithRespectToBounds(newPoint.x, newPoint.y, 'Fraction');\n                    handleContent.relativeMode = 'Object';\n                    handleContent.description = obj.name || 'User handle';\n                    handleContent.measure(new Size(obj.size, obj.size));\n                    handleContent.arrange(handleContent.desiredSize);\n                    this.svgRenderer.drawNativeContent(handleContent, canvas, obj.size, obj.size, this.adornerSvgLayer);\n                }\n                else if (obj.source) {\n                    var element = new ImageElement();\n                    var options = this.getBaseAttributes(element, transform);\n                    options.width = obj.size;\n                    options.height = obj.size;\n                    options.x = newPoint.x - (obj.size / 2);\n                    options.y = newPoint.y - (obj.size / 2);\n                    options.sourceWidth = obj.size;\n                    options.sourceHeight = obj.size;\n                    options.alignment = element.imageAlign;\n                    options.source = obj.source;\n                    options.scale = element.imageScale;\n                    options.visible = obj.visible;\n                    options.description = obj.name || 'User handle';\n                    options.id = obj.name + '_';\n                    this.renderer.drawImage(canvas, options, this.adornerSvgLayer, false);\n                }\n                else {\n                    //const templateContent: DiagramHtmlElement;\n                    var templateContent = new DiagramHtmlElement(obj.name, this.diagramId);\n                    templateContent.offsetX = newPoint.x;\n                    templateContent.offsetY = newPoint.y;\n                    templateContent.id = obj.name + '_shape';\n                    templateContent.visible = obj.visible;\n                    templateContent.relativeMode = 'Object';\n                    templateContent.template = obj.template;\n                    templateContent.measure(new Size(obj.size, obj.size));\n                    templateContent.arrange(templateContent.desiredSize);\n                    this.svgRenderer.drawHTMLContent(templateContent, diagramUserHandlelayer, undefined, true, undefined);\n                }\n            }\n        }\n    };\n    /**\n     * Method used to render rotate thumb of the diagramnode element  \\\n     *\n     * @returns {void } Method used to render rotate thumb of the diagramnode element .\\\n     *\n     * @param {DiagramElement} wrapper - Provide the wrapper  element value.\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { SelectorConstraints } selectorConstraints - Provide the selectorConstraints value.\n     * @param { boolean } canMask - Provide the boolean value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderRotateThumb = function (wrapper, canvas, transform, selectorConstraints, canMask) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var element = new PathElement();\n        var newPoint;\n        var size = new Size();\n        size.width = 18;\n        size.height = 16;\n        var top = wrapper.offsetY - wrapper.actualSize.height * wrapper.pivot.y;\n        var left = wrapper.offsetX - wrapper.actualSize.width * wrapper.pivot.x;\n        var visible = (selectorConstraints & SelectorConstraints.Rotate) ? true : false;\n        if (canMask) {\n            visible = false;\n        }\n        var data = 'M 16.856144362449648 10.238890446662904 L 18.000144362449646 3.437890446662903' +\n            'L 15.811144362449646 4.254890446662903 C 14.837144362449646 2.5608904466629028 13.329144362449647 ' +\n            ' 1.2598904466629026 11.485144362449645 0.5588904466629026 C 9.375144362449646 - 0.24510955333709716 7.071144362449646 ' +\n            ' - 0.18010955333709716 5.010144362449646 0.7438904466629028 C 2.942144362449646 1.6678904466629028 1.365144362449646' +\n            ' 3.341890446662903 0.558144362449646 5.452890446662903 C - 0.244855637550354 7.567890446662903 - 0.17985563755035394' +\n            ' 9.866890446662904 0.7431443624496461 11.930890446662904 C 1.6681443624496461 13.994890446662904 3.343144362449646' +\n            ' 15.575890446662903 5.457144362449647 16.380890446662903 C 6.426144362449647 16.7518904466629 7.450144362449647' +\n            ' 16.9348904466629 8.470144362449647 16.9348904466629 C 9.815144362449647 16.9348904466629 11.155144362449647 ' +\n            '16.6178904466629 12.367144362449647 15.986890446662901 L 11.351144362449647 14.024890446662901 C 9.767144362449647' +\n            ' 14.8468904466629 7.906144362449647 14.953890446662902 6.237144362449647 14.3178904466629 C 4.677144362449647' +\n            ' 13.7218904466629 3.444144362449647 12.5558904466629 2.758144362449647 11.028890446662901 C 2.078144362449646 ' +\n            '9.501890446662903 2.031144362449646 7.802890446662903 2.622144362449646 6.243890446662903 C 3.216144362449646' +\n            ' 4.6798904466629025 4.387144362449646 3.442890446662903 5.914144362449646 2.760890446662903 C 7.437144362449646 ' +\n            '2.078890446662903 9.137144362449646 2.0298904466629026 10.700144362449645 2.6258904466629027 C 11.946144362449646 ' +\n            '3.100890446662903 12.971144362449646 3.9538904466629026 13.686144362449646 5.049890446662903 L 11.540144362449645 ' +\n            '5.850890446662903 L 16.856144362449648 10.238890446662904 Z';\n        var pivotX = left + wrapper.pivot.x * wrapper.actualSize.width;\n        var pivotY = top;\n        pivotX = (pivotX + transform.tx) * transform.scale;\n        pivotY = (pivotY + transform.ty) * transform.scale;\n        newPoint = { x: pivotX - size.width * 0.5, y: pivotY - 30 - size.height * 0.5 };\n        if (wrapper.rotateAngle !== 0 || wrapper.parentTransform !== 0) {\n            var matrix = identityMatrix();\n            rotateMatrix(matrix, wrapper.rotateAngle + wrapper.parentTransform, (transform.tx + wrapper.offsetX) * transform.scale, (transform.ty + wrapper.offsetY) * transform.scale);\n            newPoint = transformPointByMatrix(matrix, newPoint);\n        }\n        var options = {\n            x: newPoint.x,\n            y: newPoint.y,\n            angle: wrapper.rotateAngle + wrapper.parentTransform,\n            fill: '#231f20', stroke: 'black', strokeWidth: 0.5, dashArray: '', data: data,\n            width: 20, height: 20, pivotX: 0, pivotY: 0, opacity: 1, visible: visible, id: wrapper.id, class: 'e-diagram-rotate-handle'\n        };\n        options.id = 'rotateThumb';\n        this.svgRenderer.drawPath(canvas, options, this.diagramId, true, undefined, { 'aria-label': 'Thumb to rotate the selected object' });\n    };\n    /**\n     * Method used to render the path element for the diagram  \\\n     *\n     * @returns {void } Method used to render the path element for the diagram .\\\n     *\n     * @param {PathElement} element - Provide the path element of the diagram .\n     * @param { HTMLCanvasElement | SVGElement } canvas - Provide the canvas element value.\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { SVGSVGElement } parentSvg - Provide the parent SVG element .\n     * @param { boolean } fromPalette - Provide the boolean value .\n     * @param { boolean } isPreviewNode - Provide the boolean value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderPathElement = function (element, canvas, transform, parentSvg, fromPalette, isPreviewNode) {\n        var options = this.getBaseAttributes(element, transform, isPreviewNode);\n        options.data = element.absolutePath;\n        options.data = element.absolutePath;\n        var ariaLabel = element.description ? element.description : element.id;\n        if (!this.isSvgMode) {\n            options.x = element.flipOffset.x ? element.flipOffset.x : options.x;\n            options.y = element.flipOffset.y ? element.flipOffset.y : options.y;\n        }\n        if (element.isExport) {\n            var pathBounds = element.absoluteBounds;\n            options.data = updatePath(element, pathBounds, undefined, options);\n        }\n        this.renderer.drawPath(canvas, options, this.diagramId, undefined, parentSvg, ariaLabel);\n    };\n    /**\n     * Method used to update the grid line for the diagram  \\\n     *\n     * @returns {void } Method used to update the grid line for the diagram .\\\n     *\n     * @param {SnapSettingsModel} snapSettings - Provide the snapsetting value of the diagram .\n     * @param { SVGSVGElement } gridSvg - Provide the SVG grid  element value.\n     * @param { Transforms } t - Provide the transform value  .\n     * @param { RulerSettingsModel } rulerSettings - Provide the ruler setting property .\n     * @param { RulerModel } hRuler - Provide the horizontal ruler property value .\n     * @param { RulerModel } vRuler - Provide the vertical ruler property value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderSvgGridlines = function (snapSettings, gridSvg, t, rulerSettings, hRuler, vRuler) {\n        var pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');\n        var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n        defs.setAttribute('id', this.diagramId + '_grid_pattern_defn');\n        if (snapSettings.constraints & SnapConstraints.ShowHorizontalLines ||\n            snapSettings.constraints & SnapConstraints.ShowVerticalLines) {\n            pattern.setAttribute('id', this.diagramId + '_pattern');\n        }\n        var hWidth = 0;\n        var hHeight = 0;\n        var hSegmentwidth = 0;\n        var vSegmentwidth = 0;\n        var scale = 1;\n        var isRulerGrid = false;\n        var isLine = snapSettings.gridType === 'Lines';\n        var verticalLineIntervals = isLine ?\n            snapSettings.verticalGridlines.lineIntervals : snapSettings.verticalGridlines.dotIntervals;\n        var horizontalLineIntervals = isLine ?\n            snapSettings.horizontalGridlines.lineIntervals : snapSettings.horizontalGridlines.dotIntervals;\n        if (rulerSettings.showRulers && rulerSettings.dynamicGrid && hRuler && vRuler) {\n            hSegmentwidth = vRuler.updateSegmentWidth(t.scale);\n            vSegmentwidth = hRuler.updateSegmentWidth(t.scale);\n            snapSettings.horizontalGridlines.scaledIntervals = [hSegmentwidth / hRuler.interval];\n            snapSettings.verticalGridlines.scaledIntervals = [vSegmentwidth / vRuler.interval];\n            isRulerGrid = true;\n        }\n        else {\n            for (var i = 0; i < verticalLineIntervals.length; i = i + 1) {\n                hWidth += verticalLineIntervals[i];\n            }\n            for (var i = 0; i < horizontalLineIntervals.length; i = i + 1) {\n                hHeight += horizontalLineIntervals[i];\n            }\n            scale = this.scaleSnapInterval(snapSettings, t.scale);\n        }\n        hWidth = isRulerGrid ? vSegmentwidth : hWidth * scale;\n        hHeight = isRulerGrid ? hSegmentwidth : hHeight * scale;\n        var attr = {\n            id: this.diagramId + '_pattern', x: 0, y: 0, width: hWidth,\n            height: hHeight, patternUnits: 'userSpaceOnUse'\n        };\n        setAttributeSvg(pattern, attr);\n        this.horizontalSvgGridlines(pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, horizontalLineIntervals);\n        this.verticalSvgGridlines(pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, verticalLineIntervals);\n        defs.appendChild(pattern);\n        gridSvg.appendChild(defs);\n    };\n    DiagramRenderer.prototype.horizontalSvgGridlines = function (pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, intervals) {\n        var space = 0;\n        var dashArray = [];\n        var hLine;\n        if (snapSettings.constraints & SnapConstraints.ShowHorizontalLines) {\n            if (snapSettings.horizontalGridlines.lineDashArray) {\n                dashArray = this.renderer.parseDashArray(snapSettings.horizontalGridlines.lineDashArray);\n            }\n            if (rulerSettings.showRulers && rulerSettings.dynamicGrid && vRuler) {\n                intervals = this.updateLineIntervals(intervals, rulerSettings, vRuler, hHeight, isLine);\n            }\n            intervals = getInterval(intervals, isLine);\n            for (var i = 0; i < intervals.length; i = i + 2) {\n                space = getSpaceValue(intervals, isLine, i, space);\n                var spaceY = 0;\n                hLine = document.createElementNS('http://www.w3.org/2000/svg', isLine ? 'path' : 'circle');\n                var attr = void 0;\n                var d = isLine ? space + intervals[i] / 2 : space;\n                d = isRulerGrid ? d : d * scale;\n                if (isLine) {\n                    if (dashArray.toString() === '') {\n                        attr = {\n                            'stroke-width': intervals[i],\n                            'd': 'M0,' + (d) + ' L' + hWidth + ',' + (d) + ' Z',\n                            'class': intervals[i] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n                            'stroke': snapSettings.horizontalGridlines.lineColor\n                        };\n                    }\n                    else {\n                        attr = {\n                            'stroke-width': intervals[i], 'stroke': snapSettings.horizontalGridlines.lineColor,\n                            'd': 'M0,' + (d) + ' L' + hWidth + ',' + (d) + ' Z',\n                            'class': intervals[i] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n                            'dashArray': dashArray.toString()\n                        };\n                    }\n                    setAttributeSvg(hLine, attr);\n                    pattern.appendChild(hLine);\n                    space += intervals[i + 1] + intervals[i];\n                }\n                else {\n                    this.renderDotGrid(i, pattern, snapSettings, spaceY, d, scale, true);\n                    space += intervals[i];\n                }\n            }\n        }\n    };\n    DiagramRenderer.prototype.renderDotGrid = function (i, pattern, snapSettings, spacey, d, scale, isHorizontal) {\n        var intervals = !isHorizontal ?\n            snapSettings.horizontalGridlines.dotIntervals : snapSettings.verticalGridlines.dotIntervals;\n        intervals = getInterval(intervals, false);\n        var r;\n        var hLine;\n        //const doubleRadius: boolean;\n        var dy;\n        var attr;\n        for (var j = 1; j < intervals.length; j = j + 2) {\n            r = j === intervals.length - 1 ? intervals[0] : intervals[j - 1];\n            hLine = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\n            dy = spacey;\n            dy = dy * scale;\n            attr = {\n                'cx': isHorizontal ? dy : d, 'cy': isHorizontal ? d : dy, 'fill': snapSettings.horizontalGridlines.lineColor, 'r': r\n            };\n            setAttributeSvg(hLine, attr);\n            pattern.appendChild(hLine);\n            spacey += intervals[j] + intervals[j - 1];\n        }\n    };\n    DiagramRenderer.prototype.verticalSvgGridlines = function (pattern, hWidth, hHeight, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, intervals) {\n        var space = 0;\n        var dashArray = [];\n        var vLine;\n        if (snapSettings.constraints & SnapConstraints.ShowVerticalLines) {\n            if (snapSettings.verticalGridlines.lineDashArray) {\n                dashArray = this.renderer.parseDashArray(snapSettings.verticalGridlines.lineDashArray);\n            }\n            if (rulerSettings.showRulers && rulerSettings.dynamicGrid && hRuler) {\n                intervals = this.updateLineIntervals(intervals, rulerSettings, hRuler, hWidth, isLine);\n            }\n            var spaceY = 0;\n            intervals = getInterval(intervals, isLine);\n            for (var i = 0; i < intervals.length; i = i + 2) {\n                space = getSpaceValue(intervals, isLine, i, space);\n                var d = isLine ? space + intervals[i] / 2 : space;\n                d = isRulerGrid ? d : d * scale;\n                vLine = document.createElementNS('http://www.w3.org/2000/svg', isLine ? 'path' : 'circle');\n                var attr = void 0;\n                if (isLine) {\n                    if (dashArray.toString() === '') {\n                        attr = {\n                            'stroke-width': intervals[i],\n                            'd': 'M' + (d) + ',0 L' + (d) + ',' + hHeight + ' Z',\n                            'class': intervals[i] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n                            'stroke': snapSettings.verticalGridlines.lineColor,\n                        };\n                    }\n                    else {\n                        attr = {\n                            'stroke-width': intervals[i],\n                            'class': intervals[i] === 1.25 ? 'e-diagram-thick-grid' : 'e-diagram-thin-grid',\n                            'stroke': snapSettings.verticalGridlines.lineColor,\n                            'd': 'M' + (d) + ',0 L' + (d) + ',' + hHeight + ' Z',\n                            'dashArray': dashArray.toString(),\n                        };\n                    }\n                    setAttributeSvg(vLine, attr);\n                    pattern.appendChild(vLine);\n                    space += intervals[i + 1] + intervals[i];\n                }\n                else {\n                    this.renderDotGrid(i, pattern, snapSettings, spaceY, d, scale, false);\n                    space += intervals[i];\n                }\n            }\n        }\n    };\n    /**\n     * Method used to update the grid line for the diagram  \\\n     *\n     * @returns {void } Method used to update the grid line for the diagram .\\\n     *\n     * @param {SnapSettingsModel} snapSettings - Provide the snapsetting value of the diagram .\n     * @param { SVGSVGElement } svgGrid - Provide the SVG grid  element value.\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { RulerSettingsModel } rulerSettings - Provide the ruler setting property .\n     * @param { RulerModel } hRuler - Provide the horizontal ruler property value .\n     * @param { RulerModel } vRuler - Provide the vertical ruler property value .\n     * @private\n     */\n    DiagramRenderer.prototype.updateGrid = function (snapSettings, svgGrid, transform, rulerSettings, hRuler, vRuler) {\n        var grid = svgGrid.getElementById(this.diagramId + '_grid_rect');\n        //let i: number;\n        var isRulerGrid = false;\n        if (grid) {\n            var pattern = svgGrid.getElementById(this.diagramId + '_pattern');\n            if (pattern) {\n                pattern.parentNode.removeChild(pattern);\n            }\n            var hSegmentwidth = 0;\n            var vSegmentwidth = 0;\n            var scale = 1;\n            var isLine = snapSettings.gridType === 'Lines';\n            var verticalLineIntervals = isLine ?\n                snapSettings.verticalGridlines.lineIntervals : snapSettings.verticalGridlines.dotIntervals;\n            var horizontalLineIntervals = isLine ?\n                snapSettings.horizontalGridlines.lineIntervals : snapSettings.horizontalGridlines.dotIntervals;\n            if (rulerSettings.showRulers && rulerSettings.dynamicGrid && vRuler && hRuler) {\n                hSegmentwidth = vRuler.updateSegmentWidth(transform.scale);\n                vSegmentwidth = hRuler.updateSegmentWidth(transform.scale);\n                isRulerGrid = true;\n                snapSettings.horizontalGridlines.scaledIntervals = [hSegmentwidth / hRuler.interval];\n                snapSettings.verticalGridlines.scaledIntervals = [vSegmentwidth / vRuler.interval];\n            }\n            else {\n                scale = this.scaleSnapInterval(snapSettings, transform.scale);\n            }\n            var height = 0;\n            for (var j = 0; j < horizontalLineIntervals.length; j = j + 1) {\n                height += horizontalLineIntervals[j];\n            }\n            var width = 0;\n            for (var j = 0; j < verticalLineIntervals.length; j = j + 1) {\n                width += verticalLineIntervals[j];\n            }\n            var attr = {\n                x: -transform.tx * transform.scale,\n                y: -transform.ty * transform.scale\n            };\n            setAttributeSvg(grid, attr);\n            width = isRulerGrid ? vSegmentwidth : width * scale;\n            height = isRulerGrid ? hSegmentwidth : height * scale;\n            attr = {\n                id: this.diagramId + '_pattern', x: 0, y: 0, width: width,\n                height: height, patternUnits: 'userSpaceOnUse'\n            };\n            pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');\n            setAttributeSvg(pattern, attr);\n            this.horizontalSvgGridlines(pattern, width, height, scale, snapSettings, rulerSettings, vRuler, isRulerGrid, isLine, horizontalLineIntervals);\n            this.verticalSvgGridlines(pattern, width, height, scale, snapSettings, rulerSettings, hRuler, isRulerGrid, isLine, verticalLineIntervals);\n            var defs = svgGrid.getElementById(this.diagramId + '_grid_pattern_defn');\n            if (defs) {\n                defs.appendChild(pattern);\n            }\n        }\n    };\n    DiagramRenderer.prototype.updateLineIntervals = function (intervals, rulerSettings, ruler, segmentWidth, isLine) {\n        var newInterval = [];\n        var tickInterval = segmentWidth / ruler.interval;\n        var interval = isLine ? ruler.interval : ruler.interval + 1;\n        for (var i = 0; i < interval * 2; i++) {\n            if (i % 2 === 0) {\n                newInterval[i] = isLine ? ((i === 0) ? 1.25 : 0.25) : 0;\n            }\n            else {\n                newInterval[i] = isLine ? (tickInterval - newInterval[i - 1]) : tickInterval;\n            }\n        }\n        return newInterval;\n    };\n    DiagramRenderer.prototype.scaleSnapInterval = function (snapSettings, scale) {\n        if (scale >= 2) {\n            while (scale >= 2) {\n                scale /= 2;\n            }\n        }\n        else if (scale <= 0.5) {\n            while (scale <= 0.5) {\n                scale *= 2;\n            }\n        }\n        var i;\n        snapSettings.horizontalGridlines.scaledIntervals = snapSettings.horizontalGridlines.snapIntervals;\n        snapSettings.verticalGridlines.scaledIntervals = snapSettings.verticalGridlines.snapIntervals;\n        if (scale !== 1) {\n            var gridlines = snapSettings.horizontalGridlines;\n            gridlines.scaledIntervals = [];\n            for (i = 0; i < gridlines.snapIntervals.length; i++) {\n                gridlines.scaledIntervals[i] = gridlines.snapIntervals[i] * scale;\n            }\n            gridlines = snapSettings.verticalGridlines;\n            gridlines.scaledIntervals = [];\n            for (i = 0; i < gridlines.snapIntervals.length; i++) {\n                gridlines.scaledIntervals[i] = gridlines.snapIntervals[i] * scale;\n            }\n        }\n        return scale;\n    };\n    /**\n     * Method used to render the text element  \\\n     *\n     * @returns {void }Method used to render the text element  .\\\n     *\n     * @param {TextElement} element - Provide the text element .\n     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .\n     * @param { boolean } fromPalette - Provide the boolean value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderTextElement = function (element, canvas, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transform, parentSvg, fromPalette, centerPoint) {\n        var options = this.getBaseAttributes(element, transform);\n        if (centerPoint) {\n            options.x = centerPoint.cx - 2;\n            options.y = centerPoint.cy - 2;\n        }\n        options.cornerRadius = 0;\n        options.whiteSpace = whiteSpaceToString(element.style.whiteSpace, element.style.textWrapping);\n        options.content = element.content;\n        options.breakWord = wordBreakToString(element.style.textWrapping);\n        options.textAlign = textAlignToString(element.style.textAlign);\n        options.color = element.style.color;\n        options.italic = element.style.italic;\n        options.bold = element.style.bold;\n        options.fontSize = element.style.fontSize;\n        options.fontFamily = element.style.fontFamily;\n        options.textOverflow = element.style.textOverflow;\n        options.textWrapping = element.style.textWrapping;\n        options.textDecoration = element.style.textDecoration;\n        options.doWrap = element.doWrap;\n        options.wrapBounds = element.wrapBounds;\n        options.childNodes = element.childNodes;\n        options.isHorizontalLane = element.isLaneOrientation;\n        options.id = element.id ? element.id : randomId();\n        if (element.isLaneOrientation) {\n            options.parentOffsetX = this.groupElement.offsetX;\n            options.parentOffsetY = this.groupElement.offsetY;\n            options.parentWidth = this.groupElement.actualSize.width;\n            options.parentHeight = this.groupElement.actualSize.height;\n        }\n        options.dashArray = '';\n        options.strokeWidth = 0;\n        options.fill = element.style.fill;\n        var ariaLabel = element.description ? element.description : element.content ? element.content : element.id;\n        if ((element.style.textWrapping === 'Wrap' || element.style.textWrapping === 'WrapWithOverflow') &&\n            this.groupElement && options.height > this.groupElement.actualSize.height &&\n            (element.style.textOverflow === 'Clip' || element.style.textOverflow === 'Ellipsis')) {\n            options.y = options.y + (options.height - this.groupElement.actualSize.height) / 2;\n        }\n        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n        this.renderer.drawText(canvas, options, parentSvg, ariaLabel, this.diagramId, (element.isExport && Math.min(element.exportScaleValue.x || element.exportScaleValue.y)), this.groupElement);\n        if (this.isSvgMode) {\n            element.doWrap = false;\n        }\n    };\n    DiagramRenderer.prototype.renderNativeElement = function (element, canvas, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transform, parentSvg, fromPalette) {\n        var templateWidth;\n        var templateHeight;\n        var nativeSvg = this.getParentSvg(element, undefined, canvas) || parentSvg;\n        var nativeLayer = this.getParentElement(element, canvas, nativeSvg).g || canvas;\n        var options = this.getBaseAttributes(element, transform);\n        options.fill = 'transparent';\n        options.cornerRadius = element.cornerRadius;\n        options.stroke = 'transparent';\n        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n        switch (element.scale) {\n            case 'None':\n                templateWidth = element.contentSize.width;\n                templateHeight = element.contentSize.height;\n                break;\n            case 'Stretch':\n                templateWidth = element.actualSize.width;\n                templateHeight = element.actualSize.height;\n                break;\n            case 'Meet':\n                if (element.actualSize.width <= element.actualSize.height) {\n                    templateWidth = templateHeight = element.actualSize.width;\n                }\n                else {\n                    templateWidth = templateHeight = element.actualSize.height;\n                }\n                break;\n            case 'Slice':\n                if (element.actualSize.width >= element.actualSize.height) {\n                    templateWidth = templateHeight = element.actualSize.width;\n                }\n                else {\n                    templateWidth = templateHeight = element.actualSize.height;\n                }\n                break;\n        }\n        if (this.svgRenderer) {\n            this.svgRenderer.drawNativeContent(element, nativeLayer, templateHeight, templateWidth, nativeSvg);\n        }\n    };\n    DiagramRenderer.prototype.renderHTMLElement = function (element, canvas, htmlLayer, transform, parentSvg, fromPalette, indexValue) {\n        var options = this.getBaseAttributes(element, transform);\n        options.fill = 'transparent';\n        options.cornerRadius = element.cornerRadius;\n        options.stroke = 'transparent';\n        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n        if (this.svgRenderer) {\n            this.svgRenderer.drawHTMLContent(element, htmlLayer.children[0], transform, isDiagramChild(htmlLayer), indexValue);\n        }\n    };\n    /**\n     * Method used to render the image element  \\\n     *\n     * @returns {void }Method used to render the image element  .\\\n     *\n     * @param {ImageElement} element - Provide the image element .\n     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .\n     * @param { Transforms } transform - Provide the transform value  .\n     * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .\n     * @param { boolean } fromPalette - Provide the boolean value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderImageElement = function (element, canvas, transform, parentSvg, fromPalette) {\n        var options = this.getBaseAttributes(element, transform);\n        options.cornerRadius = 0;\n        this.renderer.drawRectangle(canvas, options, this.diagramId, undefined, undefined, parentSvg);\n        // let sx: number; let sy: number;\n        var imageWidth;\n        var imageHeight;\n        var sourceWidth;\n        var sourceHeight;\n        if (element.stretch === 'Stretch') {\n            imageWidth = element.actualSize.width;\n            imageHeight = element.actualSize.height;\n        }\n        else {\n            var contentWidth = element.contentSize.width;\n            var contentHeight = element.contentSize.height;\n            var widthRatio = options.width / contentWidth;\n            var heightRatio = options.height / contentHeight;\n            var ratio = void 0;\n            switch (element.stretch) {\n                case 'Meet':\n                    ratio = Math.min(widthRatio, heightRatio);\n                    imageWidth = contentWidth * ratio;\n                    imageHeight = contentHeight * ratio;\n                    options.x += Math.abs(options.width - imageWidth) / 2;\n                    options.y += Math.abs(options.height - imageHeight) / 2;\n                    break;\n                case 'Slice':\n                    widthRatio = options.width / contentWidth;\n                    heightRatio = options.height / contentHeight;\n                    ratio = Math.max(widthRatio, heightRatio);\n                    imageWidth = contentWidth * ratio;\n                    imageHeight = contentHeight * ratio;\n                    sourceWidth = options.width / imageWidth * contentWidth;\n                    sourceHeight = options.height / imageHeight * contentHeight;\n                    break;\n                case 'None':\n                    imageWidth = contentWidth;\n                    imageHeight = contentHeight;\n                    break;\n            }\n        }\n        options.width = imageWidth;\n        options.height = imageHeight;\n        //Commented for code coverage\n        //(options as ImageAttributes).sourceX = sx;\n        //(options as ImageAttributes).sourceY = sy;\n        options.sourceWidth = sourceWidth;\n        options.sourceHeight = sourceHeight;\n        options.source = element.source;\n        options.alignment = element.imageAlign;\n        options.scale = element.imageScale;\n        options.description = element.description ? element.description : element.id;\n        this.renderer.drawImage(canvas, options, parentSvg, fromPalette);\n    };\n    /**\n     * Method used to render the container  \\\n     *\n     * @returns {void} Method used to render the container .\\\n     *\n     * @param {Container} group - Provide the container .\n     * @param { HTMLCanvasElement | SVGElement} canvas - Provide the canvas element .\n     * @param { HTMLElement } htmlLayer - Provide the html layer element  .\n     * @param { Transforms } transform - Provide the transform value .\n     * @param { SVGSVGElement } parentSvg - Provide the SVG layer element .\n     * @param { boolean } createParent - Provide the boolean value .\n     * @param { boolean } fromPalette - Provide the boolean value  .\n     * @param { number } indexValue - Provide the indexValue value .\n     * @param { boolean } isPreviewNode - Provide the boolean value .\n     * @private\n     */\n    DiagramRenderer.prototype.renderContainer = function (group, canvas, htmlLayer, transform, parentSvg, createParent, fromPalette, indexValue, isPreviewNode, centerPoint) {\n        var svgParent = { svg: parentSvg, g: canvas };\n        var diagramElement = document.getElementById(this.diagramId);\n        var instance = 'ej2_instances';\n        var diagram;\n        if (diagramElement) {\n            diagram = diagramElement[instance][0];\n        }\n        if (this.diagramId) {\n            parentSvg = this.getParentSvg(group) || parentSvg;\n            if (this.isSvgMode) {\n                //const groupElement: HTMLCanvasElement | SVGElement;\n                // eslint-disable-next-line max-len\n                var groupElement = this.getParentElement(group, canvas, parentSvg, indexValue).g || canvas;\n                parentSvg = this.getParentSvg(this.hasNativeParent(group.children)) || parentSvg;\n                var svgNativeParent = this.getParentElement(this.hasNativeParent(group.children), groupElement, parentSvg, indexValue);\n                svgParent.svg = svgNativeParent.svg || parentSvg;\n                svgParent.g = svgNativeParent.g || groupElement;\n                if (createParent) {\n                    if (parentSvg) {\n                        if (!parentSvg.getElementById(svgParent.g.id)) {\n                            canvas.appendChild(svgParent.g);\n                        }\n                    }\n                    canvas = svgParent.g;\n                }\n                else {\n                    canvas = svgParent.g;\n                }\n            }\n        }\n        this.renderRect(group, canvas, transform, parentSvg);\n        this.groupElement = group;\n        if (group.hasChildren()) {\n            var parentG = void 0;\n            var svgParent_1;\n            for (var _i = 0, _a = group.children; _i < _a.length; _i++) {\n                var child = _a[_i];\n                parentSvg = this.getParentSvg(this.hasNativeParent(group.children) || child) || parentSvg;\n                if (this.isSvgMode) {\n                    svgParent_1 = this.getParentElement(this.hasNativeParent(group.children) || child, canvas, parentSvg);\n                    parentG = svgParent_1.g || canvas;\n                    if (svgParent_1.svg) {\n                        parentSvg = svgParent_1.svg;\n                    }\n                }\n                if (!this.isSvgMode) {\n                    child.flip = group.flip;\n                }\n                this.renderElement(child, parentG || canvas, htmlLayer, transform, parentSvg, true, fromPalette, indexValue, isPreviewNode, centerPoint);\n                if (child instanceof TextElement && parentG && !(group.elementActions & ElementAction.ElementIsGroup)) {\n                    this.renderFlipElement(child, parentG, child.flip);\n                }\n                if ((child.elementActions & ElementAction.ElementIsPort) && parentG) {\n                    this.renderFlipElement(group, parentG, child.flip);\n                }\n                if (!(child instanceof TextElement) && group.flip !== 'None' &&\n                    (group.elementActions & ElementAction.ElementIsGroup)) {\n                    this.renderFlipElement(child, parentG || canvas, group.flip);\n                }\n            }\n            var selectedNode = void 0;\n            if (diagram && diagram.selectedItems && diagram.selectedItems.nodes && diagram.selectedItems.nodes.length > 0) {\n                selectedNode = diagram.selectedItems.nodes[0];\n            }\n            var innerNodeContent = void 0;\n            var innerLabelContent = void 0;\n            if (group.flip !== 'None' && selectedNode && selectedNode.flipMode !== 'Label' && selectedNode.flipMode !== 'All' && selectedNode.flipMode !== 'None') {\n                group.flip = 'None';\n                for (var k = 0; k < group.children.length; k++) {\n                    group.children[k].flip = 'None';\n                }\n            }\n            if (!(group.elementActions & ElementAction.ElementIsGroup) && diagram instanceof Diagram && diagram.nameTable[group.id] && diagram.nameTable[group.id].propName !== 'connectors') {\n                if (selectedNode) {\n                    innerNodeContent = document.getElementById(selectedNode.id + '_content_groupElement');\n                }\n                if (group.flip !== 'None' && selectedNode && selectedNode.flipMode && selectedNode.flipMode === 'None') {\n                    this.renderFlipElement(group, innerNodeContent, group.flip);\n                }\n                else if (group.flip !== 'None' && selectedNode && selectedNode.flipMode && selectedNode.flipMode === 'Label') {\n                    for (var i = 0; i < selectedNode.wrapper.children.length; i++) {\n                        if (selectedNode.wrapper.children[i] instanceof TextElement) {\n                            innerLabelContent = document.getElementById(selectedNode.wrapper.children[i].id + '_groupElement');\n                            this.renderFlipElement(group, innerLabelContent, group.flip);\n                            return;\n                        }\n                    }\n                }\n                else {\n                    this.renderFlipElement(group, canvas, group.flip);\n                }\n            }\n        }\n    };\n    DiagramRenderer.prototype.renderFlipElement = function (element, canvas, flip) {\n        var attr = {};\n        var scaleX = 1;\n        var scaleY = 1;\n        var posX = 0;\n        var posY = 0;\n        var offsetX = 0;\n        var offsetY = 0;\n        if (flip !== 'None') {\n            if (flip === 'Horizontal' || flip === 'Both') {\n                posX = element.bounds.center.x;\n                offsetX = -element.bounds.center.x;\n                scaleX = -1;\n            }\n            if (flip === 'Vertical' || flip === 'Both') {\n                posY = element.bounds.center.y;\n                offsetY = -element.bounds.center.y;\n                scaleY = -1;\n            }\n            attr = {\n                'transform': 'translate(' + posX + ',' + posY + ') scale(' + scaleX + ','\n                    + scaleY + ') translate(' + offsetX + ',' + offsetY + ')'\n            };\n        }\n        else {\n            attr = {\n                'transform': 'translate(' + 0 + ',' + 0 + ')'\n            };\n        }\n        if (attr) {\n            if (element && element.children &&\n                element.children.length && (element.children[0] instanceof DiagramHtmlElement)) {\n                var id = canvas.id.split('_preview');\n                var layer = document.getElementById(id[0] + '_html_div') ||\n                    (getHTMLLayer(this.diagramId).children[0]);\n                canvas = layer.querySelector(('#' + element.id + '_content_html_element'));\n                if (canvas) {\n                    canvas.style.transform =\n                        'scale(' + scaleX + ',' + scaleY + ')' + 'rotate(' + (element.rotateAngle + element.parentTransform) + 'deg)';\n                }\n            }\n            else {\n                setAttributeSvg(canvas, attr);\n            }\n        }\n    };\n    /**\n     * Method used to check the native parent  \\\n     *\n     * @returns {void} Method used to check the native parent .\\\n     *\n     * @param { DiagramElement[]} children - Provide the diagram element .\n     * @param { number} count - Provide the count value .\n     * @private\n     */\n    DiagramRenderer.prototype.hasNativeParent = function (children, count) {\n        if (children && children.length > 0 && (count || 0 < 3)) {\n            var child = children[0];\n            if (child instanceof DiagramNativeElement) {\n                return child;\n            }\n            else if (child.children && child.children.length) {\n                this.hasNativeParent(child.children, count++ || 0);\n            }\n        }\n        return undefined;\n    };\n    /**\n     * Method used the draw the reactangle for the diagram  \\\n     *\n     * @returns {void} Method used the draw the reactangle for the diagram .\\\n     *\n     * @param { SVGElement} element - Provide the SVG elements .\n     * @param { RectAttributes} canvas - Provide the Canvas element  .\n     * @param { RectAttributes} transform - Provide transform value for the node  .\n     * @param { RectAttributes} parentSvg -provide the parent SVG  .\n     * @param { RectAttributes} isPreviewNode - Provide the preview boolean value  .\n     * @private\n     */\n    DiagramRenderer.prototype.renderRect = function (element, canvas, transform, parentSvg, isPreviewNode) {\n        var options = this.getBaseAttributes(element, transform, isPreviewNode);\n        options.cornerRadius = element.cornerRadius || 0;\n        if (element.isExport) {\n            options.cornerRadius *= element.exportScaleValue.x;\n        }\n        var ariaLabel = element.description ? element.description : element.id;\n        this.renderer.drawRectangle(canvas, options, this.diagramId, element.isExport, undefined, parentSvg, ariaLabel);\n    };\n    /**\n     * Method used the draw the reactangle for the diagram  \\\n     *\n     * @returns {void} Method used the draw the reactangle for the diagram .\\\n     *\n     * @param { SVGElement} canvas - Provide the SVG elements .\n     * @param { RectAttributes} options - Provide the attributes to draw the rectangle  .\n     * @private\n     */\n    DiagramRenderer.prototype.drawRect = function (canvas, options) {\n        options.cornerRadius = 0;\n        this.svgRenderer.drawRectangle(canvas, options, this.diagramId);\n    };\n    /**\n     * Will get the base attributes for all the elements  \\\n     *\n     * @returns {BaseAttributes} Will get the base attributes for all the elements .\\\n     *\n     * @param { DiagramElement} element - Provide the diagram elements .\n     * @param { Transforms} transform - Provide the transform value for the  elements .\n     * @param { boolean} isPreviewNode - Provide the preview boolean value.\n     * @private\n     */\n    DiagramRenderer.prototype.getBaseAttributes = function (element, transform, isPreviewNode) {\n        var options = {\n            width: element.actualSize.width, height: element.actualSize.height,\n            x: element.offsetX - element.actualSize.width * element.pivot.x + 0.5,\n            y: element.offsetY - element.actualSize.height * element.pivot.y + 0.5,\n            fill: element.style.fill, stroke: element.style.strokeColor, angle: element.rotateAngle + element.parentTransform,\n            pivotX: element.pivot.x, pivotY: element.pivot.y, strokeWidth: element.style.strokeWidth,\n            dashArray: element.style.strokeDashArray || '', opacity: element.style.opacity, shadow: element.shadow,\n            gradient: element.style.gradient, visible: element.visible, id: element.id, description: element.description,\n            canApplyStyle: element.canApplyStyle\n        };\n        if (isPreviewNode) {\n            options.x = options.x - .5;\n            options.y = options.y - .5;\n        }\n        if (element.isExport) {\n            options.width *= element.exportScaleValue.x;\n            options.height *= element.exportScaleValue.y;\n            options.x *= element.exportScaleValue.x;\n            options.y *= element.exportScaleValue.y;\n            options.strokeWidth *= element.exportScaleValue.x;\n        }\n        if (element.flip) {\n            options.flip = element.flip;\n        }\n        if (transform) {\n            options.x += transform.tx;\n            options.y += transform.ty;\n        }\n        return options;\n    };\n    /**\n     * Will render the SVG background image  \\\n     *\n     * @returns {void} Will render the SVG background image  .\\\n     *\n     * @param { Transforms} background - Provide the transforms values .\n     * @param { boolean} diagramElement - Provide element for the daigram.\n     * @param { boolean} x - Provide the rendering mode of the daigram.\n     * @param { boolean} y - Provide the rendering mode of the daigram.\n     * @param { boolean} width - Provide the rendering mode of the daigram.\n     * @param { boolean} height - Provide the rendering mode of the daigram.\n     * @private\n     */\n    DiagramRenderer.renderSvgBackGroundImage = function (background, diagramElement, x, y, width, height) {\n        if (background.source) {\n            var backgroundLayer = getBackgroundLayerSvg(diagramElement.id);\n            var target = backgroundLayer.getElementById(diagramElement.id + '_image');\n            if (!target) {\n                var bgimageLayer = getBackgroundImageLayer(diagramElement.id);\n                target = document.createElementNS('http://www.w3.org/2000/svg', 'image');\n                target.setAttribute('id', diagramElement.id + '_image');\n                bgimageLayer.appendChild(target);\n            }\n            var imageObj = new Image();\n            imageObj.src = background.source;\n            target.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', imageObj.src.toString());\n            var scale = background.scale !== 'None' ? background.scale : '';\n            var imgAlign = background.align;\n            var aspectRatio = imgAlign.charAt(0).toLowerCase() + imgAlign.slice(1);\n            if (scale) {\n                aspectRatio += ' ' + scale.charAt(0).toLowerCase() + scale.slice(1);\n            }\n            var attr = {\n                'id': diagramElement.id + '_image', 'x': x, 'y': y,\n                'width': width, 'height': height,\n                'preserveAspectRatio': aspectRatio\n            };\n            setAttributeSvg(target, attr);\n        }\n    };\n    /**\n     * Method used to transform the layer  \\\n     *\n     *  @returns {boolean} Method used to transform the layer  .\\\n     *  @param { Transforms} transform - Provide the transforms values .\n     *  @param { boolean} svgMode - Provide the rendering mode of the daigram.\n     *  @private\n     */\n    DiagramRenderer.prototype.transformLayers = function (transform, svgMode) {\n        var tx = transform.tx * transform.scale;\n        var ty = transform.ty * transform.scale;\n        var domTable = 'domTable';\n        if (tx !== this.transform.x || ty !== this.transform.y || (tx === 0 || ty === 0)) {\n            //diagram layer\n            if (svgMode) {\n                if (!window[domTable][this.diagramId + '_diagramLayer']) {\n                    window[domTable][this.diagramId + '_diagramLayer'] =\n                        this.diagramSvgLayer.getElementById(this.diagramId + '_diagramLayer');\n                }\n                var diagramLayer = window[domTable][this.diagramId + '_diagramLayer'];\n                diagramLayer.setAttribute('transform', 'translate('\n                    + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('\n                    + transform.scale + ')');\n            }\n            //background\n            //gridline\n            var gridLayer = getGridLayer(this.diagramId);\n            gridLayer.setAttribute('transform', 'translate(' + (transform.tx * transform.scale) + ','\n                + (transform.ty * transform.scale) + ')');\n            //portslayer\n            if (!window[domTable][this.diagramId + '_diagramPorts']) {\n                window[domTable][this.diagramId + '_diagramPorts'] = this.iconSvgLayer.getElementById(this.diagramId + '_diagramPorts');\n            }\n            var portsLayer = window[domTable][this.diagramId + '_diagramPorts'];\n            portsLayer.setAttribute('transform', 'translate('\n                + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('\n                + transform.scale + ')');\n            //expandlayer\n            if (!window[domTable][this.diagramId + '_diagramExpander']) {\n                window[domTable][this.diagramId + '_diagramExpander'] =\n                    this.iconSvgLayer.getElementById(this.diagramId + '_diagramExpander');\n            }\n            var expandLayer = window[domTable][this.diagramId + '_diagramExpander'];\n            expandLayer.setAttribute('transform', 'translate('\n                + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('\n                + transform.scale + ')');\n            //nativelayer\n            if (!window[domTable][this.diagramId + '_nativeLayer']) {\n                window[domTable][this.diagramId + '_nativeLayer'] = this.nativeSvgLayer.getElementById(this.diagramId + '_nativeLayer');\n            }\n            var nativeLayer = window[domTable][this.diagramId + '_nativeLayer'];\n            nativeLayer.setAttribute('transform', 'translate('\n                + (transform.tx * transform.scale) + ',' + (transform.ty * transform.scale) + '),scale('\n                + transform.scale + ')');\n            //htmlLayer\n            var htmlLayer = getHTMLLayer(this.diagramId).children[0];\n            htmlLayer.style.transform = 'translate('\n                + (transform.tx * transform.scale) + 'px,' + (transform.ty * transform.scale) + 'px)scale('\n                + transform.scale + ')';\n            this.transform = { x: transform.tx * transform.scale, y: transform.ty * transform.scale };\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Method used to update the nodes in the diagram  \\\n     *\n     *  @returns {void} Method used to update the nodes in the diagram  .\\\n     *  @param { HTMLCanvasElement} element - Provide the diagram element .\n     *  @param { HTMLCanvasElement} diagramElementsLayer - Provide the diagram layer element .\n     *  @param { HTMLCanvasElement} htmlLayer -Provide the html element .\n     *  @param { HTMLCanvasElement} transform - Provide the transform value .\n     *  @param { HTMLCanvasElement} insertIndex - Provide the index value.\n     *  @private\n     */\n    DiagramRenderer.prototype.updateNode = function (element, diagramElementsLayer, htmlLayer, transform, insertIndex, centerPoint) {\n        this.renderElement(element, diagramElementsLayer, htmlLayer, transform, this.getParentSvg(element), undefined, undefined, insertIndex, null, centerPoint);\n    };\n    return DiagramRenderer;\n}());\nexport { DiagramRenderer };\n"]},"metadata":{},"sourceType":"module"}