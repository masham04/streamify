{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Size } from '../../primitives/size';\nimport { DiagramElement } from './diagram-element';\nimport { Rect } from '../../primitives/rect';\nimport { measurePath, findSegmentPoints, translatePoints } from './../../utility/dom-util';\nimport { processPathData, splitArrayCollection, transformPath, getPathString } from '../../utility/path-util';\n/**\n * PathElement takes care of how to align the path based on offsetX and offsetY\n */\n\nvar PathElement =\n/** @class */\nfunction (_super) {\n  __extends(PathElement, _super);\n  /**\n   * set the id for each element\n   */\n\n\n  function PathElement() {\n    var _this = _super.call(this) || this;\n    /**\n     * Gets or sets the geometry of the path element\n     */\n\n\n    _this.pathData = '';\n    /**\n     * Gets/Sets whether the path has to be transformed to fit the given x,y, width, height\n     */\n\n    _this.transformPath = true;\n    /**\n     * Gets/Sets the equivalent path, that will have the origin as 0,0\n     */\n\n    _this.absolutePath = '';\n    /**   @private  */\n\n    _this.canMeasurePath = false; //Private variables\n\n    /**   @private  */\n\n    _this.absoluteBounds = new Rect();\n    return _this;\n  }\n\n  Object.defineProperty(PathElement.prototype, \"data\", {\n    /**\n     *   Gets the geometry of the path element\\\n     *\n     * @returns { string | SVGElement }  Gets the geometry of the path element.\\\n     *\n     * @private\n     */\n    get: function () {\n      return this.pathData;\n    },\n\n    /**\n     *  Sets the geometry of the path element \\\n     *\n     * @returns { void } Sets the geometry of the path element.\\\n     * @param {string} value - provide the id value.\n     *\n     * @private\n     */\n    set: function (value) {\n      if (this.pathData !== value) {\n        this.pathData = value;\n        this.isDirt = true;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * getPoints methods  \\\n   *\n   * @returns { PointModel[] } Sets the geometry of the path element.\\\n   *\n   * @private\n   */\n\n  PathElement.prototype.getPoints = function () {\n    var _this = this;\n\n    if (!this.pointTimer) {\n      this.pointTimer = setTimeout(function () {\n        _this.points = null;\n        _this.pointTimer = null;\n      }, 200);\n    }\n\n    this.points = this.points || findSegmentPoints(this);\n    return translatePoints(this, this.points);\n  };\n  /**\n   * Measures the minimum space that is required to render the element  \\\n   *\n   * @returns { Size } Measures the minimum space that is required to render the element.\\\n   * @param {Size} availableSize - provide the id value.\n   *\n   * @private\n   */\n\n\n  PathElement.prototype.measure = function (availableSize) {\n    //Performance issue - Avoiding measuring the connector path\n    if (this.staticSize && this.width !== undefined && this.height !== undefined) {\n      this.absoluteBounds = new Rect(this.offsetX - this.width * this.pivot.x, this.offsetY - this.height * this.pivot.y, this.width, this.height);\n    } else if (this.isDirt && (this.transformPath || this.width === undefined || this.height === undefined) && (!this.absoluteBounds || this.absoluteBounds.height === 0) || this.canMeasurePath) {\n      //Measure the element only whent the path data is changed/ size is not specified\n      this.absoluteBounds = measurePath(this.data ? this.data : '');\n    }\n\n    if (this.width === undefined) {\n      this.desiredSize = new Size(this.absoluteBounds.width, this.height || this.absoluteBounds.height);\n    } else if (this.height === undefined) {\n      this.desiredSize = new Size(this.width || this.absoluteBounds.width, this.absoluteBounds.height);\n    } else {\n      this.desiredSize = new Size(this.width, this.height);\n    }\n\n    this.desiredSize = this.validateDesiredSize(this.desiredSize, availableSize);\n    this.canMeasurePath = false;\n    return this.desiredSize;\n  };\n  /**\n   * Arranges the path element  \\\n   *\n   * @returns { Size } Arranges the path element.\\\n   * @param {Size} desiredSize - provide the id value.\n   *\n   * @private\n   */\n\n\n  PathElement.prototype.arrange = function (desiredSize) {\n    if (this.isDirt || this.actualSize.width !== desiredSize.width || this.actualSize.height !== desiredSize.height) {\n      this.isDirt = true;\n      this.absolutePath = this.updatePath(this.data, this.absoluteBounds, desiredSize);\n\n      if (!this.staticSize) {\n        this.points = null;\n      }\n    }\n\n    this.actualSize = this.desiredSize;\n    this.updateBounds();\n    this.isDirt = false;\n    return this.actualSize;\n  };\n  /**\n   *  Translates the path to 0,0 and scales the path based on the actual size  \\\n   *\n   * @returns { Size } Arranges the path element.\\\n   * @param {string} pathData - provide the id value.\n   * @param {Rect} bounds - provide the id value.\n   * @param {Size} actualSize - provide the id value.\n   *\n   * @private\n   */\n\n\n  PathElement.prototype.updatePath = function (pathData, bounds, actualSize) {\n    var isScale = false;\n    var newPathString = '';\n    var scaleX = -bounds.x;\n    var scaleY = -bounds.y;\n    var arrayCollection = [];\n\n    if (actualSize.width !== bounds.width || actualSize.height !== bounds.height) {\n      scaleX = actualSize.width / Number(bounds.width ? bounds.width : 1);\n      scaleY = actualSize.height / Number(bounds.height ? bounds.height : 1);\n      isScale = true;\n    }\n\n    arrayCollection = processPathData(pathData);\n    arrayCollection = splitArrayCollection(arrayCollection);\n\n    if ((isScale || this.isDirt) && this.transformPath) {\n      newPathString = transformPath(arrayCollection, scaleX, scaleY, isScale, bounds.x, bounds.y, 0, 0);\n    } else {\n      newPathString = getPathString(arrayCollection);\n    }\n\n    isScale = false;\n    return newPathString;\n  };\n\n  return PathElement;\n}(DiagramElement);\n\nexport { PathElement };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/path-element.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Size","DiagramElement","Rect","measurePath","findSegmentPoints","translatePoints","processPathData","splitArrayCollection","transformPath","getPathString","PathElement","_super","_this","call","pathData","absolutePath","canMeasurePath","absoluteBounds","defineProperty","get","set","value","isDirt","enumerable","configurable","getPoints","pointTimer","setTimeout","points","measure","availableSize","staticSize","width","undefined","height","offsetX","pivot","x","offsetY","y","data","desiredSize","validateDesiredSize","arrange","actualSize","updatePath","updateBounds","bounds","isScale","newPathString","scaleX","scaleY","arrayCollection","Number"],"mappings":"AAAA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIA,CAAC,CAACM,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAF9E;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnBF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASO,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBT,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACU,SAAF,GAAcT,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACS,MAAP,CAAcV,CAAd,CAAb,IAAiCO,EAAE,CAACE,SAAH,GAAeT,CAAC,CAACS,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,GAJD;AAKH,CAZ2C,EAA5C;;AAaA,SAASI,IAAT,QAAqB,uBAArB;AACA,SAASC,cAAT,QAA+B,mBAA/B;AACA,SAASC,IAAT,QAAqB,uBAArB;AACA,SAASC,WAAT,EAAsBC,iBAAtB,EAAyCC,eAAzC,QAAgE,0BAAhE;AACA,SAASC,eAAT,EAA0BC,oBAA1B,EAAgDC,aAAhD,EAA+DC,aAA/D,QAAoF,yBAApF;AACA;AACA;AACA;;AACA,IAAIC,WAAW;AAAG;AAAe,UAAUC,MAAV,EAAkB;AAC/CzB,EAAAA,SAAS,CAACwB,WAAD,EAAcC,MAAd,CAAT;AACA;AACJ;AACA;;;AACI,WAASD,WAAT,GAAuB;AACnB,QAAIE,KAAK,GAAGD,MAAM,CAACE,IAAP,CAAY,IAAZ,KAAqB,IAAjC;AACA;AACR;AACA;;;AACQD,IAAAA,KAAK,CAACE,QAAN,GAAiB,EAAjB;AACA;AACR;AACA;;AACQF,IAAAA,KAAK,CAACJ,aAAN,GAAsB,IAAtB;AACA;AACR;AACA;;AACQI,IAAAA,KAAK,CAACG,YAAN,GAAqB,EAArB;AACA;;AACAH,IAAAA,KAAK,CAACI,cAAN,GAAuB,KAAvB,CAfmB,CAgBnB;;AACA;;AACAJ,IAAAA,KAAK,CAACK,cAAN,GAAuB,IAAIf,IAAJ,EAAvB;AACA,WAAOU,KAAP;AACH;;AACDtB,EAAAA,MAAM,CAAC4B,cAAP,CAAsBR,WAAW,CAACZ,SAAlC,EAA6C,MAA7C,EAAqD;AACjD;AACR;AACA;AACA;AACA;AACA;AACA;AACQqB,IAAAA,GAAG,EAAE,YAAY;AACb,aAAO,KAAKL,QAAZ;AACH,KAVgD;;AAWjD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACQM,IAAAA,GAAG,EAAE,UAAUC,KAAV,EAAiB;AAClB,UAAI,KAAKP,QAAL,KAAkBO,KAAtB,EAA6B;AACzB,aAAKP,QAAL,GAAgBO,KAAhB;AACA,aAAKC,MAAL,GAAc,IAAd;AACH;AACJ,KAxBgD;AAyBjDC,IAAAA,UAAU,EAAE,IAzBqC;AA0BjDC,IAAAA,YAAY,EAAE;AA1BmC,GAArD;AA4BA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACId,EAAAA,WAAW,CAACZ,SAAZ,CAAsB2B,SAAtB,GAAkC,YAAY;AAC1C,QAAIb,KAAK,GAAG,IAAZ;;AACA,QAAI,CAAC,KAAKc,UAAV,EAAsB;AAClB,WAAKA,UAAL,GAAkBC,UAAU,CAAC,YAAY;AACrCf,QAAAA,KAAK,CAACgB,MAAN,GAAe,IAAf;AACAhB,QAAAA,KAAK,CAACc,UAAN,GAAmB,IAAnB;AACH,OAH2B,EAGzB,GAHyB,CAA5B;AAIH;;AACD,SAAKE,MAAL,GAAc,KAAKA,MAAL,IAAexB,iBAAiB,CAAC,IAAD,CAA9C;AACA,WAAOC,eAAe,CAAC,IAAD,EAAO,KAAKuB,MAAZ,CAAtB;AACH,GAVD;AAWA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIlB,EAAAA,WAAW,CAACZ,SAAZ,CAAsB+B,OAAtB,GAAgC,UAAUC,aAAV,EAAyB;AACrD;AACA,QAAI,KAAKC,UAAL,IAAmB,KAAKC,KAAL,KAAeC,SAAlC,IAA+C,KAAKC,MAAL,KAAgBD,SAAnE,EAA8E;AAC1E,WAAKhB,cAAL,GAAsB,IAAIf,IAAJ,CAAS,KAAKiC,OAAL,GAAe,KAAKH,KAAL,GAAa,KAAKI,KAAL,CAAWC,CAAhD,EAAmD,KAAKC,OAAL,GAAe,KAAKJ,MAAL,GAAc,KAAKE,KAAL,CAAWG,CAA3F,EAA8F,KAAKP,KAAnG,EAA0G,KAAKE,MAA/G,CAAtB;AACH,KAFD,MAGK,IAAI,KAAKZ,MAAL,KAAgB,KAAKd,aAAL,IAAuB,KAAKwB,KAAL,KAAeC,SAAf,IAA4B,KAAKC,MAAL,KAAgBD,SAAnF,MACD,CAAC,KAAKhB,cAAN,IAAwB,KAAKA,cAAL,CAAoBiB,MAApB,KAA+B,CADtD,KAC4D,KAAKlB,cADrE,EACqF;AACtF;AACA,WAAKC,cAAL,GAAsBd,WAAW,CAAC,KAAKqC,IAAL,GAAY,KAAKA,IAAjB,GAAwB,EAAzB,CAAjC;AACH;;AACD,QAAI,KAAKR,KAAL,KAAeC,SAAnB,EAA8B;AAC1B,WAAKQ,WAAL,GAAmB,IAAIzC,IAAJ,CAAS,KAAKiB,cAAL,CAAoBe,KAA7B,EAAoC,KAAKE,MAAL,IAAe,KAAKjB,cAAL,CAAoBiB,MAAvE,CAAnB;AACH,KAFD,MAGK,IAAI,KAAKA,MAAL,KAAgBD,SAApB,EAA+B;AAChC,WAAKQ,WAAL,GAAmB,IAAIzC,IAAJ,CAAS,KAAKgC,KAAL,IAAc,KAAKf,cAAL,CAAoBe,KAA3C,EAAkD,KAAKf,cAAL,CAAoBiB,MAAtE,CAAnB;AACH,KAFI,MAGA;AACD,WAAKO,WAAL,GAAmB,IAAIzC,IAAJ,CAAS,KAAKgC,KAAd,EAAqB,KAAKE,MAA1B,CAAnB;AACH;;AACD,SAAKO,WAAL,GAAmB,KAAKC,mBAAL,CAAyB,KAAKD,WAA9B,EAA2CX,aAA3C,CAAnB;AACA,SAAKd,cAAL,GAAsB,KAAtB;AACA,WAAO,KAAKyB,WAAZ;AACH,GAtBD;AAuBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/B,EAAAA,WAAW,CAACZ,SAAZ,CAAsB6C,OAAtB,GAAgC,UAAUF,WAAV,EAAuB;AACnD,QAAI,KAAKnB,MAAL,IAAe,KAAKsB,UAAL,CAAgBZ,KAAhB,KAA0BS,WAAW,CAACT,KAArD,IAA8D,KAAKY,UAAL,CAAgBV,MAAhB,KAA2BO,WAAW,CAACP,MAAzG,EAAiH;AAC7G,WAAKZ,MAAL,GAAc,IAAd;AACA,WAAKP,YAAL,GAAoB,KAAK8B,UAAL,CAAgB,KAAKL,IAArB,EAA2B,KAAKvB,cAAhC,EAAgDwB,WAAhD,CAApB;;AACA,UAAI,CAAC,KAAKV,UAAV,EAAsB;AAClB,aAAKH,MAAL,GAAc,IAAd;AACH;AACJ;;AACD,SAAKgB,UAAL,GAAkB,KAAKH,WAAvB;AACA,SAAKK,YAAL;AACA,SAAKxB,MAAL,GAAc,KAAd;AACA,WAAO,KAAKsB,UAAZ;AACH,GAZD;AAaA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIlC,EAAAA,WAAW,CAACZ,SAAZ,CAAsB+C,UAAtB,GAAmC,UAAU/B,QAAV,EAAoBiC,MAApB,EAA4BH,UAA5B,EAAwC;AACvE,QAAII,OAAO,GAAG,KAAd;AACA,QAAIC,aAAa,GAAG,EAApB;AACA,QAAIC,MAAM,GAAG,CAACH,MAAM,CAACV,CAArB;AACA,QAAIc,MAAM,GAAG,CAACJ,MAAM,CAACR,CAArB;AACA,QAAIa,eAAe,GAAG,EAAtB;;AACA,QAAIR,UAAU,CAACZ,KAAX,KAAqBe,MAAM,CAACf,KAA5B,IAAqCY,UAAU,CAACV,MAAX,KAAsBa,MAAM,CAACb,MAAtE,EAA8E;AAC1EgB,MAAAA,MAAM,GAAGN,UAAU,CAACZ,KAAX,GAAmBqB,MAAM,CAACN,MAAM,CAACf,KAAP,GAAee,MAAM,CAACf,KAAtB,GAA8B,CAA/B,CAAlC;AACAmB,MAAAA,MAAM,GAAGP,UAAU,CAACV,MAAX,GAAoBmB,MAAM,CAACN,MAAM,CAACb,MAAP,GAAgBa,MAAM,CAACb,MAAvB,GAAgC,CAAjC,CAAnC;AACAc,MAAAA,OAAO,GAAG,IAAV;AACH;;AACDI,IAAAA,eAAe,GAAG9C,eAAe,CAACQ,QAAD,CAAjC;AACAsC,IAAAA,eAAe,GAAG7C,oBAAoB,CAAC6C,eAAD,CAAtC;;AACA,QAAI,CAACJ,OAAO,IAAI,KAAK1B,MAAjB,KAA4B,KAAKd,aAArC,EAAoD;AAChDyC,MAAAA,aAAa,GAAGzC,aAAa,CAAC4C,eAAD,EAAkBF,MAAlB,EAA0BC,MAA1B,EAAkCH,OAAlC,EAA2CD,MAAM,CAACV,CAAlD,EAAqDU,MAAM,CAACR,CAA5D,EAA+D,CAA/D,EAAkE,CAAlE,CAA7B;AACH,KAFD,MAGK;AACDU,MAAAA,aAAa,GAAGxC,aAAa,CAAC2C,eAAD,CAA7B;AACH;;AACDJ,IAAAA,OAAO,GAAG,KAAV;AACA,WAAOC,aAAP;AACH,GArBD;;AAsBA,SAAOvC,WAAP;AACH,CA7JgC,CA6J/BT,cA7J+B,CAAjC;;AA8JA,SAASS,WAAT","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Size } from '../../primitives/size';\nimport { DiagramElement } from './diagram-element';\nimport { Rect } from '../../primitives/rect';\nimport { measurePath, findSegmentPoints, translatePoints } from './../../utility/dom-util';\nimport { processPathData, splitArrayCollection, transformPath, getPathString } from '../../utility/path-util';\n/**\n * PathElement takes care of how to align the path based on offsetX and offsetY\n */\nvar PathElement = /** @class */ (function (_super) {\n    __extends(PathElement, _super);\n    /**\n     * set the id for each element\n     */\n    function PathElement() {\n        var _this = _super.call(this) || this;\n        /**\n         * Gets or sets the geometry of the path element\n         */\n        _this.pathData = '';\n        /**\n         * Gets/Sets whether the path has to be transformed to fit the given x,y, width, height\n         */\n        _this.transformPath = true;\n        /**\n         * Gets/Sets the equivalent path, that will have the origin as 0,0\n         */\n        _this.absolutePath = '';\n        /**   @private  */\n        _this.canMeasurePath = false;\n        //Private variables\n        /**   @private  */\n        _this.absoluteBounds = new Rect();\n        return _this;\n    }\n    Object.defineProperty(PathElement.prototype, \"data\", {\n        /**\n         *   Gets the geometry of the path element\\\n         *\n         * @returns { string | SVGElement }  Gets the geometry of the path element.\\\n         *\n         * @private\n         */\n        get: function () {\n            return this.pathData;\n        },\n        /**\n         *  Sets the geometry of the path element \\\n         *\n         * @returns { void } Sets the geometry of the path element.\\\n         * @param {string} value - provide the id value.\n         *\n         * @private\n         */\n        set: function (value) {\n            if (this.pathData !== value) {\n                this.pathData = value;\n                this.isDirt = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * getPoints methods  \\\n     *\n     * @returns { PointModel[] } Sets the geometry of the path element.\\\n     *\n     * @private\n     */\n    PathElement.prototype.getPoints = function () {\n        var _this = this;\n        if (!this.pointTimer) {\n            this.pointTimer = setTimeout(function () {\n                _this.points = null;\n                _this.pointTimer = null;\n            }, 200);\n        }\n        this.points = this.points || findSegmentPoints(this);\n        return translatePoints(this, this.points);\n    };\n    /**\n     * Measures the minimum space that is required to render the element  \\\n     *\n     * @returns { Size } Measures the minimum space that is required to render the element.\\\n     * @param {Size} availableSize - provide the id value.\n     *\n     * @private\n     */\n    PathElement.prototype.measure = function (availableSize) {\n        //Performance issue - Avoiding measuring the connector path\n        if (this.staticSize && this.width !== undefined && this.height !== undefined) {\n            this.absoluteBounds = new Rect(this.offsetX - this.width * this.pivot.x, this.offsetY - this.height * this.pivot.y, this.width, this.height);\n        }\n        else if (this.isDirt && (this.transformPath || (this.width === undefined || this.height === undefined))\n            && (!this.absoluteBounds || this.absoluteBounds.height === 0) || this.canMeasurePath) {\n            //Measure the element only whent the path data is changed/ size is not specified\n            this.absoluteBounds = measurePath(this.data ? this.data : '');\n        }\n        if (this.width === undefined) {\n            this.desiredSize = new Size(this.absoluteBounds.width, this.height || this.absoluteBounds.height);\n        }\n        else if (this.height === undefined) {\n            this.desiredSize = new Size(this.width || this.absoluteBounds.width, this.absoluteBounds.height);\n        }\n        else {\n            this.desiredSize = new Size(this.width, this.height);\n        }\n        this.desiredSize = this.validateDesiredSize(this.desiredSize, availableSize);\n        this.canMeasurePath = false;\n        return this.desiredSize;\n    };\n    /**\n     * Arranges the path element  \\\n     *\n     * @returns { Size } Arranges the path element.\\\n     * @param {Size} desiredSize - provide the id value.\n     *\n     * @private\n     */\n    PathElement.prototype.arrange = function (desiredSize) {\n        if (this.isDirt || this.actualSize.width !== desiredSize.width || this.actualSize.height !== desiredSize.height) {\n            this.isDirt = true;\n            this.absolutePath = this.updatePath(this.data, this.absoluteBounds, desiredSize);\n            if (!this.staticSize) {\n                this.points = null;\n            }\n        }\n        this.actualSize = this.desiredSize;\n        this.updateBounds();\n        this.isDirt = false;\n        return this.actualSize;\n    };\n    /**\n     *  Translates the path to 0,0 and scales the path based on the actual size  \\\n     *\n     * @returns { Size } Arranges the path element.\\\n     * @param {string} pathData - provide the id value.\n     * @param {Rect} bounds - provide the id value.\n     * @param {Size} actualSize - provide the id value.\n     *\n     * @private\n     */\n    PathElement.prototype.updatePath = function (pathData, bounds, actualSize) {\n        var isScale = false;\n        var newPathString = '';\n        var scaleX = -bounds.x;\n        var scaleY = -bounds.y;\n        var arrayCollection = [];\n        if (actualSize.width !== bounds.width || actualSize.height !== bounds.height) {\n            scaleX = actualSize.width / Number(bounds.width ? bounds.width : 1);\n            scaleY = actualSize.height / Number(bounds.height ? bounds.height : 1);\n            isScale = true;\n        }\n        arrayCollection = processPathData(pathData);\n        arrayCollection = splitArrayCollection(arrayCollection);\n        if ((isScale || this.isDirt) && this.transformPath) {\n            newPathString = transformPath(arrayCollection, scaleX, scaleY, isScale, bounds.x, bounds.y, 0, 0);\n        }\n        else {\n            newPathString = getPathString(arrayCollection);\n        }\n        isScale = false;\n        return newPathString;\n    };\n    return PathElement;\n}(DiagramElement));\nexport { PathElement };\n"]},"metadata":{},"sourceType":"module"}