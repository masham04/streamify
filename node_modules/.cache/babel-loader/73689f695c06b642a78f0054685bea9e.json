{"ast":null,"code":"import { Rect } from '../primitives/rect';\nimport { PathElement } from '../core/elements/path-element';\nimport { SnapConstraints } from '../enum/enum';\nimport { Connector } from './connector';\nimport { Selector } from '../objects/node';\nimport { getBounds } from './../utility/base-util';\nimport { randomId } from './../utility/base-util';\nimport { isSelected } from '../interaction/actions';\nimport { TextElement } from '../core/elements/text-element';\nimport { DiagramHtmlElement } from '../core/elements/html-element';\n/**\n * Snapping\n */\n\nvar Snapping =\n/** @class */\nfunction () {\n  function Snapping(diagram) {\n    this.line = [];\n    this.diagram = diagram;\n  }\n  /** @private */\n\n\n  Snapping.prototype.canSnap = function () {\n    return (this.diagram.snapSettings.constraints & (SnapConstraints.SnapToObject | SnapConstraints.SnapToLines)) !== 0;\n  };\n\n  Snapping.prototype.getWrapperObject = function (selectedObject, nameTable) {\n    if (selectedObject.nodes && selectedObject.nodes.length > 0 && (this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines || this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject)) {\n      for (var i = 0; i < selectedObject.nodes.length; i++) {\n        if ((selectedObject.nodes[i].shape.type === \"SwimLane\" || selectedObject.nodes[i].isLane || selectedObject.nodes[i].parentId !== '' && nameTable[selectedObject.nodes[i].parentId] && nameTable[selectedObject.nodes[i].parentId].isLane) && nameTable['helper']) {\n          return nameTable['helper'].wrapper;\n        } else {\n          return selectedObject.wrapper;\n        }\n      }\n    }\n\n    return selectedObject.wrapper;\n  };\n\n  ;\n  /**\n   * Snap to object\n   *\n   * @private\n   */\n\n  Snapping.prototype.snapPoint = function (diagram, selectedObject, towardsLeft, towardsTop, delta, startPoint, endPoint) {\n    var snapSettings = this.diagram.snapSettings;\n    var zoomFactor = this.diagram.scroller.currentZoom;\n    var offset = {\n      x: 0,\n      y: 0\n    };\n    var wrapper;\n    wrapper = this.getWrapperObject(selectedObject, diagram.nameTable);\n    var bounds = getBounds(wrapper);\n    var horizontallysnapped = {\n      snapped: false,\n      offset: 0\n    };\n    var verticallysnapped = {\n      snapped: false,\n      offset: 0\n    };\n\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) {\n      //let snapLine: SVGElement;\n      var snapLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      snapLine.setAttribute('id', '_SnappingLines');\n      snapLine.setAttribute('shapeRendering', 'crispEdges');\n      this.getAdornerLayerSvg().appendChild(snapLine);\n      this.snapObject(diagram, selectedObject, snapLine, horizontallysnapped, verticallysnapped, delta, startPoint === endPoint);\n    } //original position\n\n\n    var left = bounds.x + delta.x;\n    var top = bounds.y + delta.y;\n    var right = bounds.x + bounds.width + delta.x;\n    var bottom = bounds.y + bounds.height + delta.y;\n    var scaledIntervals = snapSettings.verticalGridlines.scaledIntervals; //snapped positions\n\n    var roundedRight = this.round(right, scaledIntervals, zoomFactor);\n    var roundedLeft = this.round(left, scaledIntervals, zoomFactor);\n    scaledIntervals = snapSettings.horizontalGridlines.scaledIntervals;\n    var roundedTop = this.round(top, scaledIntervals, zoomFactor);\n    var roundedBottom = this.round(bottom, scaledIntervals, zoomFactor); //currentposition\n\n    var currentright = bounds.x + bounds.width;\n    var currentbottom = bounds.y + bounds.height;\n\n    if (!horizontallysnapped.snapped) {\n      if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToVerticalLines) {\n        if (Math.abs(delta.x) >= 1) {\n          if (towardsLeft) {\n            if (Math.abs(roundedRight - currentright) > Math.abs(roundedLeft - bounds.x)) {\n              offset.x += roundedLeft - bounds.x;\n            } else {\n              offset.x += roundedRight - currentright;\n            }\n          } else {\n            if (Math.abs(roundedRight - currentright) < Math.abs(roundedLeft - bounds.x)) {\n              offset.x += roundedRight - currentright;\n            } else {\n              offset.x += roundedLeft - bounds.x;\n            }\n          }\n        }\n      } else {\n        offset.x = endPoint.x - startPoint.x;\n      }\n    } else {\n      if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) {\n        offset.x = horizontallysnapped.offset;\n      } else {\n        offset.x = endPoint.x - startPoint.x;\n      }\n    }\n\n    if (!verticallysnapped.snapped) {\n      if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToHorizontalLines) {\n        if (Math.abs(delta.y) >= 1) {\n          if (towardsTop) {\n            if (Math.abs(roundedBottom - currentbottom) > Math.abs(roundedTop - bounds.y)) {\n              offset.y += roundedTop - bounds.y;\n            } else {\n              offset.y += roundedBottom - currentbottom;\n            }\n          } else {\n            if (Math.abs(roundedBottom - currentbottom) < Math.abs(roundedTop - bounds.y)) {\n              offset.y += roundedBottom - currentbottom;\n            } else {\n              offset.y += roundedTop - bounds.y;\n            }\n          }\n        }\n      } else {\n        offset.y = endPoint.y - startPoint.y;\n      }\n    } else {\n      offset.y = verticallysnapped.offset;\n    }\n\n    return offset;\n  };\n  /**\n   * @private\n   */\n\n\n  Snapping.prototype.round = function (value, snapIntervals, scale) {\n    if (scale === 1) {\n      scale = Math.pow(2, Math.floor(Math.log(scale) / Math.log(2)));\n    } else {\n      scale = scale;\n    }\n\n    var cutoff = 0;\n    var i = 0;\n\n    for (i = 0; i < snapIntervals.length; i++) {\n      cutoff += snapIntervals[i];\n    }\n\n    cutoff /= scale;\n    var quotient = Math.floor(Math.abs(value) / cutoff);\n    var bal = value % cutoff;\n    var prev = quotient * cutoff;\n\n    if (prev !== value) {\n      if (value >= 0) {\n        for (i = 0; i < snapIntervals.length; i++) {\n          if (bal <= snapIntervals[i] / scale) {\n            return prev + (bal < snapIntervals[i] / (2 * scale) ? 0 : snapIntervals[i] / scale);\n          } else {\n            prev += snapIntervals[i] / scale;\n            bal -= snapIntervals[i] / scale;\n          }\n        }\n      } else {\n        prev = prev * -1;\n\n        for (i = snapIntervals.length - 1; i >= 0; i--) {\n          if (Math.abs(bal) <= snapIntervals[i] / scale) {\n            return prev - (Math.abs(bal) < snapIntervals[i] / (2 * scale) ? 0 : snapIntervals[i] / scale);\n          } else {\n            prev -= snapIntervals[i] / scale;\n            bal += snapIntervals[i] / scale;\n          }\n        }\n      }\n    }\n\n    return value;\n  }; //Snap to Object\n\n\n  Snapping.prototype.snapObject = function (diagram, selectedObject, g, horizontalSnap, verticalSnap, delta, ended) {\n    var lengthX = null;\n    var lengthY;\n    var hTarget;\n    var vTarget;\n    var scroller = this.diagram.scroller;\n    var snapSettings = this.diagram.snapSettings;\n    var objectsAtLeft = [];\n    var objectsAtRight = [];\n    var objectsAtTop = [];\n    var objectsAtBottom = [];\n    var wrapper;\n    wrapper = this.getWrapperObject(selectedObject, diagram.nameTable);\n    var bounds = getBounds(wrapper);\n    var scale = diagram.scroller.currentZoom;\n    var hoffset = -scroller.horizontalOffset;\n    var voffset = -scroller.verticalOffset;\n    var snapObjDistance = snapSettings.snapObjectDistance / scale;\n    var viewPort = new Rect(0, 0, scroller.viewPortWidth, scroller.viewPortHeight);\n    var hIntersectRect = new Rect(hoffset / scale, bounds.y - snapObjDistance - 5, viewPort.width / scale, bounds.height + 2 * snapObjDistance + 10);\n    var vIntersectRect = new Rect(bounds.x - snapObjDistance - 5, voffset / scale, bounds.width + 2 * snapObjDistance + 10, viewPort.height / scale);\n    viewPort = new Rect(hoffset / scale, voffset / scale, viewPort.width / scale, viewPort.height / scale);\n    var nodes = this.findNodes(diagram.spatialSearch, selectedObject, vIntersectRect, viewPort);\n    var i;\n    var target;\n    var targetBounds;\n    var nameTable = diagram.nameTable;\n\n    for (i = 0; i < nodes.length; i++) {\n      target = nodes[i];\n\n      if (this.canBeTarget(diagram, target)) {\n        if (!(this.diagram.nameTable[target.id] instanceof Connector) && this.canConsider(nameTable, selectedObject, target)) {\n          targetBounds = target.bounds;\n\n          if (targetBounds.height + targetBounds.y < delta.y + bounds.y) {\n            objectsAtTop.push({\n              obj: target,\n              distance: Math.abs(bounds.y + delta.y - targetBounds.y - targetBounds.height)\n            });\n          } else if (targetBounds.y > bounds.y + delta.y + bounds.height) {\n            objectsAtBottom.push({\n              obj: target,\n              distance: Math.abs(bounds.y + delta.y + bounds.height - targetBounds.y)\n            });\n          }\n\n          if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y - delta.y)) {\n            if (Math.abs(targetBounds.x + targetBounds.width / 2 - (bounds.x + bounds.width / 2 + delta.x)) <= snapObjDistance) {\n              hTarget = this.createSnapObject(targetBounds, bounds, 'centerX');\n              lengthX = Math.abs(targetBounds.y - bounds.y);\n            } else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + bounds.width + delta.x)) <= snapObjDistance) {\n              hTarget = this.createSnapObject(targetBounds, bounds, 'right');\n              lengthX = Math.abs(targetBounds.y - bounds.y);\n            } else if (Math.abs(targetBounds.x - (bounds.x + delta.x)) <= snapObjDistance) {\n              hTarget = this.createSnapObject(targetBounds, bounds, 'left');\n              lengthX = Math.abs(targetBounds.y - bounds.y);\n            } else if (Math.abs(targetBounds.x - (bounds.x + bounds.width + delta.x)) <= snapObjDistance) {\n              hTarget = this.createSnapObject(targetBounds, bounds, 'rightLeft');\n              lengthX = Math.abs(targetBounds.y - bounds.y);\n            } else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + delta.x)) <= snapObjDistance) {\n              hTarget = this.createSnapObject(targetBounds, bounds, 'leftRight');\n              lengthX = Math.abs(targetBounds.y - bounds.y);\n            }\n          }\n        }\n      }\n    }\n\n    nodes = this.findNodes(diagram.spatialSearch, selectedObject, hIntersectRect, viewPort);\n\n    for (var j = 0; j < nodes.length; j++) {\n      target = nodes[j];\n\n      if (this.canBeTarget(diagram, target)) {\n        if (!(this.diagram.nameTable[target.id] instanceof Connector) && this.canConsider(nameTable, selectedObject, target)) {\n          targetBounds = target.bounds;\n\n          if (targetBounds.x + targetBounds.width < bounds.x + delta.x) {\n            objectsAtLeft[objectsAtLeft.length] = {\n              obj: target,\n              distance: Math.abs(bounds.x + delta.x - targetBounds.x - targetBounds.width)\n            };\n          }\n\n          if (targetBounds.x > bounds.x + delta.x + bounds.width) {\n            objectsAtRight[objectsAtRight.length] = {\n              obj: target,\n              distance: Math.abs(bounds.x + delta.x + bounds.width - targetBounds.x)\n            };\n          }\n\n          if (lengthY == null || lengthY > Math.abs(targetBounds.x - bounds.x - delta.x)) {\n            if (Math.abs(targetBounds.y + targetBounds.height / 2 - (bounds.y + bounds.height / 2 + delta.y)) <= snapObjDistance) {\n              vTarget = this.createSnapObject(targetBounds, bounds, 'centerY');\n              lengthY = Math.abs(targetBounds.x - bounds.x);\n            } else if (Math.abs(targetBounds.y - bounds.y - delta.y) <= snapObjDistance) {\n              vTarget = this.createSnapObject(targetBounds, bounds, 'top');\n              lengthY = Math.abs(targetBounds.x - bounds.x);\n            } else if (Math.abs(targetBounds.y + targetBounds.height - (bounds.y + bounds.height + delta.y)) <= snapObjDistance) {\n              vTarget = this.createSnapObject(targetBounds, bounds, 'bottom');\n              lengthY = Math.abs(targetBounds.x - bounds.x);\n            } else if (Math.abs(targetBounds.y + targetBounds.height - bounds.y - delta.y) <= snapObjDistance) {\n              vTarget = this.createSnapObject(targetBounds, bounds, 'topBottom');\n              lengthY = Math.abs(targetBounds.x - bounds.x);\n            } else if (Math.abs(targetBounds.y - (bounds.y + bounds.height + delta.y)) <= snapObjDistance) {\n              vTarget = this.createSnapObject(targetBounds, bounds, 'bottomTop');\n              lengthY = Math.abs(targetBounds.x - bounds.x);\n            }\n          }\n        }\n      }\n    }\n\n    this.createGuidelines(diagram, hTarget, vTarget, g, horizontalSnap, verticalSnap, ended);\n\n    if (!horizontalSnap.snapped) {\n      this.createHSpacingLines(diagram, g, selectedObject, objectsAtLeft, objectsAtRight, horizontalSnap, verticalSnap, ended, delta, snapObjDistance);\n    }\n\n    if (!verticalSnap.snapped) {\n      this.createVSpacingLines(diagram, g, selectedObject, objectsAtTop, objectsAtBottom, horizontalSnap, verticalSnap, ended, delta, snapObjDistance);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  Snapping.prototype.snapConnectorEnd = function (point) {\n    var snapSettings = this.diagram.snapSettings;\n    var zoomFactor = this.diagram.scroller.currentZoom;\n\n    if (snapSettings.constraints & SnapConstraints.SnapToLines) {\n      point.x = this.round(point.x, snapSettings.verticalGridlines.scaledIntervals, zoomFactor);\n      point.y = this.round(point.y, snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n    }\n\n    return point;\n  };\n\n  Snapping.prototype.canBeTarget = function (diagram, node) {\n    node = this.diagram.nameTable[node.id];\n    return !isSelected(this.diagram, node, false);\n  };\n\n  Snapping.prototype.snapSize = function (diagram, horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, selectedObject, ended) {\n    var lengthX;\n    var lengthY;\n    var snapSettings = this.diagram.snapSettings;\n    var scroller = this.diagram.scroller;\n    var hTarget;\n    var vTarget;\n    var bounds = getBounds(selectedObject.wrapper);\n    var nameTable = diagram.nameTable;\n    var sameWidth = [];\n    var sameHeight = [];\n    var scale = diagram.scroller.currentZoom;\n    var hoffset = -scroller.horizontalOffset;\n    var voffset = -scroller.verticalOffset;\n    var snapObjDistance = snapSettings.snapObjectDistance / scale;\n    var viewPort = new Rect(0, 0, scroller.viewPortWidth, scroller.viewPortHeight);\n    var hintersectedrect = new Rect(hoffset / scale, (bounds.y - 5) / scale, viewPort.width / scale, (bounds.height + 10) / scale);\n    var vintersectedrect = new Rect((bounds.x - 5) / scale, voffset / scale, (bounds.width + 10) / scale, viewPort.height / scale);\n    viewPort = new Rect(hoffset / scale, voffset / scale, viewPort.width / scale, viewPort.height / scale);\n    var nodesInView = [];\n    var nodes = this.findNodes(diagram.spatialSearch, selectedObject, vintersectedrect, viewPort, nodesInView);\n    var i;\n    var target;\n    var targetBounds;\n\n    for (i = 0; i < nodes.length; i++) {\n      target = nodes[i];\n\n      if (this.canConsider(nameTable, selectedObject, target) && !(this.diagram.nameTable[target.id] instanceof Connector)) {\n        targetBounds = target.bounds;\n\n        if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y)) {\n          if (horizontalSnap.left) {\n            if (Math.abs(bounds.x + deltaX - targetBounds.x) <= snapObjDistance) {\n              hTarget = this.createSnapObject(targetBounds, bounds, 'left');\n              lengthX = Math.abs(targetBounds.y - bounds.y);\n            } else if (Math.abs(bounds.x + deltaX - targetBounds.x - targetBounds.width) <= snapObjDistance) {\n              hTarget = this.createSnapObject(targetBounds, bounds, 'leftRight');\n              lengthX = Math.abs(targetBounds.y - bounds.y);\n            }\n          } else if (horizontalSnap.right) {\n            if (Math.abs(bounds.x + deltaX + bounds.width - targetBounds.x - targetBounds.width) <= snapObjDistance) {\n              hTarget = this.createSnapObject(targetBounds, bounds, 'right');\n              lengthX = Math.abs(targetBounds.y - bounds.y);\n            } else if (Math.abs(bounds.x + deltaX + bounds.width - targetBounds.x) <= snapObjDistance) {\n              hTarget = this.createSnapObject(targetBounds, bounds, 'rightLeft');\n              lengthX = Math.abs(targetBounds.y - bounds.y);\n            }\n          }\n        }\n      }\n    }\n\n    nodes = this.findNodes(diagram.spatialSearch, selectedObject, hintersectedrect, viewPort);\n\n    for (var i_1 = 0; i_1 < nodes.length; i_1++) {\n      var target_1 = nodes[i_1];\n\n      if (this.canConsider(nameTable, selectedObject, target_1) && !(this.diagram.nameTable[target_1.id] instanceof Connector)) {\n        var targetBounds_1 = target_1.bounds;\n\n        if (lengthY == null || lengthY > Math.abs(targetBounds_1.x - bounds.x)) {\n          if (verticalSnap.top) {\n            if (Math.abs(bounds.y + deltaY - targetBounds_1.y) <= snapObjDistance) {\n              vTarget = this.createSnapObject(targetBounds_1, bounds, 'top');\n              lengthY = Math.abs(targetBounds_1.x - bounds.x);\n            } else if (Math.abs(bounds.y + deltaY - targetBounds_1.y - targetBounds_1.height) <= snapObjDistance) {\n              vTarget = this.createSnapObject(targetBounds_1, bounds, 'topBottom');\n              lengthY = Math.abs(targetBounds_1.x - bounds.x);\n            }\n          } else if (verticalSnap.bottom) {\n            if (Math.abs(bounds.y + bounds.height + deltaY - targetBounds_1.y - targetBounds_1.height) <= snapObjDistance) {\n              vTarget = this.createSnapObject(targetBounds_1, bounds, 'bottom');\n              lengthY = Math.abs(targetBounds_1.x - bounds.x);\n            } else if (Math.abs(bounds.y + bounds.height + deltaY - targetBounds_1.y) <= snapObjDistance) {\n              vTarget = this.createSnapObject(targetBounds_1, bounds, 'bottomTop');\n              lengthY = Math.abs(targetBounds_1.x - bounds.x);\n            }\n          }\n        }\n      }\n    }\n\n    for (i = 0; i < nodesInView.length; i++) {\n      target = nodesInView[i];\n\n      if (this.canConsider(nameTable, selectedObject, target)) {\n        var targetBounds_2 = target.bounds;\n        var delta = horizontalSnap.left ? -deltaX : deltaX;\n        var difference = Math.abs(bounds.width + delta - targetBounds_2.width);\n        var actualDiff = void 0;\n\n        if (difference <= snapObjDistance) {\n          actualDiff = horizontalSnap.left ? -targetBounds_2.width + bounds.width : targetBounds_2.width - bounds.width;\n          sameWidth[sameWidth.length] = {\n            source: target,\n            difference: difference,\n            offset: actualDiff\n          };\n        }\n\n        delta = verticalSnap.top ? -deltaY : deltaY;\n        var dify = Math.abs(bounds.height + delta - targetBounds_2.height);\n\n        if (dify <= snapObjDistance) {\n          actualDiff = verticalSnap.top ? -targetBounds_2.height + bounds.height : targetBounds_2.height - bounds.height;\n          sameHeight[sameHeight.length] = {\n            source: target,\n            difference: dify,\n            offset: actualDiff\n          };\n        }\n      }\n    }\n\n    var g;\n\n    if (!diagram.getTool) {\n      var g_1 = this.createGuidelines(diagram, hTarget, vTarget, snapLine, horizontalSnap, verticalSnap, ended);\n    }\n\n    if (!horizontalSnap.snapped && sameWidth.length > 0 && (horizontalSnap.left || horizontalSnap.right)) {\n      this.addSameWidthLines(diagram, snapLine, sameWidth, horizontalSnap, ended, selectedObject);\n    }\n\n    if (!verticalSnap.snapped && sameHeight.length > 0 && (verticalSnap.top || verticalSnap.bottom)) {\n      this.addSameHeightLines(diagram, snapLine, sameHeight, verticalSnap, ended, selectedObject);\n    }\n  };\n  /**\n   * Snap to object on top\n   *\n   * @private\n   */\n\n\n  Snapping.prototype.snapTop = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBoundsT) {\n    var dify = deltaY;\n    verticalSnap.top = true;\n    var y;\n    horizontalSnap.left = horizontalSnap.right = false;\n    var zoomFactor = this.diagram.scroller.currentZoom; //let initialBoundsT: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {\n      //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n      y = initialBoundsT.y - initialBoundsT.height * shape.pivot.y + deltaY - (shape.offsetY - shape.height * shape.pivot.y);\n      this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, deltaX, y, this.diagram.selectedItems, ended);\n    }\n\n    if (!verticalSnap.snapped) {\n      if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToHorizontalLines) {\n        var top_1 = initialBoundsT.y - initialBoundsT.height * shape.pivot.y;\n        var actualTop = top_1 + deltaY;\n        var roundedTop = this.round(actualTop, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n        dify = roundedTop - top_1;\n      }\n    } else {\n      dify = deltaY - y + verticalSnap.offset;\n    }\n\n    return dify;\n  };\n  /**\n   * Snap to object on right\n   *\n   * @private\n   */\n\n\n  Snapping.prototype.snapRight = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBound) {\n    var difx = deltaX;\n    var x;\n    horizontalSnap.right = true;\n    verticalSnap.top = verticalSnap.bottom = false;\n    var zoomFactor = this.diagram.scroller.currentZoom; //let initialBound: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {\n      //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n      x = initialBound.x + initialBound.width * (1 - shape.pivot.x) + deltaX - (shape.offsetX + shape.width * (1 - shape.pivot.x));\n      this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, x, deltaY, this.diagram.selectedItems, ended);\n    }\n\n    if (!horizontalSnap.snapped) {\n      if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToVerticalLines) {\n        var right = initialBound.x + initialBound.width * (1 - shape.pivot.x);\n        var actualRight = right + deltaX;\n        var roundedRight = this.round(actualRight, this.diagram.snapSettings.verticalGridlines.scaledIntervals, zoomFactor);\n        difx = roundedRight - right;\n      }\n    } else {\n      difx = deltaX - x + horizontalSnap.offset;\n    }\n\n    return difx;\n  };\n  /**\n   * Snap to object on left\n   *\n   * @private\n   */\n\n\n  Snapping.prototype.snapLeft = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBoundsB) {\n    var difx = deltaX;\n    var x = 0;\n    horizontalSnap.left = true;\n    verticalSnap.top = verticalSnap.bottom = false;\n    var zoomFactor = this.diagram.scroller.currentZoom; //let initialBoundsB: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {\n      //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n      x = initialBoundsB.x - initialBoundsB.width * shape.pivot.x + deltaX - (shape.offsetX - shape.width * shape.pivot.x);\n      this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, x, deltaY, this.diagram.selectedItems, ended);\n    }\n\n    if (!horizontalSnap.snapped) {\n      if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToVerticalLines) {\n        var left = initialBoundsB.x - initialBoundsB.width * shape.pivot.x;\n        var actualLeft = left + deltaX;\n        var roundedLeft = this.round(actualLeft, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n        difx = roundedLeft - left;\n      }\n    } else {\n      difx = deltaX - x + horizontalSnap.offset;\n    }\n\n    return difx;\n  };\n  /**\n   * Snap to object on bottom\n   *\n   * @private\n   */\n\n\n  Snapping.prototype.snapBottom = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialRect) {\n    var dify = deltaY;\n    verticalSnap.bottom = true;\n    horizontalSnap.left = horizontalSnap.right = false;\n    var zoomFactor = this.diagram.scroller.currentZoom;\n    var y = 0; //let initialRect: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {\n      //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n      y = initialRect.y + initialRect.height * (1 - shape.pivot.y) + deltaY - (shape.offsetY + shape.height * (1 - shape.pivot.y));\n      this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, deltaX, y, this.diagram.selectedItems, ended);\n    } // eslint-disable-next-line max-len\n\n\n    var bounds = shape instanceof TextElement || shape instanceof DiagramHtmlElement ? getBounds(shape) : getBounds(shape.wrapper);\n\n    if (!verticalSnap.snapped) {\n      if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToHorizontalLines) {\n        var bottom = initialRect.y + initialRect.height * (1 - shape.pivot.y);\n        var actualBottom = bottom + deltaY;\n        var roundedBottom = this.round(actualBottom, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n        dify = roundedBottom - bottom;\n      }\n    } else {\n      dify = deltaY - y + verticalSnap.offset;\n    }\n\n    return dify;\n  }; //To create the same width and same size lines\n\n\n  Snapping.prototype.createGuidelines = function (diagram, hTarget, vTarget, snapLine, horizontalSnap, verticalSnap, ended) {\n    if (hTarget) {\n      horizontalSnap.offset = hTarget.offsetX;\n      horizontalSnap.snapped = true;\n\n      if (!ended) {\n        if (hTarget.type === 'sideAlign') {\n          this.renderAlignmentLines(hTarget.start, hTarget.end, snapLine, diagram.scroller.transform);\n        } else {\n          this.renderAlignmentLines(hTarget.start, hTarget.end, snapLine, diagram.scroller.transform);\n        }\n      }\n    }\n\n    if (vTarget) {\n      verticalSnap.offset = vTarget.offsetY;\n      verticalSnap.snapped = true;\n\n      if (!ended) {\n        if (vTarget.type === 'sideAlign') {\n          this.renderAlignmentLines(vTarget.start, vTarget.end, snapLine, diagram.scroller.transform);\n        } else {\n          this.renderAlignmentLines(vTarget.start, vTarget.end, snapLine, diagram.scroller.transform);\n        }\n      }\n    }\n\n    return snapLine;\n  }; //To create the alignment lines\n\n\n  Snapping.prototype.renderAlignmentLines = function (start, end, svg, transform) {\n    start = {\n      x: (start.x + transform.tx) * transform.scale,\n      y: (start.y + transform.ty) * transform.scale\n    };\n    end = {\n      x: (end.x + transform.tx) * transform.scale,\n      y: (end.y + transform.ty) * transform.scale\n    };\n    var line1 = {\n      stroke: '#07EDE1',\n      strokeWidth: 1,\n      startPoint: {\n        x: start.x,\n        y: start.y\n      },\n      endPoint: {\n        x: end.x,\n        y: end.y\n      },\n      fill: '#07EDE1',\n      dashArray: '',\n      width: 1,\n      x: 0,\n      y: 0,\n      height: 0,\n      angle: 0,\n      pivotX: 0,\n      pivotY: 0,\n      visible: true,\n      opacity: 1,\n      id: randomId()\n    };\n    var i = 0;\n    this.line.push(line1);\n\n    for (i = 0; i < this.line.length; i++) {\n      this.diagram.diagramRenderer.drawLine(svg, this.line.pop());\n    }\n  }; //To create Horizontal spacing lines\n\n\n  Snapping.prototype.createHSpacingLines = function (diagram, g, shape, objectsAtLeft, objectsAtRight, horizontalSnap, verticalSnap, ended, delta, snapObjDistance) {\n    var top = 0;\n    this.sortByDistance(objectsAtLeft, 'distance', true);\n    this.sortByDistance(objectsAtRight, 'distance', true);\n    var equallySpaced = [];\n    var bounds;\n\n    if (diagram.selectedObject.helperObject) {\n      bounds = getBounds(diagram.selectedObject.helperObject.wrapper);\n    } else {\n      bounds = getBounds(shape.wrapper);\n    }\n\n    var nearestleft;\n    var nearestright;\n    var targetBounds;\n    var equaldistance;\n\n    if (objectsAtLeft.length > 0) {\n      equallySpaced[equallySpaced.length] = objectsAtLeft[0];\n      nearestleft = objectsAtLeft[0].obj.bounds;\n      top = nearestleft.y;\n\n      if (objectsAtLeft.length > 1) {\n        targetBounds = objectsAtLeft[1].obj.bounds;\n        equaldistance = nearestleft.x - targetBounds.x - targetBounds.width;\n\n        if (Math.abs(equaldistance - objectsAtLeft[0].distance) <= snapObjDistance) {\n          top = this.findEquallySpacedNodesAtLeft(objectsAtLeft, equaldistance, top, equallySpaced);\n        } else {\n          equaldistance = objectsAtLeft[0].distance;\n        }\n      } else {\n        equaldistance = objectsAtLeft[0].distance;\n      }\n    }\n\n    this.sortByDistance(equallySpaced, 'distance');\n    equallySpaced[equallySpaced.length] = {\n      obj: shape,\n      distance: 0\n    };\n    top = bounds.y < top || !top ? bounds.y : top;\n\n    if (objectsAtRight.length > 0) {\n      var dist = void 0;\n      nearestright = objectsAtRight[0].obj.bounds;\n      top = nearestright.y < top ? nearestright.y : top;\n\n      if (objectsAtRight.length > 1) {\n        targetBounds = objectsAtRight[1].obj.bounds;\n        dist = targetBounds.x - nearestright.x - nearestright.width;\n      }\n\n      if (objectsAtLeft.length > 0) {\n        if (Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) <= snapObjDistance) {\n          var adjustablevalue = Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) / 2;\n          objectsAtRight[0].distance < objectsAtLeft[0].distance ? equaldistance -= adjustablevalue : equaldistance += adjustablevalue;\n          equallySpaced[equallySpaced.length] = objectsAtRight[0];\n        } else if (objectsAtLeft.length === 1) {\n          nearestleft = undefined;\n          equallySpaced.splice(0, 1);\n          equallySpaced[equallySpaced.length] = objectsAtRight[0];\n          equaldistance = dist;\n        }\n      } else {\n        equaldistance = dist;\n        equallySpaced[equallySpaced.length] = objectsAtRight[0];\n      }\n\n      if (objectsAtRight.length > 1 && nearestright.x + nearestright.width < targetBounds.x) {\n        top = this.findEquallySpacedNodesAtRight(objectsAtRight, dist, top, equallySpaced, snapObjDistance);\n      }\n    }\n\n    if (equallySpaced.length > 2) {\n      this.addHSpacingLines(diagram, g, equallySpaced, ended, top);\n      var deltaHorizontal = 0;\n\n      if (ended) {\n        deltaHorizontal = delta.x;\n      }\n\n      if (nearestleft) {\n        horizontalSnap.offset = equaldistance - Math.abs(bounds.x + deltaHorizontal - nearestleft.x - nearestleft.width) + deltaHorizontal;\n      } else if (nearestright) {\n        horizontalSnap.offset = Math.abs(bounds.x + bounds.width + deltaHorizontal - nearestright.x) - equaldistance + deltaHorizontal;\n      }\n\n      horizontalSnap.snapped = true;\n    }\n  }; //To create vertical spacing lines\n\n\n  Snapping.prototype.createVSpacingLines = function (diagram, g, shape, objectsAtTop, objectsAtBottom, horizontalSnap, verticalSnap, ended, delta, snapObjDistance) {\n    var right = 0;\n    this.sortByDistance(objectsAtTop, 'distance', true);\n    this.sortByDistance(objectsAtBottom, 'distance', true);\n    var equallySpaced = [];\n    var wrapper;\n    wrapper = this.getWrapperObject(shape, diagram.nameTable);\n    var bounds = getBounds(wrapper);\n    var nearesttop;\n    var nearestbottom;\n    var targetBounds;\n    var equaldistance;\n\n    if (objectsAtTop.length > 0) {\n      equallySpaced[equallySpaced.length] = objectsAtTop[0];\n      nearesttop = objectsAtTop[0].obj.bounds;\n      right = nearesttop.x + nearesttop.width;\n\n      if (objectsAtTop.length > 1) {\n        targetBounds = objectsAtTop[1].obj.bounds;\n        equaldistance = nearesttop.y - targetBounds.y - targetBounds.height;\n\n        if (Math.abs(equaldistance - objectsAtTop[0].distance) <= snapObjDistance) {\n          right = this.findEquallySpacedNodesAtTop(objectsAtTop, equaldistance, right, equallySpaced);\n        } else {\n          equaldistance = objectsAtTop[0].distance;\n        }\n      } else {\n        equaldistance = objectsAtTop[0].distance;\n      }\n    }\n\n    this.sortByDistance(equallySpaced, 'distance');\n    equallySpaced[equallySpaced.length] = {\n      obj: shape,\n      distance: 0\n    };\n    right = bounds.x + bounds.width > right || !right ? bounds.x + bounds.width : right;\n    var dist;\n\n    if (objectsAtBottom.length > 0) {\n      nearestbottom = objectsAtBottom[0].obj.bounds;\n      right = nearestbottom.x + nearestbottom.width > right ? nearestbottom.x + nearestbottom.width : right;\n\n      if (objectsAtBottom.length > 1) {\n        targetBounds = objectsAtBottom[1].obj.bounds;\n        dist = targetBounds.y - nearestbottom.y - nearestbottom.height;\n      }\n\n      if (objectsAtTop.length > 0) {\n        if (Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) <= snapObjDistance) {\n          var adjustablevalue = Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) / 2;\n          objectsAtBottom[0].distance < objectsAtTop[0].distance ? equaldistance -= adjustablevalue : equaldistance += adjustablevalue;\n          equallySpaced[equallySpaced.length] = objectsAtBottom[0];\n        } else if (objectsAtTop.length === 1) {\n          nearesttop = undefined;\n          equallySpaced.splice(0, 1);\n          equallySpaced[equallySpaced.length] = objectsAtBottom[0];\n          equaldistance = dist;\n        }\n      } else {\n        equaldistance = dist;\n        equallySpaced[equallySpaced.length] = objectsAtBottom[0];\n      }\n\n      if (objectsAtBottom.length > 1 && targetBounds.y > nearestbottom.y + nearestbottom.height) {\n        right = this.findEquallySpacedNodesAtBottom(objectsAtBottom, dist, right, equallySpaced, snapObjDistance);\n      }\n    }\n\n    if (equallySpaced.length > 2) {\n      this.addVSpacingLines(diagram, g, equallySpaced, ended, right);\n      var deltaVertical = 0;\n\n      if (ended) {\n        deltaVertical = delta.y;\n      }\n\n      if (nearesttop) {\n        verticalSnap.offset = equaldistance - Math.abs(bounds.y + deltaVertical - nearesttop.y - nearesttop.height) + deltaVertical;\n      } else if (nearestbottom) {\n        verticalSnap.offset = Math.abs(bounds.y + bounds.height + deltaVertical - nearestbottom.y) - equaldistance + deltaVertical;\n      }\n\n      verticalSnap.snapped = true;\n    }\n  }; //Add the Horizontal spacing lines\n\n\n  Snapping.prototype.addHSpacingLines = function (diagram, g, equallySpaced, ended, top) {\n    var i;\n    var start;\n    var end;\n\n    if (!ended) {\n      for (i = 0; i < equallySpaced.length - 1; i++) {\n        var crnt = equallySpaced[i].obj instanceof Selector ? getBounds(equallySpaced[i].obj.wrapper) : equallySpaced[i].obj.bounds;\n        var next = equallySpaced[i + 1].obj instanceof Selector ? getBounds(equallySpaced[i + 1].obj.wrapper) : equallySpaced[i + 1].obj.bounds;\n        start = {\n          x: crnt.x + crnt.width,\n          y: top - 15\n        };\n        end = {\n          x: next.x,\n          y: top - 15\n        };\n        this.renderSpacingLines(start, end, g, this.getAdornerLayerSvg(), diagram.scroller.transform);\n      }\n    }\n  }; //Add the vertical spacing lines\n\n\n  Snapping.prototype.addVSpacingLines = function (diagram, g, equallySpacedObjects, ended, right) {\n    var start;\n    var end;\n\n    if (!ended) {\n      for (var i = 0; i < equallySpacedObjects.length - 1; i++) {\n        var crnt = equallySpacedObjects[i].obj instanceof Selector ? getBounds(equallySpacedObjects[i].obj.wrapper) : equallySpacedObjects[i].obj.bounds;\n        var next = equallySpacedObjects[i + 1].obj instanceof Selector ? getBounds(equallySpacedObjects[i + 1].obj.wrapper) : equallySpacedObjects[i + 1].obj.bounds;\n        start = {\n          x: right + 15,\n          y: crnt.y + crnt.height\n        };\n        end = {\n          x: right + 15,\n          y: next.y\n        };\n        this.renderSpacingLines(start, end, g, this.getAdornerLayerSvg(), diagram.scroller.transform);\n      }\n    }\n  }; //To add same width lines\n\n\n  Snapping.prototype.addSameWidthLines = function (diagram, snapLine, sameWidths, horizontalSnap, ended, shape) {\n    this.sortByDistance(sameWidths, 'offset');\n    var bounds = getBounds(shape.wrapper);\n    var target = sameWidths[0];\n    var startPt;\n    var endPt;\n    var targetBounds = target.source.bounds;\n    var sameSizes = [];\n    sameSizes.push(sameWidths[0]);\n    var i;\n    var crntbounds;\n\n    for (i = 1; i < sameWidths.length; i++) {\n      crntbounds = sameWidths[i].source.bounds;\n\n      if (crntbounds.width === targetBounds.width) {\n        sameSizes.push(sameWidths[i]);\n      }\n    }\n\n    if (!ended) {\n      startPt = {\n        x: bounds.x + target.offset,\n        y: bounds.y - 15\n      };\n      endPt = {\n        x: bounds.x + bounds.width + target.offset,\n        y: bounds.y - 15\n      };\n      this.renderSpacingLines(startPt, endPt, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n\n      for (i = 0; i < sameSizes.length; i++) {\n        bounds = sameSizes[i].source.bounds;\n        startPt = {\n          x: bounds.x,\n          y: bounds.y - 15\n        };\n        endPt = {\n          x: bounds.x + bounds.width,\n          y: bounds.y - 15\n        };\n        this.renderSpacingLines(startPt, endPt, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n      }\n    }\n\n    horizontalSnap.offset = target.offset;\n    horizontalSnap.snapped = true;\n  }; //To add same height lines\n\n\n  Snapping.prototype.addSameHeightLines = function (diagram, snapLine, sameHeights, verticalSnap, ended, shape) {\n    this.sortByDistance(sameHeights, 'offset');\n    var bounds = getBounds(shape.wrapper);\n    var target = sameHeights[0];\n    var targetBounds = target.source.bounds;\n    var start;\n    var end;\n    var sameSizes = [];\n    sameSizes.push(sameHeights[0]);\n    var i;\n    var crntbounds;\n\n    for (i = 0; i < sameHeights.length; i++) {\n      crntbounds = sameHeights[i].source.bounds;\n\n      if (crntbounds.height === targetBounds.height) {\n        sameSizes.push(sameHeights[i]);\n      }\n    }\n\n    if (!ended) {\n      start = {\n        x: bounds.x + bounds.width + 15,\n        y: bounds.y + target.offset\n      };\n      end = {\n        x: bounds.x + bounds.width + 15,\n        y: bounds.y + target.offset + bounds.height\n      };\n      this.renderSpacingLines(start, end, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n\n      for (i = 0; i < sameSizes.length; i++) {\n        bounds = sameSizes[i].source.bounds;\n        start = {\n          x: bounds.x + bounds.width + 15,\n          y: bounds.y\n        };\n        end = {\n          x: bounds.x + bounds.width + 15,\n          y: bounds.y + bounds.height\n        };\n        this.renderSpacingLines(start, end, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n      }\n    }\n\n    verticalSnap.offset = target.offset;\n    verticalSnap.snapped = true;\n  }; //Render spacing lines\n\n\n  Snapping.prototype.renderSpacingLines = function (start, end, snapLine, svg, transform) {\n    var d;\n    var d1;\n    var line1;\n    var element = new PathElement();\n    var options = {};\n    start = {\n      x: (start.x + transform.tx) * transform.scale,\n      y: (start.y + transform.ty) * transform.scale\n    };\n    end = {\n      x: (end.x + transform.tx) * transform.scale,\n      y: (end.y + transform.ty) * transform.scale\n    };\n\n    if (start.x === end.x) {\n      d = 'M' + (start.x - 5) + ' ' + (start.y + 5) + 'L' + start.x + ' ' + start.y + 'L' + (start.x + 5) + ' ' + (start.y + 5) + 'z' + 'M' + (end.x - 5) + ' ' + (end.y - 5) + ' L' + end.x + ' ' + end.y + ' L' + (end.x + 5) + ' ' + (end.y - 5) + 'z';\n      line1 = {\n        startPoint: {\n          x: start.x - 8,\n          y: start.y - 1\n        },\n        endPoint: {\n          x: start.x + 8,\n          y: start.y - 1\n        },\n        stroke: '#07EDE1',\n        strokeWidth: 1,\n        fill: '#07EDE1',\n        dashArray: '',\n        width: 1,\n        x: 0,\n        y: 0,\n        height: 0,\n        angle: 0,\n        pivotX: 0,\n        pivotY: 0,\n        visible: true,\n        opacity: 1,\n        id: randomId()\n      };\n      element.data = d;\n      options.data = element.data;\n      options.angle = 0;\n      options.pivotX = 0;\n      options.pivotY = 0;\n      options.x = 0;\n      options.y = 0;\n      options.height = 0;\n      options.width = 1;\n      options.id = randomId();\n      this.diagram.diagramRenderer.drawPath(snapLine, options);\n      this.line.push(line1);\n      this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n      line1 = {\n        startPoint: {\n          x: end.x - 8,\n          y: end.y + 1\n        },\n        endPoint: {\n          x: end.x + 8,\n          y: end.y + 1\n        },\n        stroke: '#07EDE1',\n        strokeWidth: 1,\n        fill: '#07EDE1',\n        dashArray: '',\n        width: 1,\n        x: 0,\n        y: 0,\n        height: 0,\n        angle: 0,\n        pivotX: 0,\n        pivotY: 0,\n        visible: true,\n        opacity: 1,\n        id: this.getAdornerLayerSvg().id + 'spacing'\n      };\n      this.line.push(line1);\n      this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n    } else {\n      d = 'M' + (start.x + 5) + ' ' + (start.y + 5) + ' L' + start.x + ' ' + start.y + ' L' + (start.x + 5) + ' ' + (start.y - 5) + 'z' + 'M' + (end.x - 5) + ' ' + (end.y - 5) + ' L' + end.x + ' ' + end.y + ' L' + (end.x - 5) + ' ' + (end.y + 5) + 'z';\n      element.data = d;\n      options.data = d;\n      options.angle = 0;\n      options.pivotX = 0;\n      options.pivotY = 0;\n      options.x = 0;\n      options.y = 0;\n      options.height = 0;\n      options.width = 1;\n      options.id = randomId();\n      this.diagram.diagramRenderer.drawPath(snapLine, options);\n      line1 = {\n        visible: true,\n        opacity: 1,\n        id: randomId(),\n        startPoint: {\n          x: start.x - 1,\n          y: start.y - 8\n        },\n        endPoint: {\n          x: start.x - 1,\n          y: start.y + 8\n        },\n        stroke: '#07EDE1',\n        strokeWidth: 1,\n        fill: '#07EDE1',\n        dashArray: '0',\n        width: 1,\n        x: 0,\n        y: 0,\n        height: 0,\n        angle: 0,\n        pivotX: 0,\n        pivotY: 0\n      };\n      this.line.push(line1);\n      this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n      line1 = {\n        width: 1,\n        x: 0,\n        y: 0,\n        height: 0,\n        angle: 0,\n        pivotX: 0,\n        pivotY: 0,\n        visible: true,\n        opacity: 1,\n        id: randomId(),\n        startPoint: {\n          x: end.x + 1,\n          y: end.y - 8\n        },\n        endPoint: {\n          x: end.x + 1,\n          y: end.y + 8\n        },\n        stroke: '#07EDE1',\n        strokeWidth: 1,\n        fill: '#07EDE1',\n        dashArray: '0'\n      };\n      this.line.push(line1);\n      this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n    }\n\n    line1 = {\n      startPoint: {\n        x: start.x,\n        y: start.y\n      },\n      endPoint: {\n        x: end.x,\n        y: end.y\n      },\n      stroke: '#07EDE1',\n      strokeWidth: 1,\n      fill: '#07EDE1',\n      dashArray: '0',\n      width: 1,\n      x: 0,\n      y: 0,\n      height: 0,\n      angle: 0,\n      pivotX: 0,\n      pivotY: 0,\n      visible: true,\n      opacity: 1,\n      id: randomId()\n    };\n    this.line.push(line1);\n    this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n  };\n  /**\n   * To Create Snap object with position, initial bounds, and final bounds \\\n   *\n   * @returns {  void }  To Create Snap object with position, initial bounds, and final bounds .\\\n   * @param {Diagram} targetBounds - provide the targetBounds value.\n   * @param {Rect} bounds - provide the angle value.\n   * @param {string} snap - provide the angle value.\n   * @private\n   */\n\n\n  Snapping.prototype.createSnapObject = function (targetBounds, bounds, snap) {\n    var snapObject;\n\n    switch (snap) {\n      case 'left':\n        snapObject = {\n          start: {\n            x: targetBounds.x,\n            y: Math.min(targetBounds.y, bounds.y)\n          },\n          end: {\n            x: targetBounds.x,\n            y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n          },\n          offsetX: targetBounds.x - bounds.x,\n          offsetY: 0,\n          type: 'sideAlign'\n        };\n        break;\n\n      case 'right':\n        snapObject = {\n          type: 'sideAlign',\n          start: {\n            x: targetBounds.x + targetBounds.width,\n            y: Math.min(targetBounds.y, bounds.y)\n          },\n          offsetX: targetBounds.x + targetBounds.width - bounds.x - bounds.width,\n          offsetY: 0,\n          end: {\n            x: targetBounds.x + targetBounds.width,\n            y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n          }\n        };\n        break;\n\n      case 'top':\n        snapObject = {\n          offsetY: targetBounds.y - bounds.y,\n          offsetX: 0,\n          type: 'sideAlign',\n          start: {\n            x: Math.min(targetBounds.x, bounds.x),\n            y: targetBounds.y\n          },\n          end: {\n            x: Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width),\n            y: targetBounds.y\n          }\n        };\n        break;\n\n      case 'bottom':\n        snapObject = {\n          type: 'sideAlign',\n          offsetY: targetBounds.y + targetBounds.height - bounds.y - bounds.height,\n          offsetX: 0,\n          end: {\n            x: Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width),\n            y: targetBounds.y + targetBounds.height\n          },\n          start: {\n            x: Math.min(targetBounds.x, bounds.x),\n            y: targetBounds.y + targetBounds.height\n          }\n        };\n        break;\n\n      case 'topBottom':\n        snapObject = {\n          start: {\n            x: Math.min(targetBounds.x, bounds.x),\n            y: targetBounds.y + targetBounds.height\n          },\n          end: {\n            x: Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width),\n            y: targetBounds.y + targetBounds.height\n          },\n          offsetY: targetBounds.y + targetBounds.height - bounds.y,\n          offsetX: 0,\n          type: 'sideAlign'\n        };\n        break;\n\n      case 'bottomTop':\n        snapObject = {\n          start: {\n            x: Math.min(targetBounds.x, bounds.x),\n            y: targetBounds.y\n          },\n          end: {\n            x: Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width),\n            y: targetBounds.y\n          },\n          offsetY: targetBounds.y - bounds.y - bounds.height,\n          offsetX: 0,\n          type: 'sideAlign'\n        };\n        break;\n\n      case 'leftRight':\n        snapObject = {\n          start: {\n            x: targetBounds.x + targetBounds.width,\n            y: Math.min(targetBounds.y, bounds.y)\n          },\n          end: {\n            x: targetBounds.x + targetBounds.width,\n            y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n          },\n          offsetX: targetBounds.x + targetBounds.width - bounds.x,\n          offsetY: 0,\n          type: 'sideAlign'\n        };\n        break;\n\n      case 'rightLeft':\n        snapObject = {\n          start: {\n            x: targetBounds.x,\n            y: Math.min(targetBounds.y, bounds.y)\n          },\n          end: {\n            x: targetBounds.x,\n            y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n          },\n          offsetX: targetBounds.x - bounds.x - bounds.width,\n          offsetY: 0,\n          type: 'sideAlign'\n        };\n        break;\n\n      case 'centerX':\n        snapObject = {\n          start: {\n            x: targetBounds.x + targetBounds.width / 2,\n            y: Math.min(targetBounds.y, bounds.y)\n          },\n          end: {\n            x: targetBounds.x + targetBounds.width / 2,\n            y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n          },\n          offsetX: targetBounds.x + targetBounds.width / 2 - (bounds.x + bounds.width / 2),\n          offsetY: 0,\n          type: 'centerAlign'\n        };\n        break;\n\n      case 'centerY':\n        snapObject = {\n          start: {\n            x: Math.min(targetBounds.x, bounds.x),\n            y: targetBounds.y + targetBounds.height / 2\n          },\n          end: {\n            x: Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width),\n            y: targetBounds.y + targetBounds.height / 2\n          },\n          offsetY: targetBounds.y + targetBounds.height / 2 - (bounds.y + bounds.height / 2),\n          offsetX: 0,\n          type: 'centerAlign'\n        };\n        break;\n    }\n\n    return snapObject;\n  };\n  /**\n   *  Calculate the snap angle \\\n   *\n   * @returns {  void }  Calculate the snap angle .\\\n   * @param {Diagram} diagram - provide the diagram value.\n   * @param {number} angle - provide the angle value.\n   * @private\n   */\n\n\n  Snapping.prototype.snapAngle = function (diagram, angle) {\n    var snapSettings = this.diagram.snapSettings;\n    var snapAngle = snapSettings.snapAngle;\n    var width = angle % (snapAngle || 0);\n\n    if (width >= snapAngle / 2) {\n      return angle + snapAngle - width;\n    } else {\n      return angle - width;\n    }\n  }; //Check whether the node to be snapped or not.\n\n\n  Snapping.prototype.canConsider = function (nameTable, selectedObject, target) {\n    var consider = false;\n\n    if (this.diagram.selectedItems.nodes.length && this.diagram.selectedItems.nodes[0].id === target.id) {\n      return false;\n    } else {\n      return true;\n    }\n  }; //Find the total number of nodes in diagram using SpatialSearch\n\n\n  Snapping.prototype.findNodes = function (spatialSearch, node, child, viewPort, nodesInView) {\n    var nodes = [];\n    var nd;\n    var bounds;\n    var quads = spatialSearch.findQuads(nodesInView ? viewPort : child);\n\n    for (var i = 0; i < quads.length; i++) {\n      var quad = quads[i];\n\n      if (quad.objects.length > 0) {\n        for (var j = 0; j < quad.objects.length; j++) {\n          nd = quad.objects[j];\n\n          if (!(this.diagram.nameTable[nd.id] instanceof Connector) && nd.visible && !(this.diagram.nameTable[nd.id].shape.type === 'SwimLane') && !this.diagram.nameTable[nd.id].isLane && !this.diagram.nameTable[nd.id].isPhase && !this.diagram.nameTable[nd.id].isHeader && nd.id != 'helper') {\n            bounds = getBounds(nd);\n\n            if (nodes.indexOf(nd) === -1 && this.intersectsRect(child, bounds)) {\n              nodes.push(nd);\n            }\n\n            if (nodesInView && nodesInView.indexOf(nd) && this.intersectsRect(viewPort, bounds)) {\n              nodesInView.push(nd);\n            }\n          }\n        }\n      }\n    }\n\n    return nodes;\n  };\n\n  Snapping.prototype.intersectsRect = function (child, bounds) {\n    return bounds.x < child.x + child.width && child.x < bounds.x + bounds.width && bounds.y < child.y + child.height && child.y < bounds.y + bounds.height;\n  };\n\n  Snapping.prototype.getAdornerLayerSvg = function () {\n    return this.diagram.diagramRenderer.adornerSvgLayer;\n  };\n  /**\n   *  To remove grid lines on mouse move and mouse up \\\n   *\n   * @returns {  void }  To remove grid lines on mouse move and mouse up .\\\n   * @param {Diagram} diagram - provide the source value.\n   * @private\n   */\n\n\n  Snapping.prototype.removeGuidelines = function (diagram) {\n    var selectionRect = this.getAdornerLayerSvg().getElementById('_SnappingLines');\n    var line = this.getAdornerLayerSvg().getElementById('pivotLine');\n\n    if (selectionRect) {\n      selectionRect.parentNode.removeChild(selectionRect);\n    }\n\n    if (line) {\n      line.parentNode.removeChild(line);\n    }\n  }; //Sort the objects by its distance\n\n\n  Snapping.prototype.sortByDistance = function (obj, value, ascending) {\n    var i;\n    var j;\n    var temp;\n\n    if (ascending) {\n      for (i = 0; i < obj.length; i++) {\n        for (j = i + 1; j < obj.length; j++) {\n          if (obj[i][value] > obj[j][value]) {\n            temp = obj[i];\n            obj[i] = obj[j];\n            obj[j] = temp;\n          }\n        }\n      }\n    } else {\n      for (i = 0; i < obj.length; i++) {\n        for (j = i + 1; j < obj.length; j++) {\n          if (obj[i][value] < obj[j][value]) {\n            temp = obj[i];\n            obj[i] = obj[j];\n            obj[j] = temp;\n          }\n        }\n      }\n    }\n  }; //To find nodes that are equally placed at left of the selected node\n\n\n  Snapping.prototype.findEquallySpacedNodesAtLeft = function (objectsAtLeft, equalDistance, top, equallySpaced) {\n    var prevBounds;\n    var targetBounds;\n    var dist;\n    var i;\n\n    for (i = 1; i < objectsAtLeft.length; i++) {\n      prevBounds = objectsAtLeft[i - 1].obj.bounds;\n      targetBounds = objectsAtLeft[i].obj.bounds;\n      dist = prevBounds.x - targetBounds.x - targetBounds.width;\n\n      if (Math.abs(dist - equalDistance) <= 1) {\n        equallySpaced[equallySpaced.length] = objectsAtLeft[i];\n\n        if (targetBounds.y < top) {\n          top = targetBounds.y;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return top;\n  }; //To find nodes that are equally placed at right of the selected node\n\n\n  Snapping.prototype.findEquallySpacedNodesAtRight = function (objectsAtRight, equalDistance, top, equallySpaced, snapObjDistance) {\n    var actualDistance = objectsAtRight[0].distance;\n    var target;\n    var targetBounds;\n    var prevBounds;\n    var dist;\n\n    if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {\n      for (var i = 0; i < objectsAtRight.length - 1; i++) {\n        target = objectsAtRight[i].obj;\n        targetBounds = objectsAtRight[i + 1].obj.bounds;\n        prevBounds = target.bounds;\n        dist = targetBounds.x - prevBounds.x - prevBounds.width;\n\n        if (Math.abs(dist - equalDistance) <= 1) {\n          equallySpaced[equallySpaced.length] = objectsAtRight[i + 1];\n\n          if (prevBounds.y < top) {\n            top = prevBounds.y;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n\n    return top;\n  };\n\n  Snapping.prototype.findEquallySpacedNodesAtTop = function (objectsAtTop, equalDistance, right, equallySpaced) {\n    var prevBounds;\n    var targetBounds;\n    var dist;\n\n    for (var i = 1; i < objectsAtTop.length; i++) {\n      prevBounds = objectsAtTop[i - 1].obj.bounds;\n      targetBounds = objectsAtTop[i].obj.bounds;\n      dist = prevBounds.y - targetBounds.y - targetBounds.height;\n\n      if (Math.abs(dist - equalDistance) <= 1) {\n        equallySpaced[equallySpaced.length] = objectsAtTop[i];\n\n        if (targetBounds.x + targetBounds.width > right) {\n          right = targetBounds.x + targetBounds.width;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return right;\n  }; //To find nodes that are equally placed at bottom of the selected node\n\n\n  Snapping.prototype.findEquallySpacedNodesAtBottom = function (objectsAtBottom, equalDistance, right, equallySpaced, snapObjDistance) {\n    var actualDistance = objectsAtBottom[0].distance;\n    var target;\n    var targetBounds;\n    var prevBounds;\n    var dist;\n\n    if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {\n      for (var i = 0; i < objectsAtBottom.length - 1; i++) {\n        target = objectsAtBottom[i].obj;\n        targetBounds = objectsAtBottom[i + 1].obj.bounds;\n        prevBounds = target.bounds;\n        dist = targetBounds.y - prevBounds.y - prevBounds.height;\n\n        if (Math.abs(dist - equalDistance) <= 1) {\n          equallySpaced[equallySpaced.length] = objectsAtBottom[i + 1];\n\n          if (prevBounds.x + prevBounds.width > right) {\n            right = prevBounds.x + prevBounds.width;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n\n    return right;\n  };\n  /**\n   * To get Adoner layer to draw snapLine\n   *\n   * @private\n   */\n\n\n  Snapping.prototype.getLayer = function () {\n    var snapLine;\n\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) {\n      snapLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      snapLine.setAttribute('id', '_SnappingLines');\n      snapLine.setAttribute('shapeRendering', 'crispEdges');\n      this.getAdornerLayerSvg().appendChild(snapLine);\n    }\n\n    return snapLine;\n  };\n  /**\n   * Constructor for the snapping module\n   *\n   * @private\n   */\n  // constructor() {\n  //     //constructs the snapping module\n  // }\n\n  /**\n   *To destroy the ruler\n   *\n   * @returns {void} To destroy the ruler\n   */\n\n\n  Snapping.prototype.destroy = function () {\n    /**\n     * Destroys the snapping module\n     */\n  };\n  /**\n   * Core method to return the component name.\n   *\n   * @returns {string}  Core method to return the component name.\n   * @private\n   */\n\n\n  Snapping.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'Snapping';\n  };\n\n  return Snapping;\n}();\n\nexport { Snapping };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/snapping.js"],"names":["Rect","PathElement","SnapConstraints","Connector","Selector","getBounds","randomId","isSelected","TextElement","DiagramHtmlElement","Snapping","diagram","line","prototype","canSnap","snapSettings","constraints","SnapToObject","SnapToLines","getWrapperObject","selectedObject","nameTable","nodes","length","i","shape","type","isLane","parentId","wrapper","snapPoint","towardsLeft","towardsTop","delta","startPoint","endPoint","zoomFactor","scroller","currentZoom","offset","x","y","bounds","horizontallysnapped","snapped","verticallysnapped","snapLine","document","createElementNS","setAttribute","getAdornerLayerSvg","appendChild","snapObject","left","top","right","width","bottom","height","scaledIntervals","verticalGridlines","roundedRight","round","roundedLeft","horizontalGridlines","roundedTop","roundedBottom","currentright","currentbottom","SnapToVerticalLines","Math","abs","SnapToHorizontalLines","value","snapIntervals","scale","pow","floor","log","cutoff","quotient","bal","prev","g","horizontalSnap","verticalSnap","ended","lengthX","lengthY","hTarget","vTarget","objectsAtLeft","objectsAtRight","objectsAtTop","objectsAtBottom","hoffset","horizontalOffset","voffset","verticalOffset","snapObjDistance","snapObjectDistance","viewPort","viewPortWidth","viewPortHeight","hIntersectRect","vIntersectRect","findNodes","spatialSearch","target","targetBounds","canBeTarget","id","canConsider","push","obj","distance","createSnapObject","j","createGuidelines","createHSpacingLines","createVSpacingLines","snapConnectorEnd","point","node","snapSize","deltaX","deltaY","sameWidth","sameHeight","hintersectedrect","vintersectedrect","nodesInView","i_1","target_1","targetBounds_1","targetBounds_2","difference","actualDiff","source","dify","getTool","g_1","addSameWidthLines","addSameHeightLines","snapTop","initialBoundsT","rotateAngle","pivot","offsetY","selectedItems","top_1","actualTop","snapRight","initialBound","difx","offsetX","actualRight","snapLeft","initialBoundsB","actualLeft","snapBottom","initialRect","actualBottom","renderAlignmentLines","start","end","transform","svg","tx","ty","line1","stroke","strokeWidth","fill","dashArray","angle","pivotX","pivotY","visible","opacity","diagramRenderer","drawLine","pop","sortByDistance","equallySpaced","helperObject","nearestleft","nearestright","equaldistance","findEquallySpacedNodesAtLeft","dist","adjustablevalue","undefined","splice","findEquallySpacedNodesAtRight","addHSpacingLines","deltaHorizontal","nearesttop","nearestbottom","findEquallySpacedNodesAtTop","findEquallySpacedNodesAtBottom","addVSpacingLines","deltaVertical","crnt","next","renderSpacingLines","equallySpacedObjects","sameWidths","startPt","endPt","sameSizes","crntbounds","sameHeights","d","d1","element","options","data","drawPath","snap","min","max","snapAngle","consider","child","nd","quads","findQuads","quad","objects","isPhase","isHeader","indexOf","intersectsRect","adornerSvgLayer","removeGuidelines","selectionRect","getElementById","parentNode","removeChild","ascending","temp","equalDistance","prevBounds","actualDistance","getLayer","destroy","getModuleName"],"mappings":"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","sourcesContent":["import { Rect } from '../primitives/rect';\nimport { PathElement } from '../core/elements/path-element';\nimport { SnapConstraints } from '../enum/enum';\nimport { Connector } from './connector';\nimport { Selector } from '../objects/node';\nimport { getBounds } from './../utility/base-util';\nimport { randomId } from './../utility/base-util';\nimport { isSelected } from '../interaction/actions';\nimport { TextElement } from '../core/elements/text-element';\nimport { DiagramHtmlElement } from '../core/elements/html-element';\n/**\n * Snapping\n */\nvar Snapping = /** @class */ (function () {\n    function Snapping(diagram) {\n        this.line = [];\n        this.diagram = diagram;\n    }\n    /** @private */\n    Snapping.prototype.canSnap = function () {\n        return (this.diagram.snapSettings.constraints\n            & (SnapConstraints.SnapToObject | SnapConstraints.SnapToLines)) !== 0;\n    };\n    Snapping.prototype.getWrapperObject = function (selectedObject, nameTable) {\n        if (selectedObject.nodes && selectedObject.nodes.length > 0\n            && (this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines || this.diagram.snapSettings.constraints\n                & SnapConstraints.SnapToObject)) {\n            for (var i = 0; i < selectedObject.nodes.length; i++) {\n                if (((selectedObject.nodes[i].shape.type === \"SwimLane\" || selectedObject.nodes[i].isLane)\n                    || selectedObject.nodes[i].parentId !== ''\n                        && nameTable[(selectedObject.nodes[i].parentId)]\n                        && nameTable[(selectedObject.nodes[i].parentId)].isLane) && nameTable['helper']) {\n                    return nameTable['helper'].wrapper;\n                }\n                else {\n                    return selectedObject.wrapper;\n                }\n            }\n        }\n        return selectedObject.wrapper;\n    };\n    ;\n    /**\n     * Snap to object\n     *\n     * @private\n     */\n    Snapping.prototype.snapPoint = function (diagram, selectedObject, towardsLeft, towardsTop, delta, startPoint, endPoint) {\n        var snapSettings = this.diagram.snapSettings;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        var offset = { x: 0, y: 0 };\n        var wrapper;\n        wrapper = this.getWrapperObject(selectedObject, diagram.nameTable);\n        var bounds = getBounds(wrapper);\n        var horizontallysnapped = { snapped: false, offset: 0 };\n        var verticallysnapped = { snapped: false, offset: 0 };\n        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) {\n            //let snapLine: SVGElement;\n            var snapLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            snapLine.setAttribute('id', '_SnappingLines');\n            snapLine.setAttribute('shapeRendering', 'crispEdges');\n            this.getAdornerLayerSvg().appendChild(snapLine);\n            this.snapObject(diagram, selectedObject, snapLine, horizontallysnapped, verticallysnapped, delta, startPoint === endPoint);\n        }\n        //original position\n        var left = bounds.x + delta.x;\n        var top = bounds.y + delta.y;\n        var right = bounds.x + bounds.width + delta.x;\n        var bottom = bounds.y + bounds.height + delta.y;\n        var scaledIntervals = snapSettings.verticalGridlines.scaledIntervals;\n        //snapped positions\n        var roundedRight = this.round(right, scaledIntervals, zoomFactor);\n        var roundedLeft = this.round(left, scaledIntervals, zoomFactor);\n        scaledIntervals = snapSettings.horizontalGridlines.scaledIntervals;\n        var roundedTop = this.round(top, scaledIntervals, zoomFactor);\n        var roundedBottom = this.round(bottom, scaledIntervals, zoomFactor);\n        //currentposition\n        var currentright = bounds.x + bounds.width;\n        var currentbottom = bounds.y + bounds.height;\n        if (!horizontallysnapped.snapped) {\n            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToVerticalLines) {\n                if (Math.abs(delta.x) >= 1) {\n                    if (towardsLeft) {\n                        if (Math.abs(roundedRight - currentright) > Math.abs(roundedLeft - bounds.x)) {\n                            offset.x += roundedLeft - bounds.x;\n                        }\n                        else {\n                            offset.x += roundedRight - currentright;\n                        }\n                    }\n                    else {\n                        if (Math.abs(roundedRight - currentright) < Math.abs(roundedLeft - bounds.x)) {\n                            offset.x += roundedRight - currentright;\n                        }\n                        else {\n                            offset.x += roundedLeft - bounds.x;\n                        }\n                    }\n                }\n            }\n            else {\n                offset.x = endPoint.x - startPoint.x;\n            }\n        }\n        else {\n            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) {\n                offset.x = horizontallysnapped.offset;\n            }\n            else {\n                offset.x = endPoint.x - startPoint.x;\n            }\n        }\n        if (!verticallysnapped.snapped) {\n            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToHorizontalLines) {\n                if (Math.abs(delta.y) >= 1) {\n                    if (towardsTop) {\n                        if (Math.abs(roundedBottom - currentbottom) > Math.abs(roundedTop - bounds.y)) {\n                            offset.y += roundedTop - bounds.y;\n                        }\n                        else {\n                            offset.y += roundedBottom - currentbottom;\n                        }\n                    }\n                    else {\n                        if (Math.abs(roundedBottom - currentbottom) < Math.abs(roundedTop - bounds.y)) {\n                            offset.y += roundedBottom - currentbottom;\n                        }\n                        else {\n                            offset.y += roundedTop - bounds.y;\n                        }\n                    }\n                }\n            }\n            else {\n                offset.y = endPoint.y - startPoint.y;\n            }\n        }\n        else {\n            offset.y = verticallysnapped.offset;\n        }\n        return offset;\n    };\n    /**\n     * @private\n     */\n    Snapping.prototype.round = function (value, snapIntervals, scale) {\n        if (scale === 1) {\n            scale = Math.pow(2, Math.floor(Math.log(scale) / Math.log(2)));\n        }\n        else {\n            scale = scale;\n        }\n        var cutoff = 0;\n        var i = 0;\n        for (i = 0; i < snapIntervals.length; i++) {\n            cutoff += snapIntervals[i];\n        }\n        cutoff /= scale;\n        var quotient = Math.floor(Math.abs(value) / cutoff);\n        var bal = value % cutoff;\n        var prev = quotient * cutoff;\n        if (prev !== value) {\n            if (value >= 0) {\n                for (i = 0; i < snapIntervals.length; i++) {\n                    if (bal <= snapIntervals[i] / scale) {\n                        return prev + (bal < (snapIntervals[i] / (2 * scale)) ? 0 : snapIntervals[i] / scale);\n                    }\n                    else {\n                        prev += snapIntervals[i] / scale;\n                        bal -= snapIntervals[i] / scale;\n                    }\n                }\n            }\n            else {\n                prev = prev * -1;\n                for (i = snapIntervals.length - 1; i >= 0; i--) {\n                    if (Math.abs(bal) <= snapIntervals[i] / scale) {\n                        return prev - (Math.abs(bal) < (snapIntervals[i] / (2 * scale)) ? 0 : snapIntervals[i] / scale);\n                    }\n                    else {\n                        prev -= snapIntervals[i] / scale;\n                        bal += snapIntervals[i] / scale;\n                    }\n                }\n            }\n        }\n        return value;\n    };\n    //Snap to Object\n    Snapping.prototype.snapObject = function (diagram, selectedObject, g, horizontalSnap, verticalSnap, delta, ended) {\n        var lengthX = null;\n        var lengthY;\n        var hTarget;\n        var vTarget;\n        var scroller = this.diagram.scroller;\n        var snapSettings = this.diagram.snapSettings;\n        var objectsAtLeft = [];\n        var objectsAtRight = [];\n        var objectsAtTop = [];\n        var objectsAtBottom = [];\n        var wrapper;\n        wrapper = this.getWrapperObject(selectedObject, diagram.nameTable);\n        var bounds = getBounds(wrapper);\n        var scale = diagram.scroller.currentZoom;\n        var hoffset = -scroller.horizontalOffset;\n        var voffset = -scroller.verticalOffset;\n        var snapObjDistance = snapSettings.snapObjectDistance / scale;\n        var viewPort = new Rect(0, 0, scroller.viewPortWidth, scroller.viewPortHeight);\n        var hIntersectRect = new Rect(hoffset / scale, (bounds.y - snapObjDistance - 5), viewPort.width / scale, (bounds.height + 2 * snapObjDistance + 10));\n        var vIntersectRect = new Rect((bounds.x - snapObjDistance - 5), voffset / scale, (bounds.width + 2 * snapObjDistance + 10), viewPort.height / scale);\n        viewPort = new Rect(hoffset / scale, voffset / scale, viewPort.width / scale, viewPort.height / scale);\n        var nodes = this.findNodes(diagram.spatialSearch, selectedObject, vIntersectRect, viewPort);\n        var i;\n        var target;\n        var targetBounds;\n        var nameTable = diagram.nameTable;\n        for (i = 0; i < nodes.length; i++) {\n            target = nodes[i];\n            if (this.canBeTarget(diagram, target)) {\n                if (!(this.diagram.nameTable[target.id] instanceof Connector) && this.canConsider(nameTable, selectedObject, target)) {\n                    targetBounds = target.bounds;\n                    if (targetBounds.height + targetBounds.y < delta.y + bounds.y) {\n                        objectsAtTop.push({\n                            obj: target, distance: Math.abs(bounds.y + delta.y - targetBounds.y - targetBounds.height)\n                        });\n                    }\n                    else if (targetBounds.y > bounds.y + delta.y + bounds.height) {\n                        objectsAtBottom.push({ obj: target, distance: Math.abs(bounds.y + delta.y + bounds.height - targetBounds.y) });\n                    }\n                    if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y - delta.y)) {\n                        if (Math.abs(targetBounds.x + targetBounds.width / 2 - (bounds.x + bounds.width / 2 + delta.x)) <=\n                            snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'centerX');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + bounds.width + delta.x)) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'right');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(targetBounds.x - (bounds.x + delta.x)) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'left');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(targetBounds.x - (bounds.x + bounds.width + delta.x)) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'rightLeft');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(targetBounds.x + targetBounds.width - (bounds.x + delta.x)) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'leftRight');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                    }\n                }\n            }\n        }\n        nodes = this.findNodes(diagram.spatialSearch, selectedObject, hIntersectRect, viewPort);\n        for (var j = 0; j < nodes.length; j++) {\n            target = nodes[j];\n            if (this.canBeTarget(diagram, target)) {\n                if (!(this.diagram.nameTable[target.id] instanceof Connector) && this.canConsider(nameTable, selectedObject, target)) {\n                    targetBounds = target.bounds;\n                    if (targetBounds.x + targetBounds.width < bounds.x + delta.x) {\n                        objectsAtLeft[objectsAtLeft.length] = {\n                            obj: target, distance: Math.abs((bounds.x + delta.x) - targetBounds.x - targetBounds.width)\n                        };\n                    }\n                    if (targetBounds.x > bounds.x + delta.x + bounds.width) {\n                        objectsAtRight[objectsAtRight.length] = {\n                            obj: target, distance: Math.abs(bounds.x + delta.x + bounds.width - targetBounds.x)\n                        };\n                    }\n                    if (lengthY == null || lengthY > Math.abs(targetBounds.x - bounds.x - delta.x)) {\n                        if (Math.abs(targetBounds.y + targetBounds.height / 2 - (bounds.y + bounds.height / 2 + delta.y))\n                            <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds, bounds, 'centerY');\n                            lengthY = Math.abs(targetBounds.x - bounds.x);\n                        }\n                        else if (Math.abs(targetBounds.y - bounds.y - delta.y) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds, bounds, 'top');\n                            lengthY = Math.abs(targetBounds.x - bounds.x);\n                        }\n                        else if (Math.abs(targetBounds.y + targetBounds.height - (bounds.y + bounds.height + delta.y)) <=\n                            snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds, bounds, 'bottom');\n                            lengthY = Math.abs(targetBounds.x - bounds.x);\n                        }\n                        else if (Math.abs(targetBounds.y + targetBounds.height - bounds.y - delta.y) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds, bounds, 'topBottom');\n                            lengthY = Math.abs(targetBounds.x - bounds.x);\n                        }\n                        else if (Math.abs(targetBounds.y - (bounds.y + bounds.height + delta.y)) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds, bounds, 'bottomTop');\n                            lengthY = Math.abs(targetBounds.x - bounds.x);\n                        }\n                    }\n                }\n            }\n        }\n        this.createGuidelines(diagram, hTarget, vTarget, g, horizontalSnap, verticalSnap, ended);\n        if (!horizontalSnap.snapped) {\n            this.createHSpacingLines(diagram, g, selectedObject, objectsAtLeft, objectsAtRight, horizontalSnap, verticalSnap, ended, delta, snapObjDistance);\n        }\n        if (!verticalSnap.snapped) {\n            this.createVSpacingLines(diagram, g, selectedObject, objectsAtTop, objectsAtBottom, horizontalSnap, verticalSnap, ended, delta, snapObjDistance);\n        }\n    };\n    /**\n     * @private\n     */\n    Snapping.prototype.snapConnectorEnd = function (point) {\n        var snapSettings = this.diagram.snapSettings;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        if (snapSettings.constraints & SnapConstraints.SnapToLines) {\n            point.x = this.round(point.x, snapSettings.verticalGridlines.scaledIntervals, zoomFactor);\n            point.y = this.round(point.y, snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n        }\n        return point;\n    };\n    Snapping.prototype.canBeTarget = function (diagram, node) {\n        node = this.diagram.nameTable[node.id];\n        return !(isSelected(this.diagram, node, false));\n    };\n    Snapping.prototype.snapSize = function (diagram, horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, selectedObject, ended) {\n        var lengthX;\n        var lengthY;\n        var snapSettings = this.diagram.snapSettings;\n        var scroller = this.diagram.scroller;\n        var hTarget;\n        var vTarget;\n        var bounds = getBounds(selectedObject.wrapper);\n        var nameTable = diagram.nameTable;\n        var sameWidth = [];\n        var sameHeight = [];\n        var scale = diagram.scroller.currentZoom;\n        var hoffset = -scroller.horizontalOffset;\n        var voffset = -scroller.verticalOffset;\n        var snapObjDistance = snapSettings.snapObjectDistance / scale;\n        var viewPort = new Rect(0, 0, scroller.viewPortWidth, scroller.viewPortHeight);\n        var hintersectedrect = new Rect(hoffset / scale, (bounds.y - 5) / scale, viewPort.width / scale, (bounds.height + 10) / scale);\n        var vintersectedrect = new Rect((bounds.x - 5) / scale, voffset / scale, (bounds.width + 10) / scale, viewPort.height / scale);\n        viewPort = new Rect(hoffset / scale, voffset / scale, viewPort.width / scale, viewPort.height / scale);\n        var nodesInView = [];\n        var nodes = this.findNodes(diagram.spatialSearch, selectedObject, vintersectedrect, viewPort, nodesInView);\n        var i;\n        var target;\n        var targetBounds;\n        for (i = 0; i < nodes.length; i++) {\n            target = nodes[i];\n            if (this.canConsider(nameTable, selectedObject, target) && !(this.diagram.nameTable[target.id] instanceof Connector)) {\n                targetBounds = target.bounds;\n                if (lengthX == null || lengthX > Math.abs(targetBounds.y - bounds.y)) {\n                    if (horizontalSnap.left) {\n                        if (Math.abs(bounds.x + deltaX - targetBounds.x) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'left');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(bounds.x + deltaX - targetBounds.x - targetBounds.width) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'leftRight');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                    }\n                    else if (horizontalSnap.right) {\n                        if (Math.abs(bounds.x + deltaX + bounds.width - targetBounds.x - targetBounds.width) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'right');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                        else if (Math.abs(bounds.x + deltaX + bounds.width - targetBounds.x) <= snapObjDistance) {\n                            hTarget = this.createSnapObject(targetBounds, bounds, 'rightLeft');\n                            lengthX = Math.abs(targetBounds.y - bounds.y);\n                        }\n                    }\n                }\n            }\n        }\n        nodes = this.findNodes(diagram.spatialSearch, selectedObject, hintersectedrect, viewPort);\n        for (var i_1 = 0; i_1 < nodes.length; i_1++) {\n            var target_1 = nodes[i_1];\n            if (this.canConsider(nameTable, selectedObject, target_1) && !(this.diagram.nameTable[target_1.id] instanceof Connector)) {\n                var targetBounds_1 = target_1.bounds;\n                if (lengthY == null || lengthY > Math.abs(targetBounds_1.x - bounds.x)) {\n                    if (verticalSnap.top) {\n                        if (Math.abs(bounds.y + deltaY - targetBounds_1.y) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'top');\n                            lengthY = Math.abs(targetBounds_1.x - bounds.x);\n                        }\n                        else if (Math.abs(bounds.y + deltaY - targetBounds_1.y - targetBounds_1.height) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'topBottom');\n                            lengthY = Math.abs(targetBounds_1.x - bounds.x);\n                        }\n                    }\n                    else if (verticalSnap.bottom) {\n                        if (Math.abs(bounds.y + bounds.height + deltaY - targetBounds_1.y - targetBounds_1.height) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'bottom');\n                            lengthY = Math.abs(targetBounds_1.x - bounds.x);\n                        }\n                        else if (Math.abs(bounds.y + bounds.height + deltaY - targetBounds_1.y) <= snapObjDistance) {\n                            vTarget = this.createSnapObject(targetBounds_1, bounds, 'bottomTop');\n                            lengthY = Math.abs(targetBounds_1.x - bounds.x);\n                        }\n                    }\n                }\n            }\n        }\n        for (i = 0; i < nodesInView.length; i++) {\n            target = nodesInView[i];\n            if (this.canConsider(nameTable, selectedObject, target)) {\n                var targetBounds_2 = target.bounds;\n                var delta = horizontalSnap.left ? -deltaX : deltaX;\n                var difference = Math.abs(bounds.width + delta - targetBounds_2.width);\n                var actualDiff = void 0;\n                if (difference <= snapObjDistance) {\n                    actualDiff = horizontalSnap.left ? -targetBounds_2.width + bounds.width : targetBounds_2.width - bounds.width;\n                    sameWidth[sameWidth.length] = { source: target, difference: difference, offset: actualDiff };\n                }\n                delta = verticalSnap.top ? -deltaY : deltaY;\n                var dify = Math.abs(bounds.height + delta - targetBounds_2.height);\n                if (dify <= snapObjDistance) {\n                    actualDiff = verticalSnap.top ? -targetBounds_2.height + bounds.height : targetBounds_2.height - bounds.height;\n                    sameHeight[sameHeight.length] = { source: target, difference: dify, offset: actualDiff };\n                }\n            }\n        }\n        var g;\n        if (!diagram.getTool) {\n            var g_1 = this.createGuidelines(diagram, hTarget, vTarget, snapLine, horizontalSnap, verticalSnap, ended);\n        }\n        if (!horizontalSnap.snapped && sameWidth.length > 0 && (horizontalSnap.left || horizontalSnap.right)) {\n            this.addSameWidthLines(diagram, snapLine, sameWidth, horizontalSnap, ended, selectedObject);\n        }\n        if (!verticalSnap.snapped && sameHeight.length > 0 && (verticalSnap.top || verticalSnap.bottom)) {\n            this.addSameHeightLines(diagram, snapLine, sameHeight, verticalSnap, ended, selectedObject);\n        }\n    };\n    /**\n     * Snap to object on top\n     *\n     * @private\n     */\n    Snapping.prototype.snapTop = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBoundsT) {\n        var dify = deltaY;\n        verticalSnap.top = true;\n        var y;\n        horizontalSnap.left = horizontalSnap.right = false;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        //let initialBoundsT: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {\n            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n            y = initialBoundsT.y - initialBoundsT.height * shape.pivot.y + deltaY - (shape.offsetY - shape.height * shape.pivot.y);\n            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, deltaX, y, this.diagram.selectedItems, ended);\n        }\n        if (!verticalSnap.snapped) {\n            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToHorizontalLines) {\n                var top_1 = initialBoundsT.y - initialBoundsT.height * shape.pivot.y;\n                var actualTop = top_1 + deltaY;\n                var roundedTop = this.round(actualTop, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n                dify = roundedTop - top_1;\n            }\n        }\n        else {\n            dify = (deltaY - y) + verticalSnap.offset;\n        }\n        return dify;\n    };\n    /**\n     * Snap to object on right\n     *\n     * @private\n     */\n    Snapping.prototype.snapRight = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBound) {\n        var difx = deltaX;\n        var x;\n        horizontalSnap.right = true;\n        verticalSnap.top = verticalSnap.bottom = false;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        //let initialBound: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {\n            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n            x = initialBound.x + initialBound.width * (1 - shape.pivot.x) + deltaX - (shape.offsetX + shape.width * (1 - shape.pivot.x));\n            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, x, deltaY, this.diagram.selectedItems, ended);\n        }\n        if (!horizontalSnap.snapped) {\n            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToVerticalLines) {\n                var right = initialBound.x + initialBound.width * (1 - shape.pivot.x);\n                var actualRight = right + deltaX;\n                var roundedRight = this.round(actualRight, this.diagram.snapSettings.verticalGridlines.scaledIntervals, zoomFactor);\n                difx = roundedRight - right;\n            }\n        }\n        else {\n            difx = (deltaX - x) + horizontalSnap.offset;\n        }\n        return difx;\n    };\n    /**\n     * Snap to object on left\n     *\n     * @private\n     */\n    Snapping.prototype.snapLeft = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialBoundsB) {\n        var difx = deltaX;\n        var x = 0;\n        horizontalSnap.left = true;\n        verticalSnap.top = verticalSnap.bottom = false;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        //let initialBoundsB: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {\n            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n            x = initialBoundsB.x - initialBoundsB.width * shape.pivot.x + deltaX - (shape.offsetX - shape.width * shape.pivot.x);\n            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, x, deltaY, this.diagram.selectedItems, ended);\n        }\n        if (!horizontalSnap.snapped) {\n            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToVerticalLines) {\n                var left = initialBoundsB.x - initialBoundsB.width * shape.pivot.x;\n                var actualLeft = left + deltaX;\n                var roundedLeft = this.round(actualLeft, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n                difx = roundedLeft - left;\n            }\n        }\n        else {\n            difx = (deltaX - x) + horizontalSnap.offset;\n        }\n        return difx;\n    };\n    /**\n     * Snap to object on bottom\n     *\n     * @private\n     */\n    Snapping.prototype.snapBottom = function (horizontalSnap, verticalSnap, snapLine, deltaX, deltaY, shape, ended, initialRect) {\n        var dify = deltaY;\n        verticalSnap.bottom = true;\n        horizontalSnap.left = horizontalSnap.right = false;\n        var zoomFactor = this.diagram.scroller.currentZoom;\n        var y = 0;\n        //let initialRect: Rect = new Rect(shape.offsetX, shape.offsetY, shape.width, shape.height);\n        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && !shape.rotateAngle) {\n            //(!this.selectedObject.isLane && !this.selectedObject.isSwimlane)) {\n            y = initialRect.y + initialRect.height * (1 - shape.pivot.y) + deltaY - (shape.offsetY + shape.height * (1 - shape.pivot.y));\n            this.snapSize(this.diagram, horizontalSnap, verticalSnap, snapLine, deltaX, y, this.diagram.selectedItems, ended);\n        }\n        // eslint-disable-next-line max-len\n        var bounds = ((shape instanceof TextElement) || (shape instanceof DiagramHtmlElement)) ? getBounds(shape) :\n            getBounds(shape.wrapper);\n        if (!verticalSnap.snapped) {\n            if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToHorizontalLines) {\n                var bottom = initialRect.y + initialRect.height * (1 - shape.pivot.y);\n                var actualBottom = bottom + deltaY;\n                var roundedBottom = this.round(actualBottom, this.diagram.snapSettings.horizontalGridlines.scaledIntervals, zoomFactor);\n                dify = roundedBottom - bottom;\n            }\n        }\n        else {\n            dify = (deltaY - y) + verticalSnap.offset;\n        }\n        return dify;\n    };\n    //To create the same width and same size lines\n    Snapping.prototype.createGuidelines = function (diagram, hTarget, vTarget, snapLine, horizontalSnap, verticalSnap, ended) {\n        if (hTarget) {\n            horizontalSnap.offset = hTarget.offsetX;\n            horizontalSnap.snapped = true;\n            if (!ended) {\n                if (hTarget.type === 'sideAlign') {\n                    this.renderAlignmentLines(hTarget.start, hTarget.end, snapLine, diagram.scroller.transform);\n                }\n                else {\n                    this.renderAlignmentLines(hTarget.start, hTarget.end, snapLine, diagram.scroller.transform);\n                }\n            }\n        }\n        if (vTarget) {\n            verticalSnap.offset = vTarget.offsetY;\n            verticalSnap.snapped = true;\n            if (!ended) {\n                if (vTarget.type === 'sideAlign') {\n                    this.renderAlignmentLines(vTarget.start, vTarget.end, snapLine, diagram.scroller.transform);\n                }\n                else {\n                    this.renderAlignmentLines(vTarget.start, vTarget.end, snapLine, diagram.scroller.transform);\n                }\n            }\n        }\n        return snapLine;\n    };\n    //To create the alignment lines\n    Snapping.prototype.renderAlignmentLines = function (start, end, svg, transform) {\n        start = {\n            x: (start.x + transform.tx) * transform.scale,\n            y: (start.y + transform.ty) * transform.scale\n        };\n        end = {\n            x: (end.x + transform.tx) * transform.scale,\n            y: (end.y + transform.ty) * transform.scale\n        };\n        var line1 = {\n            stroke: '#07EDE1', strokeWidth: 1, startPoint: { x: start.x, y: start.y },\n            endPoint: { x: end.x, y: end.y }, fill: '#07EDE1', dashArray: '', width: 1,\n            x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n            pivotY: 0, visible: true, opacity: 1, id: randomId()\n        };\n        var i = 0;\n        this.line.push(line1);\n        for (i = 0; i < this.line.length; i++) {\n            this.diagram.diagramRenderer.drawLine(svg, this.line.pop());\n        }\n    };\n    //To create Horizontal spacing lines\n    Snapping.prototype.createHSpacingLines = function (diagram, g, shape, objectsAtLeft, objectsAtRight, horizontalSnap, verticalSnap, ended, delta, snapObjDistance) {\n        var top = 0;\n        this.sortByDistance(objectsAtLeft, 'distance', true);\n        this.sortByDistance(objectsAtRight, 'distance', true);\n        var equallySpaced = [];\n        var bounds;\n        if (diagram.selectedObject.helperObject) {\n            bounds = getBounds(diagram.selectedObject.helperObject.wrapper);\n        }\n        else {\n            bounds = getBounds(shape.wrapper);\n        }\n        var nearestleft;\n        var nearestright;\n        var targetBounds;\n        var equaldistance;\n        if (objectsAtLeft.length > 0) {\n            equallySpaced[equallySpaced.length] = objectsAtLeft[0];\n            nearestleft = ((objectsAtLeft[0].obj).bounds);\n            top = nearestleft.y;\n            if (objectsAtLeft.length > 1) {\n                targetBounds = ((objectsAtLeft[1].obj).bounds);\n                equaldistance = nearestleft.x - targetBounds.x - targetBounds.width;\n                if (Math.abs(equaldistance - objectsAtLeft[0].distance) <= snapObjDistance) {\n                    top = this.findEquallySpacedNodesAtLeft(objectsAtLeft, equaldistance, top, equallySpaced);\n                }\n                else {\n                    equaldistance = objectsAtLeft[0].distance;\n                }\n            }\n            else {\n                equaldistance = objectsAtLeft[0].distance;\n            }\n        }\n        this.sortByDistance(equallySpaced, 'distance');\n        equallySpaced[equallySpaced.length] = { obj: shape, distance: 0 };\n        top = bounds.y < top || !top ? bounds.y : top;\n        if (objectsAtRight.length > 0) {\n            var dist = void 0;\n            nearestright = ((objectsAtRight[0].obj).bounds);\n            top = nearestright.y < top ? nearestright.y : top;\n            if (objectsAtRight.length > 1) {\n                targetBounds = ((objectsAtRight[1].obj).bounds);\n                dist = targetBounds.x - nearestright.x - nearestright.width;\n            }\n            if (objectsAtLeft.length > 0) {\n                if (Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) <= snapObjDistance) {\n                    var adjustablevalue = Math.abs(objectsAtRight[0].distance - objectsAtLeft[0].distance) / 2;\n                    (objectsAtRight[0].distance < objectsAtLeft[0].distance) ?\n                        equaldistance -= adjustablevalue : equaldistance += adjustablevalue;\n                    equallySpaced[equallySpaced.length] = objectsAtRight[0];\n                }\n                else if (objectsAtLeft.length === 1) {\n                    nearestleft = undefined;\n                    equallySpaced.splice(0, 1);\n                    equallySpaced[equallySpaced.length] = objectsAtRight[0];\n                    equaldistance = dist;\n                }\n            }\n            else {\n                equaldistance = dist;\n                equallySpaced[equallySpaced.length] = objectsAtRight[0];\n            }\n            if (objectsAtRight.length > 1 && nearestright.x + nearestright.width < targetBounds.x) {\n                top = this.findEquallySpacedNodesAtRight(objectsAtRight, dist, top, equallySpaced, snapObjDistance);\n            }\n        }\n        if (equallySpaced.length > 2) {\n            this.addHSpacingLines(diagram, g, equallySpaced, ended, top);\n            var deltaHorizontal = 0;\n            if (ended) {\n                deltaHorizontal = delta.x;\n            }\n            if (nearestleft) {\n                horizontalSnap.offset = equaldistance - Math.abs(bounds.x + deltaHorizontal - nearestleft.x - nearestleft.width)\n                    + deltaHorizontal;\n            }\n            else if (nearestright) {\n                horizontalSnap.offset = Math.abs(bounds.x + bounds.width + deltaHorizontal - nearestright.x)\n                    - equaldistance + deltaHorizontal;\n            }\n            horizontalSnap.snapped = true;\n        }\n    };\n    //To create vertical spacing lines\n    Snapping.prototype.createVSpacingLines = function (diagram, g, shape, objectsAtTop, objectsAtBottom, horizontalSnap, verticalSnap, ended, delta, snapObjDistance) {\n        var right = 0;\n        this.sortByDistance(objectsAtTop, 'distance', true);\n        this.sortByDistance(objectsAtBottom, 'distance', true);\n        var equallySpaced = [];\n        var wrapper;\n        wrapper = this.getWrapperObject(shape, diagram.nameTable);\n        var bounds = getBounds(wrapper);\n        var nearesttop;\n        var nearestbottom;\n        var targetBounds;\n        var equaldistance;\n        if (objectsAtTop.length > 0) {\n            equallySpaced[equallySpaced.length] = objectsAtTop[0];\n            nearesttop = ((objectsAtTop[0].obj).bounds);\n            right = nearesttop.x + nearesttop.width;\n            if (objectsAtTop.length > 1) {\n                targetBounds = ((objectsAtTop[1].obj).bounds);\n                equaldistance = nearesttop.y - targetBounds.y - targetBounds.height;\n                if (Math.abs(equaldistance - objectsAtTop[0].distance) <= snapObjDistance) {\n                    right = this.findEquallySpacedNodesAtTop(objectsAtTop, equaldistance, right, equallySpaced);\n                }\n                else {\n                    equaldistance = objectsAtTop[0].distance;\n                }\n            }\n            else {\n                equaldistance = objectsAtTop[0].distance;\n            }\n        }\n        this.sortByDistance(equallySpaced, 'distance');\n        equallySpaced[equallySpaced.length] = { obj: shape, distance: 0 };\n        right = bounds.x + bounds.width > right || !right ? bounds.x + bounds.width : right;\n        var dist;\n        if (objectsAtBottom.length > 0) {\n            nearestbottom = ((objectsAtBottom[0].obj).bounds);\n            right = nearestbottom.x + nearestbottom.width > right ? nearestbottom.x + nearestbottom.width : right;\n            if (objectsAtBottom.length > 1) {\n                targetBounds = ((objectsAtBottom[1].obj).bounds);\n                dist = targetBounds.y - nearestbottom.y - nearestbottom.height;\n            }\n            if (objectsAtTop.length > 0) {\n                if (Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) <= snapObjDistance) {\n                    var adjustablevalue = Math.abs(objectsAtBottom[0].distance - objectsAtTop[0].distance) / 2;\n                    (objectsAtBottom[0].distance < objectsAtTop[0].distance) ?\n                        equaldistance -= adjustablevalue : equaldistance += adjustablevalue;\n                    equallySpaced[equallySpaced.length] = objectsAtBottom[0];\n                }\n                else if (objectsAtTop.length === 1) {\n                    nearesttop = undefined;\n                    equallySpaced.splice(0, 1);\n                    equallySpaced[equallySpaced.length] = objectsAtBottom[0];\n                    equaldistance = dist;\n                }\n            }\n            else {\n                equaldistance = dist;\n                equallySpaced[equallySpaced.length] = objectsAtBottom[0];\n            }\n            if (objectsAtBottom.length > 1 && targetBounds.y > nearestbottom.y + nearestbottom.height) {\n                right = this.findEquallySpacedNodesAtBottom(objectsAtBottom, dist, right, equallySpaced, snapObjDistance);\n            }\n        }\n        if (equallySpaced.length > 2) {\n            this.addVSpacingLines(diagram, g, equallySpaced, ended, right);\n            var deltaVertical = 0;\n            if (ended) {\n                deltaVertical = delta.y;\n            }\n            if (nearesttop) {\n                verticalSnap.offset = equaldistance - Math.abs(bounds.y + deltaVertical - nearesttop.y - nearesttop.height) + deltaVertical;\n            }\n            else if (nearestbottom) {\n                verticalSnap.offset = Math.abs(bounds.y + bounds.height + deltaVertical - nearestbottom.y) - equaldistance + deltaVertical;\n            }\n            verticalSnap.snapped = true;\n        }\n    };\n    //Add the Horizontal spacing lines\n    Snapping.prototype.addHSpacingLines = function (diagram, g, equallySpaced, ended, top) {\n        var i;\n        var start;\n        var end;\n        if (!ended) {\n            for (i = 0; i < equallySpaced.length - 1; i++) {\n                var crnt = equallySpaced[i].obj instanceof Selector ?\n                    getBounds((equallySpaced[i].obj).wrapper) : ((equallySpaced[i].obj).bounds);\n                var next = equallySpaced[i + 1].obj instanceof Selector ?\n                    getBounds((equallySpaced[i + 1].obj).wrapper) : ((equallySpaced[i + 1].obj).bounds);\n                start = { x: crnt.x + crnt.width, y: top - 15 };\n                end = { x: next.x, y: top - 15 };\n                this.renderSpacingLines(start, end, g, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            }\n        }\n    };\n    //Add the vertical spacing lines\n    Snapping.prototype.addVSpacingLines = function (diagram, g, equallySpacedObjects, ended, right) {\n        var start;\n        var end;\n        if (!ended) {\n            for (var i = 0; i < equallySpacedObjects.length - 1; i++) {\n                var crnt = equallySpacedObjects[i].obj instanceof Selector ?\n                    getBounds((equallySpacedObjects[i].obj).wrapper) : ((equallySpacedObjects[i].obj).bounds);\n                var next = equallySpacedObjects[i + 1].obj instanceof Selector ?\n                    getBounds((equallySpacedObjects[i + 1].obj).wrapper) :\n                    ((equallySpacedObjects[i + 1].obj).bounds);\n                start = { x: right + 15, y: crnt.y + crnt.height };\n                end = { x: right + 15, y: next.y };\n                this.renderSpacingLines(start, end, g, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            }\n        }\n    };\n    //To add same width lines\n    Snapping.prototype.addSameWidthLines = function (diagram, snapLine, sameWidths, horizontalSnap, ended, shape) {\n        this.sortByDistance(sameWidths, 'offset');\n        var bounds = getBounds(shape.wrapper);\n        var target = sameWidths[0];\n        var startPt;\n        var endPt;\n        var targetBounds = (target.source).bounds;\n        var sameSizes = [];\n        sameSizes.push(sameWidths[0]);\n        var i;\n        var crntbounds;\n        for (i = 1; i < sameWidths.length; i++) {\n            crntbounds = (sameWidths[i].source).bounds;\n            if (crntbounds.width === targetBounds.width) {\n                sameSizes.push(sameWidths[i]);\n            }\n        }\n        if (!ended) {\n            startPt = { x: bounds.x + target.offset, y: bounds.y - 15 };\n            endPt = { x: bounds.x + bounds.width + target.offset, y: bounds.y - 15 };\n            this.renderSpacingLines(startPt, endPt, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            for (i = 0; i < sameSizes.length; i++) {\n                bounds = (sameSizes[i].source).bounds;\n                startPt = { x: bounds.x, y: bounds.y - 15 };\n                endPt = { x: bounds.x + bounds.width, y: bounds.y - 15 };\n                this.renderSpacingLines(startPt, endPt, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            }\n        }\n        horizontalSnap.offset = target.offset;\n        horizontalSnap.snapped = true;\n    };\n    //To add same height lines\n    Snapping.prototype.addSameHeightLines = function (diagram, snapLine, sameHeights, verticalSnap, ended, shape) {\n        this.sortByDistance(sameHeights, 'offset');\n        var bounds = getBounds(shape.wrapper);\n        var target = sameHeights[0];\n        var targetBounds = (target.source).bounds;\n        var start;\n        var end;\n        var sameSizes = [];\n        sameSizes.push(sameHeights[0]);\n        var i;\n        var crntbounds;\n        for (i = 0; i < sameHeights.length; i++) {\n            crntbounds = (sameHeights[i].source).bounds;\n            if (crntbounds.height === targetBounds.height) {\n                sameSizes.push(sameHeights[i]);\n            }\n        }\n        if (!ended) {\n            start = { x: bounds.x + bounds.width + 15, y: bounds.y + target.offset };\n            end = { x: bounds.x + bounds.width + 15, y: bounds.y + target.offset + bounds.height };\n            this.renderSpacingLines(start, end, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            for (i = 0; i < sameSizes.length; i++) {\n                bounds = (sameSizes[i].source).bounds;\n                start = { x: bounds.x + bounds.width + 15, y: bounds.y };\n                end = { x: bounds.x + bounds.width + 15, y: bounds.y + bounds.height };\n                this.renderSpacingLines(start, end, snapLine, this.getAdornerLayerSvg(), diagram.scroller.transform);\n            }\n        }\n        verticalSnap.offset = target.offset;\n        verticalSnap.snapped = true;\n    };\n    //Render spacing lines\n    Snapping.prototype.renderSpacingLines = function (start, end, snapLine, svg, transform) {\n        var d;\n        var d1;\n        var line1;\n        var element = new PathElement();\n        var options = {};\n        start = {\n            x: (start.x + transform.tx) * transform.scale,\n            y: (start.y + transform.ty) * transform.scale\n        };\n        end = {\n            x: (end.x + transform.tx) * transform.scale,\n            y: (end.y + transform.ty) * transform.scale\n        };\n        if (start.x === end.x) {\n            d = 'M' + (start.x - 5) + ' ' + (start.y + 5) + 'L' + start.x + ' ' + start.y +\n                'L' + (start.x + 5) + ' ' + (start.y + 5) + 'z' + 'M' + (end.x - 5) + ' ' +\n                (end.y - 5) + ' L' + end.x + ' ' + end.y + ' L' +\n                (end.x + 5) + ' ' + (end.y - 5) + 'z';\n            line1 = {\n                startPoint: { x: start.x - 8, y: start.y - 1 },\n                endPoint: { x: start.x + 8, y: start.y - 1 },\n                stroke: '#07EDE1',\n                strokeWidth: 1, fill: '#07EDE1', dashArray: '', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n                pivotY: 0, visible: true, opacity: 1, id: randomId()\n            };\n            element.data = d;\n            options.data = element.data;\n            options.angle = 0;\n            options.pivotX = 0;\n            options.pivotY = 0;\n            options.x = 0;\n            options.y = 0;\n            options.height = 0;\n            options.width = 1;\n            options.id = randomId();\n            this.diagram.diagramRenderer.drawPath(snapLine, options);\n            this.line.push(line1);\n            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n            line1 = {\n                startPoint: { x: end.x - 8, y: end.y + 1 },\n                endPoint: { x: end.x + 8, y: end.y + 1 },\n                stroke: '#07EDE1',\n                strokeWidth: 1, fill: '#07EDE1', dashArray: '', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n                pivotY: 0, visible: true, opacity: 1, id: this.getAdornerLayerSvg().id + 'spacing'\n            };\n            this.line.push(line1);\n            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n        }\n        else {\n            d = 'M' + (start.x + 5) + ' ' + (start.y + 5) + ' L' + start.x + ' ' + start.y +\n                ' L' + (start.x + 5) + ' ' + (start.y - 5) + 'z' + 'M' + (end.x - 5) + ' ' +\n                (end.y - 5) + ' L' + end.x + ' ' + end.y +\n                ' L' + (end.x - 5) + ' ' + (end.y + 5) + 'z';\n            element.data = d;\n            options.data = d;\n            options.angle = 0;\n            options.pivotX = 0;\n            options.pivotY = 0;\n            options.x = 0;\n            options.y = 0;\n            options.height = 0;\n            options.width = 1;\n            options.id = randomId();\n            this.diagram.diagramRenderer.drawPath(snapLine, options);\n            line1 = {\n                visible: true, opacity: 1, id: randomId(),\n                startPoint: { x: start.x - 1, y: start.y - 8 },\n                endPoint: { x: start.x - 1, y: start.y + 8 },\n                stroke: '#07EDE1',\n                strokeWidth: 1, fill: '#07EDE1', dashArray: '0', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n                pivotY: 0\n            };\n            this.line.push(line1);\n            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n            line1 = {\n                width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n                pivotY: 0, visible: true, opacity: 1, id: randomId(),\n                startPoint: { x: end.x + 1, y: end.y - 8 },\n                endPoint: { x: end.x + 1, y: end.y + 8 },\n                stroke: '#07EDE1',\n                strokeWidth: 1, fill: '#07EDE1', dashArray: '0'\n            };\n            this.line.push(line1);\n            this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n        }\n        line1 = {\n            startPoint: { x: start.x, y: start.y },\n            endPoint: { x: end.x, y: end.y }, stroke: '#07EDE1', strokeWidth: 1, fill: '#07EDE1',\n            dashArray: '0', width: 1, x: 0, y: 0, height: 0, angle: 0, pivotX: 0,\n            pivotY: 0, visible: true, opacity: 1, id: randomId()\n        };\n        this.line.push(line1);\n        this.diagram.diagramRenderer.drawLine(snapLine, this.line.pop());\n    };\n    /**\n     * To Create Snap object with position, initial bounds, and final bounds \\\n     *\n     * @returns {  void }  To Create Snap object with position, initial bounds, and final bounds .\\\n     * @param {Diagram} targetBounds - provide the targetBounds value.\n     * @param {Rect} bounds - provide the angle value.\n     * @param {string} snap - provide the angle value.\n     * @private\n     */\n    Snapping.prototype.createSnapObject = function (targetBounds, bounds, snap) {\n        var snapObject;\n        switch (snap) {\n            case 'left':\n                snapObject = {\n                    start: { x: (targetBounds.x), y: Math.min(targetBounds.y, bounds.y) },\n                    end: { x: (targetBounds.x), y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height) },\n                    offsetX: targetBounds.x - bounds.x, offsetY: 0, type: 'sideAlign'\n                };\n                break;\n            case 'right':\n                snapObject = {\n                    type: 'sideAlign',\n                    start: { x: (targetBounds.x + targetBounds.width), y: Math.min(targetBounds.y, bounds.y) },\n                    offsetX: targetBounds.x + targetBounds.width - bounds.x - bounds.width,\n                    offsetY: 0,\n                    end: {\n                        x: (targetBounds.x + targetBounds.width),\n                        y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n                    }\n                };\n                break;\n            case 'top':\n                snapObject = {\n                    offsetY: targetBounds.y - bounds.y, offsetX: 0, type: 'sideAlign',\n                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y },\n                    end: { x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)), y: targetBounds.y }\n                };\n                break;\n            case 'bottom':\n                snapObject = {\n                    type: 'sideAlign', offsetY: targetBounds.y + targetBounds.height - bounds.y - bounds.height, offsetX: 0,\n                    end: {\n                        x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)),\n                        y: targetBounds.y + targetBounds.height\n                    },\n                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y + targetBounds.height }\n                };\n                break;\n            case 'topBottom':\n                snapObject = {\n                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y + targetBounds.height },\n                    end: {\n                        x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)),\n                        y: targetBounds.y + targetBounds.height\n                    },\n                    offsetY: targetBounds.y + targetBounds.height - bounds.y, offsetX: 0, type: 'sideAlign'\n                };\n                break;\n            case 'bottomTop':\n                snapObject = {\n                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y },\n                    end: { x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)), y: targetBounds.y },\n                    offsetY: targetBounds.y - bounds.y - bounds.height, offsetX: 0, type: 'sideAlign'\n                };\n                break;\n            case 'leftRight':\n                snapObject = {\n                    start: { x: (targetBounds.x + targetBounds.width), y: Math.min(targetBounds.y, bounds.y) },\n                    end: {\n                        x: (targetBounds.x + targetBounds.width),\n                        y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n                    },\n                    offsetX: targetBounds.x + targetBounds.width - bounds.x, offsetY: 0, type: 'sideAlign'\n                };\n                break;\n            case 'rightLeft':\n                snapObject = {\n                    start: { x: (targetBounds.x), y: (Math.min(targetBounds.y, bounds.y)) },\n                    end: { x: (targetBounds.x), y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height) },\n                    offsetX: targetBounds.x - bounds.x - bounds.width, offsetY: 0, type: 'sideAlign'\n                };\n                break;\n            case 'centerX':\n                snapObject = {\n                    start: { x: (targetBounds.x + targetBounds.width / 2), y: (Math.min(targetBounds.y, bounds.y)) },\n                    end: {\n                        x: (targetBounds.x + targetBounds.width / 2),\n                        y: Math.max(targetBounds.y + targetBounds.height, bounds.y + bounds.height)\n                    },\n                    offsetX: targetBounds.x + targetBounds.width / 2 - (bounds.x + bounds.width / 2), offsetY: 0, type: 'centerAlign'\n                };\n                break;\n            case 'centerY':\n                snapObject = {\n                    start: { x: (Math.min(targetBounds.x, bounds.x)), y: targetBounds.y + targetBounds.height / 2 },\n                    end: {\n                        x: (Math.max(targetBounds.x + targetBounds.width, bounds.x + bounds.width)),\n                        y: targetBounds.y + targetBounds.height / 2\n                    },\n                    offsetY: targetBounds.y + targetBounds.height / 2 - (bounds.y + bounds.height / 2), offsetX: 0, type: 'centerAlign'\n                };\n                break;\n        }\n        return snapObject;\n    };\n    /**\n     *  Calculate the snap angle \\\n     *\n     * @returns {  void }  Calculate the snap angle .\\\n     * @param {Diagram} diagram - provide the diagram value.\n     * @param {number} angle - provide the angle value.\n     * @private\n     */\n    Snapping.prototype.snapAngle = function (diagram, angle) {\n        var snapSettings = this.diagram.snapSettings;\n        var snapAngle = snapSettings.snapAngle;\n        var width = angle % (snapAngle || 0);\n        if (width >= (snapAngle / 2)) {\n            return angle + snapAngle - width;\n        }\n        else {\n            return angle - width;\n        }\n    };\n    //Check whether the node to be snapped or not.\n    Snapping.prototype.canConsider = function (nameTable, selectedObject, target) {\n        var consider = false;\n        if (this.diagram.selectedItems.nodes.length && this.diagram.selectedItems.nodes[0].id === target.id) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    //Find the total number of nodes in diagram using SpatialSearch\n    Snapping.prototype.findNodes = function (spatialSearch, node, child, viewPort, nodesInView) {\n        var nodes = [];\n        var nd;\n        var bounds;\n        var quads = spatialSearch.findQuads(nodesInView ? viewPort : child);\n        for (var i = 0; i < quads.length; i++) {\n            var quad = quads[i];\n            if (quad.objects.length > 0) {\n                for (var j = 0; j < quad.objects.length; j++) {\n                    nd = quad.objects[j];\n                    if (!(this.diagram.nameTable[nd.id] instanceof Connector) && nd.visible\n                        && !(this.diagram.nameTable[nd.id].shape.type === 'SwimLane') && !(this.diagram.nameTable[nd.id].isLane) &&\n                        !(this.diagram.nameTable[nd.id].isPhase) && !(this.diagram.nameTable[nd.id].isHeader) && nd.id != 'helper') {\n                        bounds = getBounds(nd);\n                        if (nodes.indexOf(nd) === -1 && this.intersectsRect(child, bounds)) {\n                            nodes.push(nd);\n                        }\n                        if (nodesInView && nodesInView.indexOf(nd) && this.intersectsRect(viewPort, bounds)) {\n                            nodesInView.push(nd);\n                        }\n                    }\n                }\n            }\n        }\n        return nodes;\n    };\n    Snapping.prototype.intersectsRect = function (child, bounds) {\n        return ((((bounds.x < (child.x + child.width)) && (child.x < (bounds.x + bounds.width)))\n            && (bounds.y < (child.y + child.height))) && (child.y < (bounds.y + bounds.height)));\n    };\n    Snapping.prototype.getAdornerLayerSvg = function () {\n        return this.diagram.diagramRenderer.adornerSvgLayer;\n    };\n    /**\n     *  To remove grid lines on mouse move and mouse up \\\n     *\n     * @returns {  void }  To remove grid lines on mouse move and mouse up .\\\n     * @param {Diagram} diagram - provide the source value.\n     * @private\n     */\n    Snapping.prototype.removeGuidelines = function (diagram) {\n        var selectionRect = this.getAdornerLayerSvg().getElementById('_SnappingLines');\n        var line = this.getAdornerLayerSvg().getElementById('pivotLine');\n        if (selectionRect) {\n            selectionRect.parentNode.removeChild(selectionRect);\n        }\n        if (line) {\n            line.parentNode.removeChild(line);\n        }\n    };\n    //Sort the objects by its distance\n    Snapping.prototype.sortByDistance = function (obj, value, ascending) {\n        var i;\n        var j;\n        var temp;\n        if (ascending) {\n            for (i = 0; i < obj.length; i++) {\n                for (j = i + 1; j < obj.length; j++) {\n                    if (obj[i][value] > obj[j][value]) {\n                        temp = obj[i];\n                        obj[i] = obj[j];\n                        obj[j] = temp;\n                    }\n                }\n            }\n        }\n        else {\n            for (i = 0; i < obj.length; i++) {\n                for (j = i + 1; j < obj.length; j++) {\n                    if (obj[i][value] < obj[j][value]) {\n                        temp = obj[i];\n                        obj[i] = obj[j];\n                        obj[j] = temp;\n                    }\n                }\n            }\n        }\n    };\n    //To find nodes that are equally placed at left of the selected node\n    Snapping.prototype.findEquallySpacedNodesAtLeft = function (objectsAtLeft, equalDistance, top, equallySpaced) {\n        var prevBounds;\n        var targetBounds;\n        var dist;\n        var i;\n        for (i = 1; i < objectsAtLeft.length; i++) {\n            prevBounds = ((objectsAtLeft[i - 1].obj).bounds);\n            targetBounds = ((objectsAtLeft[i].obj).bounds);\n            dist = prevBounds.x - targetBounds.x - targetBounds.width;\n            if (Math.abs(dist - equalDistance) <= 1) {\n                equallySpaced[equallySpaced.length] = objectsAtLeft[i];\n                if (targetBounds.y < top) {\n                    top = targetBounds.y;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        return top;\n    };\n    //To find nodes that are equally placed at right of the selected node\n    Snapping.prototype.findEquallySpacedNodesAtRight = function (objectsAtRight, equalDistance, top, equallySpaced, snapObjDistance) {\n        var actualDistance = objectsAtRight[0].distance;\n        var target;\n        var targetBounds;\n        var prevBounds;\n        var dist;\n        if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {\n            for (var i = 0; i < objectsAtRight.length - 1; i++) {\n                target = objectsAtRight[i].obj;\n                targetBounds = ((objectsAtRight[i + 1].obj).bounds);\n                prevBounds = (target.bounds);\n                dist = targetBounds.x - prevBounds.x - prevBounds.width;\n                if (Math.abs(dist - equalDistance) <= 1) {\n                    equallySpaced[equallySpaced.length] = objectsAtRight[i + 1];\n                    if (prevBounds.y < top) {\n                        top = prevBounds.y;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return top;\n    };\n    Snapping.prototype.findEquallySpacedNodesAtTop = function (objectsAtTop, equalDistance, right, equallySpaced) {\n        var prevBounds;\n        var targetBounds;\n        var dist;\n        for (var i = 1; i < objectsAtTop.length; i++) {\n            prevBounds = ((objectsAtTop[i - 1].obj).bounds);\n            targetBounds = ((objectsAtTop[i].obj).bounds);\n            dist = prevBounds.y - targetBounds.y - targetBounds.height;\n            if (Math.abs(dist - equalDistance) <= 1) {\n                equallySpaced[equallySpaced.length] = objectsAtTop[i];\n                if (targetBounds.x + targetBounds.width > right) {\n                    right = targetBounds.x + targetBounds.width;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        return right;\n    };\n    //To find nodes that are equally placed at bottom of the selected node\n    Snapping.prototype.findEquallySpacedNodesAtBottom = function (objectsAtBottom, equalDistance, right, equallySpaced, snapObjDistance) {\n        var actualDistance = objectsAtBottom[0].distance;\n        var target;\n        var targetBounds;\n        var prevBounds;\n        var dist;\n        if (Math.abs(equalDistance - actualDistance) <= snapObjDistance) {\n            for (var i = 0; i < objectsAtBottom.length - 1; i++) {\n                target = objectsAtBottom[i].obj;\n                targetBounds = ((objectsAtBottom[i + 1].obj).bounds);\n                prevBounds = (target.bounds);\n                dist = targetBounds.y - prevBounds.y - prevBounds.height;\n                if (Math.abs(dist - equalDistance) <= 1) {\n                    equallySpaced[equallySpaced.length] = objectsAtBottom[i + 1];\n                    if (prevBounds.x + prevBounds.width > right) {\n                        right = prevBounds.x + prevBounds.width;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return right;\n    };\n    /**\n     * To get Adoner layer to draw snapLine\n     *\n     * @private\n     */\n    Snapping.prototype.getLayer = function () {\n        var snapLine;\n        if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) {\n            snapLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            snapLine.setAttribute('id', '_SnappingLines');\n            snapLine.setAttribute('shapeRendering', 'crispEdges');\n            this.getAdornerLayerSvg().appendChild(snapLine);\n        }\n        return snapLine;\n    };\n    /**\n     * Constructor for the snapping module\n     *\n     * @private\n     */\n    // constructor() {\n    //     //constructs the snapping module\n    // }\n    /**\n     *To destroy the ruler\n     *\n     * @returns {void} To destroy the ruler\n     */\n    Snapping.prototype.destroy = function () {\n        /**\n         * Destroys the snapping module\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    Snapping.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'Snapping';\n    };\n    return Snapping;\n}());\nexport { Snapping };\n"]},"metadata":{},"sourceType":"module"}