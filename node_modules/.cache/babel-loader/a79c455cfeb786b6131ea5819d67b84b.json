{"ast":null,"code":"import { Rect } from '../primitives/rect';\nimport { cloneObject } from '../utility/base-util';\n\nvar GraphForceNode =\n/** @class */\nfunction () {\n  function GraphForceNode(gnNode) {\n    /**\n     * @private\n     */\n    this.velocityX = 0;\n    /**\n     * @private\n     */\n\n    this.velocityY = 0;\n    /**\n     * @private\n     */\n\n    this.nodes = [];\n    this.graphNode = gnNode;\n    var nNode = this.graphNode;\n    var bounds = getGraphBounds(nNode);\n    this.location = bounds.center;\n    this.nodes = [];\n\n    if (!gnNode.treeInfo.parents) {\n      gnNode.treeInfo.parents = [];\n    }\n\n    if (!gnNode.treeInfo.children) {\n      gnNode.treeInfo.children = [];\n    }\n\n    this.nodes = gnNode.treeInfo.parents.concat(gnNode.treeInfo.children);\n  }\n  /**\n   * applyChanges method\\\n   *\n   * @returns {  void }    applyChanges method .\\\n   * @private\n   */\n\n\n  GraphForceNode.prototype.applyChanges = function () {\n    this.graphNode.treeInfo.center = this.location;\n  };\n\n  return GraphForceNode;\n}();\n\nexport { GraphForceNode };\n/**\n * SymmetricalLayout\n */\n\nvar SymmetricLayout =\n/** @class */\nfunction () {\n  function SymmetricLayout() {\n    this.cdCOEF = 0.442;\n    this.cfMAXVELOCITY = 50;\n    this.cnMAXITERACTION = 1000;\n    this.cnSPRINGLENGTH = 100;\n    this.mszMaxForceVelocity = {\n      width: this.cfMAXVELOCITY,\n      height: this.cfMAXVELOCITY\n    };\n    /**\n     * @private\n     */\n\n    this.springLength = 0;\n    /**\n     * @private\n     */\n\n    this.springFactor = this.cdCOEF;\n    /**\n     * @private\n     */\n\n    this.maxIteration = this.cnMAXITERACTION;\n    this.springLength = this.cnSPRINGLENGTH;\n  }\n  /**\n   *To destroy the layout\n   *\n   * @returns {void} To destroy the layout\n   */\n\n\n  SymmetricLayout.prototype.destroy = function () {\n    /**\n     * Destroys symmetricLayout\n     */\n  };\n\n  SymmetricLayout.prototype.getModuleName = function () {\n    return 'SymmetricalLayout';\n  };\n\n  SymmetricLayout.prototype.doGraphLayout = function (graphLayoutManager) {\n    var graph = this.selectedNode;\n    graph.treeInfo.Bounds = graphLayoutManager.getModelBounds(graphLayoutManager.nodes);\n    var lstGraphNodes = graph.treeInfo.GraphNodes;\n    var lstNodes = this.convertGraphNodes(lstGraphNodes);\n    var count = lstNodes.length;\n    count = Math.min(this.maxIteration, count * count * count);\n    this.preLayoutNodes(lstNodes, graph.treeInfo.Bounds);\n\n    for (var i = 0, nLenght = count; i < nLenght; i++) {\n      this.makeSymmetricLayout(lstNodes);\n      this.appendForces(lstNodes);\n    }\n\n    this.resetGraphPosition(lstNodes, graph);\n  };\n\n  SymmetricLayout.prototype.preLayoutNodes = function (lstNodes, rcBounds) {\n    var fMaxSize = Math.max(rcBounds ? rcBounds.width : 25, rcBounds ? rcBounds.height : 25);\n    var ptCenter = {\n      x: fMaxSize / 2,\n      y: fMaxSize / 2\n    };\n    var dRotateAngle = 2 * Math.PI / lstNodes.length;\n    var dAngle = dRotateAngle;\n\n    for (var i = 0; i < lstNodes.length; i++) {\n      var gnNode = lstNodes[i];\n      var forceNode = this.getForceNode(gnNode);\n      forceNode.location = {\n        x: ptCenter.x + fMaxSize * Number(Math.cos(dAngle).toFixed(2)),\n        y: ptCenter.y + fMaxSize * Number(Math.sin(dAngle).toFixed(2))\n      };\n      dAngle -= dRotateAngle;\n    }\n  };\n  /**\n   * doLayout method\\\n   *\n   * @returns {  void }    doLayout method .\\\n   * @param {GraphLayoutManager} graphLayoutManager - provide the angle value.\n   * @private\n   */\n\n\n  SymmetricLayout.prototype.doLayout = function (graphLayoutManager) {\n    this.selectedNode = graphLayoutManager.selectedNode;\n    this.doGraphLayout(graphLayoutManager);\n  };\n\n  SymmetricLayout.prototype.makeSymmetricLayout = function (lstNodes) {\n    var forceNode;\n    var force;\n\n    for (var k = 0; k < lstNodes.length; k++) {\n      var gnNode = lstNodes[k];\n      forceNode = this.getForceNode(gnNode);\n      var nodes = forceNode.nodes;\n\n      for (var l = 0; l < nodes.length; l++) {\n        var gnChild = nodes[l];\n\n        if (collectionContains(gnChild.id, lstNodes)) {\n          this.calcNodesForce(forceNode, this.getForceNode(gnChild));\n        }\n      }\n\n      for (var i = 0, length_1 = nodes.length; i < length_1; i++) {\n        if (length_1 < 2) {\n          break;\n        }\n\n        var vtx1 = this.getForceNode(nodes[i]);\n        var vtx2 = i + 1 >= length_1 ? this.getForceNode(nodes[0]) : this.getForceNode(nodes[i + 1]);\n        var angle = 360 / nodes.length / 2 * Math.PI / 180;\n        var normalDistance = 2 * this.springLength * Math.sin(angle);\n        this.calcRelatesForce(vtx1, vtx2, normalDistance);\n      }\n\n      for (var s = 0; s < lstNodes.length; s++) {\n        var gnChild = lstNodes[s];\n\n        if (!collectionContains(gnChild.id, nodes) && gnChild.id !== gnNode.id) {\n          force = this.getForceNode(gnChild);\n          this.updateNeigbour(forceNode, force);\n        }\n      }\n    }\n  };\n\n  SymmetricLayout.prototype.appendForces = function (lstNodes) {\n    var gfnNode = null;\n\n    for (var k = 0; k < lstNodes.length; k++) {\n      var gnNode = lstNodes[k];\n      gfnNode = this.getForceNode(gnNode);\n      var ptPoint = gfnNode.location;\n      ptPoint.x += Math.min(gfnNode.velocityX, this.mszMaxForceVelocity.width);\n      ptPoint.y += Math.min(gfnNode.velocityY, this.mszMaxForceVelocity.height);\n      gfnNode.velocityX = 0;\n      gfnNode.velocityY = 0;\n      gfnNode.location = ptPoint;\n    }\n  };\n\n  SymmetricLayout.prototype.resetGraphPosition = function (lstNodes, graph) {\n    var szMin = {\n      width: Number.MAX_VALUE,\n      height: Number.MAX_VALUE\n    };\n    var gfnNode = null;\n    var gnNode;\n\n    for (var k = 0; k < lstNodes.length; k++) {\n      gnNode = lstNodes[k];\n      gfnNode = this.getForceNode(gnNode);\n      var ptLocation = {\n        x: gfnNode.location.x - gnNode.actualSize.width / 2,\n        y: gfnNode.location.y - gnNode.actualSize.height / 2\n      };\n      szMin.width = Math.min(szMin.width, ptLocation.x);\n      szMin.height = Math.min(szMin.height, ptLocation.y);\n    }\n\n    for (var k = 0; k < lstNodes.length; k++) {\n      gnNode = lstNodes[k];\n      gfnNode = this.getForceNode(gnNode);\n      var ptLocation = gfnNode.location;\n      ptLocation.x -= szMin.width - (graph.treeInfo.location ? graph.treeInfo.location.x : 0);\n      ptLocation.y -= szMin.height - (graph.treeInfo.location ? graph.treeInfo.location.y : 0);\n      gfnNode.location = ptLocation;\n      gfnNode.applyChanges();\n    }\n  };\n\n  SymmetricLayout.prototype.convertGraphNodes = function (lstNodes) {\n    var lstToReturn = [];\n    var keys = Object.keys(lstNodes);\n\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var k = keys_1[_i];\n\n      if (lstNodes[k]) {\n        var gnNode = lstNodes[k];\n        var forceNode = new GraphForceNode(gnNode);\n        gnNode.treeInfo.tag = forceNode;\n        lstToReturn.push(gnNode);\n      }\n    }\n\n    return lstToReturn;\n  };\n  /**\n   * getForceNode method\\\n   *\n   * @returns {  GraphForceNode }    getForceNode method .\\\n   * @param {IGraphObject} gnNode - provide the angle value.\n   * @private\n   */\n\n\n  SymmetricLayout.prototype.getForceNode = function (gnNode) {\n    return gnNode.treeInfo.tag;\n  };\n\n  SymmetricLayout.prototype.updateNeigbour = function (vtSource, vtTarget) {\n    if (vtTarget == null || vtSource == null) {\n      return;\n    }\n\n    var distance = this.pointDistance(vtSource.location, vtTarget.location);\n    var angle = this.lineAngle(vtSource.location, vtTarget.location);\n    var normalDistance = this.springLength * 0.9;\n\n    if (distance < normalDistance) {\n      this.calcForce(distance, normalDistance, angle, vtTarget);\n    }\n  };\n\n  SymmetricLayout.prototype.lineAngle = function (pt1, pt2) {\n    var radians = 0;\n    var vx = pt2.x - pt1.x;\n    var vy = pt2.y - pt1.y;\n\n    if (vx === 0) {\n      if (vy <= 0) {\n        radians = 3.0 * Math.PI / 2.0;\n      } else {\n        radians = Math.PI / 2.0;\n      }\n    } else if (vy === 0) {\n      if (vx < 0) {\n        radians = Math.PI;\n      } else {\n        radians = 0;\n      }\n    } else {\n      radians = Math.atan(vy / vx);\n\n      if (vx < 0 && vy > 0) {\n        radians = Math.PI + radians;\n      } else if (vx < 0 && vy < 0) {\n        radians = Math.PI + radians;\n      } else if (vx > 0 && vy < 0) {\n        radians = 2.0 * Math.PI + radians;\n      }\n    }\n\n    return radians;\n  };\n\n  SymmetricLayout.prototype.pointDistance = function (pt1, pt2) {\n    var d = 0;\n    var dx = pt2.x - pt1.x;\n    var dy = pt2.y - pt1.y;\n    var t = dx * dx + dy * dy;\n\n    if (t > 0) {\n      d = Math.sqrt(t);\n    }\n\n    return d;\n  };\n\n  SymmetricLayout.prototype.calcRelatesForce = function (vtSource, vtTarget, normalDistance) {\n    var distance = this.pointDistance(vtSource.location, vtTarget.location);\n    var angle = this.lineAngle(vtSource.location, vtTarget.location);\n\n    if (distance < normalDistance) {\n      this.calcForce(distance, normalDistance, angle, vtTarget);\n    }\n  };\n  /**\n   * @param nodeCollection\n   * @param connectors\n   * @param symmetricLayout\n   * @param nameTable\n   * @param layout\n   * @param viewPort\n   * @private\n   */\n\n  /**\n   * updateLayout method\\\n   *\n   * @returns {  void }    updateLayout method .\\\n   * @param {IGraphObject[]} nodeCollection - provide the angle value.\n   * @param {IGraphObject[]} connectors - provide the connectors value.\n   * @param {SymmetricLayout} symmetricLayout - provide the symmetricLayout value.\n   * @param {Object} nameTable - provide the nameTable value.\n   * @param {Layout} layout - provide the layout value.\n   * @param {PointModel} viewPort - provide the viewPort value.\n   * @private\n   */\n\n\n  SymmetricLayout.prototype.updateLayout = function (nodeCollection, connectors, symmetricLayout, nameTable, layout, viewPort) {\n    var layoutManager = new GraphLayoutManager();\n    layoutManager.updateLayout(nodeCollection, connectors, symmetricLayout, nameTable, layout, viewPort);\n  };\n\n  SymmetricLayout.prototype.calcNodesForce = function (vtSource, vtTarget) {\n    var distance = this.pointDistance(vtSource.location, vtTarget.location);\n    var angle = this.lineAngle(vtSource.location, vtTarget.location);\n\n    if (distance > this.springLength || distance < this.springLength) {\n      this.calcForce(distance, this.springLength, angle, vtTarget);\n    }\n  };\n\n  SymmetricLayout.prototype.calcForce = function (distance, minDist, angle, vtTarget) {\n    var count = vtTarget.nodes.length;\n    var length = distance - minDist;\n    var factor = this.springFactor / (count * count) * Math.sqrt(count);\n\n    if (length !== 0) {\n      var fVelocity = length * factor;\n      var fOffset = fVelocity;\n      var offsetX = Math.cos(angle) * fOffset;\n      var offsetY = Math.sin(angle) * fOffset;\n      vtTarget.velocityX -= offsetX;\n      vtTarget.velocityY -= offsetY;\n    }\n  };\n\n  return SymmetricLayout;\n}();\n\nexport { SymmetricLayout };\n\nvar GraphLayoutManager =\n/** @class */\nfunction () {\n  function GraphLayoutManager() {\n    this.visitedStack = [];\n    this.cycleEdgesCollection = [];\n    this.graphObjects = [];\n    this.passedNodes = [];\n  }\n  /**\n   * @param nodeCollection\n   * @param connectors\n   * @param symmetricLayout\n   * @param nameTable\n   * @param layout\n   * @param viewPort\n   * @private\n   */\n\n  /**\n   * updateLayout method\\\n   *\n   * @returns {  boolean }    updateLayout method .\\\n   * @param {IGraphObject[]} nodeCollection - provide the nodeCollection value.\n   * @param {IGraphObject[]} connectors - provide the nodeCollection value.\n   * @param {SymmetricLayout} symmetricLayout - provide the nodeCollection value.\n   * @param {Object} nameTable - provide the nodeCollection value.\n   * @param {Layout} layout - provide the nodeCollection value.\n   * @param {PointModel} viewPort - provide the nodeCollection value.\n   * @private\n   */\n\n\n  GraphLayoutManager.prototype.updateLayout = function (nodeCollection, connectors, symmetricLayout, nameTable, layout, viewPort) {\n    this.nameTable = nameTable;\n    this.nodes = nodeCollection;\n    this.connectors = connectors;\n    var selectionList = nodeCollection;\n\n    if (selectionList.length > 0) {\n      this.mhelperSelectedNode = cloneObject(selectionList[0]);\n    }\n\n    for (var _i = 0, nodeCollection_1 = nodeCollection; _i < nodeCollection_1.length; _i++) {\n      var node = nodeCollection_1[_i];\n      var nodeGraphObject = node;\n      nodeGraphObject.treeInfo = {};\n      nodeGraphObject.treeInfo.graphType = 'Node';\n      this.graphObjects.push(nodeGraphObject);\n    }\n\n    for (var _a = 0, connectors_1 = connectors; _a < connectors_1.length; _a++) {\n      var connector = connectors_1[_a];\n      var connectorGraphObject = connector;\n      connectorGraphObject.treeInfo = {};\n      connectorGraphObject.treeInfo.graphType = 'Connector';\n      this.graphObjects.push(connectorGraphObject);\n    }\n\n    this.updateLayout1(this.graphObjects, symmetricLayout);\n    var modelBounds = this.getModelBounds(selectionList);\n\n    for (var i = 0; i < selectionList.length; i++) {\n      var node = selectionList[i];\n      var trnsX = (viewPort.x - modelBounds.width) / 2;\n      var margin = layout.margin || {}; //let marginX: number; let marginY: number;\n\n      margin.left = margin.left || 0;\n      margin.right = margin.right || 0;\n      margin.top = margin.top || 0;\n      margin.bottom = margin.bottom || 0;\n\n      if (layout.margin.left) {\n        margin.left = layout.margin.left;\n      }\n\n      if (layout.margin.top) {\n        margin.top = layout.margin.top;\n      }\n\n      var dx = node.treeInfo.tag.location.x - (node.offsetX - node.actualSize.width / 2) - modelBounds.x + trnsX + margin.left;\n      var dy = node.treeInfo.tag.location.y - (node.offsetY - node.actualSize.height / 2) - modelBounds.y + margin.top;\n      node.offsetX += dx;\n      node.offsetY += dy;\n      delete node.treeInfo;\n    }\n\n    return true;\n  };\n  /**\n   * getModelBounds method\\\n   *\n   * @returns {  Rect }    getModelBounds method .\\\n   * @param {IGraphObject[]} lNodes - provide the angle value.\n   * @private\n   */\n\n\n  GraphLayoutManager.prototype.getModelBounds = function (lNodes) {\n    lNodes = lNodes.slice();\n    var rect = null;\n    var rect1 = null;\n    var node;\n\n    for (var i = 0; i < lNodes.length; i++) {\n      node = lNodes[i];\n      var bounds = getGraphBounds(node);\n      rect = new Rect(node.treeInfo.tag ? node.treeInfo.tag.location.x : bounds.x, node.treeInfo.tag ? node.treeInfo.tag.location.y : bounds.y, node.actualSize.width, node.actualSize.height);\n\n      if (rect1) {\n        rect1 = rect1.uniteRect(rect);\n      } else {\n        rect1 = rect;\n      }\n    }\n\n    return rect1;\n  };\n\n  GraphLayoutManager.prototype.updateLayout1 = function (nodesToLayout, symmetricLayout) {\n    this.detectCyclesInGraph(nodesToLayout);\n    var nodesCount = nodesToLayout.length;\n\n    if (nodesCount > 0) {\n      var cycleConnColln = [];\n      var nodes = [];\n      var nodeSymbols = [];\n\n      for (var s = 0; s < nodesToLayout.length; s++) {\n        var nd = nodesToLayout[s];\n\n        if (nd.treeInfo.isCycleEdge === undefined) {\n          nd.treeInfo.isCycleEdge = false;\n        }\n\n        if (nd.treeInfo.graphType === 'Connector' && !nd.treeInfo.isCycleEdge) {\n          nodes.push(nd);\n        } else if (nd.treeInfo.graphType === 'Connector') {\n          cycleConnColln.push(nd);\n        } else {\n          nodeSymbols.push(nd);\n        }\n      }\n\n      nodes = nodes.concat(nodeSymbols);\n      nodes = cycleConnColln.concat(nodes);\n\n      while (nodesCount > this.dictionaryLength(this.passedNodes)) {\n        this.getNodesToPosition(nodes);\n\n        if (this.selectedNode == null) {\n          continue;\n        }\n\n        symmetricLayout.doLayout(this);\n        this.selectedNode = null;\n        this.visitedStack = [];\n\n        for (var _i = 0, _a = this.cycleEdgesCollection; _i < _a.length; _i++) {\n          var connector = _a[_i];\n          connector.treeInfo.isCycleEdge = false;\n        }\n      }\n\n      this.passedNodes = null;\n      this.selectedNode = null;\n    }\n\n    return false;\n  };\n\n  GraphLayoutManager.prototype.getNodesToPosition = function (nodes) {\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n\n      if (!collectionContains(node.id, this.passedNodes)) {\n        if (node) {\n          this.selectNodes(node);\n        }\n\n        break;\n      }\n    }\n  };\n\n  GraphLayoutManager.prototype.selectNodes = function (node) {\n    var nodeGraph = node;\n\n    if (node.treeInfo.graphType === 'Connector') {\n      this.exploreGraphEdge(node);\n    } else if (nodeGraph != null) {\n      if (this.addNode(node, 'passed')) {\n        this.addNode(node, 'selected');\n\n        if (this.isConnectedToAnotherNode(nodeGraph)) {\n          this.selectedNode = {\n            treeInfo: {}\n          };\n          this.selectedNode.treeInfo.LeftMargin = 10;\n          this.selectedNode.treeInfo.TopMargin = 10;\n          this.selectConnectedNodes(nodeGraph);\n        } else {\n          this.selectedNode = node;\n        }\n      }\n    }\n  };\n\n  GraphLayoutManager.prototype.selectConnectedNodes = function (nodeGraph) {\n    var graph = this.selectedNode;\n\n    if (!graph.treeInfo.GraphNodes) {\n      graph.treeInfo.GraphNodes = {};\n    }\n\n    var node = nodeGraph;\n\n    if (node != null && this.addNode(node, 'passed')) {\n      var nodeName = node.id;\n\n      if (!this.dictionaryContains(graph.treeInfo.GraphNodes, node)) {\n        var gnNode = this.addGraphNode(node);\n        this.getConnectedRelatives(gnNode);\n        this.exploreRelatives(nodeGraph);\n      } else {\n        var graphNode = graph.treeInfo.GraphNodes[nodeName];\n\n        if (graphNode.treeInfo.Added) {\n          graphNode.treeInfo.Added = false;\n          this.getConnectedRelatives(graphNode);\n          this.exploreRelatives(nodeGraph);\n        }\n      }\n    }\n  };\n\n  GraphLayoutManager.prototype.exploreRelatives = function (nodeGraph) {\n    this.exploreRelatives1(nodeGraph, 'Parents');\n    this.exploreRelatives1(nodeGraph, 'Children');\n  };\n\n  GraphLayoutManager.prototype.exploreRelatives1 = function (nodeGraph, relativesToExplore) {\n    var edges = [];\n\n    if (relativesToExplore === 'Parents') {\n      edges = nodeGraph.inEdges;\n    } else if (relativesToExplore === 'Children') {\n      edges = nodeGraph.outEdges;\n    }\n\n    for (var i = 0; i < edges.length; i++) {\n      var edge = this.nameTable[edges[i]];\n\n      if (this.addNode(edge, 'passed')) {\n        var fromNode = this.nameTable[edge.sourceID];\n        var toNode = this.nameTable[edge.targetID];\n\n        if (relativesToExplore === 'Parents' && fromNode != null && collectionContains(fromNode.id, this.nodes)) {\n          this.selectConnectedNodes(this.nameTable[edge.sourceID]);\n        } else if (relativesToExplore === 'Children' && toNode != null && collectionContains(toNode.id, this.nodes)) {\n          this.selectConnectedNodes(this.nameTable[edge.targetID]);\n        }\n      }\n    }\n  };\n\n  GraphLayoutManager.prototype.getConnectedRelatives = function (graphNode) {\n    this.getConnectedParents(graphNode);\n    this.getConnectedChildren(graphNode);\n  };\n\n  GraphLayoutManager.prototype.dictionaryContains = function (obj, keyObj) {\n    var keys = Object.keys(obj);\n\n    for (var i = 0; i < keys.length; i++) {\n      if (keys[i] === keyObj.id) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  GraphLayoutManager.prototype.dictionaryLength = function (obj) {\n    var keys = Object.keys(obj);\n    return keys.length;\n  };\n\n  GraphLayoutManager.prototype.getConnectedChildren = function (graphNode) {\n    var graph = this.selectedNode;\n    var nodeGraph = graphNode;\n\n    for (var s = 0; s < nodeGraph.outEdges.length; s++) {\n      var edge = this.nameTable[nodeGraph.outEdges[s]];\n\n      if (!edge.treeInfo.isCycleEdge) {\n        var node = this.nameTable[edge.targetID];\n\n        if (collectionContains(node.id, this.nodes) && node != null && node.visible) {\n          var gnNodeChildren = void 0;\n\n          if (!this.dictionaryContains(graph.treeInfo.GraphNodes, node)) {\n            gnNodeChildren = this.addGraphNode(node);\n            gnNodeChildren.treeInfo.Added = true;\n          } else {\n            gnNodeChildren = graph.treeInfo.GraphNodes[node.id];\n          }\n\n          if (!graphNode.treeInfo.children) {\n            graphNode.treeInfo.children = [];\n          }\n\n          if (!gnNodeChildren.treeInfo.parents) {\n            gnNodeChildren.treeInfo.parents = [];\n          }\n\n          this.setNode(gnNodeChildren.treeInfo.parents, graphNode);\n\n          if (this.findNode(graphNode.treeInfo.children, gnNodeChildren.id) < 0) {\n            graphNode.treeInfo.children.push(gnNodeChildren);\n          }\n        }\n      }\n    }\n  };\n\n  GraphLayoutManager.prototype.getConnectedParents = function (graphNode) {\n    var graph = this.selectedNode;\n    var nodeGraph = graphNode;\n\n    for (var s = 0; s < nodeGraph.inEdges.length; s++) {\n      var edge = this.nameTable[nodeGraph.inEdges[s]];\n\n      if (!edge.treeInfo.isCycleEdge) {\n        var node = this.nameTable[edge.sourceID];\n\n        if (collectionContains(node.id, this.nodes) && node != null && node.visible) {\n          var gnNode = void 0;\n\n          if (!this.dictionaryContains(graph.treeInfo.GraphNodes, node)) {\n            gnNode = this.addGraphNode(node);\n            gnNode.treeInfo.Added = true;\n          } else {\n            gnNode = graph.treeInfo.GraphNodes[node.id];\n          }\n\n          if (!graphNode.treeInfo.parents) {\n            graphNode.treeInfo.parents = [];\n          }\n\n          if (!gnNode.treeInfo.children) {\n            gnNode.treeInfo.children = [];\n          }\n\n          this.setNode(gnNode.treeInfo.children, graphNode);\n\n          if (this.findNode(graphNode.treeInfo.parents, gnNode.id) < 0) {\n            graphNode.treeInfo.parents.push(gnNode);\n          }\n        }\n      }\n    }\n  };\n\n  GraphLayoutManager.prototype.setNode = function (list, node) {\n    var nIndex = this.findNode(list, node.id);\n\n    if (nIndex >= 0 && nIndex < list.length) {\n      list[nIndex] = node;\n    } else {\n      list.push(node);\n    }\n  };\n\n  GraphLayoutManager.prototype.findNode = function (list, fullName) {\n    var nIndex = -1;\n\n    if (list != null && fullName !== '') {\n      for (var i = 0, nLength = list.length; i < nLength; i++) {\n        var gnNode = list[i];\n\n        if (typeof gnNode === 'string' && gnNode === fullName) {\n          nIndex = i;\n          break;\n        } else if (gnNode != null && gnNode.id === fullName) {\n          nIndex = i;\n          break;\n        }\n      }\n    }\n\n    return nIndex;\n  };\n\n  GraphLayoutManager.prototype.addGraphNode = function (node) {\n    var graph = this.selectedNode;\n\n    if (!graph.treeInfo.GraphNodes) {\n      graph.treeInfo.GraphNodes = {};\n    }\n\n    var gnNode = node;\n\n    if (graph != null) {\n      graph.treeInfo.GraphNodes[gnNode.id] = gnNode;\n      var nodeHelper = this.mhelperSelectedNode;\n\n      if (nodeHelper != null && node.id === nodeHelper.id) {\n        this.mhelperSelectedNode = gnNode;\n      }\n    }\n\n    return gnNode;\n  };\n\n  GraphLayoutManager.prototype.isConnectedToAnotherNode = function (gnNode) {\n    var bFoundConnectedNode = false;\n    var edges = gnNode.inEdges.concat(gnNode.outEdges);\n\n    if (edges.length > 0) {\n      if (gnNode.inEdges != null && gnNode.inEdges.length > 0) {\n        bFoundConnectedNode = this.searchEdgeCollection(gnNode.inEdges, 'FromNode');\n      }\n\n      if (!bFoundConnectedNode && gnNode.outEdges != null && gnNode.outEdges.length > 0) {\n        bFoundConnectedNode = this.searchEdgeCollection(gnNode.outEdges, 'ToNode');\n      }\n    }\n\n    return bFoundConnectedNode;\n  };\n\n  GraphLayoutManager.prototype.searchEdgeCollection = function (edgesToSearchThrough, connectionDirection) {\n    var bFoundConnectedNode = false;\n\n    for (var i = 0; i < edgesToSearchThrough.length - 1; i++) {\n      var edge = this.nameTable[edgesToSearchThrough[i]];\n\n      if (!this.addNode(edge, 'passed')) {\n        continue;\n      }\n\n      if (!edge.treeInfo.isCycleEdge && (connectionDirection === 'FromNode' && this.nameTable[edge.sourceID] != null || connectionDirection === 'ToNode' && this.nameTable[edge.targetID] != null)) {\n        bFoundConnectedNode = true;\n        break;\n      }\n    }\n\n    return bFoundConnectedNode;\n  };\n\n  GraphLayoutManager.prototype.exploreGraphEdge = function (node) {\n    var nodeLink = node;\n\n    if (nodeLink != null && !nodeLink.treeInfo.isCycleEdge && this.addNode(node, 'passed')) {\n      this.addNode(node, 'selected');\n      var fromNode = this.nameTable[nodeLink.sourceID];\n      var toNode = this.nameTable[nodeLink.targetID];\n\n      if (fromNode != null) {\n        this.selectNodes(fromNode);\n      } else if (toNode != null) {\n        this.selectNodes(toNode);\n      } else {\n        this.selectedNode = node;\n      }\n    }\n  };\n\n  GraphLayoutManager.prototype.addNode = function (nodeToAdd, collectionToAdd) {\n    var bResult = true;\n    var node = nodeToAdd;\n\n    if (collectionToAdd === 'passed' || !node.visible) {\n      if (!this.dictionaryContains(this.passedNodes, node)) {\n        this.passedNodes[node.id] = node;\n      }\n    }\n\n    if (!node.visible) {\n      return false;\n    }\n\n    return bResult;\n  };\n\n  GraphLayoutManager.prototype.detectCyclesInGraph = function (nodes) {\n    var vertex = [];\n    var currentStack = [];\n\n    for (var k = 0; k < nodes.length; k++) {\n      if (!(nodes[k].treeInfo.graphType === 'Connector')) {\n        vertex.push(nodes[k]);\n      }\n    }\n\n    if (vertex.length > 0) {\n      currentStack.push(vertex[0]);\n      this.visitedStack.push(vertex[0]);\n\n      while (currentStack.length > 0) {\n        var top_1 = currentStack[currentStack.length - 1];\n        var childNodes = this.getUnVisitedChildNodes(top_1);\n\n        if (childNodes.length > 0) {\n          var child = childNodes[0];\n          var currentEdge = childNodes[childNodes.length - 1];\n\n          if (collectionContains(child.id, this.visitedStack)) {\n            currentEdge.treeInfo.isCycleEdge = true;\n            this.cycleEdgesCollection.push(currentEdge);\n          } else {\n            currentStack.push(child);\n            this.visitedStack.splice(0, 0, child);\n          }\n        } else {\n          currentStack.pop();\n        }\n      }\n    }\n  };\n\n  GraphLayoutManager.prototype.getUnVisitedChildNodes = function (top) {\n    var childNodes = [];\n\n    if (top.outEdges.length > 0) {\n      for (var i = 0; i < top.outEdges.length; i++) {\n        var con = this.nameTable[top.outEdges[i]];\n\n        if (!collectionContains(con.id, this.visitedStack)) {\n          var toNode = this.nameTable[con.targetID];\n\n          if (toNode != null) {\n            childNodes.push(toNode);\n          }\n\n          childNodes.push(con);\n          this.visitedStack.splice(0, 0, con);\n          return childNodes;\n        }\n      }\n\n      return childNodes;\n    }\n\n    return childNodes;\n  };\n\n  return GraphLayoutManager;\n}();\n\nexport { GraphLayoutManager };\n/**\n * getGraphBounds method\\\n *\n * @returns {  void }    getGraphBounds method .\\\n * @param {IGraphObject} node - provide the angle value.\n * @private\n */\n\nfunction getGraphBounds(node) {\n  var x = node.offsetX - node.actualSize.width * node.pivot.x;\n  var y = node.offsetY - node.actualSize.height * node.pivot.y;\n  return new Rect(x, y, node.actualSize.width, node.actualSize.height);\n}\n/**\n * @param id\n * @param coll\n */\n\n/**\n * collectionContains method\\\n *\n * @returns {  boolean }    collectionContains method .\\\n * @param {string} id - provide the id value.\n * @param {IGraphObject[]} coll - provide the id value.\n * @private\n */\n\n\nfunction collectionContains(id, coll) {\n  for (var i = 0; i < coll.length; i++) {\n    if (coll[i].id === id) {\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/symmetrical-layout.js"],"names":["Rect","cloneObject","GraphForceNode","gnNode","velocityX","velocityY","nodes","graphNode","nNode","bounds","getGraphBounds","location","center","treeInfo","parents","children","concat","prototype","applyChanges","SymmetricLayout","cdCOEF","cfMAXVELOCITY","cnMAXITERACTION","cnSPRINGLENGTH","mszMaxForceVelocity","width","height","springLength","springFactor","maxIteration","destroy","getModuleName","doGraphLayout","graphLayoutManager","graph","selectedNode","Bounds","getModelBounds","lstGraphNodes","GraphNodes","lstNodes","convertGraphNodes","count","length","Math","min","preLayoutNodes","i","nLenght","makeSymmetricLayout","appendForces","resetGraphPosition","rcBounds","fMaxSize","max","ptCenter","x","y","dRotateAngle","PI","dAngle","forceNode","getForceNode","Number","cos","toFixed","sin","doLayout","force","k","l","gnChild","collectionContains","id","calcNodesForce","length_1","vtx1","vtx2","angle","normalDistance","calcRelatesForce","s","updateNeigbour","gfnNode","ptPoint","szMin","MAX_VALUE","ptLocation","actualSize","lstToReturn","keys","Object","_i","keys_1","tag","push","vtSource","vtTarget","distance","pointDistance","lineAngle","calcForce","pt1","pt2","radians","vx","vy","atan","d","dx","dy","t","sqrt","updateLayout","nodeCollection","connectors","symmetricLayout","nameTable","layout","viewPort","layoutManager","GraphLayoutManager","minDist","factor","fVelocity","fOffset","offsetX","offsetY","visitedStack","cycleEdgesCollection","graphObjects","passedNodes","selectionList","mhelperSelectedNode","nodeCollection_1","node","nodeGraphObject","graphType","_a","connectors_1","connector","connectorGraphObject","updateLayout1","modelBounds","trnsX","margin","left","right","top","bottom","lNodes","slice","rect","rect1","uniteRect","nodesToLayout","detectCyclesInGraph","nodesCount","cycleConnColln","nodeSymbols","nd","isCycleEdge","undefined","dictionaryLength","getNodesToPosition","selectNodes","nodeGraph","exploreGraphEdge","addNode","isConnectedToAnotherNode","LeftMargin","TopMargin","selectConnectedNodes","nodeName","dictionaryContains","addGraphNode","getConnectedRelatives","exploreRelatives","Added","exploreRelatives1","relativesToExplore","edges","inEdges","outEdges","edge","fromNode","sourceID","toNode","targetID","getConnectedParents","getConnectedChildren","obj","keyObj","visible","gnNodeChildren","setNode","findNode","list","nIndex","fullName","nLength","nodeHelper","bFoundConnectedNode","searchEdgeCollection","edgesToSearchThrough","connectionDirection","nodeLink","nodeToAdd","collectionToAdd","bResult","vertex","currentStack","top_1","childNodes","getUnVisitedChildNodes","child","currentEdge","splice","pop","con","pivot","coll"],"mappings":"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","sourcesContent":["import { Rect } from '../primitives/rect';\nimport { cloneObject } from '../utility/base-util';\nvar GraphForceNode = /** @class */ (function () {\n    function GraphForceNode(gnNode) {\n        /**\n         * @private\n         */\n        this.velocityX = 0;\n        /**\n         * @private\n         */\n        this.velocityY = 0;\n        /**\n         * @private\n         */\n        this.nodes = [];\n        this.graphNode = gnNode;\n        var nNode = this.graphNode;\n        var bounds = getGraphBounds(nNode);\n        this.location = bounds.center;\n        this.nodes = [];\n        if (!gnNode.treeInfo.parents) {\n            gnNode.treeInfo.parents = [];\n        }\n        if (!gnNode.treeInfo.children) {\n            gnNode.treeInfo.children = [];\n        }\n        this.nodes = (gnNode.treeInfo.parents).concat(gnNode.treeInfo.children);\n    }\n    /**\n     * applyChanges method\\\n     *\n     * @returns {  void }    applyChanges method .\\\n     * @private\n     */\n    GraphForceNode.prototype.applyChanges = function () {\n        this.graphNode.treeInfo.center = this.location;\n    };\n    return GraphForceNode;\n}());\nexport { GraphForceNode };\n/**\n * SymmetricalLayout\n */\nvar SymmetricLayout = /** @class */ (function () {\n    function SymmetricLayout() {\n        this.cdCOEF = 0.442;\n        this.cfMAXVELOCITY = 50;\n        this.cnMAXITERACTION = 1000;\n        this.cnSPRINGLENGTH = 100;\n        this.mszMaxForceVelocity = { width: this.cfMAXVELOCITY, height: this.cfMAXVELOCITY };\n        /**\n         * @private\n         */\n        this.springLength = 0;\n        /**\n         * @private\n         */\n        this.springFactor = this.cdCOEF;\n        /**\n         * @private\n         */\n        this.maxIteration = this.cnMAXITERACTION;\n        this.springLength = this.cnSPRINGLENGTH;\n    }\n    /**\n     *To destroy the layout\n     *\n     * @returns {void} To destroy the layout\n     */\n    SymmetricLayout.prototype.destroy = function () {\n        /**\n         * Destroys symmetricLayout\n         */\n    };\n    SymmetricLayout.prototype.getModuleName = function () {\n        return 'SymmetricalLayout';\n    };\n    SymmetricLayout.prototype.doGraphLayout = function (graphLayoutManager) {\n        var graph = this.selectedNode;\n        graph.treeInfo.Bounds = graphLayoutManager.getModelBounds(graphLayoutManager.nodes);\n        var lstGraphNodes = graph.treeInfo.GraphNodes;\n        var lstNodes = this.convertGraphNodes(lstGraphNodes);\n        var count = lstNodes.length;\n        count = Math.min(this.maxIteration, count * count * count);\n        this.preLayoutNodes(lstNodes, graph.treeInfo.Bounds);\n        for (var i = 0, nLenght = count; i < nLenght; i++) {\n            this.makeSymmetricLayout(lstNodes);\n            this.appendForces(lstNodes);\n        }\n        this.resetGraphPosition(lstNodes, graph);\n    };\n    SymmetricLayout.prototype.preLayoutNodes = function (lstNodes, rcBounds) {\n        var fMaxSize = Math.max(rcBounds ? rcBounds.width : 25, rcBounds ? rcBounds.height : 25);\n        var ptCenter = { x: fMaxSize / 2, y: fMaxSize / 2 };\n        var dRotateAngle = 2 * Math.PI / lstNodes.length;\n        var dAngle = dRotateAngle;\n        for (var i = 0; i < lstNodes.length; i++) {\n            var gnNode = lstNodes[i];\n            var forceNode = this.getForceNode(gnNode);\n            forceNode.location = {\n                x: ptCenter.x + fMaxSize * Number((Math.cos(dAngle)).toFixed(2)),\n                y: ptCenter.y + fMaxSize * Number(Math.sin(dAngle).toFixed(2))\n            };\n            dAngle -= dRotateAngle;\n        }\n    };\n    /**\n     * doLayout method\\\n     *\n     * @returns {  void }    doLayout method .\\\n     * @param {GraphLayoutManager} graphLayoutManager - provide the angle value.\n     * @private\n     */\n    SymmetricLayout.prototype.doLayout = function (graphLayoutManager) {\n        this.selectedNode = graphLayoutManager.selectedNode;\n        this.doGraphLayout(graphLayoutManager);\n    };\n    SymmetricLayout.prototype.makeSymmetricLayout = function (lstNodes) {\n        var forceNode;\n        var force;\n        for (var k = 0; k < lstNodes.length; k++) {\n            var gnNode = lstNodes[k];\n            forceNode = this.getForceNode(gnNode);\n            var nodes = forceNode.nodes;\n            for (var l = 0; l < nodes.length; l++) {\n                var gnChild = nodes[l];\n                if (collectionContains(gnChild.id, lstNodes)) {\n                    this.calcNodesForce(forceNode, this.getForceNode(gnChild));\n                }\n            }\n            for (var i = 0, length_1 = nodes.length; i < length_1; i++) {\n                if (length_1 < 2) {\n                    break;\n                }\n                var vtx1 = this.getForceNode(nodes[i]);\n                var vtx2 = (i + 1 >= length_1) ? this.getForceNode(nodes[0]) : this.getForceNode((nodes[i + 1]));\n                var angle = (360 / nodes.length / 2) * Math.PI / 180;\n                var normalDistance = 2 * this.springLength * Math.sin(angle);\n                this.calcRelatesForce(vtx1, vtx2, normalDistance);\n            }\n            for (var s = 0; s < lstNodes.length; s++) {\n                var gnChild = lstNodes[s];\n                if (!collectionContains(gnChild.id, nodes) && gnChild.id !== gnNode.id) {\n                    force = this.getForceNode(gnChild);\n                    this.updateNeigbour(forceNode, force);\n                }\n            }\n        }\n    };\n    SymmetricLayout.prototype.appendForces = function (lstNodes) {\n        var gfnNode = null;\n        for (var k = 0; k < lstNodes.length; k++) {\n            var gnNode = lstNodes[k];\n            gfnNode = this.getForceNode(gnNode);\n            var ptPoint = gfnNode.location;\n            ptPoint.x += Math.min(gfnNode.velocityX, this.mszMaxForceVelocity.width);\n            ptPoint.y += Math.min(gfnNode.velocityY, this.mszMaxForceVelocity.height);\n            gfnNode.velocityX = 0;\n            gfnNode.velocityY = 0;\n            gfnNode.location = ptPoint;\n        }\n    };\n    SymmetricLayout.prototype.resetGraphPosition = function (lstNodes, graph) {\n        var szMin = { width: Number.MAX_VALUE, height: Number.MAX_VALUE };\n        var gfnNode = null;\n        var gnNode;\n        for (var k = 0; k < lstNodes.length; k++) {\n            gnNode = lstNodes[k];\n            gfnNode = this.getForceNode(gnNode);\n            var ptLocation = {\n                x: gfnNode.location.x - gnNode.actualSize.width / 2,\n                y: gfnNode.location.y - gnNode.actualSize.height / 2\n            };\n            szMin.width = Math.min(szMin.width, ptLocation.x);\n            szMin.height = Math.min(szMin.height, ptLocation.y);\n        }\n        for (var k = 0; k < lstNodes.length; k++) {\n            gnNode = lstNodes[k];\n            gfnNode = this.getForceNode(gnNode);\n            var ptLocation = gfnNode.location;\n            ptLocation.x -= szMin.width - (graph.treeInfo.location ? graph.treeInfo.location.x : 0);\n            ptLocation.y -= szMin.height - (graph.treeInfo.location ? graph.treeInfo.location.y : 0);\n            gfnNode.location = ptLocation;\n            gfnNode.applyChanges();\n        }\n    };\n    SymmetricLayout.prototype.convertGraphNodes = function (lstNodes) {\n        var lstToReturn = [];\n        var keys = Object.keys(lstNodes);\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var k = keys_1[_i];\n            if (lstNodes[k]) {\n                var gnNode = lstNodes[k];\n                var forceNode = new GraphForceNode(gnNode);\n                gnNode.treeInfo.tag = forceNode;\n                lstToReturn.push(gnNode);\n            }\n        }\n        return lstToReturn;\n    };\n    /**\n     * getForceNode method\\\n     *\n     * @returns {  GraphForceNode }    getForceNode method .\\\n     * @param {IGraphObject} gnNode - provide the angle value.\n     * @private\n     */\n    SymmetricLayout.prototype.getForceNode = function (gnNode) {\n        return gnNode.treeInfo.tag;\n    };\n    SymmetricLayout.prototype.updateNeigbour = function (vtSource, vtTarget) {\n        if (vtTarget == null || vtSource == null) {\n            return;\n        }\n        var distance = this.pointDistance(vtSource.location, vtTarget.location);\n        var angle = this.lineAngle(vtSource.location, vtTarget.location);\n        var normalDistance = (this.springLength * 0.9);\n        if (distance < normalDistance) {\n            this.calcForce(distance, normalDistance, angle, vtTarget);\n        }\n    };\n    SymmetricLayout.prototype.lineAngle = function (pt1, pt2) {\n        var radians = 0;\n        var vx = pt2.x - pt1.x;\n        var vy = pt2.y - pt1.y;\n        if (vx === 0) {\n            if (vy <= 0) {\n                radians = (3.0 * Math.PI) / 2.0;\n            }\n            else {\n                radians = Math.PI / 2.0;\n            }\n        }\n        else if (vy === 0) {\n            if (vx < 0) {\n                radians = Math.PI;\n            }\n            else {\n                radians = 0;\n            }\n        }\n        else {\n            radians = Math.atan(vy / vx);\n            if (vx < 0 && vy > 0) {\n                radians = Math.PI + radians;\n            }\n            else if (vx < 0 && vy < 0) {\n                radians = Math.PI + radians;\n            }\n            else if (vx > 0 && vy < 0) {\n                radians = 2.0 * Math.PI + radians;\n            }\n        }\n        return radians;\n    };\n    SymmetricLayout.prototype.pointDistance = function (pt1, pt2) {\n        var d = 0;\n        var dx = pt2.x - pt1.x;\n        var dy = pt2.y - pt1.y;\n        var t = (dx * dx) + (dy * dy);\n        if (t > 0) {\n            d = Math.sqrt(t);\n        }\n        return d;\n    };\n    SymmetricLayout.prototype.calcRelatesForce = function (vtSource, vtTarget, normalDistance) {\n        var distance = this.pointDistance(vtSource.location, vtTarget.location);\n        var angle = this.lineAngle(vtSource.location, vtTarget.location);\n        if (distance < normalDistance) {\n            this.calcForce(distance, normalDistance, angle, vtTarget);\n        }\n    };\n    /**\n     * @param nodeCollection\n     * @param connectors\n     * @param symmetricLayout\n     * @param nameTable\n     * @param layout\n     * @param viewPort\n     * @private\n     */\n    /**\n     * updateLayout method\\\n     *\n     * @returns {  void }    updateLayout method .\\\n     * @param {IGraphObject[]} nodeCollection - provide the angle value.\n     * @param {IGraphObject[]} connectors - provide the connectors value.\n     * @param {SymmetricLayout} symmetricLayout - provide the symmetricLayout value.\n     * @param {Object} nameTable - provide the nameTable value.\n     * @param {Layout} layout - provide the layout value.\n     * @param {PointModel} viewPort - provide the viewPort value.\n     * @private\n     */\n    SymmetricLayout.prototype.updateLayout = function (nodeCollection, connectors, symmetricLayout, nameTable, layout, viewPort) {\n        var layoutManager = new GraphLayoutManager();\n        layoutManager.updateLayout(nodeCollection, connectors, symmetricLayout, nameTable, layout, viewPort);\n    };\n    SymmetricLayout.prototype.calcNodesForce = function (vtSource, vtTarget) {\n        var distance = this.pointDistance(vtSource.location, vtTarget.location);\n        var angle = this.lineAngle(vtSource.location, vtTarget.location);\n        if (distance > this.springLength || distance < this.springLength) {\n            this.calcForce(distance, this.springLength, angle, vtTarget);\n        }\n    };\n    SymmetricLayout.prototype.calcForce = function (distance, minDist, angle, vtTarget) {\n        var count = vtTarget.nodes.length;\n        var length = distance - minDist;\n        var factor = this.springFactor / (count * count) * Math.sqrt(count);\n        if (length !== 0) {\n            var fVelocity = length * factor;\n            var fOffset = fVelocity;\n            var offsetX = Math.cos(angle) * fOffset;\n            var offsetY = Math.sin(angle) * fOffset;\n            vtTarget.velocityX -= offsetX;\n            vtTarget.velocityY -= offsetY;\n        }\n    };\n    return SymmetricLayout;\n}());\nexport { SymmetricLayout };\nvar GraphLayoutManager = /** @class */ (function () {\n    function GraphLayoutManager() {\n        this.visitedStack = [];\n        this.cycleEdgesCollection = [];\n        this.graphObjects = [];\n        this.passedNodes = [];\n    }\n    /**\n     * @param nodeCollection\n     * @param connectors\n     * @param symmetricLayout\n     * @param nameTable\n     * @param layout\n     * @param viewPort\n     * @private\n     */\n    /**\n     * updateLayout method\\\n     *\n     * @returns {  boolean }    updateLayout method .\\\n     * @param {IGraphObject[]} nodeCollection - provide the nodeCollection value.\n     * @param {IGraphObject[]} connectors - provide the nodeCollection value.\n     * @param {SymmetricLayout} symmetricLayout - provide the nodeCollection value.\n     * @param {Object} nameTable - provide the nodeCollection value.\n     * @param {Layout} layout - provide the nodeCollection value.\n     * @param {PointModel} viewPort - provide the nodeCollection value.\n     * @private\n     */\n    GraphLayoutManager.prototype.updateLayout = function (nodeCollection, connectors, symmetricLayout, nameTable, layout, viewPort) {\n        this.nameTable = nameTable;\n        this.nodes = nodeCollection;\n        this.connectors = connectors;\n        var selectionList = nodeCollection;\n        if (selectionList.length > 0) {\n            this.mhelperSelectedNode = cloneObject(selectionList[0]);\n        }\n        for (var _i = 0, nodeCollection_1 = nodeCollection; _i < nodeCollection_1.length; _i++) {\n            var node = nodeCollection_1[_i];\n            var nodeGraphObject = node;\n            nodeGraphObject.treeInfo = {};\n            nodeGraphObject.treeInfo.graphType = 'Node';\n            this.graphObjects.push(nodeGraphObject);\n        }\n        for (var _a = 0, connectors_1 = connectors; _a < connectors_1.length; _a++) {\n            var connector = connectors_1[_a];\n            var connectorGraphObject = connector;\n            connectorGraphObject.treeInfo = {};\n            connectorGraphObject.treeInfo.graphType = 'Connector';\n            this.graphObjects.push(connectorGraphObject);\n        }\n        this.updateLayout1(this.graphObjects, symmetricLayout);\n        var modelBounds = this.getModelBounds(selectionList);\n        for (var i = 0; i < selectionList.length; i++) {\n            var node = selectionList[i];\n            var trnsX = (viewPort.x - modelBounds.width) / 2;\n            var margin = layout.margin || {};\n            //let marginX: number; let marginY: number;\n            margin.left = margin.left || 0;\n            margin.right = margin.right || 0;\n            margin.top = margin.top || 0;\n            margin.bottom = margin.bottom || 0;\n            if (layout.margin.left) {\n                margin.left = layout.margin.left;\n            }\n            if (layout.margin.top) {\n                margin.top = layout.margin.top;\n            }\n            var dx = (node.treeInfo.tag.location.x - (node.offsetX - (node.actualSize.width / 2)) -\n                modelBounds.x + trnsX + margin.left);\n            var dy = (node.treeInfo.tag.location.y - (node.offsetY - (node.actualSize.height / 2)) - modelBounds.y + margin.top);\n            node.offsetX += dx;\n            node.offsetY += dy;\n            delete node.treeInfo;\n        }\n        return true;\n    };\n    /**\n     * getModelBounds method\\\n     *\n     * @returns {  Rect }    getModelBounds method .\\\n     * @param {IGraphObject[]} lNodes - provide the angle value.\n     * @private\n     */\n    GraphLayoutManager.prototype.getModelBounds = function (lNodes) {\n        lNodes = lNodes.slice();\n        var rect = null;\n        var rect1 = null;\n        var node;\n        for (var i = 0; i < lNodes.length; i++) {\n            node = lNodes[i];\n            var bounds = getGraphBounds(node);\n            rect = new Rect(node.treeInfo.tag ? node.treeInfo.tag.location.x : bounds.x, node.treeInfo.tag ? node.treeInfo.tag.location.y : bounds.y, node.actualSize.width, node.actualSize.height);\n            if (rect1) {\n                rect1 = rect1.uniteRect(rect);\n            }\n            else {\n                rect1 = rect;\n            }\n        }\n        return rect1;\n    };\n    GraphLayoutManager.prototype.updateLayout1 = function (nodesToLayout, symmetricLayout) {\n        this.detectCyclesInGraph(nodesToLayout);\n        var nodesCount = nodesToLayout.length;\n        if (nodesCount > 0) {\n            var cycleConnColln = [];\n            var nodes = [];\n            var nodeSymbols = [];\n            for (var s = 0; s < nodesToLayout.length; s++) {\n                var nd = nodesToLayout[s];\n                if (nd.treeInfo.isCycleEdge === undefined) {\n                    nd.treeInfo.isCycleEdge = false;\n                }\n                if (nd.treeInfo.graphType === 'Connector' && !nd.treeInfo.isCycleEdge) {\n                    nodes.push(nd);\n                }\n                else if (nd.treeInfo.graphType === 'Connector') {\n                    cycleConnColln.push(nd);\n                }\n                else {\n                    nodeSymbols.push(nd);\n                }\n            }\n            nodes = nodes.concat(nodeSymbols);\n            nodes = cycleConnColln.concat(nodes);\n            while (nodesCount > this.dictionaryLength(this.passedNodes)) {\n                this.getNodesToPosition(nodes);\n                if (this.selectedNode == null) {\n                    continue;\n                }\n                symmetricLayout.doLayout(this);\n                this.selectedNode = null;\n                this.visitedStack = [];\n                for (var _i = 0, _a = this.cycleEdgesCollection; _i < _a.length; _i++) {\n                    var connector = _a[_i];\n                    connector.treeInfo.isCycleEdge = false;\n                }\n            }\n            this.passedNodes = null;\n            this.selectedNode = null;\n        }\n        return false;\n    };\n    GraphLayoutManager.prototype.getNodesToPosition = function (nodes) {\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            if (!collectionContains(node.id, this.passedNodes)) {\n                if (node) {\n                    this.selectNodes(node);\n                }\n                break;\n            }\n        }\n    };\n    GraphLayoutManager.prototype.selectNodes = function (node) {\n        var nodeGraph = node;\n        if (node.treeInfo.graphType === 'Connector') {\n            this.exploreGraphEdge(node);\n        }\n        else if (nodeGraph != null) {\n            if (this.addNode(node, 'passed')) {\n                this.addNode(node, 'selected');\n                if (this.isConnectedToAnotherNode(nodeGraph)) {\n                    this.selectedNode = { treeInfo: {} };\n                    this.selectedNode.treeInfo.LeftMargin = 10;\n                    this.selectedNode.treeInfo.TopMargin = 10;\n                    this.selectConnectedNodes(nodeGraph);\n                }\n                else {\n                    this.selectedNode = node;\n                }\n            }\n        }\n    };\n    GraphLayoutManager.prototype.selectConnectedNodes = function (nodeGraph) {\n        var graph = this.selectedNode;\n        if (!graph.treeInfo.GraphNodes) {\n            graph.treeInfo.GraphNodes = {};\n        }\n        var node = nodeGraph;\n        if (node != null && this.addNode(node, 'passed')) {\n            var nodeName = node.id;\n            if (!this.dictionaryContains(graph.treeInfo.GraphNodes, node)) {\n                var gnNode = this.addGraphNode(node);\n                this.getConnectedRelatives(gnNode);\n                this.exploreRelatives(nodeGraph);\n            }\n            else {\n                var graphNode = graph.treeInfo.GraphNodes[nodeName];\n                if (graphNode.treeInfo.Added) {\n                    graphNode.treeInfo.Added = false;\n                    this.getConnectedRelatives(graphNode);\n                    this.exploreRelatives(nodeGraph);\n                }\n            }\n        }\n    };\n    GraphLayoutManager.prototype.exploreRelatives = function (nodeGraph) {\n        this.exploreRelatives1(nodeGraph, 'Parents');\n        this.exploreRelatives1(nodeGraph, 'Children');\n    };\n    GraphLayoutManager.prototype.exploreRelatives1 = function (nodeGraph, relativesToExplore) {\n        var edges = [];\n        if (relativesToExplore === 'Parents') {\n            edges = nodeGraph.inEdges;\n        }\n        else if (relativesToExplore === 'Children') {\n            edges = nodeGraph.outEdges;\n        }\n        for (var i = 0; i < edges.length; i++) {\n            var edge = this.nameTable[edges[i]];\n            if (this.addNode(edge, 'passed')) {\n                var fromNode = this.nameTable[edge.sourceID];\n                var toNode = this.nameTable[edge.targetID];\n                if (relativesToExplore === 'Parents' && fromNode != null &&\n                    collectionContains(fromNode.id, this.nodes)) {\n                    this.selectConnectedNodes(this.nameTable[edge.sourceID]);\n                }\n                else if (relativesToExplore === 'Children' && toNode != null &&\n                    collectionContains(toNode.id, this.nodes)) {\n                    this.selectConnectedNodes(this.nameTable[edge.targetID]);\n                }\n            }\n        }\n    };\n    GraphLayoutManager.prototype.getConnectedRelatives = function (graphNode) {\n        this.getConnectedParents(graphNode);\n        this.getConnectedChildren(graphNode);\n    };\n    GraphLayoutManager.prototype.dictionaryContains = function (obj, keyObj) {\n        var keys = Object.keys(obj);\n        for (var i = 0; i < keys.length; i++) {\n            if (keys[i] === keyObj.id) {\n                return true;\n            }\n        }\n        return false;\n    };\n    GraphLayoutManager.prototype.dictionaryLength = function (obj) {\n        var keys = Object.keys(obj);\n        return keys.length;\n    };\n    GraphLayoutManager.prototype.getConnectedChildren = function (graphNode) {\n        var graph = this.selectedNode;\n        var nodeGraph = graphNode;\n        for (var s = 0; s < nodeGraph.outEdges.length; s++) {\n            var edge = this.nameTable[nodeGraph.outEdges[s]];\n            if (!edge.treeInfo.isCycleEdge) {\n                var node = this.nameTable[edge.targetID];\n                if (collectionContains(node.id, this.nodes) && node != null && node.visible) {\n                    var gnNodeChildren = void 0;\n                    if (!this.dictionaryContains(graph.treeInfo.GraphNodes, node)) {\n                        gnNodeChildren = this.addGraphNode(node);\n                        gnNodeChildren.treeInfo.Added = true;\n                    }\n                    else {\n                        gnNodeChildren = graph.treeInfo.GraphNodes[node.id];\n                    }\n                    if (!graphNode.treeInfo.children) {\n                        graphNode.treeInfo.children = [];\n                    }\n                    if (!gnNodeChildren.treeInfo.parents) {\n                        gnNodeChildren.treeInfo.parents = [];\n                    }\n                    this.setNode(gnNodeChildren.treeInfo.parents, graphNode);\n                    if (this.findNode(graphNode.treeInfo.children, gnNodeChildren.id) < 0) {\n                        graphNode.treeInfo.children.push(gnNodeChildren);\n                    }\n                }\n            }\n        }\n    };\n    GraphLayoutManager.prototype.getConnectedParents = function (graphNode) {\n        var graph = this.selectedNode;\n        var nodeGraph = graphNode;\n        for (var s = 0; s < nodeGraph.inEdges.length; s++) {\n            var edge = this.nameTable[nodeGraph.inEdges[s]];\n            if (!edge.treeInfo.isCycleEdge) {\n                var node = this.nameTable[edge.sourceID];\n                if (collectionContains(node.id, this.nodes) && node != null && node.visible) {\n                    var gnNode = void 0;\n                    if (!this.dictionaryContains(graph.treeInfo.GraphNodes, node)) {\n                        gnNode = this.addGraphNode(node);\n                        gnNode.treeInfo.Added = true;\n                    }\n                    else {\n                        gnNode = graph.treeInfo.GraphNodes[node.id];\n                    }\n                    if (!graphNode.treeInfo.parents) {\n                        graphNode.treeInfo.parents = [];\n                    }\n                    if (!gnNode.treeInfo.children) {\n                        gnNode.treeInfo.children = [];\n                    }\n                    this.setNode(gnNode.treeInfo.children, graphNode);\n                    if (this.findNode(graphNode.treeInfo.parents, gnNode.id) < 0) {\n                        graphNode.treeInfo.parents.push(gnNode);\n                    }\n                }\n            }\n        }\n    };\n    GraphLayoutManager.prototype.setNode = function (list, node) {\n        var nIndex = this.findNode(list, node.id);\n        if (nIndex >= 0 && nIndex < list.length) {\n            list[nIndex] = node;\n        }\n        else {\n            list.push(node);\n        }\n    };\n    GraphLayoutManager.prototype.findNode = function (list, fullName) {\n        var nIndex = -1;\n        if (list != null && fullName !== '') {\n            for (var i = 0, nLength = list.length; i < nLength; i++) {\n                var gnNode = list[i];\n                if (typeof (gnNode) === 'string' && gnNode === fullName) {\n                    nIndex = i;\n                    break;\n                }\n                else if (gnNode != null && gnNode.id === fullName) {\n                    nIndex = i;\n                    break;\n                }\n            }\n        }\n        return nIndex;\n    };\n    GraphLayoutManager.prototype.addGraphNode = function (node) {\n        var graph = this.selectedNode;\n        if (!graph.treeInfo.GraphNodes) {\n            graph.treeInfo.GraphNodes = {};\n        }\n        var gnNode = node;\n        if (graph != null) {\n            graph.treeInfo.GraphNodes[gnNode.id] = gnNode;\n            var nodeHelper = this.mhelperSelectedNode;\n            if (nodeHelper != null && node.id === nodeHelper.id) {\n                this.mhelperSelectedNode = gnNode;\n            }\n        }\n        return gnNode;\n    };\n    GraphLayoutManager.prototype.isConnectedToAnotherNode = function (gnNode) {\n        var bFoundConnectedNode = false;\n        var edges = (gnNode.inEdges).concat(gnNode.outEdges);\n        if (edges.length > 0) {\n            if ((gnNode.inEdges != null) && (gnNode.inEdges.length > 0)) {\n                bFoundConnectedNode = this.searchEdgeCollection(gnNode.inEdges, 'FromNode');\n            }\n            if ((!bFoundConnectedNode) && (gnNode.outEdges != null) && (gnNode.outEdges.length > 0)) {\n                bFoundConnectedNode = this.searchEdgeCollection(gnNode.outEdges, 'ToNode');\n            }\n        }\n        return bFoundConnectedNode;\n    };\n    GraphLayoutManager.prototype.searchEdgeCollection = function (edgesToSearchThrough, connectionDirection) {\n        var bFoundConnectedNode = false;\n        for (var i = 0; i < edgesToSearchThrough.length - 1; i++) {\n            var edge = this.nameTable[edgesToSearchThrough[i]];\n            if (!this.addNode(edge, 'passed')) {\n                continue;\n            }\n            if (!edge.treeInfo.isCycleEdge && ((connectionDirection === 'FromNode' && this.nameTable[edge.sourceID] != null)\n                || (connectionDirection === 'ToNode' && this.nameTable[edge.targetID] != null))) {\n                bFoundConnectedNode = true;\n                break;\n            }\n        }\n        return bFoundConnectedNode;\n    };\n    GraphLayoutManager.prototype.exploreGraphEdge = function (node) {\n        var nodeLink = node;\n        if (nodeLink != null && !nodeLink.treeInfo.isCycleEdge && this.addNode(node, 'passed')) {\n            this.addNode(node, 'selected');\n            var fromNode = this.nameTable[nodeLink.sourceID];\n            var toNode = this.nameTable[nodeLink.targetID];\n            if (fromNode != null) {\n                this.selectNodes(fromNode);\n            }\n            else if (toNode != null) {\n                this.selectNodes(toNode);\n            }\n            else {\n                this.selectedNode = node;\n            }\n        }\n    };\n    GraphLayoutManager.prototype.addNode = function (nodeToAdd, collectionToAdd) {\n        var bResult = true;\n        var node = nodeToAdd;\n        if (collectionToAdd === 'passed' || !node.visible) {\n            if (!this.dictionaryContains(this.passedNodes, node)) {\n                this.passedNodes[node.id] = node;\n            }\n        }\n        if (!node.visible) {\n            return false;\n        }\n        return bResult;\n    };\n    GraphLayoutManager.prototype.detectCyclesInGraph = function (nodes) {\n        var vertex = [];\n        var currentStack = [];\n        for (var k = 0; k < nodes.length; k++) {\n            if (!(nodes[k].treeInfo.graphType === 'Connector')) {\n                vertex.push(nodes[k]);\n            }\n        }\n        if (vertex.length > 0) {\n            currentStack.push(vertex[0]);\n            this.visitedStack.push(vertex[0]);\n            while (currentStack.length > 0) {\n                var top_1 = currentStack[currentStack.length - 1];\n                var childNodes = this.getUnVisitedChildNodes(top_1);\n                if (childNodes.length > 0) {\n                    var child = childNodes[0];\n                    var currentEdge = childNodes[childNodes.length - 1];\n                    if (collectionContains(child.id, this.visitedStack)) {\n                        currentEdge.treeInfo.isCycleEdge = true;\n                        this.cycleEdgesCollection.push(currentEdge);\n                    }\n                    else {\n                        currentStack.push(child);\n                        this.visitedStack.splice(0, 0, child);\n                    }\n                }\n                else {\n                    currentStack.pop();\n                }\n            }\n        }\n    };\n    GraphLayoutManager.prototype.getUnVisitedChildNodes = function (top) {\n        var childNodes = [];\n        if (top.outEdges.length > 0) {\n            for (var i = 0; i < top.outEdges.length; i++) {\n                var con = this.nameTable[top.outEdges[i]];\n                if (!collectionContains(con.id, this.visitedStack)) {\n                    var toNode = this.nameTable[con.targetID];\n                    if (toNode != null) {\n                        childNodes.push(toNode);\n                    }\n                    childNodes.push(con);\n                    this.visitedStack.splice(0, 0, con);\n                    return childNodes;\n                }\n            }\n            return childNodes;\n        }\n        return childNodes;\n    };\n    return GraphLayoutManager;\n}());\nexport { GraphLayoutManager };\n/**\n * getGraphBounds method\\\n *\n * @returns {  void }    getGraphBounds method .\\\n * @param {IGraphObject} node - provide the angle value.\n * @private\n */\nfunction getGraphBounds(node) {\n    var x = node.offsetX - node.actualSize.width * node.pivot.x;\n    var y = node.offsetY - node.actualSize.height * node.pivot.y;\n    return new Rect(x, y, node.actualSize.width, node.actualSize.height);\n}\n/**\n * @param id\n * @param coll\n */\n/**\n * collectionContains method\\\n *\n * @returns {  boolean }    collectionContains method .\\\n * @param {string} id - provide the id value.\n * @param {IGraphObject[]} coll - provide the id value.\n * @private\n */\nfunction collectionContains(id, coll) {\n    for (var i = 0; i < coll.length; i++) {\n        if (coll[i].id === id) {\n            return true;\n        }\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"module"}