{"ast":null,"code":"import { Node } from '../objects/node';\nimport { GridPanel, RowDefinition, ColumnDefinition } from '../core/containers/grid';\nimport { Lane, Phase } from '../objects/node';\nimport { DiagramAction, NodeConstraints, DiagramConstraints, DiagramEvent, ElementAction } from '../enum/enum';\nimport { cloneObject, randomId } from './../utility/base-util';\nimport { DiagramElement } from '../core/elements/diagram-element';\nimport { TextElement } from '../core/elements/text-element';\nimport { Size } from '../primitives/size';\nimport { Canvas } from '../core/containers/canvas';\nimport { Rect } from '../primitives/rect';\nimport { checkParentAsContainer, findBounds, removeChildInContainer } from '../interaction/container-interaction';\nimport { canSelect } from './constraints-util';\n/**\n * SwimLane modules are used to rendering and interaction.\n */\n\n/** @private */\n\n/**\n * initSwimLane method \\\n *\n * @returns {void} initSwimLane method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param { Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the node  value.\n * @private\n */\n\nexport function initSwimLane(grid, diagram, node) {\n  if (!node.width && node.shape.phases.length === 0) {\n    node.width = 100;\n  }\n\n  var row = [];\n  var columns = [];\n  var index = 0;\n  var shape = node.shape;\n  var orientation = shape.orientation === 'Horizontal' ? true : false;\n\n  if (shape.header && shape.hasHeader) {\n    createRow(row, shape.header.height);\n  }\n\n  initGridRow(row, orientation, node);\n  initGridColumns(columns, orientation, node);\n  grid.setDefinitions(row, columns);\n\n  if (shape.header && shape.hasHeader) {\n    headerDefine(grid, diagram, node);\n    index++;\n  }\n\n  if (shape.phases.length > 0 && shape.phaseSize) {\n    for (var k = 0; k < shape.phases.length; k++) {\n      if (shape.phases[k].id === '') {\n        shape.phases[k].id = randomId();\n      }\n\n      phaseDefine(grid, diagram, node, index, orientation, k);\n    }\n\n    index++;\n  }\n\n  if (shape.lanes.length > 0) {\n    for (var k = 0; k < shape.lanes.length; k++) {\n      if (shape.lanes[k].id === '') {\n        shape.lanes[k].id = randomId();\n      }\n\n      laneCollection(grid, diagram, node, index, k, orientation);\n      index++;\n    }\n  }\n}\n/**\n * addObjectToGrid method \\\n *\n * @returns {Container} addObjectToGrid method .\\\n * @param { Diagram} diagram - provide the diagram  value.\n * @param { GridPanel} grid - provide the grid  value.\n * @param {NodeModel} parent - provide the parent  value.\n * @param {NodeModel} object - provide the object  value.\n * @param {boolean} isHeader - provide the isHeader  value.\n * @param {boolean} isPhase - provide the isPhase  value.\n * @param {boolean} isLane - provide the isLane  value.\n * @param {string} canvas - provide the canvas  value.\n * @private\n */\n\nexport function addObjectToGrid(diagram, grid, parent, object, isHeader, isPhase, isLane, canvas) {\n  var node = new Node(diagram, 'nodes', object, true);\n  node.parentId = parent.id;\n  node.isHeader = isHeader ? true : false;\n  node.isPhase = isPhase ? true : false;\n  node.isLane = isLane ? true : false;\n  var id = isPhase ? 'PhaseHeaderParent' : 'LaneHeaderParent';\n\n  if (canvas) {\n    node[id] = canvas;\n  }\n\n  node.constraints &= ~(NodeConstraints.InConnect | NodeConstraints.OutConnect);\n  node.constraints |= NodeConstraints.HideThumbs;\n  diagram.initObject(node);\n  diagram.nodes.push(node);\n\n  if (node.wrapper.children.length > 0) {\n    for (var i = 0; i < node.wrapper.children.length; i++) {\n      var child = node.wrapper.children[i];\n\n      if (child instanceof DiagramElement) {\n        child.isCalculateDesiredSize = false;\n      }\n\n      if (child instanceof TextElement) {\n        child.canConsiderBounds = false;\n\n        if (!isHeader && parent.shape.orientation === 'Vertical' && isPhase || parent.shape.orientation !== 'Vertical' && isLane) {\n          child.isLaneOrientation = true;\n          child.refreshTextElement();\n        }\n      }\n    }\n\n    node.wrapper.measure(new Size(undefined, undefined));\n    node.wrapper.arrange(node.wrapper.desiredSize);\n  }\n\n  return node.wrapper;\n}\n/**\n * headerDefine method \\\n *\n * @returns {void} headerDefine method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} object - provide the object  value.\n * @private\n */\n\nexport function headerDefine(grid, diagram, object) {\n  var maxWidth = 0;\n  var columns = grid.columnDefinitions();\n  var shape = object.shape;\n\n  for (var i = 0; i < columns.length; i++) {\n    maxWidth += columns[i].width;\n  }\n\n  shape.header.id = shape.header.id || randomId();\n  var node = {\n    id: object.id + shape.header.id,\n    annotations: [cloneObject(shape.header.annotation)],\n    style: shape.header.style ? shape.header.style : undefined,\n    offsetX: object.offsetX,\n    offsetY: object.offsetY,\n    rowIndex: 0,\n    columnIndex: 0,\n    maxWidth: maxWidth,\n    container: {\n      type: 'Canvas',\n      orientation: 'Horizontal'\n    }\n  };\n\n  if (!canSelect(object)) {\n    node.constraints &= ~NodeConstraints.Select;\n  }\n\n  var wrapper = addObjectToGrid(diagram, grid, object, node, true);\n  grid.addObject(wrapper, 0, 0, 1, grid.columnDefinitions().length);\n}\n/**\n * phaseDefine method \\\n *\n * @returns {void} phaseDefine method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} object - provide the object  value.\n * @param {number} indexValue - provide the indexValue  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @param {number} phaseIndex - provide the phaseIndex  value.\n * @private\n */\n\nexport function phaseDefine(grid, diagram, object, indexValue, orientation, phaseIndex) {\n  var rowValue = 0;\n  var colValue = 0;\n  var maxWidth;\n  var shape = object.shape;\n\n  if (orientation) {\n    colValue = phaseIndex;\n    rowValue = indexValue;\n    maxWidth = grid.columnDefinitions()[phaseIndex].width;\n  } else {\n    rowValue = shape.header && shape.hasHeader ? phaseIndex + 1 : phaseIndex;\n  }\n\n  var phaseObject = {\n    annotations: [cloneObject(shape.phases[phaseIndex].header.annotation)],\n    maxWidth: maxWidth,\n    id: object.id + shape.phases[phaseIndex].id + '_header',\n    offsetX: object.offsetX,\n    offsetY: object.offsetY,\n    style: shape.phases[phaseIndex].style,\n    rowIndex: rowValue,\n    columnIndex: colValue,\n    container: {\n      type: 'Canvas',\n      orientation: orientation ? 'Horizontal' : 'Vertical'\n    }\n  };\n  phaseObject.annotations[0].rotateAngle = orientation ? 0 : 270;\n\n  if (!canSelect(object)) {\n    phaseObject.constraints &= ~NodeConstraints.Select;\n  }\n\n  shape.phases[phaseIndex].header.id = phaseObject.id;\n  var wrapper = addObjectToGrid(diagram, grid, object, phaseObject, false, true, false, shape.phases[phaseIndex].id);\n  grid.addObject(wrapper, rowValue, colValue);\n}\n/**\n * laneCollection method \\\n *\n * @returns {void} laneCollection method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} object - provide the object  value.\n * @param {number} indexValue - provide the indexValue  value.\n * @param {number} laneIndex - provide the laneIndex  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @private\n */\n\nexport function laneCollection(grid, diagram, object, indexValue, laneIndex, orientation) {\n  var laneNode;\n  var parentWrapper;\n  var gridCell;\n  var canvas;\n  var childWrapper;\n  var shape = object.shape;\n  var value = shape.phases.length || 1;\n  var isHeader = shape.header && shape.hasHeader ? 1 : 0;\n  var rowValue = orientation ? indexValue : isHeader;\n  var phaseCount = shape.phaseSize && shape.phases.length > 0 ? 1 : 0;\n\n  for (var l = 0; l < value; l++) {\n    var colValue = orientation ? l : laneIndex + phaseCount;\n    gridCell = grid.rows[rowValue].cells[colValue];\n    canvas = {\n      id: object.id + shape.lanes[laneIndex].id + l,\n      rowIndex: rowValue,\n      columnIndex: colValue,\n      width: gridCell.minWidth,\n      height: gridCell.minHeight,\n      offsetX: object.offsetX,\n      offsetY: object.offsetY,\n      style: shape.lanes[laneIndex].style,\n      constraints: NodeConstraints.Default | NodeConstraints.ReadOnly | NodeConstraints.AllowDrop,\n      container: {\n        type: 'Canvas',\n        orientation: orientation ? 'Horizontal' : 'Vertical'\n      }\n    };\n\n    if (!canSelect(object)) {\n      canvas.constraints &= ~NodeConstraints.Select;\n    }\n\n    parentWrapper = addObjectToGrid(diagram, grid, object, canvas, false, false, true);\n    parentWrapper.children[0].isCalculateDesiredSize = false;\n\n    if (l === 0) {\n      laneNode = {\n        id: object.id + shape.lanes[laneIndex].id + '_' + l + '_header',\n        style: shape.lanes[laneIndex].header.style,\n        annotations: [cloneObject(shape.lanes[laneIndex].header.annotation)],\n        offsetX: object.offsetX,\n        offsetY: object.offsetY,\n        rowIndex: rowValue,\n        columnIndex: colValue,\n        container: {\n          type: 'Canvas',\n          orientation: orientation ? 'Horizontal' : 'Vertical'\n        }\n      };\n      laneNode.annotations[0].rotateAngle = orientation ? 270 : 0;\n      shape.lanes[laneIndex].header.id = laneNode.id; // eslint-disable-next-line\n\n      orientation ? laneNode.width = shape.lanes[laneIndex].header.width : laneNode.height = shape.lanes[laneIndex].header.height;\n\n      if (!canSelect(object)) {\n        laneNode.constraints &= ~NodeConstraints.Select;\n      }\n\n      childWrapper = addObjectToGrid(diagram, grid, object, laneNode, false, false, true, shape.lanes[laneIndex].id);\n\n      if (orientation) {\n        childWrapper.children[0].elementActions = childWrapper.children[0].elementActions | ElementAction.HorizontalLaneHeader;\n      }\n\n      parentWrapper.children.push(childWrapper);\n    }\n\n    grid.addObject(parentWrapper, rowValue, colValue);\n\n    if (!orientation) {\n      rowValue++;\n    }\n\n    colValue = orientation ? l : laneIndex + 1;\n  }\n}\n/**\n * createRow method \\\n *\n * @returns {void} createRow method .\\\n * @param { RowDefinition[]} row - provide the row  value.\n * @param {number} height - provide the height  value.\n * @private\n */\n\nexport function createRow(row, height) {\n  var rows = new RowDefinition();\n  rows.height = height;\n  row.push(rows);\n}\n/**\n * createColumn method \\\n *\n * @returns {void} createColumn method .\\\n * @param {number} width - provide the width  value.\n * @private\n */\n\nexport function createColumn(width) {\n  var cols = new ColumnDefinition();\n  cols.width = width;\n  return cols;\n}\n/**\n * initGridRow method \\\n *\n * @returns {void} initGridRow method .\\\n * @param {RowDefinition[]} row - provide the row  value.\n * @param {boolean} orientation - provide the row  value.\n * @param {NodeModel} object - provide the row  value.\n * @private\n */\n\nexport function initGridRow(row, orientation, object) {\n  var totalHeight = 0;\n  var height;\n  var shape = object.shape;\n\n  if (row.length > 0) {\n    for (var i = 0; i < row.length; i++) {\n      totalHeight += row[i].height;\n    }\n  }\n\n  if (orientation) {\n    if (shape.phases.length > 0 && shape.phaseSize) {\n      totalHeight += shape.phaseSize;\n      createRow(row, shape.phaseSize);\n    }\n\n    if (shape.lanes.length > 0) {\n      for (var i = 0; i < shape.lanes.length; i++) {\n        height = shape.lanes[i].height;\n        totalHeight += height;\n\n        if (i === shape.lanes.length - 1 && totalHeight < object.height) {\n          height += object.height - totalHeight;\n        }\n\n        createRow(row, height);\n      }\n    }\n  } else {\n    if (shape.phases.length > 0) {\n      var phaseHeight = 0;\n\n      for (var i = 0; i < shape.phases.length; i++) {\n        var phaseOffset = shape.phases[i].offset;\n\n        if (i === 0) {\n          phaseHeight += phaseOffset;\n        } else {\n          phaseOffset -= phaseHeight;\n          phaseHeight += phaseOffset;\n        }\n\n        height = phaseOffset;\n        totalHeight += height;\n\n        if (i === shape.phases.length - 1 && totalHeight < object.height) {\n          height += object.height - totalHeight;\n        }\n\n        createRow(row, height);\n      }\n    } else {\n      createRow(row, object.height);\n    }\n  }\n}\n/**\n * initGridColumns method \\\n *\n * @returns {void} initGridRow method .\\\n * @param {ColumnDefinition[]} columns - provide the row  value.\n * @param {boolean} orientation - provide the row  value.\n * @param {NodeModel} object - provide the row  value.\n * @private\n */\n\nexport function initGridColumns(columns, orientation, object) {\n  var totalWidth = 0;\n  var shape = object.shape;\n  var phaseOffset;\n  var cols;\n  var k;\n  var j;\n  var value;\n\n  if (shape.phases.length > 0 && shape.orientation === 'Horizontal') {\n    for (j = 0; j < shape.phases.length; j++) {\n      phaseOffset = shape.phases[j].offset;\n\n      if (j === 0) {\n        totalWidth += phaseOffset;\n      } else {\n        phaseOffset -= totalWidth;\n        totalWidth += phaseOffset;\n      }\n\n      cols = createColumn(phaseOffset);\n\n      if (j === shape.phases.length - 1 && totalWidth < object.width) {\n        cols.width += object.width - totalWidth;\n      }\n\n      columns.push(cols);\n    }\n  } else if (!orientation) {\n    value = shape.phaseSize && shape.phases.length > 0 ? shape.lanes.length + 1 : shape.lanes.length;\n\n    if (shape.phaseSize && shape.phases.length > 0) {\n      totalWidth += shape.phaseSize;\n      cols = createColumn(shape.phaseSize);\n      columns.push(cols);\n    }\n\n    for (k = 0; k < shape.lanes.length; k++) {\n      totalWidth += shape.lanes[k].width;\n      cols = createColumn(shape.lanes[k].width);\n\n      if (k === shape.lanes.length - 1 && totalWidth < object.width) {\n        cols.width += object.width - totalWidth;\n      }\n\n      columns.push(cols);\n    }\n\n    if (shape.phases.length === 0 && shape.lanes.length === 0) {\n      cols = createColumn(object.width);\n      columns.push(cols);\n    }\n  } else {\n    cols = createColumn(object.width);\n    columns.push(cols);\n  }\n}\n/**\n * getConnectors method \\\n *\n * @returns {void} getConnectors method .\\\n * @param {Diagram} diagram - provide the row  value.\n * @param {GridPanel} grid - provide the row  value.\n * @param {number} rowIndex - provide the row  value.\n * @param {boolean} isRowUpdate - provide the row  value.\n * @private\n */\n\nexport function getConnectors(diagram, grid, rowIndex, isRowUpdate) {\n  var connectors = [];\n  var conn = 0;\n  var childNode;\n  var node;\n  var k;\n  var i;\n  var j;\n  var canvas;\n  var row;\n  var length = grid.rowDefinitions().length;\n  var edges;\n\n  for (var i_1 = 0; i_1 < length; i_1++) {\n    row = grid.rows[i_1];\n\n    for (j = 0; j < row.cells.length; j++) {\n      canvas = row.cells[j].children[0];\n\n      if (canvas && canvas.children && canvas.children.length) {\n        for (k = 1; k < canvas.children.length; k++) {\n          childNode = canvas.children[k];\n          node = diagram.getObject(childNode.id);\n\n          if (node && (node.inEdges.length > 0 || node.outEdges.length > 0)) {\n            edges = node.inEdges.concat(node.outEdges);\n\n            for (conn = 0; conn < edges.length; conn++) {\n              if (connectors.indexOf(edges[conn]) === -1) {\n                connectors.push(edges[conn]);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return connectors;\n}\n/**\n * swimLaneMeasureAndArrange method \\\n *\n * @returns {void} swimLaneMeasureAndArrange method .\\\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\n\nexport function swimLaneMeasureAndArrange(obj) {\n  var canvas = obj.wrapper;\n  canvas.measure(new Size(obj.width, obj.height));\n\n  if (canvas.children[0] instanceof GridPanel) {\n    var grid = canvas.children[0];\n    var isMeasure = false;\n\n    if (grid.width && grid.width < grid.desiredSize.width) {\n      isMeasure = true;\n      grid.width = grid.desiredSize.width;\n    }\n\n    if (grid.height && grid.height < grid.desiredSize.height) {\n      isMeasure = true;\n      grid.height = grid.desiredSize.height;\n    }\n\n    if (isMeasure) {\n      grid.measure(new Size(grid.width, grid.height));\n    }\n  }\n\n  canvas.arrange(canvas.desiredSize);\n}\n/**\n * ChangeLaneIndex method \\\n *\n * @returns {void} ChangeLaneIndex method .\\\n * @param {Diagram} diagram - provide the row  value.\n * @param {NodeModel} obj - provide the row  value.\n * @param {number} startRowIndex - provide the row  value.\n * @private\n */\n\nexport function ChangeLaneIndex(diagram, obj, startRowIndex) {\n  var container = obj.wrapper.children[0];\n  var i;\n  var j;\n  var k;\n  var object;\n  var subChild;\n  var row;\n  var cell;\n  var child;\n\n  for (i = startRowIndex; i < container.rows.length; i++) {\n    row = container.rows[i];\n\n    for (j = 0; j < row.cells.length; j++) {\n      cell = row.cells[j];\n\n      if (cell.children && cell.children.length > 0) {\n        for (k = 0; k < cell.children.length; k++) {\n          child = cell.children[k];\n          object = diagram.nameTable[child.id];\n\n          if (object.isLane && child.children.length > 1) {\n            subChild = diagram.nameTable[child.children[1].id];\n\n            if (subChild && subChild.isLane) {\n              subChild.rowIndex = i;\n              subChild.columnIndex = j;\n            }\n          }\n\n          object.rowIndex = i;\n          object.columnIndex = j;\n        }\n      }\n    }\n  }\n}\n/**\n * arrangeChildNodesInSwimLane method \\\n *\n * @returns {void} arrangeChildNodesInSwimLane method .\\\n * @param {Diagram} diagram - provide the row  value.\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\n\nexport function arrangeChildNodesInSwimLane(diagram, obj) {\n  var grid = obj.wrapper.children[0];\n  var shape = obj.shape;\n  var padding = shape.padding;\n  var lanes = shape.lanes;\n  var top = grid.bounds.y;\n  var rowvalue;\n  var columnValue;\n  var phaseCount = shape.phaseSize > 0 ? shape.phases.length : 0;\n  var node;\n  var canvas;\n  var cell;\n  var i;\n  var j;\n  var k;\n  var orientation = shape.orientation === 'Horizontal' ? true : false;\n  var col = orientation ? shape.phases.length || 1 : lanes.length + 1;\n  var row = orientation ? (shape.header && shape.hasHeader ? 1 : 0) + (shape.phases.length > 0 ? 1 : 0) + shape.lanes.length : (shape.header && shape.hasHeader ? 1 : 0) + shape.phases.length;\n\n  if (phaseCount === 0 && !orientation && shape.lanes.length) {\n    row += 1;\n  }\n\n  if (orientation) {\n    rowvalue = (shape.header && shape.hasHeader ? 1 : 0) + (phaseCount > 0 ? 1 : 0);\n    columnValue = 0;\n  } else {\n    rowvalue = shape.header && shape.hasHeader ? 1 : 0;\n    columnValue = phaseCount > 0 ? 1 : 0;\n  }\n\n  if (lanes.length > 0) {\n    top += shape.header && shape.hasHeader ? shape.header.height : 0;\n\n    for (i = 0; i < lanes.length; i++) {\n      for (j = 0; j < lanes[i].children.length; j++) {\n        node = lanes[i].children[j];\n        node.offsetX = lanes[i].width;\n        node.offsetY = lanes[i].height;\n        diagram.initObject(node);\n        diagram.nodes.push(node);\n        canvas = node.wrapper;\n\n        if (orientation) {\n          for (k = columnValue; k < col; k++) {\n            cell = grid.rows[rowvalue].cells[k];\n\n            if (canvas.margin.left < cell.bounds.right - grid.bounds.x) {\n              node.parentId = cell.children[0].id;\n\n              if (k > columnValue) {\n                canvas.margin.left = canvas.margin.left - (cell.bounds.left - grid.bounds.left);\n              } else {\n                if (cell.children[0].children[1].actualSize.width + padding >= canvas.margin.left) {\n                  canvas.margin.left = cell.children[0].children[1].actualSize.width + padding;\n                }\n              }\n\n              if (canvas.margin.left < padding) {\n                canvas.margin.left = padding;\n              }\n\n              if (canvas.margin.top < padding) {\n                canvas.margin.top = padding;\n              }\n\n              addChildToLane(canvas, node, diagram);\n              break;\n            }\n          }\n        } else {\n          for (var k_1 = rowvalue; k_1 < row; k_1++) {\n            cell = grid.rows[k_1].cells[columnValue];\n\n            if (canvas.margin.top < cell.bounds.bottom - top) {\n              node.parentId = cell.children[0].id;\n\n              if (k_1 > rowvalue) {\n                canvas.margin.top = canvas.margin.top - (cell.bounds.top - top);\n              } else {\n                if (cell.children[0].children[1].actualSize.height + padding >= canvas.margin.top) {\n                  canvas.margin.top = cell.children[0].children[1].actualSize.height + padding;\n                }\n              }\n\n              if (canvas.margin.left < padding) {\n                canvas.margin.left = padding;\n              }\n\n              if (canvas.margin.top < padding) {\n                canvas.margin.top = padding;\n              }\n\n              addChildToLane(canvas, node, diagram);\n              break;\n            }\n          }\n        }\n      } // eslint-disable-next-line\n\n\n      orientation ? rowvalue++ : columnValue++;\n    }\n  }\n\n  grid.measure(new Size(obj.width, obj.height));\n  grid.arrange(grid.desiredSize);\n  updateChildOuterBounds(grid, obj);\n  obj.width = obj.wrapper.width = grid.width;\n  obj.height = obj.wrapper.height = grid.height;\n  updateHeaderMaxWidth(diagram, obj);\n  obj.wrapper.measure(new Size(obj.width, obj.height));\n  obj.wrapper.arrange(grid.desiredSize);\n  checkLaneChildrenOffset(obj);\n  checkPhaseOffset(obj, diagram);\n  checkLaneSize(obj);\n}\n/**\n * addChildToLane method \\\n *\n * @returns {void} addChildToLane method .\\\n * @param {Container} canvas - provide the row  value.\n * @param {NodeModel} node - provide the row  value.\n * @param {Diagram} diagram - provide the row  value.\n * @private\n */\n\nfunction addChildToLane(canvas, node, diagram) {\n  canvas.measure(new Size(node.width, node.height));\n  canvas.arrange(canvas.desiredSize);\n  var parent = diagram.getObject(node.parentId);\n  diagram.addChild(parent, node.id);\n}\n/**\n * updateChildOuterBounds method \\\n *\n * @returns {void} updateChildOuterBounds method .\\\n * @param {GridPanel} grid - provide the row  value.\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\n\n\nexport function updateChildOuterBounds(grid, obj) {\n  var columnDefinitions = grid.columnDefinitions();\n  var rowDefinitions = grid.rowDefinitions();\n  var i;\n  var k;\n  var j;\n  var cell;\n  var child;\n  var row;\n  var rowIndex = findStartLaneIndex(obj);\n\n  if (obj.shape.orientation === 'Vertical') {\n    if (rowIndex === 0) {\n      rowIndex = obj.shape.header && obj.shape.hasHeader ? 1 : 0;\n    }\n  }\n\n  var padding = obj.shape.padding;\n\n  for (i = 0; i < columnDefinitions.length; i++) {\n    grid.updateColumnWidth(i, columnDefinitions[i].width, true, padding);\n  }\n\n  for (i = rowIndex; i < rowDefinitions.length; i++) {\n    grid.updateRowHeight(i, rowDefinitions[i].height, true, padding);\n  }\n\n  for (k = 0; k < rowDefinitions.length; k++) {\n    row = grid.rows[k];\n\n    for (i = 0; i < columnDefinitions.length; i++) {\n      cell = row.cells[i];\n\n      if (cell.children && cell.children.length > 0) {\n        for (j = 0; j < cell.children.length; j++) {\n          child = cell.children[j];\n\n          if (child.maxWidth) {\n            child.maxWidth = cell.actualSize.width;\n          }\n\n          if (child.maxHeight) {\n            child.maxHeight = cell.actualSize.height;\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * checkLaneSize method \\\n *\n * @returns {void} checkLaneSize method .\\\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\n\nexport function checkLaneSize(obj) {\n  if (obj.shape.type === 'SwimLane' && !obj.shape.isLane && !obj.shape.isPhase) {\n    var lane = void 0;\n    var i = void 0;\n    var columns = void 0;\n    var size = void 0; //let laneCount: number = 0;\n\n    var lanes = obj.shape.lanes;\n    var laneIndex = findStartLaneIndex(obj);\n    var rows = obj.wrapper.children[0].rowDefinitions();\n\n    for (i = 0; i < lanes.length; i++, laneIndex++) {\n      lane = lanes[i];\n\n      if (obj.shape.orientation === 'Horizontal') {\n        size = rows[laneIndex].height;\n\n        if (lane.height !== size) {\n          lane.height = size;\n        }\n      } else {\n        columns = obj.wrapper.children[0].columnDefinitions();\n        size = columns[laneIndex].width;\n\n        if (lane.width !== size) {\n          lane.width = size;\n        }\n      }\n    }\n  }\n}\n/**\n * checkPhaseOffset method \\\n *\n * @returns {void} checkPhaseOffset method .\\\n * @param {NodeModel} obj - provide the obj  value.\n * @param {Diagram} diagram - provide the obj  value.\n * @private\n */\n\nexport function checkPhaseOffset(obj, diagram) {\n  var shape = obj.shape;\n  var phases = shape.phases;\n  var i;\n  var offset;\n  var phaseRow;\n  var phase;\n  var gridRowIndex = shape.header && shape.hasHeader ? 1 : 0;\n  var grid = obj.wrapper.children[0];\n  var top = grid.bounds.y + (shape.header && shape.hasHeader ? shape.header.height : 0);\n\n  if (obj.shape.type === 'SwimLane') {\n    obj = diagram.getObject(obj.id) || obj;\n\n    if (phases.length > 0) {\n      grid = obj.wrapper.children[0];\n\n      if (shape.orientation === 'Horizontal') {\n        phaseRow = shape.header && shape.hasHeader ? grid.rows[1] : grid.rows[0];\n\n        for (i = 0; i < phases.length; i++) {\n          phase = phaseRow.cells[i].children[0];\n          offset = phase.bounds.right - grid.bounds.x;\n\n          if (phases[i].offset !== offset) {\n            phases[i].offset = offset;\n          }\n\n          diagram.nameTable[phase.id].maxWidth = phase.maxWidth;\n        }\n      } else {\n        for (i = 0; i < phases.length; i++) {\n          phase = grid.rows[gridRowIndex + i].cells[0].children[0];\n          offset = phase.bounds.bottom - top;\n\n          if (phases[i].offset !== offset) {\n            phases[i].offset = offset;\n          }\n\n          diagram.nameTable[phase.id].maxWidth = phase.maxWidth;\n        }\n      }\n    }\n  }\n}\n/**\n * updateConnectorsProperties method \\\n *\n * @returns {void} checkPhaseOffset method .\\\n * @param {string[]} connectors - provide the obj  value.\n * @param {Diagram} diagram - provide the obj  value.\n * @private\n */\n\nexport function updateConnectorsProperties(connectors, diagram) {\n  if (connectors && connectors.length > 0) {\n    var edges = void 0;\n\n    if (diagram.lineRoutingModule && diagram.constraints & DiagramConstraints.LineRouting) {\n      diagram.lineRoutingModule.renderVirtualRegion(diagram, true);\n    }\n\n    for (var i = 0; i < connectors.length; i++) {\n      edges = diagram.getObject(connectors[i]);\n\n      if (diagram.lineRoutingModule && diagram.constraints & DiagramConstraints.LineRouting && edges.type === 'Orthogonal') {\n        diagram.lineRoutingModule.refreshConnectorSegments(diagram, edges, true);\n      } else {\n        diagram.connectorPropertyChange(edges, {}, {\n          sourceID: edges.sourceID,\n          targetID: edges.targetID\n        });\n      }\n    }\n  }\n}\n/**\n * laneInterChanged method \\\n *\n * @returns {void} laneInterChanged method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} obj - provide the obj  value.\n * @param {NodeModel} target - provide the target  value.\n * @param {PointModel} position - provide the position  value.\n * @private\n */\n\nexport function laneInterChanged(diagram, obj, target, position) {\n  var index;\n  var undoElement;\n  var entry;\n  var redoElement;\n  var sourceIndex;\n  var targetIndex;\n  var temp;\n  var sourceLaneIndex;\n  var targetLaneIndex;\n  var rowIndex;\n  var swimLane = diagram.getObject(obj.parentId);\n  var shape = swimLane.shape;\n  var grid = swimLane.wrapper.children[0];\n  var lanes = shape.lanes;\n  var connectors = getConnectors(diagram, grid, obj.rowIndex, true);\n\n  if (shape.orientation === 'Horizontal' && obj.rowIndex !== target.rowIndex || shape.orientation === 'Vertical' && obj.columnIndex !== target.columnIndex) {\n    if (shape.orientation === 'Horizontal') {\n      sourceIndex = obj.rowIndex;\n      targetIndex = target.rowIndex;\n      index = (shape.header && shape.hasHeader ? 1 : 0) + (shape.phases.length && shape.phaseSize ? 1 : 0);\n      sourceLaneIndex = obj.rowIndex - index;\n      targetLaneIndex = target.rowIndex - index;\n\n      if (lanes[sourceLaneIndex].canMove) {\n        if (sourceLaneIndex < targetLaneIndex) {\n          if (position && target.wrapper.offsetY > position.y) {\n            targetIndex += targetLaneIndex > 0 ? -1 : 1;\n            targetLaneIndex += targetLaneIndex > 0 ? -1 : 1;\n          }\n        } else {\n          if (position && target.wrapper.offsetY < position.y) {\n            targetIndex += 1;\n            targetLaneIndex += 1;\n          }\n        }\n\n        if (sourceIndex !== targetIndex) {\n          grid.updateRowIndex(sourceIndex, targetIndex);\n        }\n      }\n    } else {\n      sourceIndex = obj.columnIndex;\n      targetIndex = target.columnIndex;\n      index = shape.phases.length && shape.phaseSize ? 1 : 0;\n      sourceLaneIndex = obj.columnIndex - index;\n      targetLaneIndex = target.columnIndex - index;\n      rowIndex = shape.header && shape.hasHeader ? 1 : 0;\n\n      if (lanes[sourceLaneIndex].canMove) {\n        if (sourceLaneIndex < targetLaneIndex) {\n          if (position && target.wrapper.offsetX > position.x) {\n            targetIndex += targetLaneIndex > 0 ? -1 : 1;\n            targetLaneIndex += targetLaneIndex > 0 ? -1 : 1;\n          }\n        } else {\n          if (position && target.wrapper.offsetX < position.x) {\n            targetIndex += 1;\n            targetLaneIndex += 1;\n          }\n        }\n\n        if (sourceIndex !== targetIndex) {\n          if ((shape.phaseSize === 0 || shape.phases.length === 0) && (targetIndex === 0 || sourceIndex === 0)) {\n            if (shape.header && shape.hasHeader) {\n              var changeHeaderIndex = targetIndex === 0 ? sourceIndex : targetIndex;\n              grid.rows[0].cells[changeHeaderIndex].children = grid.rows[0].cells[0].children;\n              grid.rows[0].cells[changeHeaderIndex].columnSpan = grid.rows[0].cells[0].columnSpan;\n              grid.rows[0].cells[0].children = [];\n            }\n          }\n\n          grid.updateColumnIndex(0, sourceIndex, targetIndex);\n        }\n      }\n    }\n\n    if (sourceIndex !== targetIndex) {\n      temp = lanes[sourceLaneIndex];\n\n      if (temp.canMove) {\n        undoElement = {\n          target: cloneObject(target),\n          source: cloneObject(obj)\n        };\n        temp = lanes[sourceLaneIndex];\n        lanes.splice(sourceLaneIndex, 1);\n        lanes.splice(targetLaneIndex, 0, temp);\n        redoElement = {\n          target: cloneObject(undoElement.source),\n          source: cloneObject(undoElement.target)\n        };\n        entry = {\n          type: 'LanePositionChanged',\n          redoObject: redoElement,\n          undoObject: undoElement,\n          category: 'Internal'\n        };\n\n        if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n          diagram.commandHandler.addHistoryEntry(entry);\n        }\n\n        ChangeLaneIndex(diagram, swimLane, 0);\n        updateConnectorsProperties(connectors, diagram);\n        updateSwimLaneChildPosition(lanes, diagram);\n        swimLane.wrapper.measure(new Size(swimLane.width, swimLane.height));\n        swimLane.wrapper.arrange(swimLane.wrapper.desiredSize);\n        diagram.updateDiagramObject(swimLane);\n      }\n    }\n  }\n\n  diagram.updateDiagramElementQuad();\n}\n/**\n * updateSwimLaneObject method \\\n *\n * @returns {void} updateSwimLaneObject method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {Node} obj - provide the obj  value.\n * @param {NodeModel} swimLane - provide the target  value.\n * @param {NodeModel} helperObject - provide the position  value.\n * @private\n */\n\nexport function updateSwimLaneObject(diagram, obj, swimLane, helperObject) {\n  var parentNode = diagram.getObject(swimLane.id);\n  var shape = parentNode.shape;\n  var index = shape.header && shape.hasHeader ? 1 : 0;\n  var lanes = shape.lanes;\n  var phases = shape.phases;\n  var helperWidth = helperObject.wrapper.actualSize.width;\n  var helperHeight = helperObject.wrapper.actualSize.height;\n  var objWidth = obj.wrapper.actualSize.width;\n  var objHeight = obj.wrapper.actualSize.height;\n\n  if (parentNode.shape.type === 'SwimLane') {\n    if (shape.orientation === 'Horizontal') {\n      if (obj.isPhase) {\n        phases[obj.columnIndex].offset += helperWidth - objWidth;\n      } else {\n        index = shape.phaseSize && shape.phases.length > 0 ? index + 1 : index;\n        lanes[obj.rowIndex - index].height += helperHeight - objHeight;\n      }\n    } else {\n      if (obj.isPhase) {\n        phases[obj.rowIndex - index].offset += helperHeight - objHeight;\n      } else {\n        index = shape.phaseSize && shape.phases.length > 0 ? 1 : 0;\n        lanes[obj.columnIndex - index].width += helperWidth - objWidth;\n      }\n    }\n  }\n}\n/**\n * findLaneIndex method \\\n *\n * @returns {number} findLaneIndex method .\\\n * @param {NodeModel} swimLane - provide the diagram  value.\n * @param {NodeModel} laneObj - provide the obj  value.\n * @private\n */\n\nexport function findLaneIndex(swimLane, laneObj) {\n  var laneIndex;\n  var shape = swimLane.shape;\n  var index = shape.header && shape.hasHeader ? 1 : 0;\n\n  if (shape.orientation === 'Horizontal') {\n    index += shape.phases.length > 0 ? 1 : 0;\n    laneIndex = laneObj.rowIndex - index;\n  } else {\n    laneIndex = laneObj.columnIndex - (shape.phaseSize && shape.phases.length > 0 ? 1 : 0);\n  }\n\n  return laneIndex;\n}\n/**\n * findPhaseIndex method \\\n *\n * @returns {number} findPhaseIndex method .\\\n * @param {NodeModel} phase - provide the diagram  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @private\n */\n\nexport function findPhaseIndex(phase, swimLane) {\n  var shape = swimLane.shape;\n  var index = shape.header && shape.hasHeader ? 1 : 0;\n  var phaseIndex = shape.orientation === 'Horizontal' ? phase.columnIndex : phase.rowIndex - index;\n  return phaseIndex;\n}\n/**\n * findStartLaneIndex method \\\n *\n * @returns {number} findStartLaneIndex method .\\\n * @param {NodeModel} swimLane - provide the obj  value.\n * @private\n */\n\nexport function findStartLaneIndex(swimLane) {\n  var index = 0;\n  var shape = swimLane.shape;\n\n  if (shape.orientation === 'Horizontal') {\n    index = shape.header && shape.hasHeader ? 1 : 0;\n  }\n\n  if (shape.phases.length > 0 && shape.phaseSize) {\n    index += 1;\n  }\n\n  return index;\n}\n/**\n * updatePhaseMaxWidth method \\\n *\n * @returns {void} updatePhaseMaxWidth method .\\\n * @param {NodeModel} parent - provide the obj  value.\n * @param {Diagram} diagram - provide the obj  value.\n * @param {Canvas} wrapper - provide the obj  value.\n * @param {number} columnIndex - provide the obj  value.\n * @private\n */\n\nexport function updatePhaseMaxWidth(parent, diagram, wrapper, columnIndex) {\n  var shape = parent.shape;\n\n  if (shape.phases.length > 0) {\n    var node = diagram.nameTable[shape.phases[columnIndex].header.id];\n\n    if (node && node.maxWidth < wrapper.outerBounds.width) {\n      node.maxWidth = wrapper.outerBounds.width;\n      node.wrapper.maxWidth = wrapper.outerBounds.width;\n    }\n  }\n}\n/**\n * updateHeaderMaxWidth method \\\n *\n * @returns {void} updateHeaderMaxWidth method .\\\n * @param {NodeModel} diagram - provide the obj  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @private\n */\n\nexport function updateHeaderMaxWidth(diagram, swimLane) {\n  if (swimLane.shape.header && swimLane.shape.hasHeader) {\n    var grid = swimLane.wrapper.children[0];\n    var id = grid.rows[0].cells[0].children[0].id;\n    var headerNode = diagram.nameTable[id];\n\n    if (headerNode && headerNode.isHeader && headerNode.maxWidth < swimLane.width) {\n      headerNode.maxWidth = swimLane.width;\n      headerNode.wrapper.maxWidth = swimLane.width;\n    }\n  }\n}\n/**\n * addLane method \\\n *\n * @returns {void} addLane method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} parent - provide the obj  value.\n * @param {LaneModel} lane - provide the obj  value.\n * @param {number} count - provide the obj  value.\n * @private\n */\n\nexport function addLane(diagram, parent, lane, count) {\n  var args;\n  var swimLane = diagram.nameTable[parent.id];\n\n  if (swimLane.shape.type === 'SwimLane') {\n    diagram.protectPropertyChange(true);\n    var grid = swimLane.wrapper.children[0];\n    var bounds = grid.bounds;\n    var shape = swimLane.shape;\n    var redoObj = void 0;\n    var orientation_1 = false;\n    var entry = void 0;\n    var index = void 0;\n    var children = void 0;\n    var j = void 0;\n    var i = void 0;\n    var k = void 0;\n    var cell = void 0;\n    var child = void 0;\n    var point = void 0;\n    var laneObj = new Lane(shape, 'lanes', lane, true);\n    index = shape.header && shape.hasHeader ? 1 : 0;\n\n    if (shape.orientation === 'Horizontal') {\n      orientation_1 = true;\n      index = shape.phases.length > 0 ? index + 1 : index;\n    }\n\n    var connectors = getConnectors(diagram, grid, 0, true);\n    var laneIndex = count !== undefined ? count : shape.lanes.length;\n    index += laneIndex;\n    args = {\n      element: laneObj,\n      cause: diagram.diagramActions,\n      state: 'Changing',\n      type: 'Addition',\n      cancel: false,\n      laneIndex: laneIndex\n    };\n    diagram.triggerEvent(DiagramEvent.collectionChange, args);\n\n    if (!args.cancel) {\n      if (orientation_1) {\n        var rowDef = new RowDefinition();\n        rowDef.height = lane.height;\n        grid.addRow(index, rowDef, false);\n        swimLane.height = swimLane.height !== undefined ? swimLane.height + lane.height : swimLane.height;\n        swimLane.wrapper.height = grid.height = swimLane.height;\n      } else {\n        var colDef = new ColumnDefinition();\n        colDef.width = lane.width;\n        grid.addColumn(laneIndex + 1, colDef, false);\n\n        if (swimLane.width) {\n          swimLane.width += lane.width;\n          swimLane.wrapper.width = grid.width = swimLane.width;\n        }\n\n        if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n          grid.rows[0].cells[0].columnSpan += 1;\n        }\n      }\n\n      if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n        laneObj.id = laneObj.id === '' ? randomId() : laneObj.id;\n      }\n\n      if (count !== undefined) {\n        shape.lanes.splice(count, 0, laneObj);\n      } else {\n        shape.lanes.push(laneObj);\n      }\n\n      args = {\n        element: laneObj,\n        cause: diagram.diagramActions,\n        state: 'Changed',\n        type: 'Addition',\n        cancel: false,\n        laneIndex: laneIndex\n      };\n      diagram.triggerEvent(DiagramEvent.collectionChange, args);\n      laneCollection(grid, diagram, swimLane, index, laneIndex, orientation_1);\n      redoObj = shape.orientation === 'Horizontal' ? diagram.nameTable[grid.rows[index].cells[0].children[0].id] : shape.header && shape.hasHeader ? diagram.nameTable[grid.rows[1].cells[index].children[0].id] : diagram.nameTable[grid.rows[0].cells[index].children[0].id];\n\n      if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n        entry = {\n          type: 'LaneCollectionChanged',\n          changeType: 'Insert',\n          undoObject: cloneObject(laneObj),\n          redoObject: cloneObject(redoObj),\n          category: 'Internal'\n        };\n        diagram.addHistoryEntry(entry);\n      }\n\n      var startRowIndex = shape.orientation === 'Horizontal' ? index : shape.header && shape.hasHeader ? 1 : 0;\n      ChangeLaneIndex(diagram, swimLane, startRowIndex);\n      swimLaneMeasureAndArrange(swimLane);\n      updateHeaderMaxWidth(diagram, swimLane);\n      children = lane.children;\n\n      if (children && children.length > 0) {\n        for (j = 0; j < children.length; j++) {\n          child = children[j];\n          point = {\n            x: child.wrapper.offsetX,\n            y: child.wrapper.offsetY\n          };\n\n          if (shape.orientation === 'Horizontal') {\n            cell = grid.rows[index].cells[i];\n\n            for (i = 0; i < grid.rows[index].cells.length; i++) {\n              addChildNodeToNewLane(diagram, grid.rows[index].cells[i], point, child);\n            }\n          } else {\n            for (k = 0; k < grid.rows.length; k++) {\n              cell = grid.rows[k].cells[index];\n              addChildNodeToNewLane(diagram, cell, point, child);\n            }\n          }\n        }\n      }\n\n      updateConnectorsProperties(connectors, diagram);\n      diagram.drag(swimLane, bounds.x - grid.bounds.x, bounds.y - grid.bounds.y);\n    }\n\n    diagram.protectPropertyChange(false);\n  }\n}\n/**\n * addChildNodeToNewLane method \\\n *\n * @returns {void} addChildNodeToNewLane method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {GridCell} cell - provide the cell  value.\n * @param {PointModel} point - provide the point  value.\n * @param {NodeModel} child - provide the child  value.\n * @private\n */\n\nfunction addChildNodeToNewLane(diagram, cell, point, child) {\n  if (cell.children && cell.children.length > 0) {\n    var canvas = cell.children[0];\n    var parent_1 = diagram.nameTable[canvas.id];\n\n    if (canvas.bounds.containsPoint(point)) {\n      diagram.addChild(parent_1, child);\n    }\n  }\n}\n/**\n * addPhase method \\\n *\n * @returns {void} addPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} parent - provide the cell  value.\n * @param {PhaseModel} newPhase - provide the point  value.\n * @private\n */\n\n\nexport function addPhase(diagram, parent, newPhase) {\n  if (parent.shape.type === 'SwimLane') {\n    var gridRowIndex = void 0;\n    var gridColIndex = void 0;\n    var phaseNode = void 0;\n    var phase = void 0;\n    var previousPhase = void 0;\n    var nextPhase = void 0;\n    var phaseIndex = void 0;\n    var i = void 0;\n    var x = parent.wrapper.bounds.x;\n    var y = parent.wrapper.bounds.y;\n    var shape = parent.shape;\n    var padding = shape.padding;\n    var phasesCollection = shape.phases;\n    var width = void 0;\n    var grid = parent.wrapper.children[0];\n    var orientation_2 = shape.orientation === 'Horizontal' ? true : false;\n    gridRowIndex = shape.header && shape.hasHeader ? 0 : -1;\n\n    if (shape.phases.length > 0) {\n      gridRowIndex += 1;\n      gridColIndex = 0;\n    }\n\n    var laneHeaderSize = orientation_2 ? shape.lanes[0].header.width : shape.lanes[0].header.height;\n\n    if (newPhase.offset > laneHeaderSize) {\n      for (i = 0; i < phasesCollection.length; i++) {\n        phase = phasesCollection[i];\n        previousPhase = i > 0 ? phasesCollection[i - 1] : phase;\n\n        if (phase.offset > newPhase.offset) {\n          width = i > 0 ? newPhase.offset - previousPhase.offset : newPhase.offset;\n\n          if (orientation_2) {\n            var nextCol = grid.columnDefinitions()[i];\n            nextCol.width -= width;\n            nextPhase = diagram.nameTable[shape.phases[i].header.id];\n            nextPhase.maxWidth = nextPhase.wrapper.maxWidth = nextCol.width;\n            grid.updateColumnWidth(i, nextCol.width, false);\n            var addPhase_1 = new ColumnDefinition();\n            addPhase_1.width = width;\n            phaseIndex = i;\n            grid.addColumn(i, addPhase_1, false);\n            break;\n          } else {\n            var nextRow = grid.rowDefinitions()[i + gridRowIndex];\n            nextRow.height -= width;\n            nextPhase = diagram.nameTable[shape.phases[i].header.id];\n            grid.updateRowHeight(i + gridRowIndex, nextRow.height, false);\n            var addPhase_2 = new RowDefinition();\n            addPhase_2.height = width;\n            phaseIndex = i;\n            grid.addRow(i + gridRowIndex, addPhase_2, false);\n            break;\n          }\n        }\n      }\n\n      if (diagram.diagramActions & DiagramAction.UndoRedo && phaseIndex === undefined) {\n        var entry = diagram.historyManager.currentEntry.next;\n\n        if (entry.isLastPhase) {\n          phaseIndex = phasesCollection.length;\n          addLastPhase(phaseIndex, parent, entry, grid, orientation_2, newPhase);\n        }\n      }\n\n      var phaseObj = new Phase(parent.shape, 'phases', newPhase, true);\n\n      if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n        phaseObj.id += randomId();\n      }\n\n      shape.phases.splice(phaseIndex, 0, phaseObj);\n      phaseDefine(grid, diagram, parent, gridRowIndex, orientation_2, phaseIndex);\n\n      if (orientation_2) {\n        phaseNode = diagram.nameTable[grid.rows[gridRowIndex].cells[phaseIndex].children[0].id];\n\n        if (phaseIndex === 0 && shape.header && shape.hasHeader) {\n          grid.rows[0].cells[0].children = grid.rows[0].cells[1].children;\n          grid.rows[0].cells[1].children = [];\n          var fristRow = grid.rows[0];\n\n          for (var i_2 = 0; i_2 < fristRow.cells.length; i_2++) {\n            fristRow.cells[i_2].minWidth = undefined;\n\n            if (i_2 === 0) {\n              fristRow.cells[i_2].columnSpan = grid.rows[0].cells.length;\n            } else {\n              fristRow.cells[i_2].columnSpan = 1;\n            }\n          }\n        }\n\n        addHorizontalPhase(diagram, parent, grid, phaseIndex, orientation_2);\n        var col = grid.columnDefinitions();\n        grid.updateColumnWidth(phaseIndex, col[phaseIndex].width, true, padding);\n        phaseNode.maxWidth = phaseNode.wrapper.maxWidth = col[phaseIndex].width;\n\n        if (col.length > phaseIndex + 1) {\n          var nextPhaseNode = diagram.nameTable[grid.rows[gridRowIndex].cells[phaseIndex + 1].children[0].id];\n          grid.updateColumnWidth(phaseIndex + 1, col[phaseIndex + 1].width, true, padding);\n          nextPhaseNode.maxWidth = nextPhaseNode.wrapper.maxWidth = col[phaseIndex + 1].width;\n        }\n\n        parent.width = parent.wrapper.width = parent.wrapper.children[0].width = grid.width;\n      } else {\n        phaseNode = diagram.nameTable[grid.rows[gridRowIndex + phaseIndex].cells[0].children[0].id];\n        var row = grid.rowDefinitions();\n        var size = row[gridRowIndex + phaseIndex].height;\n        addVerticalPhase(diagram, parent, grid, gridRowIndex + phaseIndex, orientation_2);\n        grid.updateRowHeight(gridRowIndex + phaseIndex, size, true, padding);\n\n        if (row.length > gridRowIndex + phaseIndex + 1) {\n          size = row[gridRowIndex + phaseIndex + 1].height;\n          grid.updateRowHeight(gridRowIndex + phaseIndex + 1, size, true, padding);\n        }\n\n        parent.height = parent.wrapper.height = parent.wrapper.children[0].height = grid.actualSize.height;\n      }\n\n      swimLaneMeasureAndArrange(parent);\n      parent.width = parent.wrapper.actualSize.width;\n      updateHeaderMaxWidth(diagram, parent);\n      diagram.drag(parent, x - parent.wrapper.bounds.x, y - parent.wrapper.bounds.y);\n      checkPhaseOffset(parent, diagram);\n\n      if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n        var entry = {\n          type: 'PhaseCollectionChanged',\n          changeType: 'Insert',\n          undoObject: cloneObject(phaseObj),\n          redoObject: cloneObject(phaseNode),\n          category: 'Internal'\n        };\n        diagram.addHistoryEntry(entry);\n      }\n\n      diagram.updateDiagramObject(parent);\n    }\n  }\n}\n/**\n * addLastPhase method \\\n *\n * @returns {void} addLastPhase method .\\\n * @param {number} phaseIndex - provide the diagram  value.\n * @param {NodeModel} parent - provide the cell  value.\n * @param {HistoryEntry} entry - provide the point  value.\n * @param {GridPanel} grid - provide the grid  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @param {PhaseModel} newPhase - provide the newPhase  value.\n * @private\n */\n\nexport function addLastPhase(phaseIndex, parent, entry, grid, orientation, newPhase) {\n  var shape = parent.shape;\n  var prevPhase = shape.phases[phaseIndex - 2];\n  var prevOffset = entry.previousPhase.offset;\n\n  if (orientation) {\n    var nextCol = grid.columnDefinitions()[phaseIndex - 1];\n    var addPhase_3 = new ColumnDefinition();\n\n    if (phaseIndex > 1) {\n      addPhase_3.width = nextCol.width - (prevOffset - prevPhase.offset);\n      nextCol.width = prevOffset - prevPhase.offset;\n    } else {\n      addPhase_3.width = nextCol.width - prevOffset;\n      nextCol.width = prevOffset;\n    }\n\n    grid.updateColumnWidth(phaseIndex - 1, nextCol.width, false);\n    grid.addColumn(phaseIndex, addPhase_3, false);\n  } else {\n    var nextCol = grid.rowDefinitions()[phaseIndex];\n    var addPhase_4 = new RowDefinition();\n\n    if (phaseIndex > 1) {\n      addPhase_4.height = entry.undoObject.offset - prevOffset;\n      nextCol.height = prevOffset - prevPhase.offset;\n    } else {\n      addPhase_4.height = nextCol.height - prevOffset;\n      nextCol.height = prevOffset;\n    }\n\n    grid.updateRowHeight(phaseIndex, nextCol.height, false);\n    grid.addRow(1 + phaseIndex, addPhase_4, false);\n  }\n}\n/**\n * addHorizontalPhase method \\\n *\n * @returns {void} addHorizontalPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the cell  value.\n * @param {GridPanel} grid - provide the point  value.\n * @param {number} index - provide the point  value.\n * @param {boolean} orientation - provide the point  value.\n * @private\n */\n\nexport function addHorizontalPhase(diagram, node, grid, index, orientation) {\n  var shape = node.shape;\n  var nextCell;\n  var i;\n  var prevCell;\n  var gridCell;\n  var row;\n  var laneIndex = findStartLaneIndex(node);\n\n  if (shape.header && shape.hasHeader) {\n    grid.rows[0].cells[0].columnSpan = grid.rows[0].cells.length;\n  }\n\n  for (i = laneIndex; i < grid.rows.length; i++) {\n    row = grid.rows[i];\n    prevCell = row.cells[index - 1];\n    gridCell = row.cells[index];\n    nextCell = row.cells[index + 1];\n    addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, i, index);\n  }\n\n  ChangeLaneIndex(diagram, node, 1);\n}\n/**\n * addVerticalPhase method \\\n *\n * @returns {void} addVerticalPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the cell  value.\n * @param {GridPanel} grid - provide the point  value.\n * @param {number} rowIndex - provide the point  value.\n * @param {boolean} orientation - provide the point  value.\n * @private\n */\n\nexport function addVerticalPhase(diagram, node, grid, rowIndex, orientation) {\n  var prevCell;\n  var gridCell;\n  var nextCell;\n  var row = grid.rows[rowIndex];\n  var nextRow = grid.rows[rowIndex + 1];\n  var prevRow = grid.rows[rowIndex - 1];\n\n  for (var i = 1; i < row.cells.length; i++) {\n    gridCell = row.cells[i];\n    nextCell = nextRow ? nextRow.cells[i] : undefined;\n    prevCell = prevRow.cells[i];\n    addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, rowIndex, i);\n  }\n\n  ChangeLaneIndex(diagram, node, 1);\n}\n/**\n * addSwimlanePhases method \\\n *\n * @returns {void} addSwimlanePhases method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the node  value.\n * @param {GridPanel} prevCell - provide the prevCell  value.\n * @param {number} gridCell - provide the gridCell  value.\n * @param {boolean} nextCell - provide the nextCell  value.\n * @param {boolean} rowIndex - provide the rowIndex  value.\n * @param {boolean} columnIndex - provide the columnIndex  value.\n * @private\n */\n\nfunction addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, rowIndex, columnIndex) {\n  var x;\n  var y;\n  var shape = node.shape;\n  var orientation = shape.orientation === 'Horizontal' ? true : false;\n  var grid = node.wrapper.children[0];\n  var width = gridCell.desiredCellWidth;\n  var height = gridCell.desiredCellHeight; //const col: number = (orientation) ? rowIndex : columnIndex;\n  //let parentWrapper: Container;\n\n  var j;\n  var i = orientation ? rowIndex : columnIndex;\n\n  if (prevCell) {\n    x = orientation ? prevCell.bounds.x + prevCell.bounds.width : prevCell.bounds.x;\n    y = orientation ? prevCell.bounds.y : prevCell.bounds.y + prevCell.bounds.height;\n  } else {\n    x = grid.bounds.x;\n    y = nextCell.bounds.y;\n  }\n\n  var rect = new Rect(x, y, width, height);\n  var canvas = {\n    id: node.id + (orientation ? shape.lanes[i - 2] : shape.lanes[i - 1]).id + randomId()[0],\n    rowIndex: rowIndex,\n    columnIndex: columnIndex,\n    width: gridCell.minWidth,\n    height: gridCell.minHeight,\n    style: (orientation ? shape.lanes[i - 2] : shape.lanes[i - 1]).style,\n    constraints: NodeConstraints.Default | NodeConstraints.AllowDrop,\n    container: {\n      type: 'Canvas',\n      orientation: orientation ? 'Horizontal' : 'Vertical'\n    }\n  };\n  var parentWrapper = addObjectToGrid(diagram, grid, node, canvas, false, false, true);\n  parentWrapper.children[0].isCalculateDesiredSize = false;\n  grid.addObject(parentWrapper, rowIndex, columnIndex);\n\n  if (nextCell && nextCell.children && nextCell.children.length) {\n    for (j = 0; j < nextCell.children.length; j++) {\n      if (orientation) {\n        diagram.nameTable[nextCell.children[j].id].columnIndex += 1;\n      } else {\n        diagram.nameTable[nextCell.children[j].id].rowIndex += 1;\n      }\n    }\n  }\n\n  arrangeChildInGrid(diagram, nextCell, gridCell, rect, parentWrapper, orientation, prevCell);\n}\n/**\n * arrangeChildInGrid method \\\n *\n * @returns {void} arrangeChildInGrid method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {GridCell} nextCell - provide the nextCell  value.\n * @param {GridPanel} gridCell - provide the gridCell  value.\n * @param {Rect} rect - provide the rect  value.\n * @param {Container} parentWrapper - provide the parentWrapper  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @param {GridCell} prevCell - provide the prevCell  value.\n * @private\n */\n\n\nexport function arrangeChildInGrid(diagram, nextCell, gridCell, rect, parentWrapper, orientation, prevCell) {\n  var child;\n  var point;\n  var childNode;\n  var parent = diagram.nameTable[parentWrapper.id];\n  var changeCell = !nextCell ? prevCell : nextCell;\n  var swimLane = diagram.nameTable[parent.parentId];\n  var padding = swimLane.shape.padding;\n\n  if (changeCell.children && changeCell.children[0].children.length > 1) {\n    for (var j = 1; j < changeCell.children[0].children.length; j++) {\n      child = changeCell.children[0].children[j];\n      childNode = diagram.nameTable[child.id];\n      point = orientation ? {\n        x: child.bounds.x,\n        y: child.bounds.center.y\n      } : {\n        x: child.bounds.center.x,\n        y: child.bounds.top\n      };\n\n      if (rect.containsPoint(point)) {\n        gridCell.children[0].children.push(child);\n        changeCell.children[0].children.splice(j, 1);\n        j--;\n        diagram.deleteChild(childNode);\n\n        if (!childNode.isLane) {\n          childNode.parentId = parentWrapper.id;\n        }\n\n        if (!parent.children) {\n          parent.children = [];\n        }\n\n        if (!nextCell) {\n          if (orientation) {\n            childNode.margin.left = childNode.wrapper.bounds.x - changeCell.children[0].bounds.right;\n          } else {\n            childNode.margin.top = childNode.wrapper.bounds.y - changeCell.children[0].bounds.bottom;\n          }\n        }\n\n        parent.children.push(child.id);\n        childNode.zIndex = parent.zIndex + 1;\n        diagram.removeElements(childNode);\n      } else if (nextCell) {\n        if (orientation) {\n          childNode.margin.left -= gridCell.desiredCellWidth;\n\n          if (padding > childNode.margin.left) {\n            childNode.margin.left = padding;\n          }\n        } else {\n          childNode.margin.top -= gridCell.desiredCellHeight;\n\n          if (padding > childNode.margin.top) {\n            childNode.margin.top = padding;\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * swimLaneSelection method \\\n *\n * @returns {void} swimLaneSelection method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the node  value.\n * @param {string} corner - provide the corner  value.\n * @private\n */\n\nexport function swimLaneSelection(diagram, node, corner) {\n  if (node.shape.type === 'SwimLane' && (corner === 'ResizeSouth' || corner === 'ResizeEast')) {\n    var shape = node.shape;\n    var wrapper = node.wrapper.children[0];\n    var child = void 0;\n    var index = void 0;\n\n    if (corner === 'ResizeSouth') {\n      if (shape.orientation === 'Vertical') {\n        child = wrapper.rows[wrapper.rows.length - 1].cells[0];\n      } else {\n        index = wrapper.rows.length - 1;\n        child = wrapper.rows[index].cells[wrapper.rows[index].cells.length - 1];\n      }\n    } else {\n      index = shape.header && shape.hasHeader ? 1 : 0;\n      child = wrapper.rows[index].cells[wrapper.rows[index].cells.length - 1];\n    }\n\n    diagram.commandHandler.select(diagram.nameTable[child.children[0].id]);\n  }\n}\n/**\n * pasteSwimLane method \\\n *\n * @returns {void} pasteSwimLane method .\\\n * @param {Diagram} swimLane - provide the diagram  value.\n * @param {NodeModel} diagram - provide the diagram  value.\n * @param {string} clipboardData - provide the clipboardData  value.\n * @param {string} laneNode - provide the laneNode  value.\n * @param {string} isLane - provide the isLane  value.\n * @param {string} isUndo - provide the isUndo  value.\n * @private\n */\n\nexport function pasteSwimLane(swimLane, diagram, clipboardData, laneNode, isLane, isUndo) {\n  var i;\n  var j;\n  var lane;\n  var phase;\n  var node;\n  var ranId = randomId();\n  var cloneLane;\n  var childX;\n  var childY;\n  var shape = swimLane.shape; //let lanes: LaneModel[];\n\n  var phases = shape.phases;\n  var nodeX = swimLane.offsetX - swimLane.wrapper.actualSize.width / 2;\n  var nodeY = swimLane.offsetY - swimLane.wrapper.actualSize.height / 2;\n\n  if (shape.orientation === 'Vertical') {\n    nodeY += shape.header && shape.hasHeader ? shape.header.height : 0;\n  }\n\n  if (!isUndo) {\n    if (!isLane) {\n      swimLane.id += ranId;\n\n      if (shape && shape.header && shape.hasHeader) {\n        shape.header.id += ranId;\n      } else {\n        shape.header = undefined;\n      }\n    }\n\n    for (i = 0; phases && i < phases.length; i++) {\n      phase = phases[i];\n      phase.id += ranId;\n    }\n  }\n\n  var lanes = isLane ? [clipboardData.childTable[laneNode.id]] : shape.lanes;\n\n  for (i = 0; lanes && i < lanes.length; i++) {\n    lane = lanes[i];\n\n    if (!isUndo) {\n      lane.id += ranId;\n    }\n\n    for (j = 0; lane.children && j < lane.children.length; j++) {\n      node = lane.children[j];\n      childX = node.wrapper.offsetX - node.width / 2;\n      childY = node.wrapper.offsetY - node.height / 2;\n      node.zIndex = -1;\n      node.inEdges = node.outEdges = [];\n\n      if (isUndo || clipboardData && (clipboardData.pasteIndex === 1 || clipboardData.pasteIndex === 0)) {\n        if (shape.orientation === 'Vertical') {\n          node.margin.top = childY - nodeY;\n        } else {\n          node.margin.left = childX - nodeX;\n        }\n      }\n\n      if (!isUndo) {\n        node.id += ranId;\n      }\n    }\n  }\n\n  if (!isUndo) {\n    if (isLane) {\n      var newShape = {\n        lanes: lanes,\n        phases: phases,\n        phaseSize: shape.phaseSize,\n        type: 'SwimLane',\n        orientation: shape.orientation,\n        header: {\n          annotation: {\n            content: 'Title'\n          },\n          height: 50\n        }\n      };\n      cloneLane = {\n        shape: newShape\n      };\n\n      if (shape.orientation === 'Horizontal') {\n        cloneLane.width = swimLane.wrapper.actualSize.width;\n        cloneLane.height = laneNode.wrapper.actualSize.height + shape.header.height + shape.phaseSize;\n        cloneLane.offsetX = swimLane.wrapper.offsetX + clipboardData.pasteIndex * 10;\n        cloneLane.offsetY = laneNode.wrapper.offsetY + clipboardData.pasteIndex * 10;\n      } else {\n        cloneLane.width = laneNode.wrapper.actualSize.width;\n        cloneLane.height = swimLane.wrapper.actualSize.height;\n        cloneLane.offsetX = laneNode.wrapper.offsetX + clipboardData.pasteIndex * 10;\n        cloneLane.offsetY = swimLane.wrapper.offsetY + clipboardData.pasteIndex * 10;\n      }\n\n      swimLane = cloneLane;\n    }\n\n    if (clipboardData.pasteIndex !== 0) {\n      swimLane.offsetX += 10;\n      swimLane.offsetY += 10;\n    }\n\n    swimLane.zIndex = -1;\n    swimLane = diagram.add(swimLane);\n\n    if (!isLane) {\n      for (var _i = 0, _a = Object.keys(clipboardData.childTable); _i < _a.length; _i++) {\n        var i_3 = _a[_i];\n        var connector = clipboardData.childTable[i_3];\n        connector.id += ranId;\n        connector.sourceID += ranId;\n        connector.targetID += ranId;\n        connector.zIndex = -1;\n        diagram.add(connector);\n      }\n    }\n\n    if (diagram.mode !== 'SVG') {\n      diagram.refreshDiagramLayer();\n    }\n\n    diagram.select([swimLane]);\n  }\n\n  return swimLane;\n}\n/**\n * gridSelection method \\\n *\n * @returns {void} gridSelection method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {SelectorModel} selectorModel - provide the selectorModel  value.\n * @param {string} id - provide the id  value.\n * @param {boolean} isSymbolDrag - provide the isSymbolDrag  value.\n * @private\n */\n\nexport function gridSelection(diagram, selectorModel, id, isSymbolDrag) {\n  var canvas;\n  var node = selectorModel.nodes[0];\n\n  if (isSymbolDrag || checkParentAsContainer(diagram, node, true)) {\n    var targetnode = void 0;\n    var bounds = void 0;\n    var swimLaneId = void 0;\n    var element = new DiagramElement();\n\n    if (id) {\n      swimLaneId = diagram.nameTable[id].parentId;\n      targetnode = node = diagram.nameTable[id];\n    }\n\n    var wrapper = !id ? node.wrapper : targetnode.wrapper;\n    var parentNode = diagram.nameTable[swimLaneId || node.parentId];\n\n    if (parentNode && parentNode.container.type === 'Grid') {\n      canvas = new Canvas();\n      canvas.children = [];\n\n      if (isSymbolDrag || !node.isHeader) {\n        if (parentNode.container.orientation === 'Horizontal' && node.isPhase || parentNode.container.orientation === 'Vertical' && (node.rowIndex > 0 && node.columnIndex > 0 || node.isLane)) {\n          bounds = findBounds(parentNode, targetnode ? targetnode.columnIndex : node.columnIndex, parentNode.shape.header && parentNode.shape.hasHeader ? true : false);\n          canvas.offsetX = bounds.center.x;\n          canvas.offsetY = bounds.center.y;\n          element.width = bounds.width;\n          element.height = bounds.height;\n        } else {\n          canvas.offsetX = parentNode.offsetX;\n          canvas.offsetY = wrapper.offsetY;\n          element.width = parentNode.wrapper.actualSize.width;\n          element.height = wrapper.actualSize.height;\n        }\n      }\n\n      canvas.children.push(element);\n      canvas.measure(new Size());\n      canvas.arrange(canvas.desiredSize);\n    }\n  }\n\n  return canvas;\n}\n/**\n * removeLaneChildNode method \\\n *\n * @returns {void} removeLaneChildNode method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} swimLaneNode - provide the diagram  value.\n * @param {NodeModel} currentObj - provide the currentObj  value.\n * @param {NodeModel} isChildNode - provide the isChildNode  value.\n * @param {number} laneIndex - provide the laneIndex  value.\n * @private\n */\n\nexport function removeLaneChildNode(diagram, swimLaneNode, currentObj, isChildNode, laneIndex) {\n  laneIndex = laneIndex !== undefined ? laneIndex : findLaneIndex(swimLaneNode, currentObj);\n  var preventHistory = false;\n  var lanenode = swimLaneNode.shape.lanes[laneIndex];\n\n  for (var j = lanenode.children.length - 1; j >= 0; j--) {\n    if (isChildNode) {\n      if (isChildNode.id === lanenode.children[j].id) {\n        lanenode.children.splice(j, 1);\n      }\n    } else {\n      diagram.removeDependentConnector(lanenode.children[j]);\n\n      if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n        diagram.diagramActions = diagram.diagramActions | DiagramAction.UndoRedo;\n        preventHistory = true;\n      }\n\n      diagram.remove(lanenode.children[j]);\n      lanenode.children.splice(j, 1);\n\n      if (preventHistory) {\n        diagram.diagramActions = diagram.diagramActions & ~DiagramAction.UndoRedo;\n      }\n    }\n  }\n}\n/**\n * getGridChildren method \\\n *\n * @returns {DiagramElement} getGridChildren method .\\\n * @param {Diagram} obj - provide the obj  value.\n * @private\n */\n\nexport function getGridChildren(obj) {\n  var children = obj.children[0];\n  return children;\n}\n/**\n * removeSwimLane method \\\n *\n * @returns {void} removeSwimLane method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} obj - provide the obj  value.\n * @private\n */\n\nexport function removeSwimLane(diagram, obj) {\n  var rows = obj.wrapper.children[0].rows; //let preventHistory: boolean = false;\n\n  var node;\n  var i;\n  var j;\n  var k;\n  var child;\n  var removeNode;\n\n  for (i = 0; i < rows.length; i++) {\n    for (j = 0; j < rows[i].cells.length; j++) {\n      child = getGridChildren(rows[i].cells[j]);\n\n      if (child && child.children) {\n        for (k = child.children.length - 1; k >= 0; k--) {\n          if (child.children[k].children) {\n            removeNode = diagram.nameTable[child.children[k].id];\n\n            if (removeNode) {\n              if (removeNode.isLane) {\n                deleteNode(diagram, removeNode);\n              } else {\n                diagram.removeDependentConnector(removeNode);\n                diagram.diagramActions |= DiagramAction.PreventHistory;\n\n                if (removeNode.constraints & NodeConstraints.Delete) {\n                  diagram.remove(removeNode);\n                } else {\n                  removeChildInContainer(diagram, removeNode, {}, false);\n                }\n\n                diagram.diagramActions &= ~DiagramAction.PreventHistory;\n              }\n            }\n          }\n        }\n      }\n\n      if (child) {\n        node = diagram.nameTable[child.id];\n\n        if (node) {\n          deleteNode(diagram, node);\n        }\n      }\n    }\n  }\n}\n/**\n * deleteNode method \\\n *\n * @returns {void} deleteNode method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} node - provide the obj  value.\n * @private\n */\n\nfunction deleteNode(diagram, node) {\n  diagram.nodes.splice(diagram.nodes.indexOf(node), 1);\n  diagram.removeFromAQuad(node);\n  diagram.removeObjectsFromLayer(node);\n  delete diagram.nameTable[node.id];\n  diagram.removeElements(node);\n}\n/**\n * removeLane method \\\n *\n * @returns {void} removeLane method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} lane - provide the obj  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @param {LaneModel} lanes - provide the obj  value.\n * @private\n */\n\n\nexport function removeLane(diagram, lane, swimLane, lanes) {\n  var args;\n\n  if (swimLane.shape.type === 'SwimLane') {\n    var shape = swimLane.shape;\n    var laneIndex = void 0;\n\n    if (shape.lanes.length === 1) {\n      diagram.remove(swimLane);\n    } else {\n      var x = swimLane.wrapper.bounds.x;\n      var y = swimLane.wrapper.bounds.y;\n      var row = void 0;\n      var i = void 0;\n      var cell = void 0;\n      var j = void 0;\n      var child = void 0;\n      var grid = swimLane.wrapper.children[0];\n      laneIndex = lanes ? shape.lanes.indexOf(lanes) : findLaneIndex(swimLane, lane);\n      args = {\n        element: lane,\n        cause: diagram.diagramActions,\n        state: 'Changing',\n        type: 'Removal',\n        cancel: false,\n        laneIndex: laneIndex\n      };\n      diagram.triggerEvent(DiagramEvent.collectionChange, args);\n\n      if (!args.cancel) {\n        var undoObj = cloneObject(shape.lanes[laneIndex]);\n        removeLaneChildNode(diagram, swimLane, lane, undefined, laneIndex);\n\n        if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n          var entry = {\n            type: 'LaneCollectionChanged',\n            changeType: 'Remove',\n            undoObject: undoObj,\n            redoObject: cloneObject(lane),\n            category: 'Internal'\n          };\n          diagram.addHistoryEntry(entry);\n        }\n\n        shape.lanes.splice(laneIndex, 1);\n        var index = lane ? shape.orientation === 'Horizontal' ? lane.rowIndex : lane.columnIndex : findStartLaneIndex(swimLane) + laneIndex;\n\n        if (shape.orientation === 'Horizontal') {\n          row = grid.rows[index];\n\n          for (i = 0; i < row.cells.length; i++) {\n            cell = row.cells[i];\n\n            if (cell && cell.children.length > 0) {\n              for (j = 0; j < cell.children.length; j++) {\n                child = cell.children[j];\n                removeChildren(diagram, child);\n              }\n            }\n          }\n\n          grid.removeRow(index);\n        } else {\n          swimLane.width = swimLane.width !== undefined ? swimLane.width - grid.rows[0].cells[index].actualSize.width : swimLane.width;\n\n          for (i = 0; i < grid.rows.length; i++) {\n            cell = grid.rows[i].cells[index];\n\n            if (cell && cell.children.length > 0) {\n              for (j = 0; j < cell.children.length; j++) {\n                child = cell.children[j];\n                removeChildren(diagram, child);\n              }\n            }\n          }\n\n          grid.removeColumn(index);\n        }\n\n        args = {\n          element: lane,\n          cause: diagram.diagramActions,\n          state: 'Changed',\n          type: 'Removal',\n          cancel: false,\n          laneIndex: laneIndex\n        };\n        diagram.triggerEvent(DiagramEvent.collectionChange, args);\n        swimLane.width = swimLane.wrapper.width = grid.width;\n        swimLane.height = swimLane.wrapper.height = grid.height;\n        swimLaneMeasureAndArrange(swimLane);\n\n        if (swimLane.shape.orientation === 'Vertical') {\n          index = 0;\n        }\n\n        ChangeLaneIndex(diagram, swimLane, index);\n        diagram.drag(swimLane, x - swimLane.wrapper.bounds.x, y - swimLane.wrapper.bounds.y);\n        diagram.updateDiagramObject(swimLane);\n      }\n    }\n  }\n}\n/**\n * removeChildren method \\\n *\n * @returns {void} removeChildren method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {Canvas} canvas - provide the obj  value.\n * @private\n */\n\nexport function removeChildren(diagram, canvas) {\n  var i;\n  var node;\n\n  if (canvas instanceof Canvas) {\n    if (canvas.children.length > 0) {\n      for (i = 0; i < canvas.children.length; i++) {\n        if (canvas.children[i] instanceof Canvas) {\n          removeChildren(diagram, canvas.children[i]);\n        }\n      }\n    }\n\n    node = diagram.getObject(canvas.id);\n    deleteNode(diagram, node);\n  }\n}\n/**\n * removePhase method \\\n *\n * @returns {void} removePhase method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} phase - provide the obj  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @param {PhaseModel} swimLanePhases - provide the obj  value.\n * @private\n */\n\nexport function removePhase(diagram, phase, swimLane, swimLanePhases) {\n  diagram.protectPropertyChange(true);\n  var x = swimLane.wrapper.bounds.x;\n  var y = swimLane.wrapper.bounds.y;\n  var isLastPhase = false;\n  var previousPhase;\n  var shape = swimLane.shape;\n  var grid = swimLane.wrapper.children[0];\n  var phaseIndex = swimLanePhases ? shape.phases.indexOf(swimLanePhases) : findPhaseIndex(phase, swimLane);\n  var phaseLength = shape.phases.length;\n\n  if (shape.phases.length > 1) {\n    if (phaseIndex === phaseLength - 1) {\n      isLastPhase = true;\n      previousPhase = cloneObject(shape.phases[phaseIndex - 1]);\n    }\n\n    var undoObj = cloneObject(shape.phases[phaseIndex]);\n    shape.phases.splice(phaseIndex, 1);\n\n    if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n      var entry = {\n        type: 'PhaseCollectionChanged',\n        changeType: 'Remove',\n        undoObject: undoObj,\n        previousPhase: previousPhase,\n        redoObject: cloneObject(phase),\n        category: 'Internal',\n        isLastPhase: isLastPhase\n      };\n      diagram.addHistoryEntry(entry);\n    }\n\n    if (shape.orientation === 'Horizontal') {\n      removeHorizontalPhase(diagram, grid, phase, phaseIndex);\n    } else {\n      removeVerticalPhase(diagram, grid, phase, phaseIndex, swimLane);\n    }\n\n    updateHeaderMaxWidth(diagram, swimLane);\n    ChangeLaneIndex(diagram, swimLane, 1);\n    checkPhaseOffset(swimLane, diagram);\n    diagram.protectPropertyChange(false);\n    diagram.updateDiagramObject(swimLane);\n  }\n}\n/**\n * removeHorizontalPhase method \\\n *\n * @returns {void} removeHorizontalPhase method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {GridPanel} grid - provide the obj  value.\n * @param {NodeModel} phase - provide the obj  value.\n * @param {number} phaseIndex - provide the obj  value.\n * @private\n */\n\nexport function removeHorizontalPhase(diagram, grid, phase, phaseIndex) {\n  var row;\n  var cell;\n  var prevCell;\n  var actualChild; //let prevChild: Canvas;\n\n  var prevCanvas;\n  var width;\n  phaseIndex = phaseIndex !== undefined ? phaseIndex : phase.columnIndex;\n  var i;\n  var j;\n  var k;\n  var child;\n  var node;\n  var object;\n\n  for (i = 0; i < grid.rows.length; i++) {\n    row = grid.rows[i];\n\n    if (row.cells.length > 1) {\n      cell = row.cells[phaseIndex];\n      prevCell = row.cells.length - 1 === phaseIndex ? row.cells[phaseIndex - 1] : row.cells[phaseIndex + 1];\n      prevCanvas = prevCell.children[0];\n\n      if (cell.children.length > 0) {\n        actualChild = cell.children[0];\n        node = diagram.nameTable[actualChild.id];\n\n        if (prevCell.children.length === 0 && cell.children.length > 0) {\n          prevCell.children = cell.children;\n          prevCell.columnSpan = cell.columnSpan - 1;\n        } else {\n          for (j = 0; j < actualChild.children.length; j++) {\n            child = actualChild.children[j];\n\n            if (child instanceof Canvas) {\n              object = diagram.nameTable[child.id];\n\n              if (!object.isLane) {\n                object.parentId = prevCanvas.id;\n              }\n\n              if (row.cells.length - 1 === phaseIndex) {\n                object.margin.left = object.wrapper.bounds.x - prevCanvas.bounds.x;\n                child.margin.left = object.wrapper.bounds.x - prevCanvas.bounds.x;\n              }\n\n              prevCanvas.children.push(child);\n\n              if (diagram.nameTable[prevCanvas.id]) {\n                var parentNode = diagram.nameTable[prevCanvas.id];\n\n                if (!parentNode.children) {\n                  parentNode.children = [];\n                }\n\n                parentNode.children.push(child.id);\n              }\n\n              actualChild.children.splice(j, 1);\n              j--;\n\n              if (node && node.children && node.children.indexOf(object.id) !== -1) {\n                node.children.splice(node.children.indexOf(object.id), 1);\n              }\n            }\n\n            if (row.cells.length - 1 !== phaseIndex) {\n              for (k = 0; k < prevCanvas.children.length; k++) {\n                var prevChild = prevCanvas.children[k];\n\n                if (prevChild instanceof Canvas) {\n                  var prevNode = diagram.nameTable[prevChild.id];\n                  prevNode.margin.left = prevNode.wrapper.bounds.x - actualChild.bounds.x;\n                  prevChild.margin.left = prevNode.wrapper.bounds.x - actualChild.bounds.x;\n                }\n              }\n            }\n          }\n\n          if (node && node.isPhase) {\n            var object_1 = diagram.nameTable[prevCanvas.id];\n\n            if (object_1) {\n              prevCanvas.maxWidth = object_1.wrapper.maxWidth = object_1.wrapper.maxWidth += node.wrapper.maxWidth;\n            }\n          }\n\n          deleteNode(diagram, node);\n        }\n      }\n    }\n  }\n\n  var prevWidth = grid.columnDefinitions()[phaseIndex].width;\n  grid.removeColumn(phaseIndex);\n\n  if (phaseIndex < grid.columnDefinitions().length) {\n    width = grid.columnDefinitions()[phaseIndex].width;\n    width += prevWidth;\n    grid.updateColumnWidth(phaseIndex, width, true);\n  } else {\n    width = grid.columnDefinitions()[phaseIndex - 1].width;\n    width += prevWidth;\n    grid.updateColumnWidth(phaseIndex - 1, width, true);\n  }\n}\n/**\n * removeVerticalPhase method \\\n *\n * @returns {void} removeVerticalPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {GridPanel} grid - provide the grid  value.\n * @param {NodeModel} phase - provide the phase  value.\n * @param {number} phaseIndex - provide the phaseIndex  value.\n * @param {number} swimLane - provide the swimLane  value.\n * @private\n */\n\nexport function removeVerticalPhase(diagram, grid, phase, phaseIndex, swimLane) {\n  var cell;\n  var height;\n  var i;\n  var j;\n  var k;\n  var prevCell;\n  var prevChild;\n  var shape = swimLane.shape;\n  var child;\n  var object;\n  var phaseRowIndex = phaseIndex !== undefined ? shape.header ? phaseIndex + 1 : phaseIndex : phase.rowIndex;\n  var row = grid.rows[phaseRowIndex];\n  var top = swimLane.wrapper.bounds.y;\n  var phaseCount = shape.phases.length;\n\n  if (shape.header !== undefined && shape.hasHeader) {\n    top += grid.rowDefinitions()[0].height;\n  }\n\n  var prevRow = phaseIndex === phaseCount ? grid.rows[phaseRowIndex - 1] : grid.rows[phaseRowIndex + 1];\n\n  for (i = 0; i < row.cells.length; i++) {\n    cell = row.cells[i];\n    prevCell = prevRow.cells[i];\n    prevChild = prevCell.children[0];\n\n    if (cell.children.length > 0) {\n      var children = cell.children[0];\n      var node = diagram.nameTable[children.id];\n\n      if (phaseIndex < phaseCount) {\n        for (k = 0; k < prevChild.children.length; k++) {\n          child = prevChild.children[k];\n\n          if (child instanceof Canvas) {\n            object = diagram.nameTable[child.id];\n            object.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : children.bounds.y);\n            child.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : children.bounds.y);\n          }\n        }\n      }\n\n      for (j = 0; j < children.children.length; j++) {\n        child = children.children[j];\n\n        if (child instanceof Canvas) {\n          object = diagram.nameTable[child.id];\n          object.parentId = prevChild.id;\n\n          if (phaseIndex === phaseCount) {\n            object.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : prevChild.bounds.y);\n            child.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : prevChild.bounds.y);\n          }\n\n          prevChild.children.push(child);\n          children.children.splice(j, 1);\n          j--;\n\n          if (node.children && node.children.indexOf(object.id) !== -1) {\n            node.children.splice(node.children.indexOf(object.id), 1);\n          }\n        }\n      }\n\n      deleteNode(diagram, node);\n    }\n  }\n\n  var prevHeight = grid.rowDefinitions()[phaseRowIndex].height;\n  grid.removeRow(phaseRowIndex);\n\n  if (phaseRowIndex < grid.rowDefinitions().length) {\n    height = grid.rowDefinitions()[phaseRowIndex].height;\n    height += prevHeight;\n    grid.updateRowHeight(phaseRowIndex, height, true);\n  } else {\n    height = grid.rowDefinitions()[phaseRowIndex - 1].height;\n    height += prevHeight;\n    grid.updateRowHeight(phaseRowIndex - 1, height, true);\n  }\n}\n/**\n * considerSwimLanePadding method \\\n *\n * @returns {void} considerSwimLanePadding method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the grid  value.\n * @param {number} padding - provide the phase  value.\n * @private\n */\n\nexport function considerSwimLanePadding(diagram, node, padding) {\n  var lane = diagram.nameTable[node.parentId];\n\n  if (lane && lane.isLane) {\n    var swimLane = diagram.nameTable[lane.parentId];\n    var grid = swimLane.wrapper.children[0]; //let x: number = swimLane.wrapper.bounds.x; let y: number = swimLane.wrapper.bounds.y;\n\n    grid.updateColumnWidth(lane.columnIndex, grid.columnDefinitions()[lane.columnIndex].width, true, padding);\n    grid.updateRowHeight(lane.rowIndex, grid.rowDefinitions()[lane.rowIndex].height, true, padding);\n    var canvas = lane.wrapper;\n    var laneHeader = void 0;\n    var isConsiderHeader = false;\n\n    if (node.margin.left < padding) {\n      node.margin.left = padding;\n    }\n\n    if (node.margin.top < padding) {\n      node.margin.top = padding;\n    }\n\n    for (var i = 0; i < canvas.children.length; i++) {\n      var child = canvas.children[i];\n\n      if (child instanceof Canvas) {\n        var childNode = diagram.nameTable[child.id];\n\n        if (childNode.isLane) {\n          laneHeader = childNode.wrapper;\n          isConsiderHeader = true;\n          break;\n        }\n      }\n    }\n\n    if (laneHeader) {\n      if (swimLane.shape.orientation === 'Horizontal') {\n        if (node.margin.left < padding + laneHeader.actualSize.width) {\n          node.margin.left = padding + laneHeader.actualSize.width;\n        }\n      } else {\n        if (node.margin.top < padding + laneHeader.actualSize.height) {\n          node.margin.top = padding + laneHeader.actualSize.height;\n        }\n      }\n    }\n\n    swimLane.wrapper.measure(new Size(swimLane.width, swimLane.height));\n    swimLane.wrapper.arrange(swimLane.wrapper.desiredSize);\n    node.offsetX = node.wrapper.offsetX;\n    node.offsetY = node.wrapper.offsetY;\n    diagram.nodePropertyChange(node, {}, {\n      margin: {\n        left: node.margin.left,\n        top: node.margin.top\n      }\n    });\n    grid.measure(new Size(grid.width, grid.height));\n    grid.arrange(grid.desiredSize);\n    swimLane.width = swimLane.wrapper.width = swimLane.wrapper.children[0].actualSize.width;\n    swimLane.height = swimLane.wrapper.height = swimLane.wrapper.children[0].actualSize.height;\n  }\n}\n/**\n * checkLaneChildrenOffset method \\\n *\n * @returns {void} checkLaneChildrenOffset method .\\\n * @param {NodeModel} swimLane - provide the diagram  value.\n * @private\n */\n\nexport function checkLaneChildrenOffset(swimLane) {\n  if (swimLane.shape.type === 'SwimLane') {\n    var lanes = swimLane.shape.lanes;\n    var lane = void 0;\n    var child = void 0;\n\n    for (var i = 0; i < lanes.length; i++) {\n      lane = lanes[i];\n\n      for (var j = 0; j < lane.children.length; j++) {\n        child = lane.children[j];\n        child.offsetX = child.wrapper.offsetX;\n        child.offsetY = child.wrapper.offsetY;\n      }\n    }\n  }\n}\n/**\n * findLane method \\\n *\n * @returns {LaneModel} findLane method .\\\n * @param {Node} laneNode - provide the laneNode  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\n\nexport function findLane(laneNode, diagram) {\n  var lane;\n\n  if (laneNode.isLane) {\n    var swimLane = diagram.getObject(laneNode.parentId);\n\n    if (swimLane && swimLane.shape.type === 'SwimLane' && laneNode.isLane) {\n      var laneIndex = findLaneIndex(swimLane, laneNode);\n      lane = swimLane.shape.lanes[laneIndex];\n    }\n  }\n\n  return lane;\n}\n/**\n * canLaneInterchange method \\\n *\n * @returns {boolean} canLaneInterchange method .\\\n * @param {Node} laneNode - provide the laneNode  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\n\nexport function canLaneInterchange(laneNode, diagram) {\n  if (laneNode.isLane) {\n    var lane = findLane(laneNode, diagram);\n    var eventHandler = 'eventHandler';\n    var resize = diagram[eventHandler].action;\n    var canResize = resize.includes('Resize');\n\n    if (canResize || lane.canMove) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * updateSwimLaneChildPosition method \\\n *\n * @returns {void} updateSwimLaneChildPosition method .\\\n * @param {Lane[]} lanes - provide the laneNode  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\n\nexport function updateSwimLaneChildPosition(lanes, diagram) {\n  var lane;\n  var node;\n\n  for (var i = 0; i < lanes.length; i++) {\n    lane = lanes[i];\n\n    for (var j = 0; j < lane.children.length; j++) {\n      node = diagram.nameTable[lane.children[j].id];\n      node.offsetX = node.wrapper.offsetX;\n      node.offsetY = node.wrapper.offsetY;\n    }\n  }\n}","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/swim-lane-util.js"],"names":["Node","GridPanel","RowDefinition","ColumnDefinition","Lane","Phase","DiagramAction","NodeConstraints","DiagramConstraints","DiagramEvent","ElementAction","cloneObject","randomId","DiagramElement","TextElement","Size","Canvas","Rect","checkParentAsContainer","findBounds","removeChildInContainer","canSelect","initSwimLane","grid","diagram","node","width","shape","phases","length","row","columns","index","orientation","header","hasHeader","createRow","height","initGridRow","initGridColumns","setDefinitions","headerDefine","phaseSize","k","id","phaseDefine","lanes","laneCollection","addObjectToGrid","parent","object","isHeader","isPhase","isLane","canvas","parentId","constraints","InConnect","OutConnect","HideThumbs","initObject","nodes","push","wrapper","children","i","child","isCalculateDesiredSize","canConsiderBounds","isLaneOrientation","refreshTextElement","measure","undefined","arrange","desiredSize","maxWidth","columnDefinitions","annotations","annotation","style","offsetX","offsetY","rowIndex","columnIndex","container","type","Select","addObject","indexValue","phaseIndex","rowValue","colValue","phaseObject","rotateAngle","laneIndex","laneNode","parentWrapper","gridCell","childWrapper","value","phaseCount","l","rows","cells","minWidth","minHeight","Default","ReadOnly","AllowDrop","elementActions","HorizontalLaneHeader","createColumn","cols","totalHeight","phaseHeight","phaseOffset","offset","totalWidth","j","getConnectors","isRowUpdate","connectors","conn","childNode","rowDefinitions","edges","i_1","getObject","inEdges","outEdges","concat","indexOf","swimLaneMeasureAndArrange","obj","isMeasure","ChangeLaneIndex","startRowIndex","subChild","cell","nameTable","arrangeChildNodesInSwimLane","padding","top","bounds","y","rowvalue","columnValue","col","margin","left","right","x","actualSize","addChildToLane","k_1","bottom","updateChildOuterBounds","updateHeaderMaxWidth","checkLaneChildrenOffset","checkPhaseOffset","checkLaneSize","addChild","findStartLaneIndex","updateColumnWidth","updateRowHeight","maxHeight","lane","size","phaseRow","phase","gridRowIndex","updateConnectorsProperties","lineRoutingModule","LineRouting","renderVirtualRegion","refreshConnectorSegments","connectorPropertyChange","sourceID","targetID","laneInterChanged","target","position","undoElement","entry","redoElement","sourceIndex","targetIndex","temp","sourceLaneIndex","targetLaneIndex","swimLane","canMove","updateRowIndex","changeHeaderIndex","columnSpan","updateColumnIndex","source","splice","redoObject","undoObject","category","diagramActions","UndoRedo","commandHandler","addHistoryEntry","updateSwimLaneChildPosition","updateDiagramObject","updateDiagramElementQuad","updateSwimLaneObject","helperObject","parentNode","helperWidth","helperHeight","objWidth","objHeight","findLaneIndex","laneObj","findPhaseIndex","updatePhaseMaxWidth","outerBounds","headerNode","addLane","count","args","protectPropertyChange","redoObj","orientation_1","point","element","cause","state","cancel","triggerEvent","collectionChange","rowDef","addRow","colDef","addColumn","changeType","addChildNodeToNewLane","drag","parent_1","containsPoint","addPhase","newPhase","gridColIndex","phaseNode","previousPhase","nextPhase","phasesCollection","orientation_2","laneHeaderSize","nextCol","addPhase_1","nextRow","addPhase_2","historyManager","currentEntry","next","isLastPhase","addLastPhase","phaseObj","fristRow","i_2","addHorizontalPhase","nextPhaseNode","addVerticalPhase","prevPhase","prevOffset","addPhase_3","addPhase_4","nextCell","prevCell","addSwimlanePhases","prevRow","desiredCellWidth","desiredCellHeight","rect","arrangeChildInGrid","changeCell","center","deleteChild","zIndex","removeElements","swimLaneSelection","corner","select","pasteSwimLane","clipboardData","isUndo","ranId","cloneLane","childX","childY","nodeX","nodeY","childTable","pasteIndex","newShape","content","add","_i","_a","Object","keys","i_3","connector","mode","refreshDiagramLayer","gridSelection","selectorModel","isSymbolDrag","targetnode","swimLaneId","removeLaneChildNode","swimLaneNode","currentObj","isChildNode","preventHistory","lanenode","removeDependentConnector","remove","getGridChildren","removeSwimLane","removeNode","deleteNode","PreventHistory","Delete","removeFromAQuad","removeObjectsFromLayer","removeLane","undoObj","removeChildren","removeRow","removeColumn","removePhase","swimLanePhases","phaseLength","removeHorizontalPhase","removeVerticalPhase","actualChild","prevCanvas","prevChild","prevNode","object_1","prevWidth","phaseRowIndex","prevHeight","considerSwimLanePadding","laneHeader","isConsiderHeader","nodePropertyChange","findLane","canLaneInterchange","eventHandler","resize","action","canResize","includes"],"mappings":"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","sourcesContent":["import { Node } from '../objects/node';\nimport { GridPanel, RowDefinition, ColumnDefinition } from '../core/containers/grid';\nimport { Lane, Phase } from '../objects/node';\nimport { DiagramAction, NodeConstraints, DiagramConstraints, DiagramEvent, ElementAction } from '../enum/enum';\nimport { cloneObject, randomId } from './../utility/base-util';\nimport { DiagramElement } from '../core/elements/diagram-element';\nimport { TextElement } from '../core/elements/text-element';\nimport { Size } from '../primitives/size';\nimport { Canvas } from '../core/containers/canvas';\nimport { Rect } from '../primitives/rect';\nimport { checkParentAsContainer, findBounds, removeChildInContainer } from '../interaction/container-interaction';\nimport { canSelect } from './constraints-util';\n/**\n * SwimLane modules are used to rendering and interaction.\n */\n/** @private */\n/**\n * initSwimLane method \\\n *\n * @returns {void} initSwimLane method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param { Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the node  value.\n * @private\n */\nexport function initSwimLane(grid, diagram, node) {\n    if (!node.width && node.shape.phases.length === 0) {\n        node.width = 100;\n    }\n    var row = [];\n    var columns = [];\n    var index = 0;\n    var shape = node.shape;\n    var orientation = shape.orientation === 'Horizontal' ? true : false;\n    if (shape.header && shape.hasHeader) {\n        createRow(row, shape.header.height);\n    }\n    initGridRow(row, orientation, node);\n    initGridColumns(columns, orientation, node);\n    grid.setDefinitions(row, columns);\n    if (shape.header && shape.hasHeader) {\n        headerDefine(grid, diagram, node);\n        index++;\n    }\n    if (shape.phases.length > 0 && shape.phaseSize) {\n        for (var k = 0; k < shape.phases.length; k++) {\n            if (shape.phases[k].id === '') {\n                shape.phases[k].id = randomId();\n            }\n            phaseDefine(grid, diagram, node, index, orientation, k);\n        }\n        index++;\n    }\n    if (shape.lanes.length > 0) {\n        for (var k = 0; k < shape.lanes.length; k++) {\n            if (shape.lanes[k].id === '') {\n                shape.lanes[k].id = randomId();\n            }\n            laneCollection(grid, diagram, node, index, k, orientation);\n            index++;\n        }\n    }\n}\n/**\n * addObjectToGrid method \\\n *\n * @returns {Container} addObjectToGrid method .\\\n * @param { Diagram} diagram - provide the diagram  value.\n * @param { GridPanel} grid - provide the grid  value.\n * @param {NodeModel} parent - provide the parent  value.\n * @param {NodeModel} object - provide the object  value.\n * @param {boolean} isHeader - provide the isHeader  value.\n * @param {boolean} isPhase - provide the isPhase  value.\n * @param {boolean} isLane - provide the isLane  value.\n * @param {string} canvas - provide the canvas  value.\n * @private\n */\nexport function addObjectToGrid(diagram, grid, parent, object, isHeader, isPhase, isLane, canvas) {\n    var node = new Node(diagram, 'nodes', object, true);\n    node.parentId = parent.id;\n    node.isHeader = (isHeader) ? true : false;\n    node.isPhase = (isPhase) ? true : false;\n    node.isLane = (isLane) ? true : false;\n    var id = (isPhase) ? 'PhaseHeaderParent' : 'LaneHeaderParent';\n    if (canvas) {\n        node[id] = canvas;\n    }\n    node.constraints &= ~(NodeConstraints.InConnect | NodeConstraints.OutConnect);\n    node.constraints |= NodeConstraints.HideThumbs;\n    diagram.initObject(node);\n    diagram.nodes.push(node);\n    if (node.wrapper.children.length > 0) {\n        for (var i = 0; i < node.wrapper.children.length; i++) {\n            var child = node.wrapper.children[i];\n            if (child instanceof DiagramElement) {\n                child.isCalculateDesiredSize = false;\n            }\n            if (child instanceof TextElement) {\n                child.canConsiderBounds = false;\n                if (!isHeader && (parent.shape.orientation === 'Vertical' && isPhase) ||\n                    (parent.shape.orientation !== 'Vertical' && isLane)) {\n                    child.isLaneOrientation = true;\n                    child.refreshTextElement();\n                }\n            }\n        }\n        node.wrapper.measure(new Size(undefined, undefined));\n        node.wrapper.arrange(node.wrapper.desiredSize);\n    }\n    return node.wrapper;\n}\n/**\n * headerDefine method \\\n *\n * @returns {void} headerDefine method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} object - provide the object  value.\n * @private\n */\nexport function headerDefine(grid, diagram, object) {\n    var maxWidth = 0;\n    var columns = grid.columnDefinitions();\n    var shape = object.shape;\n    for (var i = 0; i < columns.length; i++) {\n        maxWidth += columns[i].width;\n    }\n    shape.header.id = shape.header.id || randomId();\n    var node = {\n        id: object.id + shape.header.id,\n        annotations: [cloneObject(shape.header.annotation)],\n        style: shape.header.style ? shape.header.style : undefined,\n        offsetX: object.offsetX, offsetY: object.offsetY,\n        rowIndex: 0, columnIndex: 0,\n        maxWidth: maxWidth,\n        container: { type: 'Canvas', orientation: 'Horizontal' }\n    };\n    if (!canSelect(object)) {\n        node.constraints &= ~NodeConstraints.Select;\n    }\n    var wrapper = addObjectToGrid(diagram, grid, object, node, true);\n    grid.addObject(wrapper, 0, 0, 1, grid.columnDefinitions().length);\n}\n/**\n * phaseDefine method \\\n *\n * @returns {void} phaseDefine method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} object - provide the object  value.\n * @param {number} indexValue - provide the indexValue  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @param {number} phaseIndex - provide the phaseIndex  value.\n * @private\n */\nexport function phaseDefine(grid, diagram, object, indexValue, orientation, phaseIndex) {\n    var rowValue = 0;\n    var colValue = 0;\n    var maxWidth;\n    var shape = object.shape;\n    if (orientation) {\n        colValue = phaseIndex;\n        rowValue = indexValue;\n        maxWidth = grid.columnDefinitions()[phaseIndex].width;\n    }\n    else {\n        rowValue = shape.header && shape.hasHeader ? phaseIndex + 1 : phaseIndex;\n    }\n    var phaseObject = {\n        annotations: [cloneObject(shape.phases[phaseIndex].header.annotation)],\n        maxWidth: maxWidth,\n        id: object.id + shape.phases[phaseIndex].id + '_header',\n        offsetX: object.offsetX, offsetY: object.offsetY,\n        style: shape.phases[phaseIndex].style,\n        rowIndex: rowValue, columnIndex: colValue,\n        container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }\n    };\n    phaseObject.annotations[0].rotateAngle = orientation ? 0 : 270;\n    if (!canSelect(object)) {\n        phaseObject.constraints &= ~NodeConstraints.Select;\n    }\n    shape.phases[phaseIndex].header.id = phaseObject.id;\n    var wrapper = addObjectToGrid(diagram, grid, object, phaseObject, false, true, false, shape.phases[phaseIndex].id);\n    grid.addObject(wrapper, rowValue, colValue);\n}\n/**\n * laneCollection method \\\n *\n * @returns {void} laneCollection method .\\\n * @param { GridPanel} grid - provide the grid  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} object - provide the object  value.\n * @param {number} indexValue - provide the indexValue  value.\n * @param {number} laneIndex - provide the laneIndex  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @private\n */\nexport function laneCollection(grid, diagram, object, indexValue, laneIndex, orientation) {\n    var laneNode;\n    var parentWrapper;\n    var gridCell;\n    var canvas;\n    var childWrapper;\n    var shape = object.shape;\n    var value = shape.phases.length || 1;\n    var isHeader = (shape.header && shape.hasHeader) ? 1 : 0;\n    var rowValue = orientation ? indexValue : isHeader;\n    var phaseCount = (shape.phaseSize && shape.phases.length > 0) ? 1 : 0;\n    for (var l = 0; l < value; l++) {\n        var colValue = orientation ? l : laneIndex + phaseCount;\n        gridCell = grid.rows[rowValue].cells[colValue];\n        canvas = {\n            id: object.id + shape.lanes[laneIndex].id + l,\n            rowIndex: rowValue, columnIndex: colValue,\n            width: gridCell.minWidth, height: gridCell.minHeight,\n            offsetX: object.offsetX, offsetY: object.offsetY,\n            style: shape.lanes[laneIndex].style,\n            constraints: NodeConstraints.Default | NodeConstraints.ReadOnly | NodeConstraints.AllowDrop,\n            container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }\n        };\n        if (!canSelect(object)) {\n            canvas.constraints &= ~NodeConstraints.Select;\n        }\n        parentWrapper = addObjectToGrid(diagram, grid, object, canvas, false, false, true);\n        parentWrapper.children[0].isCalculateDesiredSize = false;\n        if (l === 0) {\n            laneNode = {\n                id: object.id + shape.lanes[laneIndex].id + '_' + l + '_header',\n                style: shape.lanes[laneIndex].header.style,\n                annotations: [cloneObject(shape.lanes[laneIndex].header.annotation)],\n                offsetX: object.offsetX, offsetY: object.offsetY,\n                rowIndex: rowValue, columnIndex: colValue,\n                container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }\n            };\n            laneNode.annotations[0].rotateAngle = orientation ? 270 : 0;\n            shape.lanes[laneIndex].header.id = laneNode.id;\n            // eslint-disable-next-line\n            (orientation) ? laneNode.width = shape.lanes[laneIndex].header.width :\n                laneNode.height = shape.lanes[laneIndex].header.height;\n            if (!canSelect(object)) {\n                laneNode.constraints &= ~NodeConstraints.Select;\n            }\n            childWrapper = addObjectToGrid(diagram, grid, object, laneNode, false, false, true, shape.lanes[laneIndex].id);\n            if (orientation) {\n                childWrapper.children[0].elementActions = childWrapper.children[0].elementActions | ElementAction.HorizontalLaneHeader;\n            }\n            parentWrapper.children.push(childWrapper);\n        }\n        grid.addObject(parentWrapper, rowValue, colValue);\n        if (!orientation) {\n            rowValue++;\n        }\n        colValue = orientation ? l : laneIndex + 1;\n    }\n}\n/**\n * createRow method \\\n *\n * @returns {void} createRow method .\\\n * @param { RowDefinition[]} row - provide the row  value.\n * @param {number} height - provide the height  value.\n * @private\n */\nexport function createRow(row, height) {\n    var rows = new RowDefinition();\n    rows.height = height;\n    row.push(rows);\n}\n/**\n * createColumn method \\\n *\n * @returns {void} createColumn method .\\\n * @param {number} width - provide the width  value.\n * @private\n */\nexport function createColumn(width) {\n    var cols = new ColumnDefinition();\n    cols.width = width;\n    return cols;\n}\n/**\n * initGridRow method \\\n *\n * @returns {void} initGridRow method .\\\n * @param {RowDefinition[]} row - provide the row  value.\n * @param {boolean} orientation - provide the row  value.\n * @param {NodeModel} object - provide the row  value.\n * @private\n */\nexport function initGridRow(row, orientation, object) {\n    var totalHeight = 0;\n    var height;\n    var shape = object.shape;\n    if (row.length > 0) {\n        for (var i = 0; i < row.length; i++) {\n            totalHeight += row[i].height;\n        }\n    }\n    if (orientation) {\n        if (shape.phases.length > 0 && shape.phaseSize) {\n            totalHeight += shape.phaseSize;\n            createRow(row, shape.phaseSize);\n        }\n        if (shape.lanes.length > 0) {\n            for (var i = 0; i < shape.lanes.length; i++) {\n                height = shape.lanes[i].height;\n                totalHeight += height;\n                if (i === shape.lanes.length - 1 && totalHeight < object.height) {\n                    height += object.height - totalHeight;\n                }\n                createRow(row, height);\n            }\n        }\n    }\n    else {\n        if (shape.phases.length > 0) {\n            var phaseHeight = 0;\n            for (var i = 0; i < shape.phases.length; i++) {\n                var phaseOffset = shape.phases[i].offset;\n                if (i === 0) {\n                    phaseHeight += phaseOffset;\n                }\n                else {\n                    phaseOffset -= phaseHeight;\n                    phaseHeight += phaseOffset;\n                }\n                height = phaseOffset;\n                totalHeight += height;\n                if (i === shape.phases.length - 1 && totalHeight < object.height) {\n                    height += object.height - totalHeight;\n                }\n                createRow(row, height);\n            }\n        }\n        else {\n            createRow(row, object.height);\n        }\n    }\n}\n/**\n * initGridColumns method \\\n *\n * @returns {void} initGridRow method .\\\n * @param {ColumnDefinition[]} columns - provide the row  value.\n * @param {boolean} orientation - provide the row  value.\n * @param {NodeModel} object - provide the row  value.\n * @private\n */\nexport function initGridColumns(columns, orientation, object) {\n    var totalWidth = 0;\n    var shape = object.shape;\n    var phaseOffset;\n    var cols;\n    var k;\n    var j;\n    var value;\n    if (shape.phases.length > 0 && shape.orientation === 'Horizontal') {\n        for (j = 0; j < shape.phases.length; j++) {\n            phaseOffset = shape.phases[j].offset;\n            if (j === 0) {\n                totalWidth += phaseOffset;\n            }\n            else {\n                phaseOffset -= totalWidth;\n                totalWidth += phaseOffset;\n            }\n            cols = createColumn(phaseOffset);\n            if (j === shape.phases.length - 1 && totalWidth < object.width) {\n                cols.width += object.width - totalWidth;\n            }\n            columns.push(cols);\n        }\n    }\n    else if (!orientation) {\n        value = (shape.phaseSize && shape.phases.length > 0) ? shape.lanes.length\n            + 1 : shape.lanes.length;\n        if (shape.phaseSize && shape.phases.length > 0) {\n            totalWidth += shape.phaseSize;\n            cols = createColumn(shape.phaseSize);\n            columns.push(cols);\n        }\n        for (k = 0; k < shape.lanes.length; k++) {\n            totalWidth += shape.lanes[k].width;\n            cols = createColumn(shape.lanes[k].width);\n            if (k === shape.lanes.length - 1 && totalWidth < object.width) {\n                cols.width += object.width - totalWidth;\n            }\n            columns.push(cols);\n        }\n        if ((shape.phases.length === 0 && shape.lanes.length === 0)) {\n            cols = createColumn(object.width);\n            columns.push(cols);\n        }\n    }\n    else {\n        cols = createColumn(object.width);\n        columns.push(cols);\n    }\n}\n/**\n * getConnectors method \\\n *\n * @returns {void} getConnectors method .\\\n * @param {Diagram} diagram - provide the row  value.\n * @param {GridPanel} grid - provide the row  value.\n * @param {number} rowIndex - provide the row  value.\n * @param {boolean} isRowUpdate - provide the row  value.\n * @private\n */\nexport function getConnectors(diagram, grid, rowIndex, isRowUpdate) {\n    var connectors = [];\n    var conn = 0;\n    var childNode;\n    var node;\n    var k;\n    var i;\n    var j;\n    var canvas;\n    var row;\n    var length = grid.rowDefinitions().length;\n    var edges;\n    for (var i_1 = 0; i_1 < length; i_1++) {\n        row = grid.rows[i_1];\n        for (j = 0; j < row.cells.length; j++) {\n            canvas = row.cells[j].children[0];\n            if (canvas && canvas.children && canvas.children.length) {\n                for (k = 1; k < canvas.children.length; k++) {\n                    childNode = canvas.children[k];\n                    node = diagram.getObject(childNode.id);\n                    if (node && (node.inEdges.length > 0 || node.outEdges.length > 0)) {\n                        edges = node.inEdges.concat(node.outEdges);\n                        for (conn = 0; conn < edges.length; conn++) {\n                            if (connectors.indexOf(edges[conn]) === -1) {\n                                connectors.push(edges[conn]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return connectors;\n}\n/**\n * swimLaneMeasureAndArrange method \\\n *\n * @returns {void} swimLaneMeasureAndArrange method .\\\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\nexport function swimLaneMeasureAndArrange(obj) {\n    var canvas = obj.wrapper;\n    canvas.measure(new Size(obj.width, obj.height));\n    if (canvas.children[0] instanceof GridPanel) {\n        var grid = canvas.children[0];\n        var isMeasure = false;\n        if (grid.width && grid.width < grid.desiredSize.width) {\n            isMeasure = true;\n            grid.width = grid.desiredSize.width;\n        }\n        if (grid.height && grid.height < grid.desiredSize.height) {\n            isMeasure = true;\n            grid.height = grid.desiredSize.height;\n        }\n        if (isMeasure) {\n            grid.measure(new Size(grid.width, grid.height));\n        }\n    }\n    canvas.arrange(canvas.desiredSize);\n}\n/**\n * ChangeLaneIndex method \\\n *\n * @returns {void} ChangeLaneIndex method .\\\n * @param {Diagram} diagram - provide the row  value.\n * @param {NodeModel} obj - provide the row  value.\n * @param {number} startRowIndex - provide the row  value.\n * @private\n */\nexport function ChangeLaneIndex(diagram, obj, startRowIndex) {\n    var container = obj.wrapper.children[0];\n    var i;\n    var j;\n    var k;\n    var object;\n    var subChild;\n    var row;\n    var cell;\n    var child;\n    for (i = startRowIndex; i < container.rows.length; i++) {\n        row = container.rows[i];\n        for (j = 0; j < row.cells.length; j++) {\n            cell = row.cells[j];\n            if (cell.children && cell.children.length > 0) {\n                for (k = 0; k < cell.children.length; k++) {\n                    child = cell.children[k];\n                    object = diagram.nameTable[child.id];\n                    if (object.isLane && child.children.length > 1) {\n                        subChild = diagram.nameTable[child.children[1].id];\n                        if (subChild && subChild.isLane) {\n                            subChild.rowIndex = i;\n                            subChild.columnIndex = j;\n                        }\n                    }\n                    object.rowIndex = i;\n                    object.columnIndex = j;\n                }\n            }\n        }\n    }\n}\n/**\n * arrangeChildNodesInSwimLane method \\\n *\n * @returns {void} arrangeChildNodesInSwimLane method .\\\n * @param {Diagram} diagram - provide the row  value.\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\nexport function arrangeChildNodesInSwimLane(diagram, obj) {\n    var grid = obj.wrapper.children[0];\n    var shape = obj.shape;\n    var padding = shape.padding;\n    var lanes = shape.lanes;\n    var top = grid.bounds.y;\n    var rowvalue;\n    var columnValue;\n    var phaseCount = (shape.phaseSize > 0) ? shape.phases.length : 0;\n    var node;\n    var canvas;\n    var cell;\n    var i;\n    var j;\n    var k;\n    var orientation = shape.orientation === 'Horizontal' ? true : false;\n    var col = orientation ? shape.phases.length || 1 : lanes.length + 1;\n    var row = orientation ? ((shape.header && shape.hasHeader) ? 1 : 0) +\n        (shape.phases.length > 0 ? 1 : 0) + (shape.lanes.length)\n        : (shape.header && shape.hasHeader ? 1 : 0) + shape.phases.length;\n    if (phaseCount === 0 && !orientation && shape.lanes.length) {\n        row += 1;\n    }\n    if (orientation) {\n        rowvalue = (shape.header && shape.hasHeader ? 1 : 0) + (phaseCount > 0 ? 1 : 0);\n        columnValue = 0;\n    }\n    else {\n        rowvalue = (shape.header && shape.hasHeader ? 1 : 0);\n        columnValue = phaseCount > 0 ? 1 : 0;\n    }\n    if (lanes.length > 0) {\n        top += (shape.header && shape.hasHeader) ? shape.header.height : 0;\n        for (i = 0; i < lanes.length; i++) {\n            for (j = 0; j < lanes[i].children.length; j++) {\n                node = lanes[i].children[j];\n                node.offsetX = lanes[i].width;\n                node.offsetY = lanes[i].height;\n                diagram.initObject(node);\n                diagram.nodes.push(node);\n                canvas = node.wrapper;\n                if (orientation) {\n                    for (k = columnValue; k < col; k++) {\n                        cell = grid.rows[rowvalue].cells[k];\n                        if (canvas.margin.left < (cell.bounds.right - grid.bounds.x)) {\n                            node.parentId = cell.children[0].id;\n                            if (k > columnValue) {\n                                canvas.margin.left = canvas.margin.left - (cell.bounds.left - grid.bounds.left);\n                            }\n                            else {\n                                if ((cell.children[0].children[1].actualSize.width + padding) >= canvas.margin.left) {\n                                    canvas.margin.left = cell.children[0].children[1].actualSize.width + padding;\n                                }\n                            }\n                            if (canvas.margin.left < padding) {\n                                canvas.margin.left = padding;\n                            }\n                            if (canvas.margin.top < padding) {\n                                canvas.margin.top = padding;\n                            }\n                            addChildToLane(canvas, node, diagram);\n                            break;\n                        }\n                    }\n                }\n                else {\n                    for (var k_1 = rowvalue; k_1 < row; k_1++) {\n                        cell = grid.rows[k_1].cells[columnValue];\n                        if (canvas.margin.top < (cell.bounds.bottom - top)) {\n                            node.parentId = cell.children[0].id;\n                            if (k_1 > rowvalue) {\n                                canvas.margin.top = canvas.margin.top - (cell.bounds.top - top);\n                            }\n                            else {\n                                if ((cell.children[0].children[1].actualSize.height + padding) >= canvas.margin.top) {\n                                    canvas.margin.top = cell.children[0].children[1].actualSize.height + padding;\n                                }\n                            }\n                            if (canvas.margin.left < padding) {\n                                canvas.margin.left = padding;\n                            }\n                            if (canvas.margin.top < padding) {\n                                canvas.margin.top = padding;\n                            }\n                            addChildToLane(canvas, node, diagram);\n                            break;\n                        }\n                    }\n                }\n            }\n            // eslint-disable-next-line\n            orientation ? rowvalue++ : columnValue++;\n        }\n    }\n    grid.measure(new Size(obj.width, obj.height));\n    grid.arrange(grid.desiredSize);\n    updateChildOuterBounds(grid, obj);\n    obj.width = obj.wrapper.width = grid.width;\n    obj.height = obj.wrapper.height = grid.height;\n    updateHeaderMaxWidth(diagram, obj);\n    obj.wrapper.measure(new Size(obj.width, obj.height));\n    obj.wrapper.arrange(grid.desiredSize);\n    checkLaneChildrenOffset(obj);\n    checkPhaseOffset(obj, diagram);\n    checkLaneSize(obj);\n}\n/**\n * addChildToLane method \\\n *\n * @returns {void} addChildToLane method .\\\n * @param {Container} canvas - provide the row  value.\n * @param {NodeModel} node - provide the row  value.\n * @param {Diagram} diagram - provide the row  value.\n * @private\n */\nfunction addChildToLane(canvas, node, diagram) {\n    canvas.measure(new Size(node.width, node.height));\n    canvas.arrange(canvas.desiredSize);\n    var parent = diagram.getObject(node.parentId);\n    diagram.addChild(parent, node.id);\n}\n/**\n * updateChildOuterBounds method \\\n *\n * @returns {void} updateChildOuterBounds method .\\\n * @param {GridPanel} grid - provide the row  value.\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\nexport function updateChildOuterBounds(grid, obj) {\n    var columnDefinitions = grid.columnDefinitions();\n    var rowDefinitions = grid.rowDefinitions();\n    var i;\n    var k;\n    var j;\n    var cell;\n    var child;\n    var row;\n    var rowIndex = findStartLaneIndex(obj);\n    if (obj.shape.orientation === 'Vertical') {\n        if (rowIndex === 0) {\n            rowIndex = (obj.shape.header && obj.shape.hasHeader) ? 1 : 0;\n        }\n    }\n    var padding = obj.shape.padding;\n    for (i = 0; i < columnDefinitions.length; i++) {\n        grid.updateColumnWidth(i, columnDefinitions[i].width, true, padding);\n    }\n    for (i = rowIndex; i < rowDefinitions.length; i++) {\n        grid.updateRowHeight(i, rowDefinitions[i].height, true, padding);\n    }\n    for (k = 0; k < rowDefinitions.length; k++) {\n        row = grid.rows[k];\n        for (i = 0; i < columnDefinitions.length; i++) {\n            cell = row.cells[i];\n            if (cell.children && cell.children.length > 0) {\n                for (j = 0; j < cell.children.length; j++) {\n                    child = cell.children[j];\n                    if (child.maxWidth) {\n                        child.maxWidth = cell.actualSize.width;\n                    }\n                    if (child.maxHeight) {\n                        child.maxHeight = cell.actualSize.height;\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * checkLaneSize method \\\n *\n * @returns {void} checkLaneSize method .\\\n * @param {NodeModel} obj - provide the row  value.\n * @private\n */\nexport function checkLaneSize(obj) {\n    if (obj.shape.type === 'SwimLane' && !obj.shape.isLane && !obj.shape.isPhase) {\n        var lane = void 0;\n        var i = void 0;\n        var columns = void 0;\n        var size = void 0; //let laneCount: number = 0;\n        var lanes = obj.shape.lanes;\n        var laneIndex = findStartLaneIndex(obj);\n        var rows = obj.wrapper.children[0].rowDefinitions();\n        for (i = 0; i < lanes.length; i++, laneIndex++) {\n            lane = lanes[i];\n            if (obj.shape.orientation === 'Horizontal') {\n                size = rows[laneIndex].height;\n                if (lane.height !== size) {\n                    lane.height = size;\n                }\n            }\n            else {\n                columns = obj.wrapper.children[0].columnDefinitions();\n                size = columns[laneIndex].width;\n                if (lane.width !== size) {\n                    lane.width = size;\n                }\n            }\n        }\n    }\n}\n/**\n * checkPhaseOffset method \\\n *\n * @returns {void} checkPhaseOffset method .\\\n * @param {NodeModel} obj - provide the obj  value.\n * @param {Diagram} diagram - provide the obj  value.\n * @private\n */\nexport function checkPhaseOffset(obj, diagram) {\n    var shape = obj.shape;\n    var phases = shape.phases;\n    var i;\n    var offset;\n    var phaseRow;\n    var phase;\n    var gridRowIndex = (shape.header && shape.hasHeader) ? 1 : 0;\n    var grid = obj.wrapper.children[0];\n    var top = grid.bounds.y + ((shape.header && shape.hasHeader) ? shape.header.height : 0);\n    if (obj.shape.type === 'SwimLane') {\n        obj = diagram.getObject(obj.id) || obj;\n        if (phases.length > 0) {\n            grid = obj.wrapper.children[0];\n            if (shape.orientation === 'Horizontal') {\n                phaseRow = (shape.header && shape.hasHeader) ? grid.rows[1] : grid.rows[0];\n                for (i = 0; i < phases.length; i++) {\n                    phase = phaseRow.cells[i].children[0];\n                    offset = phase.bounds.right - grid.bounds.x;\n                    if (phases[i].offset !== offset) {\n                        phases[i].offset = offset;\n                    }\n                    diagram.nameTable[phase.id].maxWidth = phase.maxWidth;\n                }\n            }\n            else {\n                for (i = 0; i < phases.length; i++) {\n                    phase = grid.rows[gridRowIndex + i].cells[0].children[0];\n                    offset = phase.bounds.bottom - top;\n                    if (phases[i].offset !== offset) {\n                        phases[i].offset = offset;\n                    }\n                    diagram.nameTable[phase.id].maxWidth = phase.maxWidth;\n                }\n            }\n        }\n    }\n}\n/**\n * updateConnectorsProperties method \\\n *\n * @returns {void} checkPhaseOffset method .\\\n * @param {string[]} connectors - provide the obj  value.\n * @param {Diagram} diagram - provide the obj  value.\n * @private\n */\nexport function updateConnectorsProperties(connectors, diagram) {\n    if (connectors && connectors.length > 0) {\n        var edges = void 0;\n        if (diagram.lineRoutingModule && (diagram.constraints & DiagramConstraints.LineRouting)) {\n            diagram.lineRoutingModule.renderVirtualRegion(diagram, true);\n        }\n        for (var i = 0; i < connectors.length; i++) {\n            edges = diagram.getObject(connectors[i]);\n            if (diagram.lineRoutingModule && (diagram.constraints & DiagramConstraints.LineRouting) && edges.type === 'Orthogonal') {\n                diagram.lineRoutingModule.refreshConnectorSegments(diagram, edges, true);\n            }\n            else {\n                diagram.connectorPropertyChange(edges, {}, {\n                    sourceID: edges.sourceID, targetID: edges.targetID\n                });\n            }\n        }\n    }\n}\n/**\n * laneInterChanged method \\\n *\n * @returns {void} laneInterChanged method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} obj - provide the obj  value.\n * @param {NodeModel} target - provide the target  value.\n * @param {PointModel} position - provide the position  value.\n * @private\n */\nexport function laneInterChanged(diagram, obj, target, position) {\n    var index;\n    var undoElement;\n    var entry;\n    var redoElement;\n    var sourceIndex;\n    var targetIndex;\n    var temp;\n    var sourceLaneIndex;\n    var targetLaneIndex;\n    var rowIndex;\n    var swimLane = (diagram.getObject(obj.parentId));\n    var shape = swimLane.shape;\n    var grid = swimLane.wrapper.children[0];\n    var lanes = shape.lanes;\n    var connectors = getConnectors(diagram, grid, obj.rowIndex, true);\n    if ((shape.orientation === 'Horizontal' && obj.rowIndex !== target.rowIndex) ||\n        (shape.orientation === 'Vertical' && obj.columnIndex !== target.columnIndex)) {\n        if (shape.orientation === 'Horizontal') {\n            sourceIndex = obj.rowIndex;\n            targetIndex = target.rowIndex;\n            index = ((shape.header && shape.hasHeader) ? 1 : 0) + (shape.phases.length && shape.phaseSize ? 1 : 0);\n            sourceLaneIndex = obj.rowIndex - index;\n            targetLaneIndex = target.rowIndex - index;\n            if (lanes[sourceLaneIndex].canMove) {\n                if (sourceLaneIndex < targetLaneIndex) {\n                    if (position && target.wrapper.offsetY > position.y) {\n                        targetIndex += (targetLaneIndex > 0) ? -1 : 1;\n                        targetLaneIndex += (targetLaneIndex > 0) ? -1 : 1;\n                    }\n                }\n                else {\n                    if (position && target.wrapper.offsetY < position.y) {\n                        targetIndex += 1;\n                        targetLaneIndex += 1;\n                    }\n                }\n                if (sourceIndex !== targetIndex) {\n                    grid.updateRowIndex(sourceIndex, targetIndex);\n                }\n            }\n        }\n        else {\n            sourceIndex = obj.columnIndex;\n            targetIndex = target.columnIndex;\n            index = (shape.phases.length && shape.phaseSize) ? 1 : 0;\n            sourceLaneIndex = obj.columnIndex - index;\n            targetLaneIndex = target.columnIndex - index;\n            rowIndex = (shape.header && shape.hasHeader) ? 1 : 0;\n            if (lanes[sourceLaneIndex].canMove) {\n                if (sourceLaneIndex < targetLaneIndex) {\n                    if (position && target.wrapper.offsetX > position.x) {\n                        targetIndex += (targetLaneIndex > 0) ? -1 : 1;\n                        targetLaneIndex += (targetLaneIndex > 0) ? -1 : 1;\n                    }\n                }\n                else {\n                    if (position && target.wrapper.offsetX < position.x) {\n                        targetIndex += 1;\n                        targetLaneIndex += 1;\n                    }\n                }\n                if (sourceIndex !== targetIndex) {\n                    if ((shape.phaseSize === 0 || shape.phases.length === 0) && (targetIndex === 0 || sourceIndex === 0)) {\n                        if (shape.header && shape.hasHeader) {\n                            var changeHeaderIndex = (targetIndex === 0) ? sourceIndex : targetIndex;\n                            grid.rows[0].cells[changeHeaderIndex].children = grid.rows[0].cells[0].children;\n                            grid.rows[0].cells[changeHeaderIndex].columnSpan = grid.rows[0].cells[0].columnSpan;\n                            grid.rows[0].cells[0].children = [];\n                        }\n                    }\n                    grid.updateColumnIndex(0, sourceIndex, targetIndex);\n                }\n            }\n        }\n        if (sourceIndex !== targetIndex) {\n            temp = lanes[sourceLaneIndex];\n            if (temp.canMove) {\n                undoElement = {\n                    target: cloneObject(target), source: cloneObject(obj)\n                };\n                temp = lanes[sourceLaneIndex];\n                lanes.splice(sourceLaneIndex, 1);\n                lanes.splice(targetLaneIndex, 0, temp);\n                redoElement = {\n                    target: cloneObject(undoElement.source), source: cloneObject(undoElement.target)\n                };\n                entry = {\n                    type: 'LanePositionChanged', redoObject: redoElement,\n                    undoObject: undoElement, category: 'Internal'\n                };\n                if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    diagram.commandHandler.addHistoryEntry(entry);\n                }\n                ChangeLaneIndex(diagram, swimLane, 0);\n                updateConnectorsProperties(connectors, diagram);\n                updateSwimLaneChildPosition(lanes, diagram);\n                swimLane.wrapper.measure(new Size(swimLane.width, swimLane.height));\n                swimLane.wrapper.arrange(swimLane.wrapper.desiredSize);\n                diagram.updateDiagramObject(swimLane);\n            }\n        }\n    }\n    diagram.updateDiagramElementQuad();\n}\n/**\n * updateSwimLaneObject method \\\n *\n * @returns {void} updateSwimLaneObject method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {Node} obj - provide the obj  value.\n * @param {NodeModel} swimLane - provide the target  value.\n * @param {NodeModel} helperObject - provide the position  value.\n * @private\n */\nexport function updateSwimLaneObject(diagram, obj, swimLane, helperObject) {\n    var parentNode = diagram.getObject(swimLane.id);\n    var shape = parentNode.shape;\n    var index = (shape.header && shape.hasHeader) ? 1 : 0;\n    var lanes = shape.lanes;\n    var phases = shape.phases;\n    var helperWidth = helperObject.wrapper.actualSize.width;\n    var helperHeight = helperObject.wrapper.actualSize.height;\n    var objWidth = obj.wrapper.actualSize.width;\n    var objHeight = obj.wrapper.actualSize.height;\n    if (parentNode.shape.type === 'SwimLane') {\n        if (shape.orientation === 'Horizontal') {\n            if (obj.isPhase) {\n                phases[obj.columnIndex].offset += (helperWidth - objWidth);\n            }\n            else {\n                index = (shape.phaseSize && shape.phases.length > 0) ? index + 1 : index;\n                lanes[(obj.rowIndex - index)].height += (helperHeight - objHeight);\n            }\n        }\n        else {\n            if (obj.isPhase) {\n                phases[(obj.rowIndex - index)].offset += (helperHeight - objHeight);\n            }\n            else {\n                index = (shape.phaseSize && shape.phases.length > 0) ? 1 : 0;\n                lanes[(obj.columnIndex - index)].width += (helperWidth - objWidth);\n            }\n        }\n    }\n}\n/**\n * findLaneIndex method \\\n *\n * @returns {number} findLaneIndex method .\\\n * @param {NodeModel} swimLane - provide the diagram  value.\n * @param {NodeModel} laneObj - provide the obj  value.\n * @private\n */\nexport function findLaneIndex(swimLane, laneObj) {\n    var laneIndex;\n    var shape = swimLane.shape;\n    var index = (shape.header && shape.hasHeader) ? 1 : 0;\n    if (shape.orientation === 'Horizontal') {\n        index += shape.phases.length > 0 ? 1 : 0;\n        laneIndex = laneObj.rowIndex - index;\n    }\n    else {\n        laneIndex = laneObj.columnIndex - (shape.phaseSize && shape.phases.length > 0 ? 1 : 0);\n    }\n    return laneIndex;\n}\n/**\n * findPhaseIndex method \\\n *\n * @returns {number} findPhaseIndex method .\\\n * @param {NodeModel} phase - provide the diagram  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @private\n */\nexport function findPhaseIndex(phase, swimLane) {\n    var shape = swimLane.shape;\n    var index = (shape.header && shape.hasHeader) ? 1 : 0;\n    var phaseIndex = (shape.orientation === 'Horizontal') ? phase.columnIndex : phase.rowIndex - index;\n    return phaseIndex;\n}\n/**\n * findStartLaneIndex method \\\n *\n * @returns {number} findStartLaneIndex method .\\\n * @param {NodeModel} swimLane - provide the obj  value.\n * @private\n */\nexport function findStartLaneIndex(swimLane) {\n    var index = 0;\n    var shape = swimLane.shape;\n    if (shape.orientation === 'Horizontal') {\n        index = (shape.header && shape.hasHeader) ? 1 : 0;\n    }\n    if (shape.phases.length > 0 && shape.phaseSize) {\n        index += 1;\n    }\n    return index;\n}\n/**\n * updatePhaseMaxWidth method \\\n *\n * @returns {void} updatePhaseMaxWidth method .\\\n * @param {NodeModel} parent - provide the obj  value.\n * @param {Diagram} diagram - provide the obj  value.\n * @param {Canvas} wrapper - provide the obj  value.\n * @param {number} columnIndex - provide the obj  value.\n * @private\n */\nexport function updatePhaseMaxWidth(parent, diagram, wrapper, columnIndex) {\n    var shape = parent.shape;\n    if (shape.phases.length > 0) {\n        var node = diagram.nameTable[shape.phases[columnIndex].header.id];\n        if (node && node.maxWidth < wrapper.outerBounds.width) {\n            node.maxWidth = wrapper.outerBounds.width;\n            node.wrapper.maxWidth = wrapper.outerBounds.width;\n        }\n    }\n}\n/**\n * updateHeaderMaxWidth method \\\n *\n * @returns {void} updateHeaderMaxWidth method .\\\n * @param {NodeModel} diagram - provide the obj  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @private\n */\nexport function updateHeaderMaxWidth(diagram, swimLane) {\n    if (swimLane.shape.header && swimLane.shape.hasHeader) {\n        var grid = swimLane.wrapper.children[0];\n        var id = grid.rows[0].cells[0].children[0].id;\n        var headerNode = diagram.nameTable[id];\n        if (headerNode && headerNode.isHeader && headerNode.maxWidth < swimLane.width) {\n            headerNode.maxWidth = swimLane.width;\n            headerNode.wrapper.maxWidth = swimLane.width;\n        }\n    }\n}\n/**\n * addLane method \\\n *\n * @returns {void} addLane method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} parent - provide the obj  value.\n * @param {LaneModel} lane - provide the obj  value.\n * @param {number} count - provide the obj  value.\n * @private\n */\nexport function addLane(diagram, parent, lane, count) {\n    var args;\n    var swimLane = diagram.nameTable[parent.id];\n    if (swimLane.shape.type === 'SwimLane') {\n        diagram.protectPropertyChange(true);\n        var grid = swimLane.wrapper.children[0];\n        var bounds = grid.bounds;\n        var shape = swimLane.shape;\n        var redoObj = void 0;\n        var orientation_1 = false;\n        var entry = void 0;\n        var index = void 0;\n        var children = void 0;\n        var j = void 0;\n        var i = void 0;\n        var k = void 0;\n        var cell = void 0;\n        var child = void 0;\n        var point = void 0;\n        var laneObj = new Lane(shape, 'lanes', lane, true);\n        index = (shape.header && shape.hasHeader) ? 1 : 0;\n        if (shape.orientation === 'Horizontal') {\n            orientation_1 = true;\n            index = shape.phases.length > 0 ? index + 1 : index;\n        }\n        var connectors = getConnectors(diagram, grid, 0, true);\n        var laneIndex = (count !== undefined) ? count : shape.lanes.length;\n        index += laneIndex;\n        args = {\n            element: laneObj, cause: diagram.diagramActions, state: 'Changing', type: 'Addition', cancel: false, laneIndex: laneIndex\n        };\n        diagram.triggerEvent(DiagramEvent.collectionChange, args);\n        if (!args.cancel) {\n            if (orientation_1) {\n                var rowDef = new RowDefinition();\n                rowDef.height = lane.height;\n                grid.addRow(index, rowDef, false);\n                swimLane.height = (swimLane.height !== undefined) ? swimLane.height + lane.height : swimLane.height;\n                swimLane.wrapper.height = grid.height = swimLane.height;\n            }\n            else {\n                var colDef = new ColumnDefinition();\n                colDef.width = lane.width;\n                grid.addColumn(laneIndex + 1, colDef, false);\n                if (swimLane.width) {\n                    swimLane.width += lane.width;\n                    swimLane.wrapper.width = grid.width = swimLane.width;\n                }\n                if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    grid.rows[0].cells[0].columnSpan += 1;\n                }\n            }\n            if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n                laneObj.id = (laneObj.id === '') ? randomId() : laneObj.id;\n            }\n            if (count !== undefined) {\n                shape.lanes.splice(count, 0, laneObj);\n            }\n            else {\n                shape.lanes.push(laneObj);\n            }\n            args = {\n                element: laneObj, cause: diagram.diagramActions, state: 'Changed', type: 'Addition', cancel: false, laneIndex: laneIndex\n            };\n            diagram.triggerEvent(DiagramEvent.collectionChange, args);\n            laneCollection(grid, diagram, swimLane, index, laneIndex, orientation_1);\n            redoObj = (shape.orientation === 'Horizontal') ?\n                diagram.nameTable[grid.rows[index].cells[0].children[0].id] :\n                ((shape.header && shape.hasHeader) ? diagram.nameTable[grid.rows[1].cells[index].children[0].id] :\n                    diagram.nameTable[grid.rows[0].cells[index].children[0].id]);\n            if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n                entry = {\n                    type: 'LaneCollectionChanged', changeType: 'Insert', undoObject: cloneObject(laneObj),\n                    redoObject: cloneObject(redoObj), category: 'Internal'\n                };\n                diagram.addHistoryEntry(entry);\n            }\n            var startRowIndex = (shape.orientation === 'Horizontal') ?\n                index : ((shape.header && shape.hasHeader) ? 1 : 0);\n            ChangeLaneIndex(diagram, swimLane, startRowIndex);\n            swimLaneMeasureAndArrange(swimLane);\n            updateHeaderMaxWidth(diagram, swimLane);\n            children = lane.children;\n            if (children && children.length > 0) {\n                for (j = 0; j < children.length; j++) {\n                    child = children[j];\n                    point = { x: child.wrapper.offsetX, y: child.wrapper.offsetY };\n                    if (shape.orientation === 'Horizontal') {\n                        cell = grid.rows[index].cells[i];\n                        for (i = 0; i < grid.rows[index].cells.length; i++) {\n                            addChildNodeToNewLane(diagram, grid.rows[index].cells[i], point, child);\n                        }\n                    }\n                    else {\n                        for (k = 0; k < grid.rows.length; k++) {\n                            cell = grid.rows[k].cells[index];\n                            addChildNodeToNewLane(diagram, cell, point, child);\n                        }\n                    }\n                }\n            }\n            updateConnectorsProperties(connectors, diagram);\n            diagram.drag(swimLane, bounds.x - grid.bounds.x, bounds.y - grid.bounds.y);\n        }\n        diagram.protectPropertyChange(false);\n    }\n}\n/**\n * addChildNodeToNewLane method \\\n *\n * @returns {void} addChildNodeToNewLane method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {GridCell} cell - provide the cell  value.\n * @param {PointModel} point - provide the point  value.\n * @param {NodeModel} child - provide the child  value.\n * @private\n */\nfunction addChildNodeToNewLane(diagram, cell, point, child) {\n    if (cell.children && cell.children.length > 0) {\n        var canvas = cell.children[0];\n        var parent_1 = diagram.nameTable[canvas.id];\n        if (canvas.bounds.containsPoint(point)) {\n            diagram.addChild(parent_1, child);\n        }\n    }\n}\n/**\n * addPhase method \\\n *\n * @returns {void} addPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} parent - provide the cell  value.\n * @param {PhaseModel} newPhase - provide the point  value.\n * @private\n */\nexport function addPhase(diagram, parent, newPhase) {\n    if (parent.shape.type === 'SwimLane') {\n        var gridRowIndex = void 0;\n        var gridColIndex = void 0;\n        var phaseNode = void 0;\n        var phase = void 0;\n        var previousPhase = void 0;\n        var nextPhase = void 0;\n        var phaseIndex = void 0;\n        var i = void 0;\n        var x = parent.wrapper.bounds.x;\n        var y = parent.wrapper.bounds.y;\n        var shape = parent.shape;\n        var padding = shape.padding;\n        var phasesCollection = shape.phases;\n        var width = void 0;\n        var grid = parent.wrapper.children[0];\n        var orientation_2 = shape.orientation === 'Horizontal' ? true : false;\n        gridRowIndex = (shape.header && shape.hasHeader) ? 0 : -1;\n        if (shape.phases.length > 0) {\n            gridRowIndex += 1;\n            gridColIndex = 0;\n        }\n        var laneHeaderSize = (orientation_2) ? shape.lanes[0].header.width : shape.lanes[0].header.height;\n        if (newPhase.offset > laneHeaderSize) {\n            for (i = 0; i < phasesCollection.length; i++) {\n                phase = phasesCollection[i];\n                previousPhase = (i > 0) ? phasesCollection[i - 1] : phase;\n                if (phase.offset > newPhase.offset) {\n                    width = (i > 0) ? newPhase.offset - previousPhase.offset : newPhase.offset;\n                    if (orientation_2) {\n                        var nextCol = grid.columnDefinitions()[i];\n                        nextCol.width -= width;\n                        nextPhase = diagram.nameTable[shape.phases[i].header.id];\n                        nextPhase.maxWidth = nextPhase.wrapper.maxWidth = nextCol.width;\n                        grid.updateColumnWidth(i, nextCol.width, false);\n                        var addPhase_1 = new ColumnDefinition();\n                        addPhase_1.width = width;\n                        phaseIndex = i;\n                        grid.addColumn(i, addPhase_1, false);\n                        break;\n                    }\n                    else {\n                        var nextRow = grid.rowDefinitions()[i + gridRowIndex];\n                        nextRow.height -= width;\n                        nextPhase = diagram.nameTable[shape.phases[i].header.id];\n                        grid.updateRowHeight(i + gridRowIndex, nextRow.height, false);\n                        var addPhase_2 = new RowDefinition();\n                        addPhase_2.height = width;\n                        phaseIndex = i;\n                        grid.addRow(i + gridRowIndex, addPhase_2, false);\n                        break;\n                    }\n                }\n            }\n            if (diagram.diagramActions & DiagramAction.UndoRedo && phaseIndex === undefined) {\n                var entry = diagram.historyManager.currentEntry.next;\n                if (entry.isLastPhase) {\n                    phaseIndex = phasesCollection.length;\n                    addLastPhase(phaseIndex, parent, entry, grid, orientation_2, newPhase);\n                }\n            }\n            var phaseObj = new Phase((parent.shape), 'phases', newPhase, true);\n            if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n                phaseObj.id += randomId();\n            }\n            shape.phases.splice(phaseIndex, 0, phaseObj);\n            phaseDefine(grid, diagram, parent, gridRowIndex, orientation_2, phaseIndex);\n            if (orientation_2) {\n                phaseNode = diagram.nameTable[grid.rows[gridRowIndex].cells[phaseIndex].children[0].id];\n                if (phaseIndex === 0 && shape.header && shape.hasHeader) {\n                    grid.rows[0].cells[0].children = grid.rows[0].cells[1].children;\n                    grid.rows[0].cells[1].children = [];\n                    var fristRow = grid.rows[0];\n                    for (var i_2 = 0; i_2 < fristRow.cells.length; i_2++) {\n                        fristRow.cells[i_2].minWidth = undefined;\n                        if (i_2 === 0) {\n                            fristRow.cells[i_2].columnSpan = grid.rows[0].cells.length;\n                        }\n                        else {\n                            fristRow.cells[i_2].columnSpan = 1;\n                        }\n                    }\n                }\n                addHorizontalPhase(diagram, parent, grid, phaseIndex, orientation_2);\n                var col = grid.columnDefinitions();\n                grid.updateColumnWidth(phaseIndex, col[phaseIndex].width, true, padding);\n                phaseNode.maxWidth = phaseNode.wrapper.maxWidth = col[phaseIndex].width;\n                if (col.length > phaseIndex + 1) {\n                    var nextPhaseNode = diagram.nameTable[grid.rows[gridRowIndex].cells[phaseIndex + 1].children[0].id];\n                    grid.updateColumnWidth(phaseIndex + 1, col[phaseIndex + 1].width, true, padding);\n                    nextPhaseNode.maxWidth = nextPhaseNode.wrapper.maxWidth = col[phaseIndex + 1].width;\n                }\n                parent.width = parent.wrapper.width = parent.wrapper.children[0].width = grid.width;\n            }\n            else {\n                phaseNode = diagram.nameTable[grid.rows[gridRowIndex + phaseIndex].cells[0].children[0].id];\n                var row = grid.rowDefinitions();\n                var size = row[gridRowIndex + phaseIndex].height;\n                addVerticalPhase(diagram, parent, grid, gridRowIndex + phaseIndex, orientation_2);\n                grid.updateRowHeight(gridRowIndex + phaseIndex, size, true, padding);\n                if (row.length > gridRowIndex + phaseIndex + 1) {\n                    size = row[gridRowIndex + phaseIndex + 1].height;\n                    grid.updateRowHeight(gridRowIndex + phaseIndex + 1, size, true, padding);\n                }\n                parent.height = parent.wrapper.height = parent.wrapper.children[0].height = grid.actualSize.height;\n            }\n            swimLaneMeasureAndArrange(parent);\n            parent.width = parent.wrapper.actualSize.width;\n            updateHeaderMaxWidth(diagram, parent);\n            diagram.drag(parent, x - parent.wrapper.bounds.x, y - parent.wrapper.bounds.y);\n            checkPhaseOffset(parent, diagram);\n            if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n                var entry = {\n                    type: 'PhaseCollectionChanged', changeType: 'Insert', undoObject: cloneObject(phaseObj),\n                    redoObject: cloneObject(phaseNode), category: 'Internal'\n                };\n                diagram.addHistoryEntry(entry);\n            }\n            diagram.updateDiagramObject(parent);\n        }\n    }\n}\n/**\n * addLastPhase method \\\n *\n * @returns {void} addLastPhase method .\\\n * @param {number} phaseIndex - provide the diagram  value.\n * @param {NodeModel} parent - provide the cell  value.\n * @param {HistoryEntry} entry - provide the point  value.\n * @param {GridPanel} grid - provide the grid  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @param {PhaseModel} newPhase - provide the newPhase  value.\n * @private\n */\nexport function addLastPhase(phaseIndex, parent, entry, grid, orientation, newPhase) {\n    var shape = parent.shape;\n    var prevPhase = shape.phases[phaseIndex - 2];\n    var prevOffset = entry.previousPhase.offset;\n    if (orientation) {\n        var nextCol = grid.columnDefinitions()[phaseIndex - 1];\n        var addPhase_3 = new ColumnDefinition();\n        if (phaseIndex > 1) {\n            addPhase_3.width = (nextCol.width) - (prevOffset - prevPhase.offset);\n            nextCol.width = prevOffset - prevPhase.offset;\n        }\n        else {\n            addPhase_3.width = nextCol.width - prevOffset;\n            nextCol.width = prevOffset;\n        }\n        grid.updateColumnWidth(phaseIndex - 1, nextCol.width, false);\n        grid.addColumn(phaseIndex, addPhase_3, false);\n    }\n    else {\n        var nextCol = grid.rowDefinitions()[phaseIndex];\n        var addPhase_4 = new RowDefinition();\n        if (phaseIndex > 1) {\n            addPhase_4.height = entry.undoObject.offset - prevOffset;\n            nextCol.height = prevOffset - prevPhase.offset;\n        }\n        else {\n            addPhase_4.height = nextCol.height - prevOffset;\n            nextCol.height = prevOffset;\n        }\n        grid.updateRowHeight(phaseIndex, nextCol.height, false);\n        grid.addRow(1 + phaseIndex, addPhase_4, false);\n    }\n}\n/**\n * addHorizontalPhase method \\\n *\n * @returns {void} addHorizontalPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the cell  value.\n * @param {GridPanel} grid - provide the point  value.\n * @param {number} index - provide the point  value.\n * @param {boolean} orientation - provide the point  value.\n * @private\n */\nexport function addHorizontalPhase(diagram, node, grid, index, orientation) {\n    var shape = node.shape;\n    var nextCell;\n    var i;\n    var prevCell;\n    var gridCell;\n    var row;\n    var laneIndex = findStartLaneIndex(node);\n    if (shape.header && shape.hasHeader) {\n        grid.rows[0].cells[0].columnSpan = grid.rows[0].cells.length;\n    }\n    for (i = laneIndex; i < grid.rows.length; i++) {\n        row = grid.rows[i];\n        prevCell = row.cells[index - 1];\n        gridCell = row.cells[index];\n        nextCell = row.cells[index + 1];\n        addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, i, index);\n    }\n    ChangeLaneIndex(diagram, node, 1);\n}\n/**\n * addVerticalPhase method \\\n *\n * @returns {void} addVerticalPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the cell  value.\n * @param {GridPanel} grid - provide the point  value.\n * @param {number} rowIndex - provide the point  value.\n * @param {boolean} orientation - provide the point  value.\n * @private\n */\nexport function addVerticalPhase(diagram, node, grid, rowIndex, orientation) {\n    var prevCell;\n    var gridCell;\n    var nextCell;\n    var row = grid.rows[rowIndex];\n    var nextRow = grid.rows[rowIndex + 1];\n    var prevRow = grid.rows[rowIndex - 1];\n    for (var i = 1; i < row.cells.length; i++) {\n        gridCell = row.cells[i];\n        nextCell = (nextRow) ? nextRow.cells[i] : undefined;\n        prevCell = prevRow.cells[i];\n        addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, rowIndex, i);\n    }\n    ChangeLaneIndex(diagram, node, 1);\n}\n/**\n * addSwimlanePhases method \\\n *\n * @returns {void} addSwimlanePhases method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the node  value.\n * @param {GridPanel} prevCell - provide the prevCell  value.\n * @param {number} gridCell - provide the gridCell  value.\n * @param {boolean} nextCell - provide the nextCell  value.\n * @param {boolean} rowIndex - provide the rowIndex  value.\n * @param {boolean} columnIndex - provide the columnIndex  value.\n * @private\n */\nfunction addSwimlanePhases(diagram, node, prevCell, gridCell, nextCell, rowIndex, columnIndex) {\n    var x;\n    var y;\n    var shape = node.shape;\n    var orientation = shape.orientation === 'Horizontal' ? true : false;\n    var grid = node.wrapper.children[0];\n    var width = gridCell.desiredCellWidth;\n    var height = gridCell.desiredCellHeight;\n    //const col: number = (orientation) ? rowIndex : columnIndex;\n    //let parentWrapper: Container;\n    var j;\n    var i = (orientation) ? rowIndex : columnIndex;\n    if (prevCell) {\n        x = orientation ? prevCell.bounds.x + prevCell.bounds.width : prevCell.bounds.x;\n        y = orientation ? prevCell.bounds.y : prevCell.bounds.y + prevCell.bounds.height;\n    }\n    else {\n        x = grid.bounds.x;\n        y = nextCell.bounds.y;\n    }\n    var rect = new Rect(x, y, width, height);\n    var canvas = {\n        id: node.id + ((orientation) ? shape.lanes[i - 2] : shape.lanes[i - 1]).id + randomId()[0],\n        rowIndex: rowIndex, columnIndex: columnIndex,\n        width: gridCell.minWidth, height: gridCell.minHeight,\n        style: ((orientation) ? shape.lanes[i - 2] : shape.lanes[i - 1]).style,\n        constraints: NodeConstraints.Default | NodeConstraints.AllowDrop,\n        container: { type: 'Canvas', orientation: orientation ? 'Horizontal' : 'Vertical' }\n    };\n    var parentWrapper = addObjectToGrid(diagram, grid, node, canvas, false, false, true);\n    parentWrapper.children[0].isCalculateDesiredSize = false;\n    grid.addObject(parentWrapper, rowIndex, columnIndex);\n    if (nextCell && nextCell.children && nextCell.children.length) {\n        for (j = 0; j < nextCell.children.length; j++) {\n            if (orientation) {\n                diagram.nameTable[nextCell.children[j].id].columnIndex += 1;\n            }\n            else {\n                diagram.nameTable[nextCell.children[j].id].rowIndex += 1;\n            }\n        }\n    }\n    arrangeChildInGrid(diagram, nextCell, gridCell, rect, parentWrapper, orientation, prevCell);\n}\n/**\n * arrangeChildInGrid method \\\n *\n * @returns {void} arrangeChildInGrid method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {GridCell} nextCell - provide the nextCell  value.\n * @param {GridPanel} gridCell - provide the gridCell  value.\n * @param {Rect} rect - provide the rect  value.\n * @param {Container} parentWrapper - provide the parentWrapper  value.\n * @param {boolean} orientation - provide the orientation  value.\n * @param {GridCell} prevCell - provide the prevCell  value.\n * @private\n */\nexport function arrangeChildInGrid(diagram, nextCell, gridCell, rect, parentWrapper, orientation, prevCell) {\n    var child;\n    var point;\n    var childNode;\n    var parent = diagram.nameTable[parentWrapper.id];\n    var changeCell = (!nextCell) ? prevCell : nextCell;\n    var swimLane = diagram.nameTable[parent.parentId];\n    var padding = swimLane.shape.padding;\n    if (changeCell.children && changeCell.children[0].children.length > 1) {\n        for (var j = 1; j < changeCell.children[0].children.length; j++) {\n            child = changeCell.children[0].children[j];\n            childNode = diagram.nameTable[child.id];\n            point = (orientation) ? { x: child.bounds.x, y: child.bounds.center.y } :\n                { x: child.bounds.center.x, y: child.bounds.top };\n            if (rect.containsPoint(point)) {\n                gridCell.children[0].children.push(child);\n                changeCell.children[0].children.splice(j, 1);\n                j--;\n                diagram.deleteChild(childNode);\n                if (!childNode.isLane) {\n                    childNode.parentId = parentWrapper.id;\n                }\n                if (!parent.children) {\n                    parent.children = [];\n                }\n                if (!nextCell) {\n                    if (orientation) {\n                        childNode.margin.left = childNode.wrapper.bounds.x - changeCell.children[0].bounds.right;\n                    }\n                    else {\n                        childNode.margin.top = childNode.wrapper.bounds.y - changeCell.children[0].bounds.bottom;\n                    }\n                }\n                parent.children.push(child.id);\n                childNode.zIndex = parent.zIndex + 1;\n                diagram.removeElements(childNode);\n            }\n            else if (nextCell) {\n                if (orientation) {\n                    childNode.margin.left -= gridCell.desiredCellWidth;\n                    if (padding > childNode.margin.left) {\n                        childNode.margin.left = padding;\n                    }\n                }\n                else {\n                    childNode.margin.top -= gridCell.desiredCellHeight;\n                    if (padding > childNode.margin.top) {\n                        childNode.margin.top = padding;\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * swimLaneSelection method \\\n *\n * @returns {void} swimLaneSelection method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the node  value.\n * @param {string} corner - provide the corner  value.\n * @private\n */\nexport function swimLaneSelection(diagram, node, corner) {\n    if (node.shape.type === 'SwimLane' && (corner === 'ResizeSouth' || corner === 'ResizeEast')) {\n        var shape = node.shape;\n        var wrapper = node.wrapper.children[0];\n        var child = void 0;\n        var index = void 0;\n        if (corner === 'ResizeSouth') {\n            if (shape.orientation === 'Vertical') {\n                child = wrapper.rows[wrapper.rows.length - 1].cells[0];\n            }\n            else {\n                index = wrapper.rows.length - 1;\n                child = wrapper.rows[index].cells[wrapper.rows[index].cells.length - 1];\n            }\n        }\n        else {\n            index = (shape.header && shape.hasHeader) ? 1 : 0;\n            child = wrapper.rows[index].cells[wrapper.rows[index].cells.length - 1];\n        }\n        diagram.commandHandler.select(diagram.nameTable[child.children[0].id]);\n    }\n}\n/**\n * pasteSwimLane method \\\n *\n * @returns {void} pasteSwimLane method .\\\n * @param {Diagram} swimLane - provide the diagram  value.\n * @param {NodeModel} diagram - provide the diagram  value.\n * @param {string} clipboardData - provide the clipboardData  value.\n * @param {string} laneNode - provide the laneNode  value.\n * @param {string} isLane - provide the isLane  value.\n * @param {string} isUndo - provide the isUndo  value.\n * @private\n */\nexport function pasteSwimLane(swimLane, diagram, clipboardData, laneNode, isLane, isUndo) {\n    var i;\n    var j;\n    var lane;\n    var phase;\n    var node;\n    var ranId = randomId();\n    var cloneLane;\n    var childX;\n    var childY;\n    var shape = swimLane.shape; //let lanes: LaneModel[];\n    var phases = shape.phases;\n    var nodeX = swimLane.offsetX - swimLane.wrapper.actualSize.width / 2;\n    var nodeY = swimLane.offsetY - swimLane.wrapper.actualSize.height / 2;\n    if (shape.orientation === 'Vertical') {\n        nodeY += (shape.header && shape.hasHeader) ? shape.header.height : 0;\n    }\n    if (!isUndo) {\n        if (!isLane) {\n            swimLane.id += ranId;\n            if (shape && shape.header && shape.hasHeader) {\n                shape.header.id += ranId;\n            }\n            else {\n                shape.header = undefined;\n            }\n        }\n        for (i = 0; phases && i < phases.length; i++) {\n            phase = phases[i];\n            phase.id += ranId;\n        }\n    }\n    var lanes = (isLane) ? [clipboardData.childTable[laneNode.id]] : shape.lanes;\n    for (i = 0; lanes && i < lanes.length; i++) {\n        lane = lanes[i];\n        if (!isUndo) {\n            lane.id += ranId;\n        }\n        for (j = 0; lane.children && j < lane.children.length; j++) {\n            node = lane.children[j];\n            childX = node.wrapper.offsetX - node.width / 2;\n            childY = node.wrapper.offsetY - node.height / 2;\n            node.zIndex = -1;\n            node.inEdges = node.outEdges = [];\n            if (isUndo || (clipboardData && (clipboardData.pasteIndex === 1 || clipboardData.pasteIndex === 0))) {\n                if (shape.orientation === 'Vertical') {\n                    node.margin.top = childY - nodeY;\n                }\n                else {\n                    node.margin.left = childX - nodeX;\n                }\n            }\n            if (!isUndo) {\n                node.id += ranId;\n            }\n        }\n    }\n    if (!isUndo) {\n        if (isLane) {\n            var newShape = {\n                lanes: lanes,\n                phases: phases, phaseSize: shape.phaseSize,\n                type: 'SwimLane', orientation: shape.orientation,\n                header: { annotation: { content: 'Title' }, height: 50 }\n            };\n            cloneLane = { shape: newShape };\n            if (shape.orientation === 'Horizontal') {\n                cloneLane.width = swimLane.wrapper.actualSize.width;\n                cloneLane.height = laneNode.wrapper.actualSize.height + shape.header.height + shape.phaseSize;\n                cloneLane.offsetX = swimLane.wrapper.offsetX + (clipboardData.pasteIndex * 10);\n                cloneLane.offsetY = laneNode.wrapper.offsetY + (clipboardData.pasteIndex * 10);\n            }\n            else {\n                cloneLane.width = laneNode.wrapper.actualSize.width;\n                cloneLane.height = swimLane.wrapper.actualSize.height;\n                cloneLane.offsetX = laneNode.wrapper.offsetX + (clipboardData.pasteIndex * 10);\n                cloneLane.offsetY = swimLane.wrapper.offsetY + (clipboardData.pasteIndex * 10);\n            }\n            swimLane = cloneLane;\n        }\n        if (clipboardData.pasteIndex !== 0) {\n            swimLane.offsetX += 10;\n            swimLane.offsetY += 10;\n        }\n        swimLane.zIndex = -1;\n        swimLane = diagram.add(swimLane);\n        if (!isLane) {\n            for (var _i = 0, _a = Object.keys(clipboardData.childTable); _i < _a.length; _i++) {\n                var i_3 = _a[_i];\n                var connector = clipboardData.childTable[i_3];\n                connector.id += ranId;\n                connector.sourceID += ranId;\n                connector.targetID += ranId;\n                connector.zIndex = -1;\n                diagram.add(connector);\n            }\n        }\n        if (diagram.mode !== 'SVG') {\n            diagram.refreshDiagramLayer();\n        }\n        diagram.select([swimLane]);\n    }\n    return swimLane;\n}\n/**\n * gridSelection method \\\n *\n * @returns {void} gridSelection method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {SelectorModel} selectorModel - provide the selectorModel  value.\n * @param {string} id - provide the id  value.\n * @param {boolean} isSymbolDrag - provide the isSymbolDrag  value.\n * @private\n */\nexport function gridSelection(diagram, selectorModel, id, isSymbolDrag) {\n    var canvas;\n    var node = selectorModel.nodes[0];\n    if (isSymbolDrag || checkParentAsContainer(diagram, node, true)) {\n        var targetnode = void 0;\n        var bounds = void 0;\n        var swimLaneId = void 0;\n        var element = new DiagramElement();\n        if (id) {\n            swimLaneId = (diagram.nameTable[id].parentId);\n            targetnode = node = diagram.nameTable[id];\n        }\n        var wrapper = !id ? node.wrapper : targetnode.wrapper;\n        var parentNode = diagram.nameTable[swimLaneId || node.parentId];\n        if (parentNode && parentNode.container.type === 'Grid') {\n            canvas = new Canvas();\n            canvas.children = [];\n            if (isSymbolDrag || !(node.isHeader)) {\n                if ((parentNode.container.orientation === 'Horizontal' && node.isPhase) ||\n                    (parentNode.container.orientation === 'Vertical' &&\n                        (node.rowIndex > 0 && node.columnIndex > 0 || node.isLane))) {\n                    bounds = findBounds(parentNode, (targetnode) ? targetnode.columnIndex : node.columnIndex, (parentNode.shape.header && parentNode.shape.hasHeader) ? true : false);\n                    canvas.offsetX = bounds.center.x;\n                    canvas.offsetY = bounds.center.y;\n                    element.width = bounds.width;\n                    element.height = bounds.height;\n                }\n                else {\n                    canvas.offsetX = parentNode.offsetX;\n                    canvas.offsetY = wrapper.offsetY;\n                    element.width = parentNode.wrapper.actualSize.width;\n                    element.height = wrapper.actualSize.height;\n                }\n            }\n            canvas.children.push(element);\n            canvas.measure(new Size());\n            canvas.arrange(canvas.desiredSize);\n        }\n    }\n    return canvas;\n}\n/**\n * removeLaneChildNode method \\\n *\n * @returns {void} removeLaneChildNode method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} swimLaneNode - provide the diagram  value.\n * @param {NodeModel} currentObj - provide the currentObj  value.\n * @param {NodeModel} isChildNode - provide the isChildNode  value.\n * @param {number} laneIndex - provide the laneIndex  value.\n * @private\n */\nexport function removeLaneChildNode(diagram, swimLaneNode, currentObj, isChildNode, laneIndex) {\n    laneIndex = (laneIndex !== undefined) ? laneIndex : findLaneIndex(swimLaneNode, currentObj);\n    var preventHistory = false;\n    var lanenode = swimLaneNode.shape.lanes[laneIndex];\n    for (var j = lanenode.children.length - 1; j >= 0; j--) {\n        if (isChildNode) {\n            if (isChildNode.id === lanenode.children[j].id) {\n                lanenode.children.splice(j, 1);\n            }\n        }\n        else {\n            diagram.removeDependentConnector(lanenode.children[j]);\n            if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n                diagram.diagramActions = diagram.diagramActions | DiagramAction.UndoRedo;\n                preventHistory = true;\n            }\n            diagram.remove(lanenode.children[j]);\n            lanenode.children.splice(j, 1);\n            if (preventHistory) {\n                diagram.diagramActions = diagram.diagramActions & ~DiagramAction.UndoRedo;\n            }\n        }\n    }\n}\n/**\n * getGridChildren method \\\n *\n * @returns {DiagramElement} getGridChildren method .\\\n * @param {Diagram} obj - provide the obj  value.\n * @private\n */\nexport function getGridChildren(obj) {\n    var children = obj.children[0];\n    return children;\n}\n/**\n * removeSwimLane method \\\n *\n * @returns {void} removeSwimLane method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} obj - provide the obj  value.\n * @private\n */\nexport function removeSwimLane(diagram, obj) {\n    var rows = obj.wrapper.children[0].rows;\n    //let preventHistory: boolean = false;\n    var node;\n    var i;\n    var j;\n    var k;\n    var child;\n    var removeNode;\n    for (i = 0; i < rows.length; i++) {\n        for (j = 0; j < rows[i].cells.length; j++) {\n            child = getGridChildren(rows[i].cells[j]);\n            if (child && child.children) {\n                for (k = child.children.length - 1; k >= 0; k--) {\n                    if (child.children[k].children) {\n                        removeNode = diagram.nameTable[child.children[k].id];\n                        if (removeNode) {\n                            if (removeNode.isLane) {\n                                deleteNode(diagram, removeNode);\n                            }\n                            else {\n                                diagram.removeDependentConnector(removeNode);\n                                diagram.diagramActions |= DiagramAction.PreventHistory;\n                                if ((removeNode.constraints & NodeConstraints.Delete)) {\n                                    diagram.remove(removeNode);\n                                }\n                                else {\n                                    removeChildInContainer(diagram, removeNode, {}, false);\n                                }\n                                diagram.diagramActions &= ~DiagramAction.PreventHistory;\n                            }\n                        }\n                    }\n                }\n            }\n            if (child) {\n                node = diagram.nameTable[child.id];\n                if (node) {\n                    deleteNode(diagram, node);\n                }\n            }\n        }\n    }\n}\n/**\n * deleteNode method \\\n *\n * @returns {void} deleteNode method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} node - provide the obj  value.\n * @private\n */\nfunction deleteNode(diagram, node) {\n    diagram.nodes.splice(diagram.nodes.indexOf(node), 1);\n    diagram.removeFromAQuad(node);\n    diagram.removeObjectsFromLayer(node);\n    delete diagram.nameTable[node.id];\n    diagram.removeElements(node);\n}\n/**\n * removeLane method \\\n *\n * @returns {void} removeLane method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} lane - provide the obj  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @param {LaneModel} lanes - provide the obj  value.\n * @private\n */\nexport function removeLane(diagram, lane, swimLane, lanes) {\n    var args;\n    if (swimLane.shape.type === 'SwimLane') {\n        var shape = swimLane.shape;\n        var laneIndex = void 0;\n        if (shape.lanes.length === 1) {\n            diagram.remove(swimLane);\n        }\n        else {\n            var x = swimLane.wrapper.bounds.x;\n            var y = swimLane.wrapper.bounds.y;\n            var row = void 0;\n            var i = void 0;\n            var cell = void 0;\n            var j = void 0;\n            var child = void 0;\n            var grid = swimLane.wrapper.children[0];\n            laneIndex = (lanes) ? (shape.lanes.indexOf(lanes)) : findLaneIndex(swimLane, lane);\n            args = {\n                element: lane, cause: diagram.diagramActions, state: 'Changing', type: 'Removal', cancel: false, laneIndex: laneIndex\n            };\n            diagram.triggerEvent(DiagramEvent.collectionChange, args);\n            if (!args.cancel) {\n                var undoObj = cloneObject(shape.lanes[laneIndex]);\n                removeLaneChildNode(diagram, swimLane, lane, undefined, laneIndex);\n                if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    var entry = {\n                        type: 'LaneCollectionChanged', changeType: 'Remove', undoObject: undoObj,\n                        redoObject: cloneObject(lane), category: 'Internal'\n                    };\n                    diagram.addHistoryEntry(entry);\n                }\n                shape.lanes.splice(laneIndex, 1);\n                var index = (lane) ? (shape.orientation === 'Horizontal' ? lane.rowIndex : lane.columnIndex) :\n                    (findStartLaneIndex(swimLane) + laneIndex);\n                if (shape.orientation === 'Horizontal') {\n                    row = grid.rows[index];\n                    for (i = 0; i < row.cells.length; i++) {\n                        cell = row.cells[i];\n                        if (cell && cell.children.length > 0) {\n                            for (j = 0; j < cell.children.length; j++) {\n                                child = cell.children[j];\n                                removeChildren(diagram, child);\n                            }\n                        }\n                    }\n                    grid.removeRow(index);\n                }\n                else {\n                    swimLane.width = (swimLane.width !== undefined) ?\n                        swimLane.width - grid.rows[0].cells[index].actualSize.width : swimLane.width;\n                    for (i = 0; i < grid.rows.length; i++) {\n                        cell = grid.rows[i].cells[index];\n                        if (cell && cell.children.length > 0) {\n                            for (j = 0; j < cell.children.length; j++) {\n                                child = cell.children[j];\n                                removeChildren(diagram, child);\n                            }\n                        }\n                    }\n                    grid.removeColumn(index);\n                }\n                args = {\n                    element: lane, cause: diagram.diagramActions, state: 'Changed', type: 'Removal', cancel: false, laneIndex: laneIndex\n                };\n                diagram.triggerEvent(DiagramEvent.collectionChange, args);\n                swimLane.width = swimLane.wrapper.width = grid.width;\n                swimLane.height = swimLane.wrapper.height = grid.height;\n                swimLaneMeasureAndArrange(swimLane);\n                if (swimLane.shape.orientation === 'Vertical') {\n                    index = 0;\n                }\n                ChangeLaneIndex(diagram, swimLane, index);\n                diagram.drag(swimLane, x - swimLane.wrapper.bounds.x, y - swimLane.wrapper.bounds.y);\n                diagram.updateDiagramObject(swimLane);\n            }\n        }\n    }\n}\n/**\n * removeChildren method \\\n *\n * @returns {void} removeChildren method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {Canvas} canvas - provide the obj  value.\n * @private\n */\nexport function removeChildren(diagram, canvas) {\n    var i;\n    var node;\n    if (canvas instanceof Canvas) {\n        if (canvas.children.length > 0) {\n            for (i = 0; i < canvas.children.length; i++) {\n                if (canvas.children[i] instanceof Canvas) {\n                    removeChildren(diagram, canvas.children[i]);\n                }\n            }\n        }\n        node = diagram.getObject(canvas.id);\n        deleteNode(diagram, node);\n    }\n}\n/**\n * removePhase method \\\n *\n * @returns {void} removePhase method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {NodeModel} phase - provide the obj  value.\n * @param {NodeModel} swimLane - provide the obj  value.\n * @param {PhaseModel} swimLanePhases - provide the obj  value.\n * @private\n */\nexport function removePhase(diagram, phase, swimLane, swimLanePhases) {\n    diagram.protectPropertyChange(true);\n    var x = swimLane.wrapper.bounds.x;\n    var y = swimLane.wrapper.bounds.y;\n    var isLastPhase = false;\n    var previousPhase;\n    var shape = swimLane.shape;\n    var grid = swimLane.wrapper.children[0];\n    var phaseIndex = swimLanePhases ? shape.phases.indexOf(swimLanePhases) : findPhaseIndex(phase, swimLane);\n    var phaseLength = shape.phases.length;\n    if (shape.phases.length > 1) {\n        if (phaseIndex === phaseLength - 1) {\n            isLastPhase = true;\n            previousPhase = cloneObject(shape.phases[phaseIndex - 1]);\n        }\n        var undoObj = cloneObject(shape.phases[phaseIndex]);\n        shape.phases.splice(phaseIndex, 1);\n        if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n            var entry = {\n                type: 'PhaseCollectionChanged', changeType: 'Remove', undoObject: undoObj, previousPhase: previousPhase,\n                redoObject: cloneObject(phase), category: 'Internal', isLastPhase: isLastPhase\n            };\n            diagram.addHistoryEntry(entry);\n        }\n        if (shape.orientation === 'Horizontal') {\n            removeHorizontalPhase(diagram, grid, phase, phaseIndex);\n        }\n        else {\n            removeVerticalPhase(diagram, grid, phase, phaseIndex, swimLane);\n        }\n        updateHeaderMaxWidth(diagram, swimLane);\n        ChangeLaneIndex(diagram, swimLane, 1);\n        checkPhaseOffset(swimLane, diagram);\n        diagram.protectPropertyChange(false);\n        diagram.updateDiagramObject(swimLane);\n    }\n}\n/**\n * removeHorizontalPhase method \\\n *\n * @returns {void} removeHorizontalPhase method .\\\n * @param {Diagram} diagram - provide the obj  value.\n * @param {GridPanel} grid - provide the obj  value.\n * @param {NodeModel} phase - provide the obj  value.\n * @param {number} phaseIndex - provide the obj  value.\n * @private\n */\nexport function removeHorizontalPhase(diagram, grid, phase, phaseIndex) {\n    var row;\n    var cell;\n    var prevCell;\n    var actualChild; //let prevChild: Canvas;\n    var prevCanvas;\n    var width;\n    phaseIndex = (phaseIndex !== undefined) ? phaseIndex : phase.columnIndex;\n    var i;\n    var j;\n    var k;\n    var child;\n    var node;\n    var object;\n    for (i = 0; i < grid.rows.length; i++) {\n        row = grid.rows[i];\n        if (row.cells.length > 1) {\n            cell = row.cells[phaseIndex];\n            prevCell = (row.cells.length - 1 === phaseIndex) ? row.cells[phaseIndex - 1] :\n                row.cells[phaseIndex + 1];\n            prevCanvas = prevCell.children[0];\n            if (cell.children.length > 0) {\n                actualChild = cell.children[0];\n                node = diagram.nameTable[actualChild.id];\n                if (prevCell.children.length === 0 && cell.children.length > 0) {\n                    prevCell.children = cell.children;\n                    prevCell.columnSpan = cell.columnSpan - 1;\n                }\n                else {\n                    for (j = 0; j < actualChild.children.length; j++) {\n                        child = actualChild.children[j];\n                        if (child instanceof Canvas) {\n                            object = diagram.nameTable[child.id];\n                            if (!object.isLane) {\n                                object.parentId = prevCanvas.id;\n                            }\n                            if ((row.cells.length - 1 === phaseIndex)) {\n                                object.margin.left = object.wrapper.bounds.x - prevCanvas.bounds.x;\n                                child.margin.left = object.wrapper.bounds.x - prevCanvas.bounds.x;\n                            }\n                            prevCanvas.children.push(child);\n                            if (diagram.nameTable[prevCanvas.id]) {\n                                var parentNode = diagram.nameTable[prevCanvas.id];\n                                if (!parentNode.children) {\n                                    parentNode.children = [];\n                                }\n                                parentNode.children.push(child.id);\n                            }\n                            actualChild.children.splice(j, 1);\n                            j--;\n                            if (node && node.children && node.children.indexOf(object.id) !== -1) {\n                                node.children.splice(node.children.indexOf(object.id), 1);\n                            }\n                        }\n                        if ((row.cells.length - 1 !== phaseIndex)) {\n                            for (k = 0; k < prevCanvas.children.length; k++) {\n                                var prevChild = prevCanvas.children[k];\n                                if (prevChild instanceof Canvas) {\n                                    var prevNode = diagram.nameTable[prevChild.id];\n                                    prevNode.margin.left = prevNode.wrapper.bounds.x - actualChild.bounds.x;\n                                    prevChild.margin.left = prevNode.wrapper.bounds.x - actualChild.bounds.x;\n                                }\n                            }\n                        }\n                    }\n                    if (node && node.isPhase) {\n                        var object_1 = diagram.nameTable[prevCanvas.id];\n                        if (object_1) {\n                            prevCanvas.maxWidth = object_1.wrapper.maxWidth = object_1.wrapper.maxWidth += node.wrapper.maxWidth;\n                        }\n                    }\n                    deleteNode(diagram, node);\n                }\n            }\n        }\n    }\n    var prevWidth = grid.columnDefinitions()[phaseIndex].width;\n    grid.removeColumn(phaseIndex);\n    if ((phaseIndex < grid.columnDefinitions().length)) {\n        width = grid.columnDefinitions()[phaseIndex].width;\n        width += prevWidth;\n        grid.updateColumnWidth(phaseIndex, width, true);\n    }\n    else {\n        width = grid.columnDefinitions()[phaseIndex - 1].width;\n        width += prevWidth;\n        grid.updateColumnWidth(phaseIndex - 1, width, true);\n    }\n}\n/**\n * removeVerticalPhase method \\\n *\n * @returns {void} removeVerticalPhase method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {GridPanel} grid - provide the grid  value.\n * @param {NodeModel} phase - provide the phase  value.\n * @param {number} phaseIndex - provide the phaseIndex  value.\n * @param {number} swimLane - provide the swimLane  value.\n * @private\n */\nexport function removeVerticalPhase(diagram, grid, phase, phaseIndex, swimLane) {\n    var cell;\n    var height;\n    var i;\n    var j;\n    var k;\n    var prevCell;\n    var prevChild;\n    var shape = swimLane.shape;\n    var child;\n    var object;\n    var phaseRowIndex = (phaseIndex !== undefined) ? ((shape.header) ? phaseIndex + 1 : phaseIndex) : phase.rowIndex;\n    var row = grid.rows[phaseRowIndex];\n    var top = swimLane.wrapper.bounds.y;\n    var phaseCount = shape.phases.length;\n    if (shape.header !== undefined && shape.hasHeader) {\n        top += grid.rowDefinitions()[0].height;\n    }\n    var prevRow = (phaseIndex === phaseCount) ? grid.rows[phaseRowIndex - 1] : grid.rows[phaseRowIndex + 1];\n    for (i = 0; i < row.cells.length; i++) {\n        cell = row.cells[i];\n        prevCell = prevRow.cells[i];\n        prevChild = prevCell.children[0];\n        if (cell.children.length > 0) {\n            var children = cell.children[0];\n            var node = diagram.nameTable[children.id];\n            if (phaseIndex < phaseCount) {\n                for (k = 0; k < prevChild.children.length; k++) {\n                    child = prevChild.children[k];\n                    if (child instanceof Canvas) {\n                        object = diagram.nameTable[child.id];\n                        object.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : children.bounds.y);\n                        child.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : children.bounds.y);\n                    }\n                }\n            }\n            for (j = 0; j < children.children.length; j++) {\n                child = children.children[j];\n                if (child instanceof Canvas) {\n                    object = diagram.nameTable[child.id];\n                    object.parentId = prevChild.id;\n                    if (phaseIndex === phaseCount) {\n                        object.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : prevChild.bounds.y);\n                        child.margin.top = object.wrapper.bounds.y - (phaseIndex === 0 ? top : prevChild.bounds.y);\n                    }\n                    prevChild.children.push(child);\n                    children.children.splice(j, 1);\n                    j--;\n                    if (node.children && node.children.indexOf(object.id) !== -1) {\n                        node.children.splice(node.children.indexOf(object.id), 1);\n                    }\n                }\n            }\n            deleteNode(diagram, node);\n        }\n    }\n    var prevHeight = grid.rowDefinitions()[phaseRowIndex].height;\n    grid.removeRow(phaseRowIndex);\n    if ((phaseRowIndex < grid.rowDefinitions().length)) {\n        height = grid.rowDefinitions()[phaseRowIndex].height;\n        height += prevHeight;\n        grid.updateRowHeight(phaseRowIndex, height, true);\n    }\n    else {\n        height = grid.rowDefinitions()[phaseRowIndex - 1].height;\n        height += prevHeight;\n        grid.updateRowHeight(phaseRowIndex - 1, height, true);\n    }\n}\n/**\n * considerSwimLanePadding method \\\n *\n * @returns {void} considerSwimLanePadding method .\\\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {NodeModel} node - provide the grid  value.\n * @param {number} padding - provide the phase  value.\n * @private\n */\nexport function considerSwimLanePadding(diagram, node, padding) {\n    var lane = diagram.nameTable[node.parentId];\n    if (lane && lane.isLane) {\n        var swimLane = diagram.nameTable[lane.parentId];\n        var grid = swimLane.wrapper.children[0];\n        //let x: number = swimLane.wrapper.bounds.x; let y: number = swimLane.wrapper.bounds.y;\n        grid.updateColumnWidth(lane.columnIndex, grid.columnDefinitions()[lane.columnIndex].width, true, padding);\n        grid.updateRowHeight(lane.rowIndex, grid.rowDefinitions()[lane.rowIndex].height, true, padding);\n        var canvas = lane.wrapper;\n        var laneHeader = void 0;\n        var isConsiderHeader = false;\n        if (node.margin.left < padding) {\n            node.margin.left = padding;\n        }\n        if (node.margin.top < padding) {\n            node.margin.top = padding;\n        }\n        for (var i = 0; i < canvas.children.length; i++) {\n            var child = canvas.children[i];\n            if (child instanceof Canvas) {\n                var childNode = diagram.nameTable[child.id];\n                if (childNode.isLane) {\n                    laneHeader = childNode.wrapper;\n                    isConsiderHeader = true;\n                    break;\n                }\n            }\n        }\n        if (laneHeader) {\n            if (swimLane.shape.orientation === 'Horizontal') {\n                if (node.margin.left < padding + laneHeader.actualSize.width) {\n                    node.margin.left = padding + laneHeader.actualSize.width;\n                }\n            }\n            else {\n                if (node.margin.top < padding + laneHeader.actualSize.height) {\n                    node.margin.top = padding + laneHeader.actualSize.height;\n                }\n            }\n        }\n        swimLane.wrapper.measure(new Size(swimLane.width, swimLane.height));\n        swimLane.wrapper.arrange(swimLane.wrapper.desiredSize);\n        node.offsetX = node.wrapper.offsetX;\n        node.offsetY = node.wrapper.offsetY;\n        diagram.nodePropertyChange(node, {}, { margin: { left: node.margin.left, top: node.margin.top } });\n        grid.measure(new Size(grid.width, grid.height));\n        grid.arrange(grid.desiredSize);\n        swimLane.width = swimLane.wrapper.width = swimLane.wrapper.children[0].actualSize.width;\n        swimLane.height = swimLane.wrapper.height = swimLane.wrapper.children[0].actualSize.height;\n    }\n}\n/**\n * checkLaneChildrenOffset method \\\n *\n * @returns {void} checkLaneChildrenOffset method .\\\n * @param {NodeModel} swimLane - provide the diagram  value.\n * @private\n */\nexport function checkLaneChildrenOffset(swimLane) {\n    if (swimLane.shape.type === 'SwimLane') {\n        var lanes = swimLane.shape.lanes;\n        var lane = void 0;\n        var child = void 0;\n        for (var i = 0; i < lanes.length; i++) {\n            lane = lanes[i];\n            for (var j = 0; j < lane.children.length; j++) {\n                child = lane.children[j];\n                child.offsetX = child.wrapper.offsetX;\n                child.offsetY = child.wrapper.offsetY;\n            }\n        }\n    }\n}\n/**\n * findLane method \\\n *\n * @returns {LaneModel} findLane method .\\\n * @param {Node} laneNode - provide the laneNode  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nexport function findLane(laneNode, diagram) {\n    var lane;\n    if (laneNode.isLane) {\n        var swimLane = diagram.getObject(laneNode.parentId);\n        if (swimLane && swimLane.shape.type === 'SwimLane' && laneNode.isLane) {\n            var laneIndex = findLaneIndex(swimLane, laneNode);\n            lane = swimLane.shape.lanes[laneIndex];\n        }\n    }\n    return lane;\n}\n/**\n * canLaneInterchange method \\\n *\n * @returns {boolean} canLaneInterchange method .\\\n * @param {Node} laneNode - provide the laneNode  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nexport function canLaneInterchange(laneNode, diagram) {\n    if (laneNode.isLane) {\n        var lane = findLane(laneNode, diagram);\n        var eventHandler = 'eventHandler';\n        var resize = diagram[eventHandler].action;\n        var canResize = resize.includes('Resize');\n        if (canResize || lane.canMove) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * updateSwimLaneChildPosition method \\\n *\n * @returns {void} updateSwimLaneChildPosition method .\\\n * @param {Lane[]} lanes - provide the laneNode  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nexport function updateSwimLaneChildPosition(lanes, diagram) {\n    var lane;\n    var node;\n    for (var i = 0; i < lanes.length; i++) {\n        lane = lanes[i];\n        for (var j = 0; j < lane.children.length; j++) {\n            node = diagram.nameTable[lane.children[j].id];\n            node.offsetX = node.wrapper.offsetX;\n            node.offsetY = node.wrapper.offsetY;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}