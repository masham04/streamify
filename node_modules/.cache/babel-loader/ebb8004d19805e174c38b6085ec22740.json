{"ast":null,"code":"import { Node } from './node';\nimport { DiagramAction } from '../enum/enum';\nimport { removeItem, getObjectType } from '../utility/diagram-util';\nimport { cloneObject, getFunction } from '../utility/base-util';\nimport { findAnnotation, findPort } from '../utility/diagram-util';\nimport { Size, addChildToContainer } from '../index';\nimport { swimLaneMeasureAndArrange, laneInterChanged, findLaneIndex, updateSwimLaneObject, pasteSwimLane } from '../utility/swim-lane-util';\nimport { DiagramEvent, BlazorAction } from '../enum/enum';\nimport { isBlazor } from '@syncfusion/ej2-base';\n/**\n * Undo redo function used for revert and restore the changes\n */\n\nvar UndoRedo =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the undo redo module\n   *\n   * @private\n   */\n  function UndoRedo() {\n    this.groupUndo = false;\n    this.childTable = [];\n    this.historyCount = 0;\n    this.hasGroup = false;\n    this.groupCount = 0; //constructs the undo redo module\n  }\n  /**\n   * initHistory method \\\n   *\n   * @returns { void } initHistory method .\\\n   * @param {Diagram} diagram - provide the points value.\n   *\n   * @private\n   */\n\n\n  UndoRedo.prototype.initHistory = function (diagram) {\n    diagram.historyManager = {\n      canRedo: false,\n      canUndo: false,\n      currentEntry: null,\n      push: diagram.addHistoryEntry.bind(diagram),\n      undo: Function,\n      redo: Function,\n      startGroupAction: diagram.startGroupAction.bind(diagram),\n      endGroupAction: diagram.endGroupAction.bind(diagram),\n      canLog: null,\n      undoStack: [],\n      redoStack: [],\n      stackLimit: diagram.historyManager ? diagram.historyManager.stackLimit : undefined\n    };\n  };\n  /**\n   * addHistoryEntry method \\\n   *\n   * @returns { void } addHistoryEntry method .\\\n   * @param {HistoryEntry} entry - provide the points value.\n   * @param {Diagram} diagram - provide the points value.\n   *\n   * @private\n   */\n\n\n  UndoRedo.prototype.addHistoryEntry = function (entry, diagram) {\n    var entryObject = null;\n    var nextEntry = null;\n\n    if (diagram.historyManager.canLog) {\n      var hEntry = diagram.historyManager.canLog(entry);\n\n      if (hEntry.cancel === true) {\n        return;\n      }\n    }\n\n    if (diagram.historyManager && diagram.historyManager.canUndo && diagram.historyManager.currentEntry) {\n      entryObject = diagram.historyManager.currentEntry;\n\n      if (entryObject.next) {\n        if (entryObject.previous) {\n          nextEntry = entryObject.next;\n          nextEntry.previous = null;\n          entryObject.next = entry;\n          entry.previous = entryObject;\n        }\n      } else {\n        entryObject.next = entry;\n        entry.previous = entryObject;\n      }\n    }\n\n    diagram.historyManager.currentEntry = entry;\n\n    if (diagram.historyManager.stackLimit) {\n      if (entry.type === 'StartGroup' || entry.type === 'EndGroup') {\n        var value = entry.type === 'EndGroup' ? true : false;\n        this.setEntryLimit(value);\n      }\n\n      if (!this.hasGroup && this.groupCount === 0) {\n        if (this.historyCount < diagram.historyManager.stackLimit) {\n          this.historyCount++;\n        } else {\n          this.applyLimit(diagram.historyManager.currentEntry, diagram.historyManager.stackLimit, diagram);\n        }\n      }\n    }\n\n    this.getHistoryList(diagram);\n    diagram.historyManager.canUndo = true;\n    diagram.historyManager.canRedo = false;\n  };\n  /**\n   * applyLimit method \\\n   *\n   * @returns { void } applyLimit method .\\\n   * @param {HistoryEntry} list - provide the list value.\n   * @param {number} stackLimit - provide the list value.\n   * @param {Diagram} diagram - provide the list value.\n   * @param {boolean} limitHistory - provide the list value.\n   *\n   * @private\n   */\n\n\n  UndoRedo.prototype.applyLimit = function (list, stackLimit, diagram, limitHistory) {\n    if (list && list.previous) {\n      if (list.type === 'StartGroup' || list.type === 'EndGroup') {\n        var value = list.type === 'StartGroup' ? true : false;\n        this.setEntryLimit(value);\n      }\n\n      if (!this.hasGroup && this.groupCount === 0) {\n        stackLimit--;\n      }\n\n      if (stackLimit === 0) {\n        if (limitHistory) {\n          this.limitHistoryStack(list.previous, diagram);\n        }\n\n        if (diagram.historyManager.stackLimit < this.historyCount) {\n          this.historyCount = diagram.historyManager.stackLimit;\n        }\n\n        delete list.previous;\n      } else if (list.previous) {\n        this.applyLimit(list.previous, stackLimit, diagram, limitHistory);\n      }\n    }\n\n    this.groupCount = 0;\n  };\n  /**\n   * clearHistory method \\\n   *\n   * @returns { void } clearHistory method .\\\n   * @param {Diagram} diagram - provide the points value.\n   *\n   * @private\n   */\n\n\n  UndoRedo.prototype.clearHistory = function (diagram) {\n    var hList = diagram.historyManager;\n    hList.currentEntry = undefined;\n    hList.canUndo = false;\n    hList.canRedo = false;\n    this.historyCount = 0;\n    this.groupCount = 0;\n    diagram.historyManager.undoStack = [];\n    diagram.historyManager.redoStack = [];\n  };\n\n  UndoRedo.prototype.setEntryLimit = function (value) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n    value ? this.groupCount-- : this.groupCount++; // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\n    value ? this.hasGroup = !value : this.hasGroup = value;\n  };\n\n  UndoRedo.prototype.limitHistoryStack = function (list, diagram) {\n    if (list.type !== 'StartGroup' && list.type !== 'EndGroup') {\n      this.removeFromStack(diagram.historyManager.undoStack, list);\n      this.removeFromStack(diagram.historyManager.redoStack, list);\n    }\n\n    if (list.previous) {\n      this.limitHistoryStack(list.previous, diagram);\n    }\n  };\n\n  UndoRedo.prototype.removeFromStack = function (entyList, list) {\n    if (entyList.length) {\n      for (var i = 0; i <= entyList.length; i++) {\n        if (entyList[i].undoObject === list.undoObject && entyList[i].redoObject === list.redoObject) {\n          entyList.splice(i, 1);\n          break;\n        }\n      }\n    }\n  };\n  /**\n   * undo method \\\n   *\n   * @returns { void } undo method .\\\n   * @param {Diagram} diagram - provide the diagram value.\n   *\n   * @private\n   */\n\n\n  UndoRedo.prototype.undo = function (diagram) {\n    var entry = this.getUndoEntry(diagram);\n    var endGroupActionCount = 0;\n\n    if (entry) {\n      if (entry.category === 'Internal') {\n        if (entry.type === 'EndGroup') {\n          endGroupActionCount++;\n          this.groupUndo = true;\n\n          if (isBlazor()) {\n            diagram.blazorActions |= BlazorAction.GroupingInProgress;\n          }\n        } else {\n          this.undoEntry(entry, diagram);\n        }\n\n        if (this.groupUndo) {\n          this.undoGroupAction(entry, diagram, endGroupActionCount);\n          this.groupUndo = false;\n        }\n      } else {\n        if (!isBlazor()) {\n          diagram.historyManager.undo(entry);\n        }\n\n        var arg = {\n          entryType: 'undo',\n          oldValue: entry.undoObject,\n          newValue: entry.redoObject\n        };\n\n        if (isBlazor()) {\n          arg = {\n            entryType: 'undo',\n            oldValue: this.getHistoryChangeEvent(entry.undoObject, entry.blazorHistoryEntryType),\n            newValue: this.getHistoryChangeEvent(entry.redoObject, entry.blazorHistoryEntryType)\n          };\n        }\n\n        diagram.triggerEvent(DiagramEvent.historyStateChange, arg);\n      }\n    }\n  };\n\n  UndoRedo.prototype.getHistoryChangeEvent = function (object, prop) {\n    var value = {};\n\n    switch (prop) {\n      case 'Node':\n        value.node = object;\n        break;\n\n      case 'Connector':\n        value.connector = object;\n        break;\n\n      case 'Selector':\n        value.selector = object;\n        break;\n\n      case 'Diagram':\n        value.diagram = object;\n        break;\n\n      case 'ShapeAnnotation':\n        value.shapeAnnotation = object;\n        break;\n\n      case 'PathAnnotation':\n        value.pathAnnotation = object;\n        break;\n\n      case 'PortObject':\n        value.pointPortModel = object;\n        break;\n\n      case 'Object':\n        value.object = object;\n    }\n\n    return value;\n  };\n\n  UndoRedo.prototype.getHistoryList = function (diagram) {\n    var undoStack = [];\n    var redoStack = [];\n    var currEntry = diagram.historyManager.currentEntry;\n    var undoObj;\n    var redoObj;\n    currEntry = diagram.historyManager.currentEntry;\n\n    if (diagram.historyManager.canUndo || diagram.historyManager.undoStack.length === 0) {\n      this.getHistroyObject(undoStack, currEntry);\n    } else {\n      this.getHistroyObject(redoStack, currEntry);\n    }\n\n    while (currEntry && currEntry.previous) {\n      undoObj = currEntry.previous;\n      this.getHistroyObject(undoStack, undoObj);\n      currEntry = currEntry.previous;\n    }\n\n    currEntry = diagram.historyManager.currentEntry;\n\n    while (currEntry && currEntry.next) {\n      redoObj = currEntry.next;\n      this.getHistroyObject(redoStack, redoObj);\n      currEntry = currEntry.next;\n    }\n\n    diagram.historyManager.undoStack = undoStack;\n    diagram.historyManager.redoStack = redoStack;\n  };\n\n  UndoRedo.prototype.getHistroyObject = function (list, obj) {\n    if (obj && obj.type !== 'StartGroup' && obj.type !== 'EndGroup') {\n      list.push({\n        redoObject: obj.redoObject ? obj.redoObject : null,\n        undoObject: obj.undoObject ? obj.undoObject : null,\n        type: obj.type ? obj.type : null,\n        category: obj.category ? obj.category : null\n      });\n    }\n  };\n\n  UndoRedo.prototype.undoGroupAction = function (entry, diagram, endGroupActionCount) {\n    while (endGroupActionCount !== 0) {\n      this.undoEntry(entry, diagram);\n      entry = this.getUndoEntry(diagram);\n\n      if (entry.type === 'StartGroup') {\n        endGroupActionCount--;\n      } else if (entry.type === 'EndGroup') {\n        endGroupActionCount++;\n      }\n    }\n\n    endGroupActionCount = 0;\n  };\n\n  UndoRedo.prototype.undoEntry = function (entry, diagram) {\n    var obj;\n    var nodeObject;\n\n    if (entry.type !== 'PropertyChanged' && entry.type !== 'CollectionChanged' && entry.type !== 'LabelCollectionChanged') {\n      obj = entry.undoObject;\n      nodeObject = entry.undoObject;\n    }\n\n    if (entry.type !== 'StartGroup' && entry.type !== 'EndGroup') {\n      if (diagram.historyManager.undoStack.length > 0) {\n        var addObject = diagram.historyManager.undoStack.splice(0, 1);\n        diagram.historyManager.redoStack.splice(0, 0, addObject[0]);\n        nodeObject = entry.undoObject;\n      }\n    }\n\n    diagram.protectPropertyChange(true);\n    diagram.diagramActions |= DiagramAction.UndoRedo;\n\n    if (isBlazor() && entry.previous && entry.previous.type === 'StartGroup') {\n      diagram.blazorActions &= ~BlazorAction.GroupingInProgress;\n    }\n\n    switch (entry.type) {\n      case 'PositionChanged':\n      case 'Align':\n      case 'Distribute':\n        this.recordPositionChanged(obj, diagram);\n        break;\n\n      case 'SizeChanged':\n      case 'Sizing':\n        this.recordSizeChanged(obj, diagram, entry);\n        break;\n\n      case 'RotationChanged':\n        this.recordRotationChanged(obj, diagram, entry);\n        break;\n\n      case 'ConnectionChanged':\n        this.recordConnectionChanged(obj, diagram);\n        break;\n\n      case 'PropertyChanged':\n        this.recordPropertyChanged(entry, diagram, false);\n        break;\n\n      case 'CollectionChanged':\n        if (entry && entry.next && entry.next.type === 'AddChildToGroupNode' && entry.next.changeType === 'Insert') {\n          var group = diagram.getObject(entry.next.undoObject.id);\n          diagram.insertValue(cloneObject(group), true);\n        }\n\n        entry.isUndo = true;\n        this.recordCollectionChanged(entry, diagram);\n        entry.isUndo = false;\n\n        if (entry && entry.next && entry.next.type === 'AddChildToGroupNode' && entry.next.changeType === 'Insert') {\n          var group = diagram.getObject(entry.next.undoObject.id);\n          group.wrapper.measure(new Size());\n          group.wrapper.arrange(group.wrapper.desiredSize);\n          diagram.updateDiagramObject(group);\n        }\n\n        break;\n\n      case 'LabelCollectionChanged':\n        entry.isUndo = true;\n        this.recordLabelCollectionChanged(entry, diagram);\n        entry.isUndo = false;\n        break;\n\n      case 'PortCollectionChanged':\n        entry.isUndo = true;\n        this.recordPortCollectionChanged(entry, diagram);\n        entry.isUndo = false;\n        break;\n\n      case 'Group':\n        this.unGroup(entry, diagram);\n        break;\n\n      case 'UnGroup':\n        this.group(entry, diagram);\n        break;\n\n      case 'SegmentChanged':\n        this.recordSegmentChanged(obj, diagram);\n        break;\n\n      case 'PortPositionChanged':\n        this.recordPortChanged(entry, diagram, false);\n        break;\n\n      case 'AnnotationPropertyChanged':\n        this.recordAnnotationChanged(entry, diagram, false);\n        break;\n\n      case 'ChildCollectionChanged':\n        this.recordChildCollectionChanged(entry, diagram, false);\n        break;\n\n      case 'StackChildPositionChanged':\n        this.recordStackPositionChanged(entry, diagram, false);\n        break;\n\n      case 'RowHeightChanged':\n        this.recordGridSizeChanged(entry, diagram, false, true);\n        break;\n\n      case 'ColumnWidthChanged':\n        this.recordGridSizeChanged(entry, diagram, false, false);\n        break;\n\n      case 'LanePositionChanged':\n        this.recordLanePositionChanged(entry, diagram, false);\n        break;\n\n      case 'LaneCollectionChanged':\n      case 'PhaseCollectionChanged':\n        entry.isUndo = true;\n        this.recordLaneOrPhaseCollectionChanged(entry, diagram, false);\n        entry.isUndo = false;\n        break;\n\n      case 'SendToBack':\n      case 'SendForward':\n      case 'SendBackward':\n      case 'BringToFront':\n        this.recordOrderCommandChanged(entry, diagram, false);\n        break;\n\n      case 'AddChildToGroupNode':\n        this.recordAddChildToGroupNode(entry, diagram, false);\n        break;\n    }\n\n    diagram.diagramActions &= ~DiagramAction.UndoRedo;\n    diagram.protectPropertyChange(false);\n    diagram.historyChangeTrigger(entry, 'Undo');\n\n    if (nodeObject) {\n      var object = this.checkNodeObject(nodeObject, diagram);\n\n      if (object) {\n        var getnodeDefaults = getFunction(diagram.updateSelection);\n\n        if (getnodeDefaults) {\n          getnodeDefaults(object, diagram);\n        }\n      }\n    }\n  };\n\n  UndoRedo.prototype.checkNodeObject = function (value, diagram) {\n    var object;\n\n    if (!value.id) {\n      if (value.nodes && value.nodes.length > 0 || value.connectors && value.connectors.length > 0) {\n        var undoNode = value.nodes.length > 0 ? value.nodes : value.connectors;\n\n        for (var _i = 0, undoNode_1 = undoNode; _i < undoNode_1.length; _i++) {\n          object = undoNode_1[_i];\n          object = diagram.nameTable[object.id];\n        }\n      } else {\n        var knownNode = value.nodes ? value.nodes : value.connectors;\n\n        if (knownNode) {\n          for (var _a = 0, _b = Object.keys(knownNode); _a < _b.length; _a++) {\n            var key = _b[_a];\n            var index = Number(key);\n            object = value.nodes ? diagram.nodes[index] : diagram.connectors[index];\n          }\n        }\n      }\n    } else {\n      object = diagram.nameTable[value.id];\n    }\n\n    return object;\n  };\n\n  UndoRedo.prototype.group = function (historyEntry, diagram) {\n    diagram.add(historyEntry.undoObject);\n  };\n\n  UndoRedo.prototype.unGroup = function (entry, diagram) {\n    //const i: number = 0;\n    entry.redoObject = cloneObject(entry.undoObject);\n    var node = entry.undoObject;\n    diagram.commandHandler.unGroup(node);\n  };\n\n  UndoRedo.prototype.ignoreProperty = function (key) {\n    if (key === 'zIndex' || key === 'wrapper' || key === 'parentObj' || key === 'controlParent') {\n      return true;\n    }\n\n    return false;\n  };\n\n  UndoRedo.prototype.getProperty = function (collection, property) {\n    for (var _i = 0, _a = Object.keys(property); _i < _a.length; _i++) {\n      var key = _a[_i];\n\n      if (collection) {\n        if (!this.ignoreProperty(key)) {\n          if (property[key] instanceof Object) {\n            this.getProperty(collection[key], property[key]);\n          } else {\n            collection[key] = property[key];\n          }\n        }\n      }\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  UndoRedo.prototype.recordLaneOrPhaseCollectionChanged = function (entry, diagram, isRedo) {\n    var node = entry.redoObject;\n    var obj = entry.undoObject;\n    var changeType;\n\n    if (entry.isUndo) {\n      if (entry.changeType === 'Insert') {\n        changeType = 'Remove';\n      } else {\n        changeType = 'Insert';\n      }\n    } else {\n      changeType = entry.changeType;\n    }\n\n    if (changeType === 'Remove') {\n      diagram.remove(node);\n    } else {\n      if (node.isPhase) {\n        var swimlane = diagram.nameTable[node.parentId];\n        diagram.addPhases(swimlane, [obj]);\n      } else {\n        var swimlane = diagram.nameTable[node.parentId];\n        var laneIndex = findLaneIndex(swimlane, node);\n        diagram.addLanes(swimlane, [obj], laneIndex);\n      }\n    }\n\n    diagram.clearSelection();\n  };\n\n  UndoRedo.prototype.recordAnnotationChanged = function (entry, diagram, isRedo) {\n    var entryObject = isRedo ? entry.redoObject : entry.undoObject;\n\n    if (diagram.canEnableBlazorObject) {\n      var node = cloneObject(diagram.nameTable[entryObject.id]);\n      diagram.insertValue(node, node instanceof Node ? true : false);\n    }\n\n    var oldElement = findAnnotation(entryObject, entry.objectId);\n    var undoChanges = diagram.commandHandler.getAnnotationChanges(diagram.nameTable[entryObject.id], oldElement);\n    var currentObject = diagram.nameTable[entryObject.id];\n    var currentElement = findAnnotation(currentObject, entry.objectId);\n    currentElement.offset = oldElement.offset;\n    currentElement.margin = oldElement.margin;\n    currentElement.width = oldElement.width;\n    currentElement.height = oldElement.height;\n    currentElement.rotateAngle = oldElement.rotateAngle;\n    currentElement.margin = oldElement.margin;\n\n    if (currentObject instanceof Node) {\n      diagram.nodePropertyChange(currentObject, {}, undoChanges);\n    } else {\n      diagram.connectorPropertyChange(currentObject, {}, undoChanges);\n    }\n  };\n\n  UndoRedo.prototype.recordChildCollectionChanged = function (entry, diagram, isRedo) {\n    var entryObject = isRedo ? entry.redoObject : entry.undoObject;\n    var parentNode = diagram.nameTable[entryObject.parentId];\n    var actualObject = diagram.nameTable[entryObject.id];\n\n    if (parentNode) {\n      addChildToContainer(diagram, parentNode, actualObject, !isRedo, entry.historyAction === 'AddNodeToLane');\n    } else {\n      if (actualObject.parentId) {\n        parentNode = diagram.nameTable[actualObject.parentId];\n        parentNode.children.splice(parentNode.children.indexOf(actualObject.id), 1);\n        parentNode.wrapper.children.splice(parentNode.wrapper.children.indexOf(actualObject.wrapper), 1);\n      }\n\n      if (entryObject.parentId && entryObject.parentId !== '') {\n        parentNode = diagram.nameTable[entryObject.parentId];\n        parentNode.children.push(entryObject.id);\n        parentNode.wrapper.children.push(actualObject.wrapper);\n      }\n\n      actualObject.parentId = entryObject.parentId;\n      diagram.removeElements(actualObject);\n      diagram.updateDiagramObject(actualObject);\n    }\n  };\n\n  UndoRedo.prototype.recordStackPositionChanged = function (entry, diagram, isRedo) {\n    var entryObject = isRedo ? entry.redoObject : entry.undoObject;\n\n    if (entryObject.source) {\n      var parent_1 = diagram.nameTable[entryObject.source.parentId];\n\n      if (parent_1) {\n        if (entryObject.target) {\n          parent_1.wrapper.children.splice(entryObject.targetIndex, 1);\n          parent_1.wrapper.children.splice(entryObject.sourceIndex, 0, entryObject.source.wrapper);\n        } else {\n          if (entryObject.sourceIndex !== undefined) {\n            if (!diagram.nameTable[entryObject.source.id]) {\n              diagram.add(entryObject.source);\n            }\n\n            parent_1.wrapper.children.splice(entryObject.sourceIndex, 0, diagram.nameTable[entryObject.source.id].wrapper);\n            diagram.nameTable[entryObject.source.id].parentId = parent_1.id;\n          } else {\n            parent_1.wrapper.children.splice(parent_1.wrapper.children.indexOf(diagram.nameTable[entryObject.source.id].wrapper), 1);\n            diagram.nameTable[entryObject.source.id].parentId = '';\n          }\n        }\n\n        if (isRedo && parent_1.shape.type === 'UmlClassifier') {\n          diagram.remove(entryObject.source);\n        }\n\n        parent_1.wrapper.measure(new Size());\n        parent_1.wrapper.arrange(parent_1.wrapper.desiredSize);\n        diagram.updateDiagramObject(parent_1);\n        diagram.updateSelector();\n      }\n    }\n  };\n\n  UndoRedo.prototype.recordGridSizeChanged = function (entry, diagram, isRedo, isRow) {\n    var obj = isRedo ? entry.redoObject : entry.undoObject;\n    var node = !isRedo ? entry.redoObject : entry.undoObject;\n\n    if (obj.parentId) {\n      var swimlane = diagram.nameTable[obj.parentId];\n      var actualObject = diagram.nameTable[obj.id];\n      var x = swimlane.wrapper.bounds.x;\n      var y = swimlane.wrapper.bounds.y;\n\n      if (swimlane.shape.type === 'SwimLane') {\n        var grid = swimlane.wrapper.children[0];\n        var padding = swimlane.shape.padding;\n        updateSwimLaneObject(diagram, node, swimlane, obj);\n\n        if (isRow) {\n          grid.updateRowHeight(obj.rowIndex, obj.wrapper.actualSize.height, true, padding);\n          swimlane.height = swimlane.wrapper.height = grid.height;\n        } else {\n          grid.updateColumnWidth(obj.columnIndex, obj.wrapper.actualSize.width, true, padding);\n          swimlane.width = swimlane.wrapper.width = grid.width;\n\n          if (obj.isPhase) {\n            actualObject.maxWidth = actualObject.wrapper.maxWidth = obj.wrapper.actualSize.width;\n          }\n        }\n\n        swimLaneMeasureAndArrange(swimlane);\n        var tx = x - swimlane.wrapper.bounds.x;\n        var ty = y - swimlane.wrapper.bounds.y;\n        diagram.drag(swimlane, tx, ty);\n        diagram.clearSelection();\n        diagram.updateDiagramObject(swimlane);\n      }\n    }\n  };\n\n  UndoRedo.prototype.recordLanePositionChanged = function (entry, diagram, isRedo) {\n    var entryObject = isRedo ? entry.redoObject : entry.undoObject;\n\n    if (entryObject.source) {\n      var parent_2 = diagram.nameTable[entryObject.source.parentId];\n\n      if (parent_2 && parent_2.shape.type === 'SwimLane') {\n        laneInterChanged(diagram, entryObject.target, entryObject.source);\n        diagram.clearSelection();\n      }\n    }\n  };\n\n  UndoRedo.prototype.recordPortChanged = function (entry, diagram, isRedo) {\n    var entryObject = isRedo ? entry.redoObject.nodes[0] : entry.undoObject.nodes[0];\n\n    if (diagram.canEnableBlazorObject) {\n      var node = cloneObject(diagram.nameTable[entryObject.id]);\n      diagram.insertValue(node, true);\n    }\n\n    var oldElement = findPort(entryObject, entry.objectId);\n    var undoChanges = diagram.commandHandler.getPortChanges(diagram.nameTable[entryObject.id], oldElement);\n    var currentObject = diagram.nameTable[entryObject.id];\n    var currentElement = findPort(currentObject, entry.objectId);\n    currentElement.offset = oldElement.offset;\n    diagram.nodePropertyChange(currentObject, {}, undoChanges);\n\n    if (currentObject.parentId) {\n      diagram.updateConnectorEdges(diagram.nameTable[currentObject.parentId]);\n    }\n  };\n\n  UndoRedo.prototype.recordPropertyChanged = function (entry, diagram, isRedo) {\n    var redoObject = entry.redoObject;\n    var undoObject = entry.undoObject;\n\n    if (isBlazor()) {\n      for (var _i = 0, _a = Object.keys(undoObject); _i < _a.length; _i++) {\n        var prop = _a[_i];\n        var obj = void 0;\n\n        switch (prop) {\n          case 'nodes':\n            for (var _b = 0, _c = Object.keys(undoObject.nodes); _b < _c.length; _b++) {\n              var key = _c[_b];\n\n              if (diagram.canEnableBlazorObject) {\n                obj = cloneObject(diagram.nodes[Number(key)]);\n                diagram.insertValue(obj, true);\n              }\n            }\n\n            break;\n\n          case 'connectors':\n            for (var _d = 0, _e = Object.keys(undoObject.connectors); _d < _e.length; _d++) {\n              var key = _e[_d];\n\n              if (diagram.canEnableBlazorObject) {\n                obj = cloneObject(diagram.connectors[Number(key)]);\n                diagram.insertValue(obj, false);\n              }\n            }\n\n            break;\n        }\n      }\n    }\n\n    this.getProperty(diagram, isRedo ? redoObject : undoObject); // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\n    isRedo ? diagram.onPropertyChanged(redoObject, undoObject) : diagram.onPropertyChanged(undoObject, redoObject);\n    diagram.diagramActions = diagram.diagramActions | DiagramAction.UndoRedo;\n  };\n\n  UndoRedo.prototype.recordOrderCommandChanged = function (entry, diagram, isRedo) {\n    var redoObject = entry.redoObject;\n    var undoObject = entry.undoObject;\n    diagram.commandHandler.orderCommands(isRedo, isRedo ? redoObject : undoObject, entry.type);\n    diagram.diagramActions = diagram.diagramActions | DiagramAction.UndoRedo;\n  };\n\n  UndoRedo.prototype.recordAddChildToGroupNode = function (entry, diagram, isRedo) {\n    var group = diagram.nameTable[entry.undoObject.id];\n    var child = diagram.nameTable[entry.objectId];\n\n    if (isRedo && entry.changeType === 'Insert') {\n      diagram.addChildToGroup(group, child.id);\n    }\n  };\n\n  UndoRedo.prototype.recordSegmentChanged = function (obj, diagram) {\n    var i = 0; //let node: NodeModel;\n\n    var connector;\n\n    if (obj.connectors && obj.connectors.length > 0) {\n      for (i = 0; i < obj.connectors.length; i++) {\n        connector = obj.connectors[i];\n        this.segmentChanged(connector, diagram);\n      }\n    }\n  };\n\n  UndoRedo.prototype.segmentChanged = function (connector, diagram) {\n    var conn = diagram.nameTable[connector.id];\n    conn.segments = connector.segments;\n    diagram.commandHandler.updateEndPoint(conn);\n  };\n\n  UndoRedo.prototype.recordPositionChanged = function (obj, diagram) {\n    var i = 0;\n    var node;\n    var connector;\n\n    if (obj.nodes && obj.nodes.length > 0) {\n      for (i = 0; i < obj.nodes.length; i++) {\n        node = obj.nodes[i];\n        this.positionChanged(node, diagram);\n      }\n    }\n\n    if (obj.connectors && obj.connectors.length > 0) {\n      for (i = 0; i < obj.connectors.length; i++) {\n        connector = obj.connectors[i];\n        this.connectionChanged(connector, diagram);\n      }\n    }\n  };\n\n  UndoRedo.prototype.positionChanged = function (obj, diagram) {\n    var node = diagram.nameTable[obj.id];\n\n    if (obj.processId && !node.processId) {\n      diagram.addProcess(obj, obj.processId);\n    }\n\n    if (!obj.processId && node.processId) {\n      diagram.removeProcess(obj.id);\n    }\n\n    if (node.processId) {\n      var tx = obj.margin.left - node.margin.left;\n      var ty = obj.margin.top - node.margin.top;\n      diagram.drag(node, tx, ty);\n    } else {\n      if (node.parentId) {\n        var parent_3 = diagram.nameTable[node.parentId];\n\n        if (parent_3.isLane) {\n          obj.wrapper.offsetX = obj.width / 2 + (parent_3.wrapper.bounds.x + obj.margin.left);\n          obj.wrapper.offsetY = obj.height / 2 + (parent_3.wrapper.bounds.y + obj.margin.top);\n        }\n      }\n\n      var tx = obj.wrapper.offsetX - node.offsetX;\n      var ty = obj.wrapper.offsetY - node.offsetY;\n      diagram.drag(node, tx, ty);\n    }\n\n    if (diagram.bpmnModule) {\n      diagram.bpmnModule.updateDocks(node, diagram);\n    }\n  };\n\n  UndoRedo.prototype.recordSizeChanged = function (obj, diagram, entry) {\n    var i = 0;\n    var connector;\n    var node;\n\n    if (obj && obj.nodes && obj.nodes.length > 0) {\n      for (i = 0; i < obj.nodes.length; i++) {\n        node = obj.nodes[i];\n\n        if (node.children && !node.container) {\n          var elements = [];\n          var nodes = diagram.commandHandler.getAllDescendants(node, elements);\n\n          for (var i_1 = 0; i_1 < nodes.length; i_1++) {\n            var tempNode = entry.childTable[nodes[i_1].id];\n\n            if (getObjectType(tempNode) === Node) {\n              this.sizeChanged(tempNode, diagram, entry);\n              this.positionChanged(tempNode, diagram);\n            } else {\n              this.connectionChanged(tempNode, diagram, entry);\n            }\n          }\n        } else {\n          this.sizeChanged(node, diagram);\n          this.positionChanged(node, diagram);\n        }\n      }\n    }\n\n    if (obj && obj.connectors && obj.connectors.length > 0) {\n      var connectors = obj.connectors;\n\n      for (i = 0; i < connectors.length; i++) {\n        connector = connectors[i];\n        this.connectionChanged(connector, diagram);\n      }\n    }\n  };\n\n  UndoRedo.prototype.sizeChanged = function (obj, diagram, entry) {\n    var node = diagram.nameTable[obj.id];\n    var scaleWidth = obj.wrapper.actualSize.width / node.wrapper.actualSize.width;\n    var scaleHeight = obj.wrapper.actualSize.height / node.wrapper.actualSize.height;\n\n    if (entry && entry.childTable) {\n      entry.childTable[obj.id] = cloneObject(node);\n    }\n\n    diagram.scale(node, scaleWidth, scaleHeight, {\n      x: obj.wrapper.offsetX / node.wrapper.offsetX,\n      y: obj.wrapper.offsetY / node.wrapper.offsetY\n    });\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  UndoRedo.prototype.recordRotationChanged = function (obj, diagram, entry) {\n    var i = 0;\n    var node;\n    var connector;\n    var selectorObj = diagram.selectedItems;\n    selectorObj.rotateAngle = obj.rotateAngle;\n\n    if (selectorObj && selectorObj.wrapper) {\n      selectorObj.wrapper.rotateAngle = obj.rotateAngle;\n    }\n\n    if (obj && obj.nodes && obj.nodes.length > 0) {\n      for (i = 0; i < obj.nodes.length; i++) {\n        node = obj.nodes[i];\n        this.rotationChanged(node, diagram);\n        this.positionChanged(node, diagram);\n      }\n    }\n\n    if (obj && obj.connectors && obj.connectors.length > 0) {\n      for (i = 0; i < obj.connectors.length; i++) {\n        connector = obj.connectors[i];\n        this.connectionChanged(connector, diagram);\n      }\n    }\n  };\n\n  UndoRedo.prototype.rotationChanged = function (obj, diagram) {\n    var node = diagram.nameTable[obj.id];\n    diagram.rotate(node, obj.rotateAngle - node.rotateAngle);\n  };\n\n  UndoRedo.prototype.recordConnectionChanged = function (obj, diagram) {\n    var connector = obj.connectors[0];\n\n    if (connector.sourceID && diagram.nameTable[connector.sourceID]) {\n      diagram.insertValue(diagram.nameTable[connector.sourceID], true);\n    }\n\n    if (connector.targetID && diagram.nameTable[connector.targetID]) {\n      diagram.insertValue(diagram.nameTable[connector.targetID], true);\n    }\n\n    this.connectionChanged(connector, diagram);\n  };\n\n  UndoRedo.prototype.connectionChanged = function (obj, diagram, entry) {\n    var connector = diagram.nameTable[obj.id];\n    var node;\n\n    if (obj.sourcePortID !== connector.sourcePortID) {\n      diagram.removePortEdges(diagram.nameTable[connector.sourceID], connector.sourcePortID, connector.id, false);\n      connector.sourcePortID = obj.sourcePortID;\n      diagram.connectorPropertyChange(connector, {}, {\n        sourcePortID: obj.sourcePortID\n      });\n    }\n\n    if (obj.targetPortID !== connector.targetPortID) {\n      diagram.removePortEdges(diagram.nameTable[connector.targetID], connector.targetPortID, connector.id, true);\n      connector.targetPortID = obj.targetPortID;\n      diagram.connectorPropertyChange(connector, {}, {\n        targetPortID: obj.targetPortID\n      });\n    }\n\n    if (obj.sourceID !== connector.sourceID) {\n      if (obj.sourceID === '') {\n        node = diagram.nameTable[connector.sourceID];\n        removeItem(node.outEdges, obj.id);\n      } else {\n        node = diagram.nameTable[obj.sourceID];\n        node.outEdges.push(obj.id);\n        diagram.updatePortEdges(node, obj, false);\n      }\n\n      connector.sourceID = obj.sourceID;\n      diagram.connectorPropertyChange(connector, {}, {\n        sourceID: obj.sourceID\n      });\n    }\n\n    if (obj.targetID !== connector.targetID) {\n      if (obj.targetID === '') {\n        node = diagram.nameTable[connector.targetID];\n        removeItem(node.inEdges, obj.id);\n      } else {\n        node = diagram.nameTable[obj.targetID];\n        node.inEdges.push(obj.id);\n        diagram.updatePortEdges(node, obj, true);\n      }\n\n      connector.targetID = obj.targetID;\n      diagram.connectorPropertyChange(connector, {}, {\n        targetID: obj.targetID\n      });\n    }\n\n    if (entry && entry.childTable) {\n      entry.childTable[obj.id] = cloneObject(connector);\n    }\n\n    var sx = obj.sourcePoint.x - connector.sourcePoint.x;\n    var sy = obj.sourcePoint.y - connector.sourcePoint.y;\n\n    if (sx !== 0 || sy !== 0) {\n      diagram.dragSourceEnd(connector, sx, sy);\n    }\n\n    var tx = obj.targetPoint.x - connector.targetPoint.x;\n    var ty = obj.targetPoint.y - connector.targetPoint.y;\n\n    if (tx !== 0 || ty !== 0) {\n      diagram.dragTargetEnd(connector, tx, ty);\n    }\n\n    diagram.updateSelector();\n\n    if (diagram.mode !== 'SVG') {\n      diagram.refreshDiagramLayer();\n    }\n  };\n\n  UndoRedo.prototype.recordCollectionChanged = function (entry, diagram) {\n    var obj = entry.undoObject;\n\n    if (entry && entry.changeType) {\n      var changeType = void 0;\n\n      if (entry.isUndo) {\n        if (entry.changeType === 'Insert') {\n          changeType = 'Remove';\n        } else {\n          changeType = 'Insert';\n        }\n      } else {\n        changeType = entry.changeType;\n      }\n\n      if (changeType === 'Remove') {\n        if (obj.nodeId) {\n          diagram.remove(diagram.nameTable[obj.nodeId + '_textannotation_' + obj.id]);\n        } else {\n          diagram.remove(obj);\n          diagram.clearSelectorLayer();\n        }\n      } else {\n        diagram.clearSelectorLayer();\n\n        if (obj.parentId) {\n          var parentNode = diagram.nameTable[obj.parentId];\n\n          if (parentNode) {\n            diagram.addChild(parentNode, obj);\n          } else {\n            diagram.add(obj);\n          }\n        } else if (obj.nodeId) {\n          diagram.addTextAnnotation(obj, diagram.nameTable[obj.nodeId]);\n        } else {\n          if (!diagram.nameTable[obj.id]) {\n            if (obj && obj.shape && obj.shape.type === 'SwimLane' && entry.isUndo) {\n              pasteSwimLane(obj, undefined, undefined, undefined, undefined, true);\n            }\n\n            diagram.add(obj);\n          }\n        }\n\n        if (obj.processId && diagram.nameTable[obj.processId]) {\n          diagram.addProcess(obj, obj.processId);\n        }\n      }\n\n      if (diagram.mode !== 'SVG') {\n        diagram.refreshDiagramLayer();\n      }\n    }\n  };\n\n  UndoRedo.prototype.recordLabelCollectionChanged = function (entry, diagram) {\n    var label = entry.undoObject;\n    var obj = entry.redoObject;\n    var node = diagram.nameTable[obj.id];\n\n    if (entry && entry.changeType) {\n      var changeType = void 0;\n\n      if (entry.isUndo) {\n        changeType = entry.changeType === 'Insert' ? 'Remove' : 'Insert';\n      } else {\n        changeType = entry.changeType;\n      }\n\n      if (changeType === 'Remove') {\n        diagram.removeLabels(node, [label]);\n        diagram.clearSelectorLayer();\n      } else {\n        diagram.clearSelectorLayer();\n        diagram.addLabels(node, [label]);\n      }\n\n      if (diagram.mode !== 'SVG') {\n        diagram.refreshDiagramLayer();\n      }\n    }\n  };\n\n  UndoRedo.prototype.recordPortCollectionChanged = function (entry, diagram) {\n    var port = entry.undoObject;\n    var obj = entry.redoObject;\n    var node = diagram.nameTable[obj.id];\n\n    if (entry && entry.changeType) {\n      var changeType = void 0;\n\n      if (entry.isUndo) {\n        changeType = entry.changeType === 'Insert' ? 'Remove' : 'Insert';\n      } else {\n        changeType = entry.changeType;\n      }\n\n      if (changeType === 'Remove') {\n        diagram.removePorts(node, [port]);\n        diagram.clearSelectorLayer();\n      } else {\n        diagram.clearSelectorLayer();\n        diagram.addPorts(node, [port]);\n      }\n\n      if (diagram.mode !== 'SVG') {\n        diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /**\n   * redo method \\\n   *\n   * @returns { void } redo method .\\\n   * @param {Diagram} diagram - provide the diagram value.\n   *\n   * @private\n   */\n\n\n  UndoRedo.prototype.redo = function (diagram) {\n    var entry = this.getRedoEntry(diagram);\n    var startGroupActionCount = 0;\n\n    if (entry) {\n      if (entry.category === 'Internal') {\n        if (entry.type === 'StartGroup') {\n          startGroupActionCount++;\n          this.groupUndo = true;\n\n          if (isBlazor()) {\n            diagram.blazorActions |= BlazorAction.GroupingInProgress;\n          }\n        } else {\n          this.redoEntry(entry, diagram);\n        }\n\n        if (this.groupUndo) {\n          this.redoGroupAction(entry, diagram, startGroupActionCount);\n          this.groupUndo = false;\n        }\n      } else {\n        if (!isBlazor()) {\n          diagram.historyManager.redo(entry);\n        }\n\n        var arg = {\n          entryType: 'redo',\n          oldValue: entry.redoObject,\n          newValue: entry.undoObject\n        };\n\n        if (isBlazor()) {\n          arg = {\n            entryType: 'redo',\n            oldValue: this.getHistoryChangeEvent(entry.redoObject, entry.blazorHistoryEntryType),\n            newValue: this.getHistoryChangeEvent(entry.undoObject, entry.blazorHistoryEntryType)\n          };\n        }\n\n        diagram.triggerEvent(DiagramEvent.historyStateChange, arg);\n      }\n    }\n  };\n\n  UndoRedo.prototype.redoGroupAction = function (entry, diagram, startGroupActionCount) {\n    while (startGroupActionCount !== 0) {\n      this.redoEntry(entry, diagram);\n      entry = this.getRedoEntry(diagram);\n\n      if (entry.type === 'EndGroup') {\n        startGroupActionCount--;\n      } else if (entry.type === 'StartGroup') {\n        startGroupActionCount++;\n      }\n    }\n\n    startGroupActionCount = 0;\n  };\n\n  UndoRedo.prototype.redoEntry = function (historyEntry, diagram) {\n    var redoObject;\n    var redovalue;\n\n    if (historyEntry.type !== 'PropertyChanged' && historyEntry.type !== 'CollectionChanged') {\n      redoObject = historyEntry.redoObject;\n      redovalue = historyEntry.redoObject;\n    }\n\n    diagram.diagramActions |= DiagramAction.UndoRedo;\n\n    if (historyEntry.type !== 'StartGroup' && historyEntry.type !== 'EndGroup') {\n      if (diagram.historyManager.redoStack.length > 0) {\n        var addObject = diagram.historyManager.redoStack.splice(0, 1);\n        diagram.historyManager.undoStack.splice(0, 0, addObject[0]);\n        redovalue = historyEntry.redoObject;\n      }\n    }\n\n    diagram.protectPropertyChange(true);\n\n    if (isBlazor() && historyEntry.next && historyEntry.next.type === 'EndGroup') {\n      diagram.blazorActions &= ~BlazorAction.GroupingInProgress;\n    }\n\n    switch (historyEntry.type) {\n      case 'PositionChanged':\n      case 'Align':\n      case 'Distribute':\n        this.recordPositionChanged(redoObject, diagram);\n        break;\n\n      case 'SizeChanged':\n      case 'Sizing':\n        this.recordSizeChanged(redoObject, diagram, historyEntry);\n        break;\n\n      case 'RotationChanged':\n        this.recordRotationChanged(redoObject, diagram, historyEntry);\n        break;\n\n      case 'ConnectionChanged':\n        this.recordConnectionChanged(redoObject, diagram);\n        break;\n\n      case 'PropertyChanged':\n        this.recordPropertyChanged(historyEntry, diagram, true);\n        break;\n\n      case 'CollectionChanged':\n        this.recordCollectionChanged(historyEntry, diagram);\n        break;\n\n      case 'LabelCollectionChanged':\n        this.recordLabelCollectionChanged(historyEntry, diagram);\n        break;\n\n      case 'PortCollectionChanged':\n        this.recordPortCollectionChanged(historyEntry, diagram);\n        break;\n\n      case 'Group':\n        this.group(historyEntry, diagram);\n        break;\n\n      case 'UnGroup':\n        this.unGroup(historyEntry, diagram);\n        break;\n\n      case 'SegmentChanged':\n        this.recordSegmentChanged(redoObject, diagram);\n        break;\n\n      case 'PortPositionChanged':\n        this.recordPortChanged(historyEntry, diagram, true);\n        break;\n\n      case 'AnnotationPropertyChanged':\n        this.recordAnnotationChanged(historyEntry, diagram, true);\n        break;\n\n      case 'ChildCollectionChanged':\n        this.recordChildCollectionChanged(historyEntry, diagram, true);\n        break;\n\n      case 'StackChildPositionChanged':\n        this.recordStackPositionChanged(historyEntry, diagram, true);\n        break;\n\n      case 'RowHeightChanged':\n        this.recordGridSizeChanged(historyEntry, diagram, true, true);\n        break;\n\n      case 'ColumnWidthChanged':\n        this.recordGridSizeChanged(historyEntry, diagram, true, false);\n        break;\n\n      case 'LanePositionChanged':\n        this.recordLanePositionChanged(historyEntry, diagram, true);\n        break;\n\n      case 'LaneCollectionChanged':\n      case 'PhaseCollectionChanged':\n        this.recordLaneOrPhaseCollectionChanged(historyEntry, diagram, true);\n        break;\n\n      case 'SendToBack':\n      case 'SendForward':\n      case 'SendBackward':\n      case 'BringToFront':\n        this.recordOrderCommandChanged(historyEntry, diagram, true);\n        break;\n\n      case 'AddChildToGroupNode':\n        this.recordAddChildToGroupNode(historyEntry, diagram, true);\n        break;\n    }\n\n    diagram.protectPropertyChange(false);\n    diagram.diagramActions &= ~DiagramAction.UndoRedo;\n    diagram.historyChangeTrigger(historyEntry, 'Redo');\n\n    if (redovalue) {\n      var value = this.checkNodeObject(redovalue, diagram);\n\n      if (value) {\n        var getnodeDefaults = getFunction(diagram.updateSelection);\n\n        if (getnodeDefaults) {\n          getnodeDefaults(value, diagram);\n        }\n      }\n    }\n  };\n\n  UndoRedo.prototype.getUndoEntry = function (diagram) {\n    var undoEntry = null;\n    var currentObject;\n    var hList = diagram.historyManager;\n\n    if (hList.canUndo) {\n      undoEntry = hList.currentEntry;\n      currentObject = hList.currentEntry.previous;\n\n      if (currentObject) {\n        hList.currentEntry = currentObject;\n\n        if (!hList.canRedo) {\n          hList.canRedo = true;\n        }\n      } else {\n        hList.canRedo = true;\n        hList.canUndo = false;\n      }\n    }\n\n    return undoEntry;\n  };\n\n  UndoRedo.prototype.getRedoEntry = function (diagram) {\n    var redoEntry = null;\n    var entryCurrent;\n    var hList = diagram.historyManager;\n\n    if (hList.canRedo) {\n      if (!hList.currentEntry.previous && !hList.canUndo) {\n        entryCurrent = hList.currentEntry;\n      } else {\n        entryCurrent = hList.currentEntry.next;\n      }\n\n      if (entryCurrent) {\n        hList.currentEntry = entryCurrent;\n\n        if (!hList.canUndo) {\n          hList.canUndo = true;\n        }\n\n        if (!entryCurrent.next) {\n          hList.canRedo = false;\n          hList.canUndo = true;\n        }\n      }\n\n      redoEntry = hList.currentEntry;\n    }\n\n    return redoEntry;\n  };\n  /**\n   * To destroy the undo redo module\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  UndoRedo.prototype.destroy = function () {\n    /**\n     * Destroys the undo redo module\n     */\n  };\n  /**\n   * @returns { string } toBounds method .\\\n   * Get getModuleName name.\n   */\n\n\n  UndoRedo.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'UndoRedo';\n  };\n\n  return UndoRedo;\n}();\n\nexport { UndoRedo };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/undo-redo.js"],"names":["Node","DiagramAction","removeItem","getObjectType","cloneObject","getFunction","findAnnotation","findPort","Size","addChildToContainer","swimLaneMeasureAndArrange","laneInterChanged","findLaneIndex","updateSwimLaneObject","pasteSwimLane","DiagramEvent","BlazorAction","isBlazor","UndoRedo","groupUndo","childTable","historyCount","hasGroup","groupCount","prototype","initHistory","diagram","historyManager","canRedo","canUndo","currentEntry","push","addHistoryEntry","bind","undo","Function","redo","startGroupAction","endGroupAction","canLog","undoStack","redoStack","stackLimit","undefined","entry","entryObject","nextEntry","hEntry","cancel","next","previous","type","value","setEntryLimit","applyLimit","getHistoryList","list","limitHistory","limitHistoryStack","clearHistory","hList","removeFromStack","entyList","length","i","undoObject","redoObject","splice","getUndoEntry","endGroupActionCount","category","blazorActions","GroupingInProgress","undoEntry","undoGroupAction","arg","entryType","oldValue","newValue","getHistoryChangeEvent","blazorHistoryEntryType","triggerEvent","historyStateChange","object","prop","node","connector","selector","shapeAnnotation","pathAnnotation","pointPortModel","currEntry","undoObj","redoObj","getHistroyObject","obj","nodeObject","addObject","protectPropertyChange","diagramActions","recordPositionChanged","recordSizeChanged","recordRotationChanged","recordConnectionChanged","recordPropertyChanged","changeType","group","getObject","id","insertValue","isUndo","recordCollectionChanged","wrapper","measure","arrange","desiredSize","updateDiagramObject","recordLabelCollectionChanged","recordPortCollectionChanged","unGroup","recordSegmentChanged","recordPortChanged","recordAnnotationChanged","recordChildCollectionChanged","recordStackPositionChanged","recordGridSizeChanged","recordLanePositionChanged","recordLaneOrPhaseCollectionChanged","recordOrderCommandChanged","recordAddChildToGroupNode","historyChangeTrigger","checkNodeObject","getnodeDefaults","updateSelection","nodes","connectors","undoNode","_i","undoNode_1","nameTable","knownNode","_a","_b","Object","keys","key","index","Number","historyEntry","add","commandHandler","ignoreProperty","getProperty","collection","property","isRedo","remove","isPhase","swimlane","parentId","addPhases","laneIndex","addLanes","clearSelection","canEnableBlazorObject","oldElement","objectId","undoChanges","getAnnotationChanges","currentObject","currentElement","offset","margin","width","height","rotateAngle","nodePropertyChange","connectorPropertyChange","parentNode","actualObject","historyAction","children","indexOf","removeElements","source","parent_1","target","targetIndex","sourceIndex","shape","updateSelector","isRow","x","bounds","y","grid","padding","updateRowHeight","rowIndex","actualSize","updateColumnWidth","columnIndex","maxWidth","tx","ty","drag","parent_2","getPortChanges","updateConnectorEdges","_c","_d","_e","onPropertyChanged","orderCommands","child","addChildToGroup","segmentChanged","conn","segments","updateEndPoint","positionChanged","connectionChanged","processId","addProcess","removeProcess","left","top","parent_3","isLane","offsetX","offsetY","bpmnModule","updateDocks","container","elements","getAllDescendants","i_1","tempNode","sizeChanged","scaleWidth","scaleHeight","scale","selectorObj","selectedItems","rotationChanged","rotate","sourceID","targetID","sourcePortID","removePortEdges","targetPortID","outEdges","updatePortEdges","inEdges","sx","sourcePoint","sy","dragSourceEnd","targetPoint","dragTargetEnd","mode","refreshDiagramLayer","nodeId","clearSelectorLayer","addChild","addTextAnnotation","label","removeLabels","addLabels","port","removePorts","addPorts","getRedoEntry","startGroupActionCount","redoEntry","redoGroupAction","redovalue","entryCurrent","destroy","getModuleName"],"mappings":"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","sourcesContent":["import { Node } from './node';\nimport { DiagramAction } from '../enum/enum';\nimport { removeItem, getObjectType } from '../utility/diagram-util';\nimport { cloneObject, getFunction } from '../utility/base-util';\nimport { findAnnotation, findPort } from '../utility/diagram-util';\nimport { Size, addChildToContainer } from '../index';\nimport { swimLaneMeasureAndArrange, laneInterChanged, findLaneIndex, updateSwimLaneObject, pasteSwimLane } from '../utility/swim-lane-util';\nimport { DiagramEvent, BlazorAction } from '../enum/enum';\nimport { isBlazor } from '@syncfusion/ej2-base';\n/**\n * Undo redo function used for revert and restore the changes\n */\nvar UndoRedo = /** @class */ (function () {\n    /**\n     * Constructor for the undo redo module\n     *\n     * @private\n     */\n    function UndoRedo() {\n        this.groupUndo = false;\n        this.childTable = [];\n        this.historyCount = 0;\n        this.hasGroup = false;\n        this.groupCount = 0;\n        //constructs the undo redo module\n    }\n    /**\n     * initHistory method \\\n     *\n     * @returns { void } initHistory method .\\\n     * @param {Diagram} diagram - provide the points value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.initHistory = function (diagram) {\n        diagram.historyManager = {\n            canRedo: false, canUndo: false, currentEntry: null,\n            push: diagram.addHistoryEntry.bind(diagram), undo: Function, redo: Function,\n            startGroupAction: diagram.startGroupAction.bind(diagram), endGroupAction: diagram.endGroupAction.bind(diagram),\n            canLog: null, undoStack: [], redoStack: [], stackLimit: diagram.historyManager ? diagram.historyManager.stackLimit : undefined\n        };\n    };\n    /**\n     * addHistoryEntry method \\\n     *\n     * @returns { void } addHistoryEntry method .\\\n     * @param {HistoryEntry} entry - provide the points value.\n     * @param {Diagram} diagram - provide the points value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.addHistoryEntry = function (entry, diagram) {\n        var entryObject = null;\n        var nextEntry = null;\n        if (diagram.historyManager.canLog) {\n            var hEntry = diagram.historyManager.canLog(entry);\n            if (hEntry.cancel === true) {\n                return;\n            }\n        }\n        if (diagram.historyManager && diagram.historyManager.canUndo && diagram.historyManager.currentEntry) {\n            entryObject = diagram.historyManager.currentEntry;\n            if (entryObject.next) {\n                if (entryObject.previous) {\n                    nextEntry = entryObject.next;\n                    nextEntry.previous = null;\n                    entryObject.next = entry;\n                    entry.previous = entryObject;\n                }\n            }\n            else {\n                entryObject.next = entry;\n                entry.previous = entryObject;\n            }\n        }\n        diagram.historyManager.currentEntry = entry;\n        if (diagram.historyManager.stackLimit) {\n            if (entry.type === 'StartGroup' || entry.type === 'EndGroup') {\n                var value = entry.type === 'EndGroup' ? true : false;\n                this.setEntryLimit(value);\n            }\n            if (!this.hasGroup && this.groupCount === 0) {\n                if (this.historyCount < diagram.historyManager.stackLimit) {\n                    this.historyCount++;\n                }\n                else {\n                    this.applyLimit(diagram.historyManager.currentEntry, diagram.historyManager.stackLimit, diagram);\n                }\n            }\n        }\n        this.getHistoryList(diagram);\n        diagram.historyManager.canUndo = true;\n        diagram.historyManager.canRedo = false;\n    };\n    /**\n     * applyLimit method \\\n     *\n     * @returns { void } applyLimit method .\\\n     * @param {HistoryEntry} list - provide the list value.\n     * @param {number} stackLimit - provide the list value.\n     * @param {Diagram} diagram - provide the list value.\n     * @param {boolean} limitHistory - provide the list value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.applyLimit = function (list, stackLimit, diagram, limitHistory) {\n        if (list && list.previous) {\n            if (list.type === 'StartGroup' || list.type === 'EndGroup') {\n                var value = list.type === 'StartGroup' ? true : false;\n                this.setEntryLimit(value);\n            }\n            if (!this.hasGroup && this.groupCount === 0) {\n                stackLimit--;\n            }\n            if (stackLimit === 0) {\n                if (limitHistory) {\n                    this.limitHistoryStack(list.previous, diagram);\n                }\n                if (diagram.historyManager.stackLimit < this.historyCount) {\n                    this.historyCount = diagram.historyManager.stackLimit;\n                }\n                delete list.previous;\n            }\n            else if (list.previous) {\n                this.applyLimit(list.previous, stackLimit, diagram, limitHistory);\n            }\n        }\n        this.groupCount = 0;\n    };\n    /**\n     * clearHistory method \\\n     *\n     * @returns { void } clearHistory method .\\\n     * @param {Diagram} diagram - provide the points value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.clearHistory = function (diagram) {\n        var hList = diagram.historyManager;\n        hList.currentEntry = undefined;\n        hList.canUndo = false;\n        hList.canRedo = false;\n        this.historyCount = 0;\n        this.groupCount = 0;\n        diagram.historyManager.undoStack = [];\n        diagram.historyManager.redoStack = [];\n    };\n    UndoRedo.prototype.setEntryLimit = function (value) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        value ? this.groupCount-- : this.groupCount++;\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        value ? this.hasGroup = !value : this.hasGroup = value;\n    };\n    UndoRedo.prototype.limitHistoryStack = function (list, diagram) {\n        if (list.type !== 'StartGroup' && list.type !== 'EndGroup') {\n            this.removeFromStack(diagram.historyManager.undoStack, list);\n            this.removeFromStack(diagram.historyManager.redoStack, list);\n        }\n        if (list.previous) {\n            this.limitHistoryStack(list.previous, diagram);\n        }\n    };\n    UndoRedo.prototype.removeFromStack = function (entyList, list) {\n        if (entyList.length) {\n            for (var i = 0; i <= entyList.length; i++) {\n                if (entyList[i].undoObject === list.undoObject && entyList[i].redoObject === list.redoObject) {\n                    entyList.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    };\n    /**\n     * undo method \\\n     *\n     * @returns { void } undo method .\\\n     * @param {Diagram} diagram - provide the diagram value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.undo = function (diagram) {\n        var entry = this.getUndoEntry(diagram);\n        var endGroupActionCount = 0;\n        if (entry) {\n            if (entry.category === 'Internal') {\n                if (entry.type === 'EndGroup') {\n                    endGroupActionCount++;\n                    this.groupUndo = true;\n                    if (isBlazor()) {\n                        diagram.blazorActions |= BlazorAction.GroupingInProgress;\n                    }\n                }\n                else {\n                    this.undoEntry(entry, diagram);\n                }\n                if (this.groupUndo) {\n                    this.undoGroupAction(entry, diagram, endGroupActionCount);\n                    this.groupUndo = false;\n                }\n            }\n            else {\n                if (!isBlazor()) {\n                    diagram.historyManager.undo(entry);\n                }\n                var arg = {\n                    entryType: 'undo', oldValue: entry.undoObject, newValue: entry.redoObject\n                };\n                if (isBlazor()) {\n                    arg = {\n                        entryType: 'undo', oldValue: this.getHistoryChangeEvent(entry.undoObject, entry.blazorHistoryEntryType),\n                        newValue: this.getHistoryChangeEvent(entry.redoObject, entry.blazorHistoryEntryType)\n                    };\n                }\n                diagram.triggerEvent(DiagramEvent.historyStateChange, arg);\n            }\n        }\n    };\n    UndoRedo.prototype.getHistoryChangeEvent = function (object, prop) {\n        var value = {};\n        switch (prop) {\n            case 'Node':\n                value.node = object;\n                break;\n            case 'Connector':\n                value.connector = object;\n                break;\n            case 'Selector':\n                value.selector = object;\n                break;\n            case 'Diagram':\n                value.diagram = object;\n                break;\n            case 'ShapeAnnotation':\n                value.shapeAnnotation = object;\n                break;\n            case 'PathAnnotation':\n                value.pathAnnotation = object;\n                break;\n            case 'PortObject':\n                value.pointPortModel = object;\n                break;\n            case 'Object':\n                value.object = object;\n        }\n        return value;\n    };\n    UndoRedo.prototype.getHistoryList = function (diagram) {\n        var undoStack = [];\n        var redoStack = [];\n        var currEntry = diagram.historyManager.currentEntry;\n        var undoObj;\n        var redoObj;\n        currEntry = diagram.historyManager.currentEntry;\n        if (diagram.historyManager.canUndo || diagram.historyManager.undoStack.length === 0) {\n            this.getHistroyObject(undoStack, currEntry);\n        }\n        else {\n            this.getHistroyObject(redoStack, currEntry);\n        }\n        while (currEntry && currEntry.previous) {\n            undoObj = currEntry.previous;\n            this.getHistroyObject(undoStack, undoObj);\n            currEntry = currEntry.previous;\n        }\n        currEntry = diagram.historyManager.currentEntry;\n        while (currEntry && currEntry.next) {\n            redoObj = currEntry.next;\n            this.getHistroyObject(redoStack, redoObj);\n            currEntry = currEntry.next;\n        }\n        diagram.historyManager.undoStack = undoStack;\n        diagram.historyManager.redoStack = redoStack;\n    };\n    UndoRedo.prototype.getHistroyObject = function (list, obj) {\n        if (obj && obj.type !== 'StartGroup' && obj.type !== 'EndGroup') {\n            list.push({\n                redoObject: obj.redoObject ? obj.redoObject : null,\n                undoObject: obj.undoObject ? obj.undoObject : null,\n                type: obj.type ? obj.type : null,\n                category: obj.category ? obj.category : null\n            });\n        }\n    };\n    UndoRedo.prototype.undoGroupAction = function (entry, diagram, endGroupActionCount) {\n        while (endGroupActionCount !== 0) {\n            this.undoEntry(entry, diagram);\n            entry = this.getUndoEntry(diagram);\n            if (entry.type === 'StartGroup') {\n                endGroupActionCount--;\n            }\n            else if (entry.type === 'EndGroup') {\n                endGroupActionCount++;\n            }\n        }\n        endGroupActionCount = 0;\n    };\n    UndoRedo.prototype.undoEntry = function (entry, diagram) {\n        var obj;\n        var nodeObject;\n        if (entry.type !== 'PropertyChanged' && entry.type !== 'CollectionChanged' && entry.type !== 'LabelCollectionChanged') {\n            obj = (entry.undoObject);\n            nodeObject = (entry.undoObject);\n        }\n        if (entry.type !== 'StartGroup' && entry.type !== 'EndGroup') {\n            if (diagram.historyManager.undoStack.length > 0) {\n                var addObject = diagram.historyManager.undoStack.splice(0, 1);\n                diagram.historyManager.redoStack.splice(0, 0, addObject[0]);\n                nodeObject = (entry.undoObject);\n            }\n        }\n        diagram.protectPropertyChange(true);\n        diagram.diagramActions |= DiagramAction.UndoRedo;\n        if (isBlazor() && entry.previous && entry.previous.type === 'StartGroup') {\n            diagram.blazorActions &= ~BlazorAction.GroupingInProgress;\n        }\n        switch (entry.type) {\n            case 'PositionChanged':\n            case 'Align':\n            case 'Distribute':\n                this.recordPositionChanged(obj, diagram);\n                break;\n            case 'SizeChanged':\n            case 'Sizing':\n                this.recordSizeChanged(obj, diagram, entry);\n                break;\n            case 'RotationChanged':\n                this.recordRotationChanged(obj, diagram, entry);\n                break;\n            case 'ConnectionChanged':\n                this.recordConnectionChanged(obj, diagram);\n                break;\n            case 'PropertyChanged':\n                this.recordPropertyChanged(entry, diagram, false);\n                break;\n            case 'CollectionChanged':\n                if (entry && entry.next && entry.next.type === 'AddChildToGroupNode' && entry.next.changeType === 'Insert') {\n                    var group = diagram.getObject(entry.next.undoObject.id);\n                    diagram.insertValue(cloneObject(group), true);\n                }\n                entry.isUndo = true;\n                this.recordCollectionChanged(entry, diagram);\n                entry.isUndo = false;\n                if (entry && entry.next && entry.next.type === 'AddChildToGroupNode' && entry.next.changeType === 'Insert') {\n                    var group = diagram.getObject(entry.next.undoObject.id);\n                    group.wrapper.measure(new Size());\n                    group.wrapper.arrange(group.wrapper.desiredSize);\n                    diagram.updateDiagramObject(group);\n                }\n                break;\n            case 'LabelCollectionChanged':\n                entry.isUndo = true;\n                this.recordLabelCollectionChanged(entry, diagram);\n                entry.isUndo = false;\n                break;\n            case 'PortCollectionChanged':\n                entry.isUndo = true;\n                this.recordPortCollectionChanged(entry, diagram);\n                entry.isUndo = false;\n                break;\n            case 'Group':\n                this.unGroup(entry, diagram);\n                break;\n            case 'UnGroup':\n                this.group(entry, diagram);\n                break;\n            case 'SegmentChanged':\n                this.recordSegmentChanged(obj, diagram);\n                break;\n            case 'PortPositionChanged':\n                this.recordPortChanged(entry, diagram, false);\n                break;\n            case 'AnnotationPropertyChanged':\n                this.recordAnnotationChanged(entry, diagram, false);\n                break;\n            case 'ChildCollectionChanged':\n                this.recordChildCollectionChanged(entry, diagram, false);\n                break;\n            case 'StackChildPositionChanged':\n                this.recordStackPositionChanged(entry, diagram, false);\n                break;\n            case 'RowHeightChanged':\n                this.recordGridSizeChanged(entry, diagram, false, true);\n                break;\n            case 'ColumnWidthChanged':\n                this.recordGridSizeChanged(entry, diagram, false, false);\n                break;\n            case 'LanePositionChanged':\n                this.recordLanePositionChanged(entry, diagram, false);\n                break;\n            case 'LaneCollectionChanged':\n            case 'PhaseCollectionChanged':\n                entry.isUndo = true;\n                this.recordLaneOrPhaseCollectionChanged(entry, diagram, false);\n                entry.isUndo = false;\n                break;\n            case 'SendToBack':\n            case 'SendForward':\n            case 'SendBackward':\n            case 'BringToFront':\n                this.recordOrderCommandChanged(entry, diagram, false);\n                break;\n            case 'AddChildToGroupNode':\n                this.recordAddChildToGroupNode(entry, diagram, false);\n                break;\n        }\n        diagram.diagramActions &= ~DiagramAction.UndoRedo;\n        diagram.protectPropertyChange(false);\n        diagram.historyChangeTrigger(entry, 'Undo');\n        if (nodeObject) {\n            var object = this.checkNodeObject(nodeObject, diagram);\n            if (object) {\n                var getnodeDefaults = getFunction(diagram.updateSelection);\n                if (getnodeDefaults) {\n                    getnodeDefaults(object, diagram);\n                }\n            }\n        }\n    };\n    UndoRedo.prototype.checkNodeObject = function (value, diagram) {\n        var object;\n        if (!value.id) {\n            if ((value.nodes && value.nodes.length > 0) ||\n                (value.connectors && value.connectors.length > 0)) {\n                var undoNode = value.nodes.length > 0 ?\n                    value.nodes : value.connectors;\n                for (var _i = 0, undoNode_1 = undoNode; _i < undoNode_1.length; _i++) {\n                    object = undoNode_1[_i];\n                    object = diagram.nameTable[object.id];\n                }\n            }\n            else {\n                var knownNode = value.nodes ?\n                    value.nodes : value.connectors;\n                if (knownNode) {\n                    for (var _a = 0, _b = Object.keys(knownNode); _a < _b.length; _a++) {\n                        var key = _b[_a];\n                        var index = Number(key);\n                        object = value.nodes ? diagram.nodes[index] : diagram.connectors[index];\n                    }\n                }\n            }\n        }\n        else {\n            object = diagram.nameTable[value.id];\n        }\n        return object;\n    };\n    UndoRedo.prototype.group = function (historyEntry, diagram) {\n        diagram.add(historyEntry.undoObject);\n    };\n    UndoRedo.prototype.unGroup = function (entry, diagram) {\n        //const i: number = 0;\n        entry.redoObject = cloneObject(entry.undoObject);\n        var node = entry.undoObject;\n        diagram.commandHandler.unGroup(node);\n    };\n    UndoRedo.prototype.ignoreProperty = function (key) {\n        if (key === 'zIndex' || key === 'wrapper' || key === 'parentObj' || key === 'controlParent') {\n            return true;\n        }\n        return false;\n    };\n    UndoRedo.prototype.getProperty = function (collection, property) {\n        for (var _i = 0, _a = Object.keys(property); _i < _a.length; _i++) {\n            var key = _a[_i];\n            if (collection) {\n                if (!this.ignoreProperty(key)) {\n                    if (property[key] instanceof Object) {\n                        this.getProperty(collection[key], property[key]);\n                    }\n                    else {\n                        collection[key] = property[key];\n                    }\n                }\n            }\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    UndoRedo.prototype.recordLaneOrPhaseCollectionChanged = function (entry, diagram, isRedo) {\n        var node = entry.redoObject;\n        var obj = entry.undoObject;\n        var changeType;\n        if (entry.isUndo) {\n            if (entry.changeType === 'Insert') {\n                changeType = 'Remove';\n            }\n            else {\n                changeType = 'Insert';\n            }\n        }\n        else {\n            changeType = entry.changeType;\n        }\n        if (changeType === 'Remove') {\n            diagram.remove(node);\n        }\n        else {\n            if (node.isPhase) {\n                var swimlane = diagram.nameTable[node.parentId];\n                diagram.addPhases(swimlane, [obj]);\n            }\n            else {\n                var swimlane = diagram.nameTable[node.parentId];\n                var laneIndex = findLaneIndex(swimlane, node);\n                diagram.addLanes(swimlane, [obj], laneIndex);\n            }\n        }\n        diagram.clearSelection();\n    };\n    UndoRedo.prototype.recordAnnotationChanged = function (entry, diagram, isRedo) {\n        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);\n        if (diagram.canEnableBlazorObject) {\n            var node = cloneObject(diagram.nameTable[entryObject.id]);\n            diagram.insertValue(node, node instanceof Node ? true : false);\n        }\n        var oldElement = findAnnotation(entryObject, entry.objectId);\n        var undoChanges = diagram.commandHandler.getAnnotationChanges(diagram.nameTable[entryObject.id], oldElement);\n        var currentObject = diagram.nameTable[entryObject.id];\n        var currentElement = findAnnotation(currentObject, entry.objectId);\n        currentElement.offset = oldElement.offset;\n        currentElement.margin = oldElement.margin;\n        currentElement.width = oldElement.width;\n        currentElement.height = oldElement.height;\n        currentElement.rotateAngle = oldElement.rotateAngle;\n        currentElement.margin = oldElement.margin;\n        if (currentObject instanceof Node) {\n            diagram.nodePropertyChange(currentObject, {}, undoChanges);\n        }\n        else {\n            diagram.connectorPropertyChange(currentObject, {}, undoChanges);\n        }\n    };\n    UndoRedo.prototype.recordChildCollectionChanged = function (entry, diagram, isRedo) {\n        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);\n        var parentNode = diagram.nameTable[entryObject.parentId];\n        var actualObject = diagram.nameTable[entryObject.id];\n        if (parentNode) {\n            addChildToContainer(diagram, parentNode, actualObject, !isRedo, entry.historyAction === 'AddNodeToLane');\n        }\n        else {\n            if (actualObject.parentId) {\n                parentNode = diagram.nameTable[actualObject.parentId];\n                parentNode.children.splice(parentNode.children.indexOf(actualObject.id), 1);\n                parentNode.wrapper.children.splice(parentNode.wrapper.children.indexOf(actualObject.wrapper), 1);\n            }\n            if (entryObject.parentId && entryObject.parentId !== '') {\n                parentNode = diagram.nameTable[entryObject.parentId];\n                parentNode.children.push(entryObject.id);\n                parentNode.wrapper.children.push(actualObject.wrapper);\n            }\n            actualObject.parentId = entryObject.parentId;\n            diagram.removeElements(actualObject);\n            diagram.updateDiagramObject(actualObject);\n        }\n    };\n    UndoRedo.prototype.recordStackPositionChanged = function (entry, diagram, isRedo) {\n        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);\n        if (entryObject.source) {\n            var parent_1 = diagram.nameTable[entryObject.source.parentId];\n            if (parent_1) {\n                if (entryObject.target) {\n                    parent_1.wrapper.children.splice(entryObject.targetIndex, 1);\n                    parent_1.wrapper.children.splice(entryObject.sourceIndex, 0, entryObject.source.wrapper);\n                }\n                else {\n                    if (entryObject.sourceIndex !== undefined) {\n                        if (!diagram.nameTable[entryObject.source.id]) {\n                            diagram.add(entryObject.source);\n                        }\n                        parent_1.wrapper.children.splice(entryObject.sourceIndex, 0, diagram.nameTable[entryObject.source.id].wrapper);\n                        diagram.nameTable[entryObject.source.id].parentId = parent_1.id;\n                    }\n                    else {\n                        parent_1.wrapper.children.splice(parent_1.wrapper.children.indexOf(diagram.nameTable[entryObject.source.id].wrapper), 1);\n                        diagram.nameTable[entryObject.source.id].parentId = '';\n                    }\n                }\n                if (isRedo && parent_1.shape.type === 'UmlClassifier') {\n                    diagram.remove(entryObject.source);\n                }\n                parent_1.wrapper.measure(new Size());\n                parent_1.wrapper.arrange(parent_1.wrapper.desiredSize);\n                diagram.updateDiagramObject(parent_1);\n                diagram.updateSelector();\n            }\n        }\n    };\n    UndoRedo.prototype.recordGridSizeChanged = function (entry, diagram, isRedo, isRow) {\n        var obj = (isRedo) ? entry.redoObject : entry.undoObject;\n        var node = (!isRedo) ? entry.redoObject : entry.undoObject;\n        if (obj.parentId) {\n            var swimlane = diagram.nameTable[obj.parentId];\n            var actualObject = diagram.nameTable[obj.id];\n            var x = swimlane.wrapper.bounds.x;\n            var y = swimlane.wrapper.bounds.y;\n            if (swimlane.shape.type === 'SwimLane') {\n                var grid = swimlane.wrapper.children[0];\n                var padding = swimlane.shape.padding;\n                updateSwimLaneObject(diagram, node, swimlane, obj);\n                if (isRow) {\n                    grid.updateRowHeight(obj.rowIndex, obj.wrapper.actualSize.height, true, padding);\n                    swimlane.height = swimlane.wrapper.height = grid.height;\n                }\n                else {\n                    grid.updateColumnWidth(obj.columnIndex, obj.wrapper.actualSize.width, true, padding);\n                    swimlane.width = swimlane.wrapper.width = grid.width;\n                    if (obj.isPhase) {\n                        actualObject.maxWidth = actualObject.wrapper.maxWidth = obj.wrapper.actualSize.width;\n                    }\n                }\n                swimLaneMeasureAndArrange(swimlane);\n                var tx = x - swimlane.wrapper.bounds.x;\n                var ty = y - swimlane.wrapper.bounds.y;\n                diagram.drag(swimlane, tx, ty);\n                diagram.clearSelection();\n                diagram.updateDiagramObject(swimlane);\n            }\n        }\n    };\n    UndoRedo.prototype.recordLanePositionChanged = function (entry, diagram, isRedo) {\n        var entryObject = ((isRedo) ? entry.redoObject : entry.undoObject);\n        if (entryObject.source) {\n            var parent_2 = diagram.nameTable[entryObject.source.parentId];\n            if (parent_2 && parent_2.shape.type === 'SwimLane') {\n                laneInterChanged(diagram, entryObject.target, entryObject.source);\n                diagram.clearSelection();\n            }\n        }\n    };\n    UndoRedo.prototype.recordPortChanged = function (entry, diagram, isRedo) {\n        var entryObject = ((isRedo) ? entry.redoObject.nodes[0] :\n            entry.undoObject.nodes[0]);\n        if (diagram.canEnableBlazorObject) {\n            var node = cloneObject(diagram.nameTable[entryObject.id]);\n            diagram.insertValue(node, true);\n        }\n        var oldElement = findPort(entryObject, entry.objectId);\n        var undoChanges = diagram.commandHandler.getPortChanges(diagram.nameTable[entryObject.id], oldElement);\n        var currentObject = diagram.nameTable[entryObject.id];\n        var currentElement = findPort(currentObject, entry.objectId);\n        currentElement.offset = oldElement.offset;\n        diagram.nodePropertyChange(currentObject, {}, undoChanges);\n        if (currentObject.parentId) {\n            diagram.updateConnectorEdges(diagram.nameTable[currentObject.parentId]);\n        }\n    };\n    UndoRedo.prototype.recordPropertyChanged = function (entry, diagram, isRedo) {\n        var redoObject = entry.redoObject;\n        var undoObject = entry.undoObject;\n        if (isBlazor()) {\n            for (var _i = 0, _a = Object.keys(undoObject); _i < _a.length; _i++) {\n                var prop = _a[_i];\n                var obj = void 0;\n                switch (prop) {\n                    case 'nodes':\n                        for (var _b = 0, _c = Object.keys(undoObject.nodes); _b < _c.length; _b++) {\n                            var key = _c[_b];\n                            if (diagram.canEnableBlazorObject) {\n                                obj = cloneObject(diagram.nodes[Number(key)]);\n                                diagram.insertValue(obj, true);\n                            }\n                        }\n                        break;\n                    case 'connectors':\n                        for (var _d = 0, _e = Object.keys(undoObject.connectors); _d < _e.length; _d++) {\n                            var key = _e[_d];\n                            if (diagram.canEnableBlazorObject) {\n                                obj = cloneObject(diagram.connectors[Number(key)]);\n                                diagram.insertValue(obj, false);\n                            }\n                        }\n                        break;\n                }\n            }\n        }\n        this.getProperty(diagram, (isRedo ? redoObject : undoObject));\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        isRedo ? diagram.onPropertyChanged(redoObject, undoObject) : diagram.onPropertyChanged(undoObject, redoObject);\n        diagram.diagramActions = diagram.diagramActions | DiagramAction.UndoRedo;\n    };\n    UndoRedo.prototype.recordOrderCommandChanged = function (entry, diagram, isRedo) {\n        var redoObject = entry.redoObject;\n        var undoObject = entry.undoObject;\n        diagram.commandHandler.orderCommands(isRedo, (isRedo ? redoObject : undoObject), entry.type);\n        diagram.diagramActions = diagram.diagramActions | DiagramAction.UndoRedo;\n    };\n    UndoRedo.prototype.recordAddChildToGroupNode = function (entry, diagram, isRedo) {\n        var group = diagram.nameTable[entry.undoObject.id];\n        var child = diagram.nameTable[entry.objectId];\n        if (isRedo && entry.changeType === 'Insert') {\n            diagram.addChildToGroup(group, child.id);\n        }\n    };\n    UndoRedo.prototype.recordSegmentChanged = function (obj, diagram) {\n        var i = 0;\n        //let node: NodeModel;\n        var connector;\n        if (obj.connectors && obj.connectors.length > 0) {\n            for (i = 0; i < obj.connectors.length; i++) {\n                connector = obj.connectors[i];\n                this.segmentChanged(connector, diagram);\n            }\n        }\n    };\n    UndoRedo.prototype.segmentChanged = function (connector, diagram) {\n        var conn = diagram.nameTable[connector.id];\n        conn.segments = connector.segments;\n        diagram.commandHandler.updateEndPoint(conn);\n    };\n    UndoRedo.prototype.recordPositionChanged = function (obj, diagram) {\n        var i = 0;\n        var node;\n        var connector;\n        if (obj.nodes && obj.nodes.length > 0) {\n            for (i = 0; i < obj.nodes.length; i++) {\n                node = obj.nodes[i];\n                this.positionChanged(node, diagram);\n            }\n        }\n        if (obj.connectors && obj.connectors.length > 0) {\n            for (i = 0; i < obj.connectors.length; i++) {\n                connector = obj.connectors[i];\n                this.connectionChanged(connector, diagram);\n            }\n        }\n    };\n    UndoRedo.prototype.positionChanged = function (obj, diagram) {\n        var node = diagram.nameTable[obj.id];\n        if (obj.processId && !node.processId) {\n            diagram.addProcess(obj, obj.processId);\n        }\n        if (!obj.processId && node.processId) {\n            diagram.removeProcess(obj.id);\n        }\n        if (node.processId) {\n            var tx = obj.margin.left - node.margin.left;\n            var ty = obj.margin.top - node.margin.top;\n            diagram.drag(node, tx, ty);\n        }\n        else {\n            if (node.parentId) {\n                var parent_3 = diagram.nameTable[node.parentId];\n                if (parent_3.isLane) {\n                    obj.wrapper.offsetX = (obj.width / 2) + (parent_3.wrapper.bounds.x + obj.margin.left);\n                    obj.wrapper.offsetY = (obj.height / 2) + (parent_3.wrapper.bounds.y + obj.margin.top);\n                }\n            }\n            var tx = obj.wrapper.offsetX - node.offsetX;\n            var ty = obj.wrapper.offsetY - node.offsetY;\n            diagram.drag(node, tx, ty);\n        }\n        if (diagram.bpmnModule) {\n            diagram.bpmnModule.updateDocks(node, diagram);\n        }\n    };\n    UndoRedo.prototype.recordSizeChanged = function (obj, diagram, entry) {\n        var i = 0;\n        var connector;\n        var node;\n        if (obj && obj.nodes && obj.nodes.length > 0) {\n            for (i = 0; i < obj.nodes.length; i++) {\n                node = obj.nodes[i];\n                if (node.children && !node.container) {\n                    var elements = [];\n                    var nodes = diagram.commandHandler.getAllDescendants(node, elements);\n                    for (var i_1 = 0; i_1 < nodes.length; i_1++) {\n                        var tempNode = entry.childTable[nodes[i_1].id];\n                        if ((getObjectType(tempNode) === Node)) {\n                            this.sizeChanged(tempNode, diagram, entry);\n                            this.positionChanged(tempNode, diagram);\n                        }\n                        else {\n                            this.connectionChanged(tempNode, diagram, entry);\n                        }\n                    }\n                }\n                else {\n                    this.sizeChanged(node, diagram);\n                    this.positionChanged(node, diagram);\n                }\n            }\n        }\n        if (obj && obj.connectors && obj.connectors.length > 0) {\n            var connectors = obj.connectors;\n            for (i = 0; i < connectors.length; i++) {\n                connector = connectors[i];\n                this.connectionChanged(connector, diagram);\n            }\n        }\n    };\n    UndoRedo.prototype.sizeChanged = function (obj, diagram, entry) {\n        var node = diagram.nameTable[obj.id];\n        var scaleWidth = obj.wrapper.actualSize.width / node.wrapper.actualSize.width;\n        var scaleHeight = obj.wrapper.actualSize.height / node.wrapper.actualSize.height;\n        if (entry && entry.childTable) {\n            entry.childTable[obj.id] = cloneObject(node);\n        }\n        diagram.scale(node, scaleWidth, scaleHeight, {\n            x: obj.wrapper.offsetX / node.wrapper.offsetX,\n            y: obj.wrapper.offsetY / node.wrapper.offsetY\n        });\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    UndoRedo.prototype.recordRotationChanged = function (obj, diagram, entry) {\n        var i = 0;\n        var node;\n        var connector;\n        var selectorObj = diagram.selectedItems;\n        selectorObj.rotateAngle = obj.rotateAngle;\n        if (selectorObj && selectorObj.wrapper) {\n            selectorObj.wrapper.rotateAngle = obj.rotateAngle;\n        }\n        if (obj && obj.nodes && obj.nodes.length > 0) {\n            for (i = 0; i < obj.nodes.length; i++) {\n                node = obj.nodes[i];\n                this.rotationChanged(node, diagram);\n                this.positionChanged(node, diagram);\n            }\n        }\n        if (obj && obj.connectors && obj.connectors.length > 0) {\n            for (i = 0; i < obj.connectors.length; i++) {\n                connector = obj.connectors[i];\n                this.connectionChanged(connector, diagram);\n            }\n        }\n    };\n    UndoRedo.prototype.rotationChanged = function (obj, diagram) {\n        var node = diagram.nameTable[obj.id];\n        diagram.rotate(node, obj.rotateAngle - node.rotateAngle);\n    };\n    UndoRedo.prototype.recordConnectionChanged = function (obj, diagram) {\n        var connector = obj.connectors[0];\n        if (connector.sourceID && diagram.nameTable[connector.sourceID]) {\n            diagram.insertValue(diagram.nameTable[connector.sourceID], true);\n        }\n        if (connector.targetID && diagram.nameTable[connector.targetID]) {\n            diagram.insertValue(diagram.nameTable[connector.targetID], true);\n        }\n        this.connectionChanged(connector, diagram);\n    };\n    UndoRedo.prototype.connectionChanged = function (obj, diagram, entry) {\n        var connector = diagram.nameTable[obj.id];\n        var node;\n        if (obj.sourcePortID !== connector.sourcePortID) {\n            diagram.removePortEdges(diagram.nameTable[connector.sourceID], connector.sourcePortID, connector.id, false);\n            connector.sourcePortID = obj.sourcePortID;\n            diagram.connectorPropertyChange(connector, {}, { sourcePortID: obj.sourcePortID });\n        }\n        if (obj.targetPortID !== connector.targetPortID) {\n            diagram.removePortEdges(diagram.nameTable[connector.targetID], connector.targetPortID, connector.id, true);\n            connector.targetPortID = obj.targetPortID;\n            diagram.connectorPropertyChange(connector, {}, { targetPortID: obj.targetPortID });\n        }\n        if (obj.sourceID !== connector.sourceID) {\n            if (obj.sourceID === '') {\n                node = diagram.nameTable[connector.sourceID];\n                removeItem(node.outEdges, obj.id);\n            }\n            else {\n                node = diagram.nameTable[obj.sourceID];\n                node.outEdges.push(obj.id);\n                diagram.updatePortEdges(node, obj, false);\n            }\n            connector.sourceID = obj.sourceID;\n            diagram.connectorPropertyChange(connector, {}, { sourceID: obj.sourceID });\n        }\n        if (obj.targetID !== connector.targetID) {\n            if (obj.targetID === '') {\n                node = diagram.nameTable[connector.targetID];\n                removeItem(node.inEdges, obj.id);\n            }\n            else {\n                node = diagram.nameTable[obj.targetID];\n                node.inEdges.push(obj.id);\n                diagram.updatePortEdges(node, obj, true);\n            }\n            connector.targetID = obj.targetID;\n            diagram.connectorPropertyChange(connector, {}, { targetID: obj.targetID });\n        }\n        if (entry && entry.childTable) {\n            entry.childTable[obj.id] = cloneObject(connector);\n        }\n        var sx = obj.sourcePoint.x - connector.sourcePoint.x;\n        var sy = obj.sourcePoint.y - connector.sourcePoint.y;\n        if (sx !== 0 || sy !== 0) {\n            diagram.dragSourceEnd(connector, sx, sy);\n        }\n        var tx = obj.targetPoint.x - connector.targetPoint.x;\n        var ty = obj.targetPoint.y - connector.targetPoint.y;\n        if (tx !== 0 || ty !== 0) {\n            diagram.dragTargetEnd(connector, tx, ty);\n        }\n        diagram.updateSelector();\n        if (diagram.mode !== 'SVG') {\n            diagram.refreshDiagramLayer();\n        }\n    };\n    UndoRedo.prototype.recordCollectionChanged = function (entry, diagram) {\n        var obj = entry.undoObject;\n        if (entry && entry.changeType) {\n            var changeType = void 0;\n            if (entry.isUndo) {\n                if (entry.changeType === 'Insert') {\n                    changeType = 'Remove';\n                }\n                else {\n                    changeType = 'Insert';\n                }\n            }\n            else {\n                changeType = entry.changeType;\n            }\n            if (changeType === 'Remove') {\n                if (obj.nodeId) {\n                    diagram.remove(diagram.nameTable[obj.nodeId + '_textannotation_' + obj.id]);\n                }\n                else {\n                    diagram.remove(obj);\n                    diagram.clearSelectorLayer();\n                }\n            }\n            else {\n                diagram.clearSelectorLayer();\n                if (obj.parentId) {\n                    var parentNode = diagram.nameTable[obj.parentId];\n                    if (parentNode) {\n                        diagram.addChild(parentNode, obj);\n                    }\n                    else {\n                        diagram.add(obj);\n                    }\n                }\n                else if (obj.nodeId) {\n                    diagram.addTextAnnotation(obj, diagram.nameTable[obj.nodeId]);\n                }\n                else {\n                    if (!diagram.nameTable[obj.id]) {\n                        if (obj && obj.shape && obj.shape.type === 'SwimLane' && entry.isUndo) {\n                            pasteSwimLane(obj, undefined, undefined, undefined, undefined, true);\n                        }\n                        diagram.add(obj);\n                    }\n                }\n                if (obj.processId && diagram.nameTable[obj.processId]) {\n                    diagram.addProcess(obj, obj.processId);\n                }\n            }\n            if (diagram.mode !== 'SVG') {\n                diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    UndoRedo.prototype.recordLabelCollectionChanged = function (entry, diagram) {\n        var label = entry.undoObject;\n        var obj = entry.redoObject;\n        var node = diagram.nameTable[obj.id];\n        if (entry && entry.changeType) {\n            var changeType = void 0;\n            if (entry.isUndo) {\n                changeType = (entry.changeType === 'Insert') ? 'Remove' : 'Insert';\n            }\n            else {\n                changeType = entry.changeType;\n            }\n            if (changeType === 'Remove') {\n                diagram.removeLabels(node, [label]);\n                diagram.clearSelectorLayer();\n            }\n            else {\n                diagram.clearSelectorLayer();\n                diagram.addLabels(node, [label]);\n            }\n            if (diagram.mode !== 'SVG') {\n                diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    UndoRedo.prototype.recordPortCollectionChanged = function (entry, diagram) {\n        var port = entry.undoObject;\n        var obj = entry.redoObject;\n        var node = diagram.nameTable[obj.id];\n        if (entry && entry.changeType) {\n            var changeType = void 0;\n            if (entry.isUndo) {\n                changeType = (entry.changeType === 'Insert') ? 'Remove' : 'Insert';\n            }\n            else {\n                changeType = entry.changeType;\n            }\n            if (changeType === 'Remove') {\n                diagram.removePorts(node, [port]);\n                diagram.clearSelectorLayer();\n            }\n            else {\n                diagram.clearSelectorLayer();\n                diagram.addPorts(node, [port]);\n            }\n            if (diagram.mode !== 'SVG') {\n                diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * redo method \\\n     *\n     * @returns { void } redo method .\\\n     * @param {Diagram} diagram - provide the diagram value.\n     *\n     * @private\n     */\n    UndoRedo.prototype.redo = function (diagram) {\n        var entry = this.getRedoEntry(diagram);\n        var startGroupActionCount = 0;\n        if (entry) {\n            if (entry.category === 'Internal') {\n                if (entry.type === 'StartGroup') {\n                    startGroupActionCount++;\n                    this.groupUndo = true;\n                    if (isBlazor()) {\n                        diagram.blazorActions |= BlazorAction.GroupingInProgress;\n                    }\n                }\n                else {\n                    this.redoEntry(entry, diagram);\n                }\n                if (this.groupUndo) {\n                    this.redoGroupAction(entry, diagram, startGroupActionCount);\n                    this.groupUndo = false;\n                }\n            }\n            else {\n                if (!isBlazor()) {\n                    diagram.historyManager.redo(entry);\n                }\n                var arg = {\n                    entryType: 'redo', oldValue: entry.redoObject, newValue: entry.undoObject\n                };\n                if (isBlazor()) {\n                    arg = {\n                        entryType: 'redo', oldValue: this.getHistoryChangeEvent(entry.redoObject, entry.blazorHistoryEntryType),\n                        newValue: this.getHistoryChangeEvent(entry.undoObject, entry.blazorHistoryEntryType)\n                    };\n                }\n                diagram.triggerEvent(DiagramEvent.historyStateChange, arg);\n            }\n        }\n    };\n    UndoRedo.prototype.redoGroupAction = function (entry, diagram, startGroupActionCount) {\n        while (startGroupActionCount !== 0) {\n            this.redoEntry(entry, diagram);\n            entry = this.getRedoEntry(diagram);\n            if (entry.type === 'EndGroup') {\n                startGroupActionCount--;\n            }\n            else if (entry.type === 'StartGroup') {\n                startGroupActionCount++;\n            }\n        }\n        startGroupActionCount = 0;\n    };\n    UndoRedo.prototype.redoEntry = function (historyEntry, diagram) {\n        var redoObject;\n        var redovalue;\n        if (historyEntry.type !== 'PropertyChanged' && historyEntry.type !== 'CollectionChanged') {\n            redoObject = (historyEntry.redoObject);\n            redovalue = (historyEntry.redoObject);\n        }\n        diagram.diagramActions |= DiagramAction.UndoRedo;\n        if (historyEntry.type !== 'StartGroup' && historyEntry.type !== 'EndGroup') {\n            if (diagram.historyManager.redoStack.length > 0) {\n                var addObject = diagram.historyManager.redoStack.splice(0, 1);\n                diagram.historyManager.undoStack.splice(0, 0, addObject[0]);\n                redovalue = (historyEntry.redoObject);\n            }\n        }\n        diagram.protectPropertyChange(true);\n        if (isBlazor() && historyEntry.next && historyEntry.next.type === 'EndGroup') {\n            diagram.blazorActions &= ~BlazorAction.GroupingInProgress;\n        }\n        switch (historyEntry.type) {\n            case 'PositionChanged':\n            case 'Align':\n            case 'Distribute':\n                this.recordPositionChanged(redoObject, diagram);\n                break;\n            case 'SizeChanged':\n            case 'Sizing':\n                this.recordSizeChanged(redoObject, diagram, historyEntry);\n                break;\n            case 'RotationChanged':\n                this.recordRotationChanged(redoObject, diagram, historyEntry);\n                break;\n            case 'ConnectionChanged':\n                this.recordConnectionChanged(redoObject, diagram);\n                break;\n            case 'PropertyChanged':\n                this.recordPropertyChanged(historyEntry, diagram, true);\n                break;\n            case 'CollectionChanged':\n                this.recordCollectionChanged(historyEntry, diagram);\n                break;\n            case 'LabelCollectionChanged':\n                this.recordLabelCollectionChanged(historyEntry, diagram);\n                break;\n            case 'PortCollectionChanged':\n                this.recordPortCollectionChanged(historyEntry, diagram);\n                break;\n            case 'Group':\n                this.group(historyEntry, diagram);\n                break;\n            case 'UnGroup':\n                this.unGroup(historyEntry, diagram);\n                break;\n            case 'SegmentChanged':\n                this.recordSegmentChanged(redoObject, diagram);\n                break;\n            case 'PortPositionChanged':\n                this.recordPortChanged(historyEntry, diagram, true);\n                break;\n            case 'AnnotationPropertyChanged':\n                this.recordAnnotationChanged(historyEntry, diagram, true);\n                break;\n            case 'ChildCollectionChanged':\n                this.recordChildCollectionChanged(historyEntry, diagram, true);\n                break;\n            case 'StackChildPositionChanged':\n                this.recordStackPositionChanged(historyEntry, diagram, true);\n                break;\n            case 'RowHeightChanged':\n                this.recordGridSizeChanged(historyEntry, diagram, true, true);\n                break;\n            case 'ColumnWidthChanged':\n                this.recordGridSizeChanged(historyEntry, diagram, true, false);\n                break;\n            case 'LanePositionChanged':\n                this.recordLanePositionChanged(historyEntry, diagram, true);\n                break;\n            case 'LaneCollectionChanged':\n            case 'PhaseCollectionChanged':\n                this.recordLaneOrPhaseCollectionChanged(historyEntry, diagram, true);\n                break;\n            case 'SendToBack':\n            case 'SendForward':\n            case 'SendBackward':\n            case 'BringToFront':\n                this.recordOrderCommandChanged(historyEntry, diagram, true);\n                break;\n            case 'AddChildToGroupNode':\n                this.recordAddChildToGroupNode(historyEntry, diagram, true);\n                break;\n        }\n        diagram.protectPropertyChange(false);\n        diagram.diagramActions &= ~DiagramAction.UndoRedo;\n        diagram.historyChangeTrigger(historyEntry, 'Redo');\n        if (redovalue) {\n            var value = this.checkNodeObject(redovalue, diagram);\n            if (value) {\n                var getnodeDefaults = getFunction(diagram.updateSelection);\n                if (getnodeDefaults) {\n                    getnodeDefaults(value, diagram);\n                }\n            }\n        }\n    };\n    UndoRedo.prototype.getUndoEntry = function (diagram) {\n        var undoEntry = null;\n        var currentObject;\n        var hList = diagram.historyManager;\n        if (hList.canUndo) {\n            undoEntry = hList.currentEntry;\n            currentObject = hList.currentEntry.previous;\n            if (currentObject) {\n                hList.currentEntry = currentObject;\n                if (!hList.canRedo) {\n                    hList.canRedo = true;\n                }\n            }\n            else {\n                hList.canRedo = true;\n                hList.canUndo = false;\n            }\n        }\n        return undoEntry;\n    };\n    UndoRedo.prototype.getRedoEntry = function (diagram) {\n        var redoEntry = null;\n        var entryCurrent;\n        var hList = diagram.historyManager;\n        if (hList.canRedo) {\n            if (!hList.currentEntry.previous && !hList.canUndo) {\n                entryCurrent = hList.currentEntry;\n            }\n            else {\n                entryCurrent = hList.currentEntry.next;\n            }\n            if (entryCurrent) {\n                hList.currentEntry = entryCurrent;\n                if (!hList.canUndo) {\n                    hList.canUndo = true;\n                }\n                if (!entryCurrent.next) {\n                    hList.canRedo = false;\n                    hList.canUndo = true;\n                }\n            }\n            redoEntry = hList.currentEntry;\n        }\n        return redoEntry;\n    };\n    /**\n     * To destroy the undo redo module\n     *\n     * @returns {void}\n     * @private\n     */\n    UndoRedo.prototype.destroy = function () {\n        /**\n         * Destroys the undo redo module\n         */\n    };\n    /**\n     * @returns { string } toBounds method .\\\n     * Get getModuleName name.\n     */\n    UndoRedo.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'UndoRedo';\n    };\n    return UndoRedo;\n}());\nexport { UndoRedo };\n"]},"metadata":{},"sourceType":"module"}