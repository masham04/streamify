{"ast":null,"code":"import { Transform, ElementAction } from '../../enum/enum';\nimport { Size } from '../../primitives/size';\nimport { Rect } from '../../primitives/rect';\nimport { getBounds } from '../../utility/base-util';\n/**\n * DiagramElement module defines the basic unit of diagram\n */\n\nvar DiagramElement =\n/** @class */\nfunction () {\n  function DiagramElement() {\n    /**\n     * Sets/Gets the reference point of the element\n     * ```html\n     * <div id='diagram'></div>\n     * ```\n     * ```typescript\n     * let stackPanel: StackPanel = new StackPanel();\n     * stackPanel.offsetX = 300; stackPanel.offsetY = 200;\n     * stackPanel.width = 100; stackPanel.height = 100;\n     * stackPanel.style.fill = 'red';\n     * stackPanel.pivot = { x: 0.5, y: 0.5 };\n     * let diagram: Diagram = new Diagram({\n     * ...\n     * basicElements: [stackPanel],\n     * ...\n     * });\n     * diagram.appendTo('#diagram');\n     * ```\n     */\n    this.pivot = {\n      x: 0.5,\n      y: 0.5\n    };\n    /**\n     * Sets or gets whether the content of the element needs to be measured\n     */\n\n    this.isDirt = true;\n    /**\n     * set to true during print and eport\n     */\n\n    /** @private */\n\n    this.isExport = false;\n    /**\n     * set scaling value for print and export\n     */\n\n    /** @private */\n\n    this.exportScaleValue = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * set scaling value for print and export\n     */\n\n    /** @private */\n\n    this.exportScaleOffset = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Check whether style need to be apply or not\n     */\n\n    /** @private */\n\n    this.canApplyStyle = true;\n    /**\n     * Sets or gets whether the content of the element to be visible\n     */\n\n    this.visible = true;\n    /**\n     * Sets/Gets the x-coordinate of the element\n     */\n\n    this.offsetX = 0;\n    /**\n     * Sets/Gets the y-coordinate of the element\n     */\n\n    this.offsetY = 0;\n    /**\n     * Set the corner of the element\n     */\n\n    this.cornerRadius = 0;\n    /**\n     * Sets/Gets the minimum height of the element\n     */\n\n    this.minHeight = undefined;\n    /**\n     * Sets/Gets the minimum width of the element\n     */\n\n    this.minWidth = undefined;\n    /**\n     * Sets/Gets the maximum width of the element\n     */\n\n    this.maxWidth = undefined;\n    /**\n     * Sets/Gets the maximum height of the element\n     */\n\n    this.maxHeight = undefined;\n    /**\n     * Sets/Gets the width of the element\n     */\n\n    this.width = undefined;\n    /**\n     * Sets/Gets the height of the element\n     */\n\n    this.height = undefined;\n    /**\n     * Sets/Gets the rotate angle of the element\n     */\n\n    this.rotateAngle = 0;\n    /**\n     * Sets/Gets the margin of the element\n     */\n\n    this.margin = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /**\n     * Sets/Gets how the element has to be horizontally arranged with respect to its immediate parent\n     * * Stretch - Stretches the diagram element throughout its immediate parent\n     * * Left - Aligns the diagram element at the left of its immediate parent\n     * * Right - Aligns the diagram element at the right of its immediate parent\n     * * Center - Aligns the diagram element at the center of its immediate parent\n     * * Auto - Aligns the diagram element based on the characteristics of its immediate parent\n     */\n\n    this.horizontalAlignment = 'Auto';\n    /**\n     * Sets/Gets how the element has to be vertically arranged with respect to its immediate parent\n     * * Stretch - Stretches the diagram element throughout its immediate parent\n     * * Top - Aligns the diagram element at the top of its immediate parent\n     * * Bottom - Aligns the diagram element at the bottom of its immediate parent\n     * * Center - Aligns the diagram element at the center of its immediate parent\n     * * Auto - Aligns the diagram element based on the characteristics of its immediate parent\n     */\n\n    this.verticalAlignment = 'Auto';\n    /**\n     * Sets/Gets the mirror image of diagram element in both horizontal and vertical directions\n     * * FlipHorizontal - Translate the diagram element throughout its immediate parent\n     * * FlipVertical - Rotate the diagram element throughout its immediate parent\n     */\n\n    this.flip = 'None';\n    /**\n     * Sets whether the element has to be aligned with respect to a point/with respect to its immediate parent\n     * * Point - Diagram elements will be aligned with respect to a point\n     * * Object - Diagram elements will be aligned with respect to its immediate parent\n     */\n\n    this.relativeMode = 'Point';\n    /**\n     * Sets whether the element has to be transformed based on its parent or not\n     * * Self - Sets the transform type as Self\n     * * Parent - Sets the transform type as Parent\n     */\n\n    this.transform = Transform.Self | Transform.Parent;\n    /**\n     * Sets the style of the element\n     */\n\n    this.style = {\n      fill: 'white',\n      strokeColor: 'black',\n      opacity: 1,\n      strokeWidth: 1\n    };\n    /**\n     * Gets the minimum size that is required by the element\n     */\n\n    this.desiredSize = new Size();\n    /**\n     * Gets the size that the element will be rendered\n     */\n\n    this.actualSize = new Size();\n    /**\n     * Gets the rotate angle that is set to the immediate parent of the element\n     */\n\n    this.parentTransform = 0;\n    /** @private */\n\n    this.preventContainer = false;\n    /**\n     * Gets/Set the boolean value for the element\n     */\n\n    this.isSvgRender = false;\n    /**\n     * Gets/Sets the boundary of the element\n     */\n\n    this.bounds = new Rect(0, 0, 0, 0);\n    /**\n     * Defines the appearance of the shadow of the element\n     */\n\n    this.shadow = null;\n    /**\n     * Defines the description of the diagram element\n     */\n\n    this.description = '';\n    /**\n     * Defines whether the element has to be measured or not\n     */\n\n    this.staticSize = false;\n    /**\n     * check whether the element is rect or not\n     */\n\n    this.isRectElement = false;\n    /** @private */\n\n    this.isCalculateDesiredSize = true;\n    /**\n     * Set the offset values for container in flipping\n     */\n\n    /** @private */\n\n    this.flipOffset = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Defines whether the element is group or port\n     */\n\n    /** @private */\n\n    this.elementActions = ElementAction.None;\n    /** @private */\n\n    this.inversedAlignment = true; //private variables\n\n    this.position = undefined;\n    this.unitMode = undefined;\n    /**   @private  */\n\n    this.float = false;\n    this.floatingBounds = undefined;\n  } // public constructor() {\n  //     this.id = randomId();\n  // }\n\n  /**\n   * Sets the offset of the element with respect to its parent \\\n   *\n   * @returns { void }Sets the offset of the element with respect to its parent\\\n   * @param {number} x - provide the x value.\n   * @param {number} y - provide the y value.\n   * @param {UnitMode} mode - provide the id value.\n   *\n   * @private\n   */\n\n\n  DiagramElement.prototype.setOffsetWithRespectToBounds = function (x, y, mode) {\n    this.unitMode = mode;\n    this.position = {\n      x: x,\n      y: y\n    };\n  };\n  /**\n   * Gets the position of the element with respect to its parent \\\n   *\n   * @returns { PointModel } Gets the position of the element with respect to its parent\\\n   * @param {Size} size - provide the x value.\n   *\n   * @private\n   */\n\n\n  DiagramElement.prototype.getAbsolutePosition = function (size) {\n    if (this.position !== undefined) {\n      if (this.unitMode === 'Absolute') {\n        return this.position;\n      } else {\n        return {\n          x: this.position.x * size.width,\n          y: this.position.y * size.height\n        };\n      }\n    }\n\n    return undefined;\n  };\n\n  Object.defineProperty(DiagramElement.prototype, \"outerBounds\", {\n    get: function () {\n      return this.floatingBounds || this.bounds;\n    },\n\n    /**\n     * used to set the outer bounds value \\\n     *\n     * @returns { void } used to set the outer bounds value.\\\n     * @param {Rect} bounds - provide the id value.\n     *\n     * @private\n     */\n    set: function (bounds) {\n      this.floatingBounds = bounds;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Measures the minimum space that the element requires \\\n   *\n   * @returns { void } Measures the minimum space that the element requires.\\\n   * @param {Size} availableSize - provide the id value.\n   * @param {Object} obj - provide the id value.\n   * @param {Function} callback - provide the id value.\n   *\n   * @private\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n  DiagramElement.prototype.measure = function (availableSize, obj, callback) {\n    var width = this.width !== undefined ? this.width : (availableSize.width || 0) - this.margin.left - this.margin.right;\n    var height = this.height !== undefined ? this.height : (availableSize.height || 0) - this.margin.top - this.margin.bottom;\n\n    if (this.id) {\n      if (height === 0 && this.elementActions & ElementAction.HorizontalLaneHeader) {\n        height = this.actualSize.height;\n      }\n    }\n\n    this.desiredSize = new Size(width, height);\n\n    if (this.isCalculateDesiredSize) {\n      this.desiredSize = this.validateDesiredSize(this.desiredSize, availableSize);\n    }\n\n    return this.desiredSize;\n  };\n  /**\n   * Arranges the element \\\n   *\n   * @returns { PointModel } Arranges the element\\\n   * @param {Size} desiredSize - provide the x value.\n   *\n   * @private\n   */\n\n\n  DiagramElement.prototype.arrange = function (desiredSize) {\n    this.actualSize = desiredSize;\n    this.updateBounds();\n    return this.actualSize;\n  };\n  /**\n   * Updates the bounds of the element \\\n   *\n   * @returns { void } Updates the bounds of the element\\\n   *\n   * @private\n   */\n\n\n  DiagramElement.prototype.updateBounds = function () {\n    this.bounds = getBounds(this);\n  };\n  /**\n   * Validates the size of the element with respect to its minimum and maximum size \\\n   *\n   * @returns { Size } Validates the size of the element with respect to its minimum and maximum size.\\\n   * @param {Size} desiredSize - provide the id value.\n   * @param {Size} availableSize - provide the id value.\n   *\n   * @private\n   */\n\n\n  DiagramElement.prototype.validateDesiredSize = function (desiredSize, availableSize) {\n    //Empty canvas\n    if (this.isRectElement && !this.width && !this.minWidth && !this.maxWidth) {\n      desiredSize.width = 50;\n    }\n\n    if (this.isRectElement && !this.height && !this.minHeight && !this.maxHeight) {\n      desiredSize.height = 50;\n    }\n\n    if (desiredSize === undefined || this.width !== undefined && this.height !== undefined) {\n      desiredSize = desiredSize || new Size();\n      desiredSize.width = this.width === undefined ? (availableSize.width || 0) - this.margin.left - this.margin.right : this.width;\n      desiredSize.height = this.height === undefined ? (availableSize.height || 0) - this.margin.top - this.margin.bottom : this.height;\n    } //Considering min values\n\n\n    if (this.minWidth !== undefined) {\n      desiredSize.width = Math.max(desiredSize.width, this.minWidth);\n    }\n\n    if (this.minHeight !== undefined) {\n      desiredSize.height = Math.max(desiredSize.height, this.minHeight);\n    } //Considering max values\n\n\n    if (this.maxWidth !== undefined && this.maxWidth !== 0) {\n      desiredSize.width = Math.min(desiredSize.width, this.maxWidth);\n    }\n\n    if (this.maxHeight !== undefined && this.maxHeight !== 0) {\n      desiredSize.height = Math.min(desiredSize.height, this.maxHeight);\n    }\n\n    return desiredSize;\n  };\n\n  return DiagramElement;\n}();\n\nexport { DiagramElement };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/core/elements/diagram-element.js"],"names":["Transform","ElementAction","Size","Rect","getBounds","DiagramElement","pivot","x","y","isDirt","isExport","exportScaleValue","exportScaleOffset","canApplyStyle","visible","offsetX","offsetY","cornerRadius","minHeight","undefined","minWidth","maxWidth","maxHeight","width","height","rotateAngle","margin","left","right","top","bottom","horizontalAlignment","verticalAlignment","flip","relativeMode","transform","Self","Parent","style","fill","strokeColor","opacity","strokeWidth","desiredSize","actualSize","parentTransform","preventContainer","isSvgRender","bounds","shadow","description","staticSize","isRectElement","isCalculateDesiredSize","flipOffset","elementActions","None","inversedAlignment","position","unitMode","float","floatingBounds","prototype","setOffsetWithRespectToBounds","mode","getAbsolutePosition","size","Object","defineProperty","get","set","enumerable","configurable","measure","availableSize","obj","callback","id","HorizontalLaneHeader","validateDesiredSize","arrange","updateBounds","Math","max","min"],"mappings":"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","sourcesContent":["import { Transform, ElementAction } from '../../enum/enum';\nimport { Size } from '../../primitives/size';\nimport { Rect } from '../../primitives/rect';\nimport { getBounds } from '../../utility/base-util';\n/**\n * DiagramElement module defines the basic unit of diagram\n */\nvar DiagramElement = /** @class */ (function () {\n    function DiagramElement() {\n        /**\n         * Sets/Gets the reference point of the element\n         * ```html\n         * <div id='diagram'></div>\n         * ```\n         * ```typescript\n         * let stackPanel: StackPanel = new StackPanel();\n         * stackPanel.offsetX = 300; stackPanel.offsetY = 200;\n         * stackPanel.width = 100; stackPanel.height = 100;\n         * stackPanel.style.fill = 'red';\n         * stackPanel.pivot = { x: 0.5, y: 0.5 };\n         * let diagram: Diagram = new Diagram({\n         * ...\n         * basicElements: [stackPanel],\n         * ...\n         * });\n         * diagram.appendTo('#diagram');\n         * ```\n         */\n        this.pivot = { x: 0.5, y: 0.5 };\n        /**\n         * Sets or gets whether the content of the element needs to be measured\n         */\n        this.isDirt = true;\n        /**\n         * set to true during print and eport\n         */\n        /** @private */\n        this.isExport = false;\n        /**\n         * set scaling value for print and export\n         */\n        /** @private */\n        this.exportScaleValue = { x: 0, y: 0 };\n        /**\n         * set scaling value for print and export\n         */\n        /** @private */\n        this.exportScaleOffset = { x: 0, y: 0 };\n        /**\n         * Check whether style need to be apply or not\n         */\n        /** @private */\n        this.canApplyStyle = true;\n        /**\n         * Sets or gets whether the content of the element to be visible\n         */\n        this.visible = true;\n        /**\n         * Sets/Gets the x-coordinate of the element\n         */\n        this.offsetX = 0;\n        /**\n         * Sets/Gets the y-coordinate of the element\n         */\n        this.offsetY = 0;\n        /**\n         * Set the corner of the element\n         */\n        this.cornerRadius = 0;\n        /**\n         * Sets/Gets the minimum height of the element\n         */\n        this.minHeight = undefined;\n        /**\n         * Sets/Gets the minimum width of the element\n         */\n        this.minWidth = undefined;\n        /**\n         * Sets/Gets the maximum width of the element\n         */\n        this.maxWidth = undefined;\n        /**\n         * Sets/Gets the maximum height of the element\n         */\n        this.maxHeight = undefined;\n        /**\n         * Sets/Gets the width of the element\n         */\n        this.width = undefined;\n        /**\n         * Sets/Gets the height of the element\n         */\n        this.height = undefined;\n        /**\n         * Sets/Gets the rotate angle of the element\n         */\n        this.rotateAngle = 0;\n        /**\n         * Sets/Gets the margin of the element\n         */\n        this.margin = { left: 0, right: 0, top: 0, bottom: 0 };\n        /**\n         * Sets/Gets how the element has to be horizontally arranged with respect to its immediate parent\n         * * Stretch - Stretches the diagram element throughout its immediate parent\n         * * Left - Aligns the diagram element at the left of its immediate parent\n         * * Right - Aligns the diagram element at the right of its immediate parent\n         * * Center - Aligns the diagram element at the center of its immediate parent\n         * * Auto - Aligns the diagram element based on the characteristics of its immediate parent\n         */\n        this.horizontalAlignment = 'Auto';\n        /**\n         * Sets/Gets how the element has to be vertically arranged with respect to its immediate parent\n         * * Stretch - Stretches the diagram element throughout its immediate parent\n         * * Top - Aligns the diagram element at the top of its immediate parent\n         * * Bottom - Aligns the diagram element at the bottom of its immediate parent\n         * * Center - Aligns the diagram element at the center of its immediate parent\n         * * Auto - Aligns the diagram element based on the characteristics of its immediate parent\n         */\n        this.verticalAlignment = 'Auto';\n        /**\n         * Sets/Gets the mirror image of diagram element in both horizontal and vertical directions\n         * * FlipHorizontal - Translate the diagram element throughout its immediate parent\n         * * FlipVertical - Rotate the diagram element throughout its immediate parent\n         */\n        this.flip = 'None';\n        /**\n         * Sets whether the element has to be aligned with respect to a point/with respect to its immediate parent\n         * * Point - Diagram elements will be aligned with respect to a point\n         * * Object - Diagram elements will be aligned with respect to its immediate parent\n         */\n        this.relativeMode = 'Point';\n        /**\n         * Sets whether the element has to be transformed based on its parent or not\n         * * Self - Sets the transform type as Self\n         * * Parent - Sets the transform type as Parent\n         */\n        this.transform = Transform.Self | Transform.Parent;\n        /**\n         * Sets the style of the element\n         */\n        this.style = { fill: 'white', strokeColor: 'black', opacity: 1, strokeWidth: 1 };\n        /**\n         * Gets the minimum size that is required by the element\n         */\n        this.desiredSize = new Size();\n        /**\n         * Gets the size that the element will be rendered\n         */\n        this.actualSize = new Size();\n        /**\n         * Gets the rotate angle that is set to the immediate parent of the element\n         */\n        this.parentTransform = 0;\n        /** @private */\n        this.preventContainer = false;\n        /**\n         * Gets/Set the boolean value for the element\n         */\n        this.isSvgRender = false;\n        /**\n         * Gets/Sets the boundary of the element\n         */\n        this.bounds = new Rect(0, 0, 0, 0);\n        /**\n         * Defines the appearance of the shadow of the element\n         */\n        this.shadow = null;\n        /**\n         * Defines the description of the diagram element\n         */\n        this.description = '';\n        /**\n         * Defines whether the element has to be measured or not\n         */\n        this.staticSize = false;\n        /**\n         * check whether the element is rect or not\n         */\n        this.isRectElement = false;\n        /** @private */\n        this.isCalculateDesiredSize = true;\n        /**\n         * Set the offset values for container in flipping\n         */\n        /** @private */\n        this.flipOffset = { x: 0, y: 0 };\n        /**\n         * Defines whether the element is group or port\n         */\n        /** @private */\n        this.elementActions = ElementAction.None;\n        /** @private */\n        this.inversedAlignment = true;\n        //private variables\n        this.position = undefined;\n        this.unitMode = undefined;\n        /**   @private  */\n        this.float = false;\n        this.floatingBounds = undefined;\n    }\n    // public constructor() {\n    //     this.id = randomId();\n    // }\n    /**\n     * Sets the offset of the element with respect to its parent \\\n     *\n     * @returns { void }Sets the offset of the element with respect to its parent\\\n     * @param {number} x - provide the x value.\n     * @param {number} y - provide the y value.\n     * @param {UnitMode} mode - provide the id value.\n     *\n     * @private\n     */\n    DiagramElement.prototype.setOffsetWithRespectToBounds = function (x, y, mode) {\n        this.unitMode = mode;\n        this.position = { x: x, y: y };\n    };\n    /**\n     * Gets the position of the element with respect to its parent \\\n     *\n     * @returns { PointModel } Gets the position of the element with respect to its parent\\\n     * @param {Size} size - provide the x value.\n     *\n     * @private\n     */\n    DiagramElement.prototype.getAbsolutePosition = function (size) {\n        if (this.position !== undefined) {\n            if (this.unitMode === 'Absolute') {\n                return this.position;\n            }\n            else {\n                return {\n                    x: this.position.x * size.width, y: this.position.y * size.height\n                };\n            }\n        }\n        return undefined;\n    };\n    Object.defineProperty(DiagramElement.prototype, \"outerBounds\", {\n        get: function () {\n            return this.floatingBounds || this.bounds;\n        },\n        /**\n         * used to set the outer bounds value \\\n         *\n         * @returns { void } used to set the outer bounds value.\\\n         * @param {Rect} bounds - provide the id value.\n         *\n         * @private\n         */\n        set: function (bounds) {\n            this.floatingBounds = bounds;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Measures the minimum space that the element requires \\\n     *\n     * @returns { void } Measures the minimum space that the element requires.\\\n     * @param {Size} availableSize - provide the id value.\n     * @param {Object} obj - provide the id value.\n     * @param {Function} callback - provide the id value.\n     *\n     * @private\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    DiagramElement.prototype.measure = function (availableSize, obj, callback) {\n        var width = this.width !== undefined ? this.width : (availableSize.width || 0) - this.margin.left - this.margin.right;\n        var height = this.height !== undefined ? this.height : (availableSize.height || 0) - this.margin.top - this.margin.bottom;\n        if (this.id) {\n            if (height === 0 && (this.elementActions & ElementAction.HorizontalLaneHeader)) {\n                height = this.actualSize.height;\n            }\n        }\n        this.desiredSize = new Size(width, height);\n        if (this.isCalculateDesiredSize) {\n            this.desiredSize = this.validateDesiredSize(this.desiredSize, availableSize);\n        }\n        return this.desiredSize;\n    };\n    /**\n     * Arranges the element \\\n     *\n     * @returns { PointModel } Arranges the element\\\n     * @param {Size} desiredSize - provide the x value.\n     *\n     * @private\n     */\n    DiagramElement.prototype.arrange = function (desiredSize) {\n        this.actualSize = desiredSize;\n        this.updateBounds();\n        return this.actualSize;\n    };\n    /**\n     * Updates the bounds of the element \\\n     *\n     * @returns { void } Updates the bounds of the element\\\n     *\n     * @private\n     */\n    DiagramElement.prototype.updateBounds = function () {\n        this.bounds = getBounds(this);\n    };\n    /**\n     * Validates the size of the element with respect to its minimum and maximum size \\\n     *\n     * @returns { Size } Validates the size of the element with respect to its minimum and maximum size.\\\n     * @param {Size} desiredSize - provide the id value.\n     * @param {Size} availableSize - provide the id value.\n     *\n     * @private\n     */\n    DiagramElement.prototype.validateDesiredSize = function (desiredSize, availableSize) {\n        //Empty canvas\n        if (this.isRectElement && !this.width && !this.minWidth && !this.maxWidth) {\n            desiredSize.width = 50;\n        }\n        if (this.isRectElement && !this.height && !this.minHeight && !this.maxHeight) {\n            desiredSize.height = 50;\n        }\n        if (desiredSize === undefined || this.width !== undefined &&\n            this.height !== undefined) {\n            desiredSize = desiredSize || new Size();\n            desiredSize.width = this.width === undefined ? (availableSize.width || 0)\n                - this.margin.left - this.margin.right : this.width;\n            desiredSize.height = this.height === undefined ? (availableSize.height || 0)\n                - this.margin.top - this.margin.bottom : this.height;\n        }\n        //Considering min values\n        if (this.minWidth !== undefined) {\n            desiredSize.width = Math.max(desiredSize.width, this.minWidth);\n        }\n        if (this.minHeight !== undefined) {\n            desiredSize.height = Math.max(desiredSize.height, this.minHeight);\n        }\n        //Considering max values\n        if (this.maxWidth !== undefined && this.maxWidth !== 0) {\n            desiredSize.width = Math.min(desiredSize.width, this.maxWidth);\n        }\n        if (this.maxHeight !== undefined && this.maxHeight !== 0) {\n            desiredSize.height = Math.min(desiredSize.height, this.maxHeight);\n        }\n        return desiredSize;\n    };\n    return DiagramElement;\n}());\nexport { DiagramElement };\n"]},"metadata":{},"sourceType":"module"}