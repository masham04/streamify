{"ast":null,"code":"import { OrthogonalSegment } from '../objects/connector';\nimport { Rect } from '../primitives/rect';\nimport { findDistance, findPort, getConnectorDirection, intersect2 } from '../utility/diagram-util';\nimport { randomId } from '../utility/base-util';\nimport { Point } from '../primitives/point';\nimport { PointPort } from '../objects/port';\n/**\n * Line Distribution\n * @private\n */\n\nvar LineDistribution =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the line distribution module\n   * @private\n   */\n  function LineDistribution() {//constructs the line distribution module\n  }\n  /**\n   * To destroy the line distribution module\n   * @returns {void}\n   * @private\n   */\n\n\n  LineDistribution.prototype.destroy = function () {\n    /**\n     * Destroys the line distribution module\n     */\n  };\n  /**\n   * Core method to return the component name.\n   *\n   * @returns {string}  Core method to return the component name.\n   * @private\n   */\n\n\n  LineDistribution.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'LineDistribution';\n  };\n  /** @private */\n\n\n  LineDistribution.prototype.initLineDistribution = function (graph, diagram) {\n    var srcDirection = 'Bottom';\n    this.diagram = diagram;\n\n    if (diagram.layout.connectionPointOrigin === 'DifferentPoint' || diagram.layout.enableRouting) {\n      var tarDirection = 'Top';\n\n      if (graph.orientation === 'BottomToTop') {\n        srcDirection = 'Top';\n        tarDirection = 'Bottom';\n      } else if (graph.orientation === 'RightToLeft') {\n        srcDirection = 'Left';\n        tarDirection = 'Right';\n      } else if (graph.orientation === 'LeftToRight') {\n        srcDirection = 'Right';\n        tarDirection = 'Left';\n      }\n\n      var graphnodes = diagram.nodes;\n\n      if (graphnodes.length > 0) {\n        for (var i = 0; i < graphnodes.length; i++) {\n          var node = diagram.nameTable[graphnodes[i].id];\n          this.addDynamicPortandDistrrbuteLine(graph, node, srcDirection, tarDirection, diagram);\n        }\n      }\n    }\n  };\n\n  LineDistribution.prototype.ObstacleSegment = function (options) {\n    options.direction = getConnectorDirection(options.startpt, options.endpt);\n    options.distance = Point.findLength(options.startpt, options.endpt);\n    options.orientation = options.direction === 'Left' || options.direction === 'Right' ? 'horizontal' : 'vertical'; // eslint-disable-next-line no-self-assign\n\n    options.id = options.id;\n\n    if (options.orientation === 'horizontal') {\n      options.coord = options.startpt.y;\n\n      if (options.direction === 'Left') {\n        options.start = options.endpt.x;\n        options.end = options.startpt.x;\n      } else {\n        options.start = options.startpt.x;\n        options.end = options.endpt.x;\n      }\n    } else {\n      options.coord = options.startpt.x;\n\n      if (options.direction === 'Top') {\n        options.start = options.endpt.y;\n        options.end = options.startpt.y;\n      } else {\n        options.start = options.startpt.y;\n        options.end = options.endpt.y;\n      }\n    }\n\n    return options;\n  };\n  /** @private */\n\n\n  LineDistribution.prototype.distributeLines = function (layout, diagram) {\n    var isHorizontal = layout.orientation === 'LeftToRight' || layout.orientation === 'RightToLeft';\n    var inversespacing = !isHorizontal ? layout.verticalSpacing : layout.horizontalSpacing;\n    var srcdecoratorSize = 8.0;\n    var obstacleCollection = 'obstaclePointCollection';\n    var tardecoratorSize = 10.0;\n    var avaibaleSpace = inversespacing - srcdecoratorSize - tardecoratorSize;\n    var graph = [];\n    var connectorObstacles = [];\n    var globalConnectors = diagram.connectors;\n\n    for (var i = 0; i < globalConnectors.length; i++) {\n      var connector = globalConnectors[i];\n      var pts = [];\n\n      for (var key = 0; key < connector.segments.length; key++) {\n        var seg = connector.segments[key];\n\n        for (var k = 0; k < seg.points.length; k++) {\n          var pt = seg.points[k];\n\n          if (pts.length === 0 || !Point.equals(pt, pts[pts.length - 1])) {\n            pts.push(pt);\n          }\n        }\n      }\n\n      var obssegments = [];\n\n      for (var j = 1; j < pts.length; j++) {\n        var obstacle = this.ObstacleSegment({\n          startpt: pts[j - 1],\n          endpt: pts[j],\n          id: connector.id\n        });\n        obssegments.push(obstacle);\n      }\n\n      var connectorObstacle = {\n        wrapper: connector,\n        segments: obssegments\n      };\n      var segments = [];\n\n      if (!isHorizontal) {\n        for (var key = 0; key < connectorObstacle.segments.length; key++) {\n          var obstacle = connectorObstacle.segments[key];\n\n          if (obstacle.orientation === 'horizontal') {\n            segments.push(obstacle);\n          }\n        }\n      } else {\n        for (var key = 0; key < connectorObstacle.segments.length; key++) {\n          var obstacle = connectorObstacle.segments[key];\n\n          if (obstacle.orientation === 'vertical') {\n            segments.push(obstacle);\n          }\n        }\n      }\n\n      for (var j = 0; j < segments.length; j++) {\n        var obstacleSegment = segments[j];\n\n        if (!this.containsValue(graph, obstacleSegment.coord)) {\n          graph.push({\n            key: obstacleSegment.coord,\n            value: []\n          });\n        }\n\n        var index = void 0;\n\n        for (var k = 0; k < graph.length; k++) {\n          var key = graph[k].key;\n\n          if (Number(key) === obstacleSegment.coord) {\n            index = k;\n            break;\n          }\n        }\n\n        graph[index].value.push(obstacleSegment);\n      }\n\n      connectorObstacles.push(connectorObstacle);\n    }\n\n    var modifiedgrap = [];\n\n    for (var m = 0; m < graph.length; m++) {\n      var row = graph[m];\n      var sortedrow = row.value;\n      sortedrow.sort();\n      var groupby = void 0;\n      groupby = [];\n      var index = 0;\n      var maxEnd = Number.MIN_VALUE;\n      groupby.push([]);\n\n      for (var n = 0; n < sortedrow.length; n++) {\n        var obstacleSegment = sortedrow[n];\n\n        if (!(groupby[index].length > 0) || maxEnd >= obstacleSegment.start) {\n          groupby[index].push(obstacleSegment);\n          maxEnd = Math.max(maxEnd, groupby[index][groupby[index].length - 1].end);\n        } else {\n          index++;\n          groupby.push([]);\n          groupby[index].push(obstacleSegment);\n          maxEnd = groupby[index][groupby[index].length - 1].end;\n        }\n      }\n\n      for (var n = 0; n < groupby.length; n++) {\n        var group = groupby[n];\n        var sortedGroup = [];\n\n        for (var j = 0; j < group.length; j++) {\n          var e = group[j];\n\n          if (e.start) {\n            sortedGroup.push(e);\n          }\n        }\n\n        var comparingDir = isHorizontal ? 'Bottom' : 'Right';\n        var directed = [];\n\n        for (var j = 0; j < sortedGroup.length; j++) {\n          var e = sortedGroup[j];\n\n          if (e.direction === comparingDir) {\n            directed.push(e);\n          }\n        }\n\n        var reversedirected = [];\n\n        for (var j = 0; j < sortedGroup.length; j++) {\n          var e = sortedGroup[j];\n\n          if (e.direction !== comparingDir) {\n            reversedirected.push(e);\n          }\n        }\n\n        var mutual = [];\n\n        if (directed.length > 0) {\n          var temp = directed[0].start;\n          var j = 0;\n\n          while (j < reversedirected.length) {\n            if (reversedirected[j].end > temp) {\n              mutual.push(reversedirected[j]);\n              reversedirected.splice(j, 1);\n            } else {\n              j++;\n            }\n          }\n        }\n\n        var mutualRow = [];\n        mutualRow = this.updateSegmentRow(mutual, mutualRow);\n        var directedRow = [];\n        directedRow = [];\n        directedRow = this.updateSegmentRow(reversedirected, directedRow);\n        directed.reverse();\n        directedRow = this.updateSegmentRow(directed, directedRow);\n\n        if (!(mutualRow[mutualRow.length - 1].length > 0)) {\n          mutualRow.splice(mutualRow.length - 1, 1);\n        }\n\n        if (!(directedRow[directedRow.length - 1].length > 0)) {\n          directedRow.splice(directedRow.length - 1, 1);\n        }\n\n        var subrow = [];\n        var descAdding = mutual.length > 0 && (sortedGroup[0].direction === mutual[0].direction || sortedGroup[sortedGroup.length - 1].direction === mutual[mutual.length - 1].direction);\n\n        if (descAdding) {\n          subrow = directedRow;\n\n          for (var p = 0; p < mutualRow.length; p++) {\n            var obj = mutualRow[p];\n            subrow[subrow.length] = obj;\n          }\n        } else {\n          subrow = mutualRow;\n\n          for (var p = 0; p < directedRow.length; p++) {\n            var obj = directedRow[p];\n            subrow[subrow.length] = obj;\n          }\n        }\n\n        if (subrow.length > 1) {\n          var directionModifier = 1;\n\n          if (layout.orientation === 'BottomToTop' || layout.orientation === 'RightToLeft') {\n            directionModifier = -1;\n          }\n\n          var startCoord = row.key - directionModifier * avaibaleSpace / 2.0;\n          var diff = avaibaleSpace / subrow.length;\n\n          for (var i = 0; i < subrow.length; i++) {\n            var newcoord = startCoord + i * diff * directionModifier;\n\n            for (var p = 0; p < subrow[i].length; p++) {\n              var obstacleSegment = subrow[i][p];\n              obstacleSegment.coord = newcoord;\n\n              if (!this.containsValue(modifiedgrap, obstacleSegment.coord)) {\n                modifiedgrap.push({\n                  key: obstacleSegment.coord,\n                  value: []\n                });\n              }\n\n              var index_1 = void 0;\n\n              for (var k = 0; k < modifiedgrap.length; k++) {\n                var keyCheck = modifiedgrap[k].key;\n\n                if (keyCheck === obstacleSegment.coord) {\n                  index_1 = k;\n                  break;\n                }\n              }\n\n              modifiedgrap[index_1].value.push(obstacleSegment);\n            }\n          }\n        }\n      }\n    }\n\n    for (var m = 0; m < connectorObstacles.length; m++) {\n      var connectorObstacle = connectorObstacles[m];\n      var pts = [];\n\n      for (var i = 0; i < connectorObstacle.segments.length; i++) {\n        if (i === 0) {\n          pts.push(this.getObstacleStartPoint(connectorObstacle.segments[i]));\n        } else if (isHorizontal) {\n          if (connectorObstacle.segments[i].orientation === 'vertical') {\n            pts[pts.length - 1] = this.getObstacleStartPoint(connectorObstacle.segments[i]);\n          }\n        } else if (!isHorizontal) {\n          if (connectorObstacle.segments[i].orientation === 'horizontal') {\n            pts[pts.length - 1] = this.getObstacleStartPoint(connectorObstacle.segments[i]);\n          }\n        }\n\n        pts.push(this.getObstacleEndPoint(connectorObstacle.segments[i]));\n      }\n      /* tslint:disable */\n\n\n      connectorObstacle.wrapper[obstacleCollection] = [];\n\n      for (var j = 0; j < pts.length; j++) {\n        var point = pts[j];\n\n        if (j === 0 || j > 0 && !Point.equals(point, pts[j - 1])) {\n          connectorObstacle.wrapper[obstacleCollection].push(this.getPointvalue(point.x, point.y));\n        }\n      }\n      /* tslint:enable */\n\n\n      this.resetConnectorPoints(connectorObstacle.wrapper, diagram);\n    }\n  };\n\n  LineDistribution.prototype.inflate = function (rect, x, y) {\n    rect.x -= x;\n    rect.y -= y;\n    rect.width += 2 * x;\n    rect.height += 2 * y;\n    return rect;\n  };\n\n  LineDistribution.prototype.updateConnectorPoints = function (connectorPoints, startSegmentSize, intermediatePoint, bounds, orientation) {\n    var layoutBounds = bounds;\n    var isHorizontal = orientation === 'LeftToRight' || orientation === 'RightToLeft';\n    var pts = connectorPoints;\n\n    if (pts.length > 2) {\n      var newPt = Point.transform(pts[0], Point.findAngle(pts[0], pts[1]), startSegmentSize);\n      var nextPt = Point.transform(newPt, Point.findAngle(pts[1], pts[2]), Point.findLength(pts[1], pts[2]));\n      pts.splice(1, 2, newPt, nextPt);\n\n      if (intermediatePoint != null) {\n        var index = 2;\n        var ptsCount = pts.length;\n        var newPt1 = Point.transform(pts[ptsCount - 1], Point.findAngle(pts[ptsCount - 1], pts[ptsCount - 2]), startSegmentSize);\n        pts.splice(ptsCount - 1, 0, newPt1);\n\n        while (index < pts.length - 2) {\n          pts.splice(index, 1);\n        }\n\n        var edgePt = intermediatePoint;\n        this.inflate(layoutBounds, layoutBounds.width, layoutBounds.height);\n        var line1 = [];\n        line1[0] = this.getPointvalue(edgePt.x, layoutBounds.y);\n        line1[1] = this.getPointvalue(edgePt.x, layoutBounds.y + layoutBounds.height);\n        var line2 = [];\n        line2[0] = this.getPointvalue(layoutBounds.x, pts[1].y);\n        line2[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, pts[1].y);\n        var line3 = [];\n        line3[0] = this.getPointvalue(layoutBounds.x, newPt1.y);\n        line3[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, newPt1.y);\n\n        if (isHorizontal) {\n          line1[0] = this.getPointvalue(layoutBounds.x, edgePt.y);\n          line1[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, edgePt.y);\n          line2[0] = this.getPointvalue(pts[1].x, layoutBounds.y);\n          line2[1] = this.getPointvalue(pts[1].x, layoutBounds.y + layoutBounds.height);\n          line3[0] = this.getPointvalue(newPt1.x, layoutBounds.y);\n          line2[1] = this.getPointvalue(newPt1.x, layoutBounds.y + layoutBounds.height);\n        }\n\n        var intercepts1 = [intersect2(line1[0], line1[1], line2[0], line2[1])];\n        var intercepts2 = [intersect2(line1[0], line1[1], line3[0], line3[1])];\n\n        if (intercepts2.length > 0) {\n          pts.splice(2, 0, intercepts2[0]);\n        }\n\n        if (intercepts1.length > 0) {\n          pts.splice(2, 0, intercepts1[0]);\n        }\n      }\n    }\n\n    var i = 1;\n\n    while (i < pts.length - 1) {\n      if (Point.equals(pts[i - 1], pts[i])) {\n        pts.splice(i, 1);\n      } else if (Point.findAngle(pts[i - 1], pts[i]) === Point.findAngle(pts[i], pts[i + 1])) {\n        pts.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    return pts;\n  };\n  /* tslint:disable */\n\n\n  LineDistribution.prototype.resetConnectorPoints = function (edge, diagram) {\n    var obstacleCollection = 'obstaclePointCollection';\n\n    if (edge.segments[0].points && edge.segments[0].points.length > 0 && edge[obstacleCollection]) {\n      var connector = edge;\n      connector.sourcePoint = edge[obstacleCollection][0];\n      connector.targetPoint = edge[obstacleCollection][edge[obstacleCollection].length - 1];\n      var segments = void 0;\n      segments = [];\n\n      for (var i = 0; i < edge[obstacleCollection].length - 1; i++) {\n        var point1 = edge[obstacleCollection][i];\n        var point2 = edge[obstacleCollection][i + 1];\n        var length_1 = findDistance(point1, point2);\n        var direction = getConnectorDirection(point1, point2);\n\n        if (i === edge[obstacleCollection].length - 2) {\n          if (diagram.layout.orientation === 'RightToLeft' && direction === 'Left' || diagram.layout.orientation === 'LeftToRight' && direction === 'Right' || diagram.layout.orientation === 'TopToBottom' && direction === 'Bottom' || diagram.layout.orientation === 'BottomToTop' && direction === 'Top') {\n            length_1 = length_1 / 2;\n          }\n        }\n        /* tslint:enable */\n\n\n        var tempSegment = new OrthogonalSegment(edge, 'segments', {\n          type: 'Orthogonal'\n        }, true);\n        tempSegment.length = length_1;\n        tempSegment.direction = direction;\n        segments.push(tempSegment);\n      }\n\n      connector.segments = segments;\n      connector.type = 'Orthogonal';\n      diagram.connectorPropertyChange(connector, {}, {\n        type: 'Orthogonal',\n        segments: connector.segments\n      });\n    }\n  };\n\n  LineDistribution.prototype.getObstacleEndPoint = function (segment) {\n    if (segment.orientation === 'horizontal') {\n      if (segment.direction === 'Left') {\n        return this.getPointvalue(segment.start, segment.coord);\n      }\n\n      return this.getPointvalue(segment.end, segment.coord);\n    }\n\n    if (segment.direction === 'Top') {\n      return this.getPointvalue(segment.coord, segment.start);\n    }\n\n    return this.getPointvalue(segment.coord, segment.end);\n  };\n\n  LineDistribution.prototype.getObstacleStartPoint = function (segment) {\n    if (segment.orientation === 'horizontal') {\n      if (segment.direction === 'Left') {\n        return this.getPointvalue(segment.end, segment.coord);\n      }\n\n      return this.getPointvalue(segment.start, segment.coord);\n    }\n\n    if (segment.direction === 'Top') {\n      return this.getPointvalue(segment.coord, segment.end);\n    }\n\n    return this.getPointvalue(segment.coord, segment.start);\n  };\n\n  LineDistribution.prototype.updateSegmentRow = function (obstacleSegments, segmentRow) {\n    var k = 0;\n\n    if (!(segmentRow.length > 0)) {\n      segmentRow[0] = [];\n    }\n\n    for (var i = 0; i < obstacleSegments.length; i++) {\n      var obstacleSegment = obstacleSegments[i];\n\n      while (k < segmentRow.length) {\n        if (k === segmentRow.length - 1) {\n          segmentRow[k + 1] = [];\n        }\n\n        if (!(segmentRow[k].length > 0) || segmentRow[k][segmentRow[k].length - 1].end < obstacleSegment.start) {\n          segmentRow[k].push(obstacleSegment);\n          break;\n        }\n\n        k++;\n      }\n    }\n\n    return segmentRow;\n  };\n\n  LineDistribution.prototype.portOffsetCalculation = function (port, length, direction, i) {\n    if (direction === 'Top') {\n      port.offset = {\n        x: (i + 1) * (1.0 / (length + 1)),\n        y: 0\n      };\n    }\n\n    if (direction === 'Bottom') {\n      port.offset = {\n        x: (i + 1) * (1.0 / (length + 1)),\n        y: 1\n      };\n    }\n\n    if (direction === 'Left') {\n      port.offset = {\n        x: 0,\n        y: (i + 1) * (1.0 / (length + 1))\n      };\n    }\n\n    if (direction === 'Right') {\n      port.offset = {\n        x: 1,\n        y: (i + 1) * (1.0 / (length + 1))\n      };\n    }\n  };\n\n  LineDistribution.prototype.addDynamicPortandDistrrbuteLine = function (layout, node, sourceDirection, targetDirection, diagram) {\n    if (node.ports && node.ports.length > 0) {\n      var port = node.ports;\n      diagram.removePorts(node, port);\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    var existingPorts = node.ports;\n    var outConnectors = node.outEdges;\n    var inConnectors = node.inEdges;\n    this.initPort(outConnectors, diagram, node, sourceDirection, false);\n    this.initPort(inConnectors, diagram, node, targetDirection, true);\n  };\n  /* tslint:disable */\n\n\n  LineDistribution.prototype.initPort = function (connectors, diagram, node, targetDirection, inConnectors) {\n    var obstacleCollection = 'obstaclePointCollection';\n\n    for (var i = 0; i <= connectors.length - 1; i++) {\n      var internalConnector = diagram.nameTable[connectors[i]];\n      internalConnector[obstacleCollection] = [];\n      var newPort = findPort(node, inConnectors ? internalConnector.targetPortID : internalConnector.sourcePortID);\n      var direction = targetDirection;\n\n      if (newPort === undefined) {\n        newPort = new PointPort(node, 'ports', '', true);\n        newPort.id = randomId() + '_LineDistribution';\n\n        if (inConnectors) {\n          internalConnector.targetPortID = newPort.id;\n        } else {\n          internalConnector.sourcePortID = newPort.id;\n        }\n      }\n\n      this.portOffsetCalculation(newPort, connectors.length, direction, i);\n      node.ports.push(newPort);\n      var portWrapper = node.initPortWrapper(node.ports[node.ports.length - 1]);\n      node.wrapper.children.push(portWrapper);\n      diagram.connectorPropertyChange(internalConnector, inConnectors ? {\n        targetPortID: ''\n      } : {\n        sourcePortID: ''\n      }, // eslint-disable-next-line\n      inConnectors ? {\n        targetPortID: newPort.id\n      } : {\n        sourcePortID: newPort.id\n      });\n    }\n  };\n  /* tslint:enable */\n\n\n  LineDistribution.prototype.shiftMatrixCells = function (value, startingCell, shiftChildren, parentCell, matrixModel) {\n    if (!(value === 0)) {\n      var matrix = matrixModel.matrix;\n      var matrixRow = matrix[startingCell.level].value;\n      var index = matrixRow.indexOf(startingCell);\n\n      for (var i = index; i < matrixRow.length; i++) {\n        matrixRow[i].offset += value;\n      }\n\n      if (shiftChildren) {\n        if (startingCell.visitedChildren.length > 0) {\n          this.shiftMatrixCells(value, startingCell.visitedChildren[0], true, startingCell, matrixModel);\n        } else {\n          var i = 1;\n          var nextSibilingwithChild = null;\n\n          while (index + i < matrixRow.length) {\n            var nextCell = matrixRow[index + i];\n\n            if (parentCell != null && this.containsValue(nextCell.visitedParents, parentCell)) {\n              if (nextCell.visitedChildren.length > 0) {\n                nextSibilingwithChild = nextCell;\n              } else {\n                i++;\n                continue;\n              }\n            }\n\n            break;\n          }\n\n          if (nextSibilingwithChild != null) {\n            this.shiftMatrixCells(value, nextSibilingwithChild.visitedChildren[0], true, nextSibilingwithChild, matrixModel);\n          }\n        }\n      }\n    }\n  };\n\n  LineDistribution.prototype.arrangeMatrix = function (cell, parent, matrixModel) {\n    var layoutSettings = matrixModel.model.layout;\n    var isHorizontal = layoutSettings.orientation === 'LeftToRight' || layoutSettings.orientation === 'RightToLeft';\n    var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n    var matrix = matrixModel.matrix;\n    var matrixRow = matrix[cell.level].value;\n    var matrixIndex = matrixRow.indexOf(cell);\n\n    if (cell.visitedParents.length > 0) {\n      if (cell.visitedParents.length === 1) {\n        cell.initialOffset = cell.offset;\n      }\n\n      if (matrixIndex + 1 < matrixRow.length) {\n        var nextCell = matrixRow[matrixIndex + 1];\n\n        if (nextCell.visitedParents.length > 0) {\n          if (!this.containsValue(cell.visitedParents, parent)) {\n            cell.visitedParents.push(parent);\n            parent.ignoredChildren.push(cell);\n            return;\n          }\n        }\n      }\n    }\n\n    if (!(cell.children.length > 0)) {\n      var validOffset = cell.offset;\n\n      if (matrixIndex > 0) {\n        var prevCell = matrixRow[matrixIndex - 1];\n        validOffset = prevCell.offset + prevCell.size / 2 + spacing + cell.size / 2;\n      }\n\n      this.shiftMatrixCells(validOffset - cell.offset, cell, false, null, matrixModel);\n    } else {\n      for (var i = 0; i < cell.children.length; i++) {\n        var matrixCellChild = cell.children[i];\n\n        if (!this.containsValue(cell.visitedChildren, matrixCellChild)) {\n          this.arrangeMatrix(matrixCellChild, cell, matrixModel);\n          cell.visitedChildren.push(matrixCellChild);\n        }\n      }\n\n      if (cell.visitedChildren.length > 0) {\n        var children = cell.visitedChildren.slice();\n\n        for (var i = 0; i < cell.ignoredChildren.length; i++) {\n          //let cellIgnoredChild: MatrixCellGroupObject = cell.ignoredChildren[i];\n          children.splice(0, 1);\n          cell.visitedChildren.splice(0, 1);\n        }\n\n        if (children.length > 0) {\n          var firstChild = cell.visitedChildren[0];\n          var lastChild = cell.visitedChildren[cell.visitedChildren.length - 1];\n          var x1 = firstChild.offset - firstChild.size / 2;\n          var x2 = lastChild.offset + lastChild.size / 2;\n          var newoffset = (x1 + x2) / 2;\n\n          if (newoffset < cell.offset) {\n            this.shiftMatrixCells(cell.offset - newoffset, firstChild, true, cell, matrixModel);\n          } else if (newoffset > cell.offset) {\n            this.shiftMatrixCells(newoffset - cell.offset, cell, false, null, matrixModel);\n          }\n        }\n      }\n    }\n\n    if (!this.containsValue(cell.visitedParents, parent)) {\n      cell.visitedParents.push(parent);\n    }\n  };\n\n  LineDistribution.prototype.getFixedTerminalPoint = function () {\n    var pt = null;\n    return pt;\n  };\n\n  LineDistribution.prototype.setAbsoluteTerminalPoint = function (point, isSource, edge) {\n    var absolutePoints = 'absolutePoints';\n\n    if (isSource) {\n      if (edge[absolutePoints] == null) {\n        edge[absolutePoints] = [];\n      }\n\n      if (edge[absolutePoints].length === 0) {\n        edge[absolutePoints].push(point);\n      } else {\n        edge[absolutePoints][0] = point;\n      }\n    } else {\n      if (edge[absolutePoints] == null) {\n        edge[absolutePoints] = [];\n        edge[absolutePoints].push(null);\n        edge[absolutePoints].push(point);\n      } else if (edge[absolutePoints].length === 1) {\n        edge[absolutePoints].push(point);\n      } else {\n        edge[absolutePoints][edge[absolutePoints].length - 1] = point;\n      }\n    }\n  };\n\n  LineDistribution.prototype.updateFixedTerminalPoint = function (edge, source) {\n    this.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(), source, edge);\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  LineDistribution.prototype.updateFixedTerminalPoints = function (connectors, diagram) {\n    this.updateFixedTerminalPoint(connectors, true);\n    this.updateFixedTerminalPoint(connectors, false);\n  };\n\n  LineDistribution.prototype.updatePoints = function (edge, points) {\n    var absolutePoints = 'absolutePoints';\n\n    if (edge != null) {\n      var pts = [];\n      pts.push(edge[absolutePoints][0]);\n\n      for (var i = 0; i < points.length; i++) {\n        if (points[i] != null) {\n          var pt = points[i];\n          pts.push(pt);\n        }\n      }\n\n      var tmp = edge[absolutePoints];\n      pts.push(tmp[tmp.length - 1]);\n      edge[absolutePoints] = pts;\n    }\n  };\n\n  LineDistribution.prototype.updateFloatingTerminalPoint = function (edge, start, end, source) {\n    this.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source, edge);\n  };\n\n  LineDistribution.prototype.getNextPoint = function (edge, opposite, source) {\n    var absolutePoints = 'absolutePoints';\n    var pts = edge[absolutePoints];\n    var point = null;\n\n    if (pts != null && pts.length >= 2) {\n      var count = pts.length;\n      point = pts[source ? Math.min(1, count - 1) : Math.max(0, count - 2)];\n    }\n\n    return point;\n  };\n\n  LineDistribution.prototype.getCenterX = function (start) {\n    if (start.offsetX) {\n      return start.offsetX + start.width;\n    } else {\n      return start.x + start.width;\n    }\n  };\n\n  LineDistribution.prototype.getCenterY = function (start) {\n    if (start.offsetY) {\n      return start.offsetY + start.height;\n    } else {\n      return start.y + start.height;\n    }\n  };\n\n  LineDistribution.prototype.getPerimeterBounds = function (border) {\n    //let newBounds: Rect;\n    var newBounds = border.wrapper.outerBounds;\n    return newBounds;\n  };\n\n  LineDistribution.prototype.getPerimeterFunction = function (bounds, next, orthogonal) {\n    var cx = this.getCenterX(bounds);\n    var cy = this.getCenterY(bounds);\n    var dx = next.x - cx;\n    var dy = next.y - cy;\n    var alpha = Math.atan2(dy, dx);\n    var point = this.getPointvalue(0, 0);\n    var pi = Math.PI;\n    var pi2 = Math.PI / 2;\n    var beta = pi2 - alpha;\n    var t = Math.atan2(bounds.height, bounds.width);\n\n    if (alpha < -pi + t || alpha > pi - t) {\n      // Left edge\n      point.x = bounds.x;\n      point.y = cy - bounds.width * Math.tan(alpha) / 2;\n    } else if (alpha < -t) {\n      // Top Edge\n      point.y = bounds.y;\n      point.x = cx - bounds.height * Math.tan(beta) / 2;\n    } else if (alpha < t) {\n      // Right Edge\n      point.x = bounds.x + bounds.width;\n      point.y = cy + bounds.width * Math.tan(alpha) / 2;\n    } else {\n      // Bottom Edge\n      point.y = bounds.y + bounds.height;\n      point.x = cx + bounds.height * Math.tan(beta) / 2;\n    }\n\n    if (orthogonal) {\n      if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {\n        point.x = next.x;\n      } else if (next.y >= bounds.y && next.y <= bounds.y + bounds.height) {\n        point.y = next.y;\n      }\n\n      if (next.x < bounds.x) {\n        point.x = bounds.x;\n      } else if (next.x > bounds.x + bounds.width) {\n        point.x = bounds.x + bounds.width;\n      }\n\n      if (next.y < bounds.y) {\n        point.y = bounds.y;\n      } else if (next.y > bounds.y + bounds.height) {\n        point.y = bounds.y + bounds.height;\n      }\n    }\n\n    return point;\n  };\n\n  LineDistribution.prototype.getPerimeterPoint = function (terminal, next, orthogonal) {\n    var point = null;\n\n    if (terminal != null) {\n      if (next != null) {\n        var bounds = this.getPerimeterBounds(terminal);\n\n        if (bounds.width > 0 || bounds.height > 0) {\n          point = this.getPointvalue(next.x, next.y);\n          point = this.getPerimeterFunction(bounds, point, orthogonal);\n        }\n      }\n    }\n\n    return point;\n  };\n\n  LineDistribution.prototype.getFloatingTerminalPoint = function (edge, start, end, source) {\n    start = start;\n    var next = this.getNextPoint(edge, end, source);\n    var orth = 1;\n    var alpha = 0;\n    var pt = this.getPerimeterPoint(start, next, alpha === 0 && orth);\n    return pt;\n  };\n\n  LineDistribution.prototype.updateFloatingTerminalPoints = function (state, source, target) {\n    var absolutePoints = 'absolutePoints';\n    var pts = state[absolutePoints];\n    var p0 = pts[0];\n    var pe = pts[pts.length - 1];\n\n    if (pe == null && target != null) {\n      this.updateFloatingTerminalPoint(state, target, source, false);\n    }\n\n    if (p0 == null && source != null) {\n      this.updateFloatingTerminalPoint(state, source, target, true);\n    }\n  };\n\n  LineDistribution.prototype.getConnectorPoints = function (connectors, diagram) {\n    var absolutePoints = 'absolutePoints';\n    var geometry = 'geometry';\n    this.updateFixedTerminalPoints(connectors, diagram);\n    this.updatePoints(connectors, connectors[geometry].points);\n    this.updateFloatingTerminalPoints(connectors, diagram.nameTable[connectors.sourceID], diagram.nameTable[connectors.targetID]);\n    connectors[absolutePoints][0].y = connectors.sourcePoint.y;\n    connectors[absolutePoints][connectors[absolutePoints].length - 1].y = connectors.targetPoint.y;\n  };\n\n  LineDistribution.prototype.adjustSegmentPoints = function (temppoints, points, diagram) {\n    if (diagram.layout.orientation === 'TopToBottom' || diagram.layout.orientation === 'BottomToTop') {\n      temppoints[0].x = points[0].x;\n      temppoints[1].x = points[1].x;\n      temppoints[temppoints.length - 1].x = points[points.length - 1].x;\n      temppoints[temppoints.length - 2].x = points[points.length - 2].x;\n\n      if (diagram.layout.orientation === 'TopToBottom') {\n        temppoints[temppoints.length - 2].y = temppoints[temppoints.length - 1].y - diagram.layout.verticalSpacing / 2;\n        temppoints[1].y = temppoints[0].y + diagram.layout.verticalSpacing / 2;\n      } else {\n        temppoints[1].y = temppoints[0].y - diagram.layout.verticalSpacing / 2;\n        temppoints[temppoints.length - 2].y = temppoints[temppoints.length - 1].y + diagram.layout.verticalSpacing / 2;\n      }\n\n      temppoints[2].y = temppoints[1].y;\n      temppoints[temppoints.length - 3].y = temppoints[temppoints.length - 2].y;\n    }\n\n    if (diagram.layout.orientation === 'RightToLeft' || diagram.layout.orientation === 'LeftToRight') {\n      temppoints[0] = points[0];\n      temppoints[1] = points[1];\n      temppoints[temppoints.length - 1] = points[points.length - 1];\n      temppoints[temppoints.length - 2] = points[points.length - 2];\n\n      if (diagram.layout.orientation === 'RightToLeft') {\n        temppoints[1].x = temppoints[0].x - diagram.layout.verticalSpacing / 2;\n      }\n\n      if (diagram.layout.orientation === 'LeftToRight') {\n        temppoints[1].x = temppoints[0].x + diagram.layout.verticalSpacing / 2;\n      }\n\n      temppoints[2].x = temppoints[1].x;\n\n      if (diagram.layout.orientation === 'RightToLeft') {\n        temppoints[temppoints.length - 2].x = temppoints[temppoints.length - 1].x + diagram.layout.verticalSpacing / 2;\n      }\n\n      if (diagram.layout.orientation === 'LeftToRight') {\n        temppoints[temppoints.length - 2].x = temppoints[temppoints.length - 1].x - diagram.layout.verticalSpacing / 2;\n      }\n\n      temppoints[temppoints.length - 3].x = temppoints[temppoints.length - 2].x;\n    }\n  };\n\n  LineDistribution.prototype.updateConnectorSegmentPoints = function (temppoints, diagram) {\n    if (temppoints.length > 1) {\n      if (diagram.layout.orientation === 'TopToBottom' || diagram.layout.orientation === 'BottomToTop') {\n        for (var i = 1; i < temppoints.length - 1; i = i + 2) {\n          if (temppoints[i].y !== temppoints[i + 1].y && (diagram.layout.orientation === 'TopToBottom' || diagram.layout.orientation === 'BottomToTop')) {\n            temppoints[i + 1].y = temppoints[i].y;\n          }\n        }\n      } else {\n        var check = false;\n\n        for (var i = temppoints.length - 1; i > 1; i = i = i - 2) {\n          if (diagram.layout.orientation === 'RightToLeft' || diagram.layout.orientation === 'LeftToRight') {\n            if (!check) {\n              temppoints[i - 1].x = temppoints[i - 2].x;\n              check = true;\n            } else {\n              temppoints[i - 2].x = temppoints[i - 1].x;\n              check = false;\n            }\n          } else {\n            temppoints[i + 1].x = temppoints[i].x;\n          }\n        }\n      }\n    }\n  };\n\n  LineDistribution.prototype.updateConnectorSegmentPoint = function (connector, diagram) {\n    var absolutePoints = 'absolutePoints';\n    var segments = [];\n\n    for (var i = 0; i < connector[absolutePoints].length - 1; i++) {\n      var point1 = connector[absolutePoints][i];\n      var point2 = connector[absolutePoints][i + 1];\n      var length_2 = findDistance(point1, point2);\n      var direction = getConnectorDirection(point1, point2);\n\n      if (i === connector[absolutePoints].length - 2) {\n        if (diagram.layout.orientation === 'TopToBottom' && direction === 'Bottom' || diagram.layout.orientation === 'RightToLeft' && direction === 'Left' || diagram.layout.orientation === 'LeftToRight' && direction === 'Right' || diagram.layout.orientation === 'BottomToTop' && direction === 'Top') {\n          length_2 = length_2 / 2;\n        }\n      }\n\n      var tempSegment = new OrthogonalSegment(connector, 'segments', {\n        type: 'Orthogonal'\n      }, true);\n      tempSegment.length = length_2;\n      tempSegment.direction = direction;\n      segments.push(tempSegment);\n    }\n\n    connector.segments = segments;\n    connector.type = 'Orthogonal';\n    diagram.connectorPropertyChange(connector, {}, {\n      type: 'Orthogonal',\n      segments: connector.segments\n    });\n  };\n  /** @private */\n\n\n  LineDistribution.prototype.resetConnectorSegments = function (connector) {\n    var segements = connector.segments;\n\n    for (var i = segements.length; i > 1; i--) {\n      segements.splice(i - 1, 1);\n    }\n  };\n  /* tslint:disable */\n\n  /** @private */\n\n\n  LineDistribution.prototype.resetRoutingSegments = function (connector, diagram, points) {\n    if (connector['levelSkip']) {\n      var absolutePoints = 'absolutePoints'; //let temppoints: PointModel[];\n\n      this.getConnectorPoints(connector, diagram);\n      var temppoints = connector[absolutePoints];\n      this.updateConnectorSegmentPoints(temppoints, diagram);\n      this.adjustSegmentPoints(temppoints, points, diagram);\n      this.updateConnectorSegmentPoint(connector, diagram);\n    }\n  };\n  /* tslint:enable */\n\n  /** @private */\n\n\n  LineDistribution.prototype.arrangeElements = function (matrixModel, layout) {\n    var layoutSettings = matrixModel.model.layout;\n    var isHorizontal;\n\n    if (layout.orientation === 'LeftToRight' || layout.orientation === 'RightToLeft') {\n      isHorizontal = true;\n    } else {\n      isHorizontal = false;\n    }\n\n    var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing; //let spacingInverse: number = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n    // Need to group element before\n\n    this.groupLayoutCells(matrixModel);\n    this.createMatrixCells(matrixModel);\n\n    for (var j = 0; j < matrixModel.matrix.length; j++) {\n      var matrixKey = matrixModel.matrix[j].key;\n      var matrixrow = matrixModel.matrix[matrixKey].value;\n\n      for (var i = 1; i < matrixrow.length; i++) {\n        var cell = matrixrow[i];\n        var prevCell = matrixrow[i - 1];\n        cell.offset += prevCell.offset + prevCell.size / 2 + spacing + cell.size / 2;\n      }\n    }\n\n    for (var j = 0; j < matrixModel.matrix[0].value.length; j++) {\n      var root = matrixModel.matrix[0].value[j];\n      this.arrangeMatrix(root, null, matrixModel);\n    }\n\n    for (var k = 0; k < matrixModel.matrix.length; k++) {\n      var row = matrixModel.matrix[k].value;\n\n      for (var i = 0; i < row.length; i++) {\n        var cell = row[i];\n\n        if (cell.visitedParents.length > 1) {\n          var firstParent = cell.visitedParents[0];\n          var lastParent = cell.visitedParents[cell.visitedParents.length - 1];\n          var firstVertexParent = this.findParentVertexCellGroup(firstParent);\n          var lastVertexParent = this.findParentVertexCellGroup(lastParent);\n\n          if (firstParent !== firstVertexParent && firstVertexParent.offset < firstParent.offset) {\n            firstParent = firstVertexParent;\n          }\n\n          if (lastParent !== lastVertexParent && lastVertexParent.offset > lastParent.offset) {\n            lastParent = firstVertexParent;\n          }\n\n          var newoffset = (firstParent.offset + lastParent.offset) / 2;\n          var availOffsetMin = cell.initialOffset;\n          var availOffsetMax = cell.offset;\n\n          if (!(availOffsetMax === availOffsetMin)) {\n            if (newoffset >= availOffsetMin && newoffset <= availOffsetMax) {\n              this.translateMatrixCells(newoffset - cell.offset, cell);\n            } else if (newoffset < availOffsetMin) {\n              this.translateMatrixCells(availOffsetMin - cell.offset, cell);\n            }\n          }\n        }\n      }\n    }\n\n    this.setXYforMatrixCell(matrixModel);\n  };\n\n  LineDistribution.prototype.findParentVertexCellGroup = function (cell) {\n    if (cell.cells[0]) {\n      return cell;\n    }\n\n    if (cell.parents.length > 0) {\n      return this.findParentVertexCellGroup(cell.parents[0]);\n    }\n\n    return cell;\n  };\n\n  LineDistribution.prototype.setXYforMatrixCell = function (matrixModel) {\n    var layoutSettings = matrixModel.model.layout;\n    var isHorizontal = layoutSettings.orientation === 'LeftToRight' || layoutSettings.orientation === 'RightToLeft';\n    var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n\n    for (var i = 0; i < matrixModel.matrix.length; i++) {\n      var matrixrow1 = matrixModel.matrix[i].value;\n\n      for (var j = 0; j < matrixrow1.length; j++) {\n        var matrixCell = matrixrow1[j];\n        var start = matrixCell.offset - matrixCell.size / 2;\n\n        for (var k = 0; k < matrixCell.cells.length; k++) {\n          var cell = matrixCell.cells[k];\n          var type = this.getType(cell.type);\n\n          if (type === 'internalVertex') {\n            var internalVertex = cell;\n            var width = internalVertex.cell.geometry.width;\n            var height = internalVertex.cell.geometry.height;\n\n            if (isHorizontal) {\n              internalVertex.cell.geometry = new Rect(matrixModel.rowOffset[matrixCell.level] - width / 2, start, width, height);\n            } else {\n              internalVertex.cell.geometry = new Rect(start, matrixModel.rowOffset[matrixCell.level] - height / 2, width, height);\n            }\n\n            start += (isHorizontal ? height : width) + spacing;\n          } else if (type === 'internalEdge') {\n            var internalEdges = cell;\n            var parent_1 = matrixCell.visitedParents[0];\n            var isContainSibilingVertex = false;\n\n            if (parent_1) {\n              for (var l = 0; l < parent_1.visitedChildren.length; l++) {\n                var children = parent_1.visitedChildren[l];\n                var cells = [];\n\n                for (var m = 0; m < children.cells.length; m++) {\n                  var cell_1 = children.cells[m];\n                  var type_1 = this.getType(cell_1.type);\n\n                  if (type_1 === 'internalVertex') {\n                    cells.push(cell_1);\n                  }\n                }\n\n                if (cells.length > 0) {\n                  isContainSibilingVertex = true;\n                  break;\n                }\n              }\n            } // Need to updated line width\n\n\n            var lineWidth = 1;\n            var edgeSpacing = 5;\n\n            for (var m = 0; m < internalEdges.edges.length; m++) {\n              var internalConnector = internalEdges.edges[m];\n              var pt = this.getPointvalue(start + lineWidth / 2.0, matrixModel.rowOffset[matrixCell.level]);\n\n              if (isHorizontal) {\n                pt = this.getPointvalue(matrixModel.rowOffset[matrixCell.level], start + lineWidth / 2.0);\n              }\n\n              if (this.containsValue(this.getEdgeMapper(), internalConnector)) {\n                var key = void 0;\n\n                for (var l = 0; l < this.getEdgeMapper().length; l++) {\n                  if (this.getEdgeMapper()[l].key === internalConnector) {\n                    key = l;\n                    break;\n                  }\n                }\n\n                this.getEdgeMapper()[key].value.push(pt);\n              }\n\n              start += lineWidth + edgeSpacing;\n            }\n\n            start += spacing;\n          }\n        }\n      }\n    }\n  };\n\n  LineDistribution.prototype.getEdgeMapper = function () {\n    return this.edgeMapper;\n  };\n  /** @private */\n\n\n  LineDistribution.prototype.setEdgeMapper = function (value) {\n    this.edgeMapper.push(value);\n  };\n\n  LineDistribution.prototype.translateMatrixCells = function (value, cell) {\n    if (!(value === 0)) {\n      cell.offset += value;\n\n      if (cell.visitedChildren.length > 0) {\n        for (var i = 0; i < cell.visitedChildren.length; i++) {\n          var cellVisitedChild = cell.visitedChildren[i];\n          this.translateMatrixCells(value, cellVisitedChild);\n        }\n      }\n    }\n  };\n\n  LineDistribution.prototype.groupLayoutCells = function (matrixModel) {\n    var ranks = matrixModel.model.ranks;\n\n    for (var j = ranks.length - 1; j >= 0; j--) {\n      var vertices = [];\n\n      for (var v = 0; v < ranks[j].length; v++) {\n        var rank = ranks[j][v];\n        var type = this.getType(rank.type);\n\n        if (type === 'internalVertex') {\n          vertices.push(ranks[j][v]);\n        }\n      }\n\n      var edges = [];\n\n      for (var e = 0; e < ranks[j].length; e++) {\n        var rank = ranks[j][e];\n        var type = this.getType(rank.type);\n\n        if (type === 'internalEdge') {\n          edges.push(rank);\n        }\n      }\n\n      while (vertices.length > 1) {\n        var vertex1 = vertices[0];\n        var parentset1 = this.selectIds(vertex1.connectsAsTarget, true);\n        var childset1 = this.selectIds(vertex1.connectsAsSource, false);\n\n        while (vertices.length > 1) {\n          var vertex2 = vertices[1];\n          var parentset2 = this.selectIds(vertex2.connectsAsTarget, true);\n          var childset2 = this.selectIds(vertex2.connectsAsSource, false);\n          var parentequals = this.compareLists(parentset1, parentset2);\n          var childequals = this.compareLists(childset1, childset2);\n\n          if (parentequals && childequals) {\n            this.updateMutualSharing(vertices[0], vertex2.id);\n            this.updateMutualSharing(vertices[1], vertex1.id);\n            vertices.splice(1, 1);\n            continue;\n          }\n\n          break;\n        }\n\n        vertices.splice(0, 1);\n      }\n\n      while (edges.length > 1) {\n        var internalEdge = edges[0];\n        var parentset = internalEdge.source;\n        var childset = internalEdge.target;\n\n        if (parentset.identicalSibiling != null) {\n          var groupedges = [];\n\n          for (var i = 0; i < edges.length; i++) {\n            var edge = edges[i];\n\n            if (edge.target === childset) {\n              groupedges.push(edge);\n            }\n          }\n\n          for (var i = 0; i < groupedges.length; i++) {\n            var internalEdgese = groupedges[i];\n\n            if (this.containsValue(parentset.identicalSibiling, internalEdgese.source.id)) {\n              internalEdgese.source.identicalSibiling = null;\n            }\n          }\n\n          internalEdge.source.identicalSibiling = null;\n        }\n\n        edges.splice(0, 1);\n      }\n    }\n  };\n\n  LineDistribution.prototype.getType = function (type) {\n    if (type === 'internalVertex') {\n      return 'internalVertex';\n    } else {\n      return 'internalEdge';\n    }\n  };\n\n  LineDistribution.prototype.selectIds = function (node, source) {\n    var returnIds = [];\n\n    for (var i = 0; i < node.length; i++) {\n      var connector = node[i];\n\n      if (source) {\n        {\n          returnIds.push(connector.source.id);\n        }\n      } else {\n        returnIds.push(connector.target.id);\n      }\n    }\n\n    return returnIds;\n  };\n\n  LineDistribution.prototype.compareLists = function (list1, list2) {\n    var newList1 = list1.slice();\n    var newList2 = list2.slice();\n\n    if (newList1.length === newList2.length) {\n      if (newList1.length === 0) {\n        return true;\n      } else {\n        var isSame = true;\n\n        for (var i = 0; i < newList2.length; i++) {\n          var o = newList2[i];\n\n          for (var j = i; j < newList1.length; j++) {\n            if (!(newList1[j] === o)) {\n              isSame = false;\n              break;\n            }\n          }\n        }\n\n        return isSame;\n      }\n    }\n\n    return false;\n  };\n\n  LineDistribution.prototype.updateMutualSharing = function (cell, id) {\n    if (cell.identicalSibiling != null) {\n      cell.identicalSibiling.push(id);\n    } else {\n      cell.identicalSibiling = [];\n      cell.identicalSibiling.push(id);\n    }\n  };\n\n  LineDistribution.prototype.matrixCellGroup = function (options) {\n    options.level = options.level;\n    options.parents = options.parents;\n    options.children = options.children;\n    options.visitedChildren = options.visitedChildren;\n    options.visitedParents = options.visitedParents;\n    options.ignoredChildren = options.ignoredChildren;\n    options.cells = options.cells;\n    options.offset = options.offset;\n    options.initialOffset = options.initialOffset;\n    return options;\n  };\n\n  LineDistribution.prototype.getPointvalue = function (x, y) {\n    return {\n      'x': Number(x) || 0,\n      'y': Number(y) || 0\n    };\n  };\n\n  LineDistribution.prototype.containsValue = function (list, keyValue) {\n    for (var i = 0; i < list.length; i++) {\n      if (list[i].key === keyValue || list[i] === keyValue) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /* tslint:disable */\n\n\n  LineDistribution.prototype.createMatrixCells = function (matrixModel) {\n    var layoutSettings = matrixModel.model.layout;\n    var isHorizontal = layoutSettings.orientation === 'LeftToRight' || layoutSettings.orientation === 'RightToLeft';\n    var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n    var spacingInverse = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n    var ranks = matrixModel.model.ranks;\n    var matrixCellMapper = [];\n    var rowoffset = -spacingInverse;\n\n    for (var j = ranks.length - 1; j >= 0; j--) {\n      var maxDimension = 0.0;\n      var index = ranks.length - 1 - j;\n      var rank = ranks[j].slice(); //.ToList();\n      // Creating new row and adding it to matrix\n\n      var matrixRow = [];\n      matrixModel.matrix.push({\n        key: index,\n        value: matrixRow\n      }); // Creating new row mapper\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var tempMatrixRow = [];\n      matrixCellMapper.push({\n        index: index,\n        value: tempMatrixRow\n      });\n\n      while (rank.length > 0) //.Any())\n      {\n        var layoutCell = rank[0]; // eslint-disable-next-line max-len\n\n        var matrixCell = this.matrixCellGroup({\n          level: index,\n          parents: [],\n          children: [],\n          visitedParents: [],\n          visitedChildren: [],\n          ignoredChildren: [],\n          cells: [],\n          size: 0,\n          offset: 0,\n          initialOffset: 0\n        });\n        matrixRow.push(matrixCell);\n        var type = this.getType(layoutCell.type);\n\n        if (type === 'internalVertex') {\n          matrixCell.cells.push(layoutCell);\n\n          if (layoutCell.identicalSibiling != null) {\n            for (var i = 0; i < rank.length; i++) {\n              var internalVertex = rank[i];\n              var type_2 = this.getType(internalVertex.type);\n\n              if (type_2 === 'internalVertex' && this.containsValue(layoutCell.identicalSibiling, internalVertex.id)) {\n                matrixCell.cells.push(internalVertex);\n\n                if (matrixCell.cells.length > layoutCell.identicalSibiling.length) {\n                  break;\n                }\n              }\n            }\n          }\n\n          for (var i = 0; i < matrixCell.cells.length; i++) {\n            var internalVertex = matrixCell.cells[i];\n            var type_3 = this.getType(internalVertex.type);\n\n            if (type_3 === 'internalVertex') {\n              var geometry = internalVertex.cell.geometry;\n              matrixCell.size += isHorizontal ? geometry.height : geometry.width;\n              maxDimension = Math.max(maxDimension, !isHorizontal ? geometry.height : geometry.width);\n              tempMatrixRow.push({\n                key: internalVertex.id,\n                value: matrixCell\n              });\n\n              if (internalVertex.connectsAsTarget.length > 0) {\n                for (var k = 0; k < internalVertex.connectsAsTarget.length; k++) {\n                  var internalEdgese = internalVertex.connectsAsTarget[k];\n                  var key = null;\n\n                  if (this.containsValue(matrixCellMapper[index - 1].value, internalEdgese.ids)) {\n                    key = internalEdgese.ids;\n                  } else if (this.containsValue(matrixCellMapper[index - 1].value, internalEdgese.source.id)) {\n                    key = internalEdgese.source.id;\n                  }\n\n                  if (key != null) {\n                    var parentcellValue = matrixCellMapper[index - 1].value;\n                    var parentMartixCell = void 0;\n\n                    for (var v = 0; v < parentcellValue.length; v++) {\n                      if (parentcellValue[v].key === key) {\n                        parentMartixCell = parentcellValue[v].value;\n                        break;\n                      }\n                    }\n\n                    if (!this.containsValue(matrixCell.parents, parentMartixCell)) {\n                      matrixCell.parents.push(parentMartixCell);\n                    }\n\n                    if (!this.containsValue(parentMartixCell.children, matrixCell)) {\n                      parentMartixCell.children.push(matrixCell);\n                    }\n                  }\n                }\n              }\n\n              rank.reverse();\n              rank.pop();\n              rank.reverse();\n            }\n          }\n\n          matrixCell.size += (matrixCell.cells.length - 1) * spacing;\n        } else if (type === 'internalEdge') {\n          matrixCell.cells.push(layoutCell);\n\n          for (var i = 0; i < matrixCell.cells.length; i++) {\n            var internalEdge = matrixCell.cells[i];\n            var type1 = this.getType(internalEdge.type);\n\n            if (type1 === 'internalEdge' && internalEdge.edges != null) {\n              // need to spacing based on its source and target Node\n              var edgeSpacing = 5;\n              var cellSize = -edgeSpacing;\n\n              for (var k = 0; k < internalEdge.edges.length; k++) {\n                //const internalConnector = internalEdge.edges[k];\n                // need to summ up the line width\n                cellSize += 1 + edgeSpacing;\n              }\n\n              matrixCell.size += cellSize;\n            }\n\n            tempMatrixRow.push({\n              key: internalEdge.ids,\n              value: matrixCell\n            });\n            var key = null;\n\n            if (this.containsValue(matrixCellMapper[index - 1].value, internalEdge.ids)) {\n              key = internalEdge.ids;\n            } else if (this.containsValue(matrixCellMapper[index - 1].value, internalEdge.source.id)) {\n              key = internalEdge.source.id;\n            }\n\n            if (key != null) {\n              var parentcell = matrixCellMapper[index - 1].value;\n              var parentMartixCell = void 0;\n\n              for (var v = 0; v < parentcell.length; v++) {\n                if (parentcell[v].key === key) {\n                  parentMartixCell = parentcell[v].value;\n                  break;\n                }\n              }\n\n              if (!this.containsValue(matrixCell.parents, parentMartixCell)) {\n                matrixCell.parents.push(parentMartixCell);\n              }\n\n              if (!this.containsValue(parentMartixCell.children, matrixCell)) {\n                parentMartixCell.children.push(matrixCell);\n              }\n            }\n\n            rank.reverse();\n            rank.pop();\n            rank.reverse();\n          }\n\n          matrixCell.size += (matrixCell.cells.length - 1) * spacing;\n        }\n      }\n\n      matrixModel.rowOffset.push(rowoffset + maxDimension / 2 + spacingInverse);\n      rowoffset += maxDimension + spacingInverse;\n    }\n  };\n  /* eslint-disable */\n\n  /** @private */\n\n\n  LineDistribution.prototype.updateLayout = function (viewPort, modelBounds, layoutProp, layout, nodeWithMultiEdges, nameTable) {\n    {\n      var trnsX = (viewPort.x - modelBounds.width) / 2 - modelBounds.x;\n      var trnsY = (viewPort.y - modelBounds.height) / 2 - modelBounds.y;\n      trnsX = Math.round(trnsX);\n      trnsY = Math.round(trnsY);\n      var modifiedConnectors = [];\n      var transModelBounds = new Rect(modelBounds.x + trnsX, modelBounds.y + trnsY, modelBounds.width, modelBounds.height);\n      var margin = layoutProp.margin;\n      var isHorizontal = layout.orientation === 'RightToLeft' || layout.orientation === 'LeftToRight';\n      var inversespacing = !isHorizontal ? layout.verticalSpacing : layout.horizontalSpacing;\n\n      for (var i = 0; i < nodeWithMultiEdges.length; i++) {\n        var node = nodeWithMultiEdges[i];\n\n        if (node.outEdges != null && node.outEdges.length > 0) {\n          var count = node.outEdges.length;\n\n          for (var j = 0; j < count; j++) {\n            var internalConnector = nameTable[node.outEdges[j]];\n            internalConnector['pointCollection'] = [];\n\n            if (count > 1) {\n              var segmentsize = inversespacing / 2.0;\n              var intermediatePoint = null;\n              var key = void 0;\n              var edgeMapper = this.getEdgeMapper();\n\n              for (var k = 0; k < edgeMapper.length; k++) {\n                if (edgeMapper[k].key === internalConnector) {\n                  key = k;\n                  break;\n                }\n              }\n\n              if (edgeMapper[key].value.length > 0) {\n                var edgePoint = edgeMapper[key].value[0];\n                var dxValue1 = edgePoint.x + margin.left;\n                var dyValue1 = edgePoint.y + margin.top;\n                var x1 = dxValue1;\n                var y1 = dyValue1;\n\n                if (layout.orientation === 'BottomToTop') {\n                  y1 = modelBounds.height - dyValue1;\n                } else if (layout.orientation === 'RightToLeft') {\n                  x1 = modelBounds.width - dxValue1;\n                }\n\n                x1 += trnsX;\n                y1 += trnsY;\n                intermediatePoint = this.getPointvalue(x1, y1);\n              }\n\n              var pts = [];\n\n              for (var i_1 = 0; i_1 < internalConnector.segments.length; i_1++) {\n                var pt = internalConnector.segments[i_1].points; // eslint-disable-next-line guard-for-in\n\n                for (var temp in pt) {\n                  pts.push(pt[temp]);\n                }\n              } // eslint-disable-next-line max-len\n\n\n              pts = this.updateConnectorPoints(pts, segmentsize, intermediatePoint, transModelBounds, layout.orientation);\n\n              for (var p = 0; p < pts.length; p++) {\n                var pt = pts[p];\n                internalConnector['pointCollection'].push(this.getPointvalue(pt.x, pt.y));\n              }\n\n              this.resetConnectorPoints(internalConnector, this.diagram);\n            }\n\n            modifiedConnectors.push(internalConnector);\n          }\n        }\n\n        if (node.inEdges != null && node.inEdges.length > 1) {\n          var count = node.inEdges.length;\n          var edgeMapper = this.getEdgeMapper();\n\n          for (var j = 0; j < count; j++) {\n            var internalConnector = nameTable[node.inEdges[j]];\n\n            if (!this.containsValue(modifiedConnectors, internalConnector)) {\n              internalConnector['pointCollection'] = [];\n            }\n\n            if (count > 1) {\n              var segmentsize = inversespacing / 2.0;\n              var intermediatePoint = null;\n              var key = void 0;\n              var k = void 0;\n\n              for (k = 0; k < edgeMapper.length; k++) {\n                if (edgeMapper[k].key === internalConnector) {\n                  key = k;\n                  break;\n                }\n              }\n\n              if (edgeMapper[key].value.length > 0 && !this.containsValue(modifiedConnectors, internalConnector)) {\n                var edgePt = edgeMapper[k].value[0];\n                var dx1 = edgePt.x + margin.left;\n                var dy1 = edgePt.y + margin.top; // eslint-disable-next-line one-var\n\n                var x1 = dx1,\n                    y1 = dy1;\n\n                if (layout.orientation === 'BottomToTop') {\n                  y1 = modelBounds.height - dy1;\n                } else if (layout.orientation === 'RightToLeft') {\n                  x1 = modelBounds.width - dx1;\n                }\n\n                x1 += trnsX;\n                y1 += trnsY;\n                intermediatePoint = this.getPointvalue(x1, y1);\n              }\n\n              var pts = [];\n\n              for (var p = 0; p < internalConnector.segments.length; p++) {\n                var pt = internalConnector.segments[p].points; // eslint-disable-next-line guard-for-in\n\n                for (var temp in pt) {\n                  pts.push(pt[temp]);\n                }\n              }\n\n              pts.reverse(); // eslint-disable-next-line\n\n              pts = this.updateConnectorPoints(pts, segmentsize, intermediatePoint, transModelBounds, layoutProp.orientation);\n              pts.reverse();\n              internalConnector['pointCollection'] = [];\n\n              for (var p = 0; p < pts.length; p++) {\n                var pt = pts[p];\n                internalConnector['pointCollection'].push(this.getPointvalue(pt.x, pt.y));\n              }\n\n              this.resetConnectorPoints(internalConnector, this.diagram);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  return LineDistribution;\n}();\n\nexport { LineDistribution };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-distribution.js"],"names":["OrthogonalSegment","Rect","findDistance","findPort","getConnectorDirection","intersect2","randomId","Point","PointPort","LineDistribution","prototype","destroy","getModuleName","initLineDistribution","graph","diagram","srcDirection","layout","connectionPointOrigin","enableRouting","tarDirection","orientation","graphnodes","nodes","length","i","node","nameTable","id","addDynamicPortandDistrrbuteLine","ObstacleSegment","options","direction","startpt","endpt","distance","findLength","coord","y","start","x","end","distributeLines","isHorizontal","inversespacing","verticalSpacing","horizontalSpacing","srcdecoratorSize","obstacleCollection","tardecoratorSize","avaibaleSpace","connectorObstacles","globalConnectors","connectors","connector","pts","key","segments","seg","k","points","pt","equals","push","obssegments","j","obstacle","connectorObstacle","wrapper","obstacleSegment","containsValue","value","index","Number","modifiedgrap","m","row","sortedrow","sort","groupby","maxEnd","MIN_VALUE","n","Math","max","group","sortedGroup","e","comparingDir","directed","reversedirected","mutual","temp","splice","mutualRow","updateSegmentRow","directedRow","reverse","subrow","descAdding","p","obj","directionModifier","startCoord","diff","newcoord","index_1","keyCheck","getObstacleStartPoint","getObstacleEndPoint","point","getPointvalue","resetConnectorPoints","inflate","rect","width","height","updateConnectorPoints","connectorPoints","startSegmentSize","intermediatePoint","bounds","layoutBounds","newPt","transform","findAngle","nextPt","ptsCount","newPt1","edgePt","line1","line2","line3","intercepts1","intercepts2","edge","sourcePoint","targetPoint","point1","point2","length_1","tempSegment","type","connectorPropertyChange","segment","obstacleSegments","segmentRow","portOffsetCalculation","port","offset","sourceDirection","targetDirection","ports","removePorts","existingPorts","outConnectors","outEdges","inConnectors","inEdges","initPort","internalConnector","newPort","targetPortID","sourcePortID","undefined","portWrapper","initPortWrapper","children","shiftMatrixCells","startingCell","shiftChildren","parentCell","matrixModel","matrix","matrixRow","level","indexOf","visitedChildren","nextSibilingwithChild","nextCell","visitedParents","arrangeMatrix","cell","parent","layoutSettings","model","spacing","matrixIndex","initialOffset","ignoredChildren","validOffset","prevCell","size","matrixCellChild","slice","firstChild","lastChild","x1","x2","newoffset","getFixedTerminalPoint","setAbsoluteTerminalPoint","isSource","absolutePoints","updateFixedTerminalPoint","source","updateFixedTerminalPoints","updatePoints","tmp","updateFloatingTerminalPoint","getFloatingTerminalPoint","getNextPoint","opposite","count","min","getCenterX","offsetX","getCenterY","offsetY","getPerimeterBounds","border","newBounds","outerBounds","getPerimeterFunction","next","orthogonal","cx","cy","dx","dy","alpha","atan2","pi","PI","pi2","beta","t","tan","getPerimeterPoint","terminal","orth","updateFloatingTerminalPoints","state","target","p0","pe","getConnectorPoints","geometry","sourceID","targetID","adjustSegmentPoints","temppoints","updateConnectorSegmentPoints","check","updateConnectorSegmentPoint","length_2","resetConnectorSegments","segements","resetRoutingSegments","arrangeElements","groupLayoutCells","createMatrixCells","matrixKey","matrixrow","root","firstParent","lastParent","firstVertexParent","findParentVertexCellGroup","lastVertexParent","availOffsetMin","availOffsetMax","translateMatrixCells","setXYforMatrixCell","cells","parents","matrixrow1","matrixCell","getType","internalVertex","rowOffset","internalEdges","parent_1","isContainSibilingVertex","l","cell_1","type_1","lineWidth","edgeSpacing","edges","getEdgeMapper","edgeMapper","setEdgeMapper","cellVisitedChild","ranks","vertices","v","rank","vertex1","parentset1","selectIds","connectsAsTarget","childset1","connectsAsSource","vertex2","parentset2","childset2","parentequals","compareLists","childequals","updateMutualSharing","internalEdge","parentset","childset","identicalSibiling","groupedges","internalEdgese","returnIds","list1","list2","newList1","newList2","isSame","o","matrixCellGroup","list","keyValue","spacingInverse","matrixCellMapper","rowoffset","maxDimension","tempMatrixRow","layoutCell","type_2","type_3","ids","parentcellValue","parentMartixCell","pop","type1","cellSize","parentcell","updateLayout","viewPort","modelBounds","layoutProp","nodeWithMultiEdges","trnsX","trnsY","round","modifiedConnectors","transModelBounds","margin","segmentsize","edgePoint","dxValue1","left","dyValue1","top","y1","i_1","dx1","dy1"],"mappings":"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","sourcesContent":["import { OrthogonalSegment } from '../objects/connector';\nimport { Rect } from '../primitives/rect';\nimport { findDistance, findPort, getConnectorDirection, intersect2 } from '../utility/diagram-util';\nimport { randomId } from '../utility/base-util';\nimport { Point } from '../primitives/point';\nimport { PointPort } from '../objects/port';\n/**\n * Line Distribution\n * @private\n */\nvar LineDistribution = /** @class */ (function () {\n    /**\n     * Constructor for the line distribution module\n     * @private\n     */\n    function LineDistribution() {\n        //constructs the line distribution module\n    }\n    /**\n     * To destroy the line distribution module\n     * @returns {void}\n     * @private\n     */\n    LineDistribution.prototype.destroy = function () {\n        /**\n         * Destroys the line distribution module\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    LineDistribution.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'LineDistribution';\n    };\n    /** @private */\n    LineDistribution.prototype.initLineDistribution = function (graph, diagram) {\n        var srcDirection = 'Bottom';\n        this.diagram = diagram;\n        if (diagram.layout.connectionPointOrigin === 'DifferentPoint' || diagram.layout.enableRouting) {\n            var tarDirection = 'Top';\n            if (graph.orientation === 'BottomToTop') {\n                srcDirection = 'Top';\n                tarDirection = 'Bottom';\n            }\n            else if (graph.orientation === 'RightToLeft') {\n                srcDirection = 'Left';\n                tarDirection = 'Right';\n            }\n            else if (graph.orientation === 'LeftToRight') {\n                srcDirection = 'Right';\n                tarDirection = 'Left';\n            }\n            var graphnodes = diagram.nodes;\n            if (graphnodes.length > 0) {\n                for (var i = 0; i < graphnodes.length; i++) {\n                    var node = diagram.nameTable[graphnodes[i].id];\n                    this.addDynamicPortandDistrrbuteLine(graph, node, srcDirection, tarDirection, diagram);\n                }\n            }\n        }\n    };\n    LineDistribution.prototype.ObstacleSegment = function (options) {\n        options.direction = getConnectorDirection(options.startpt, options.endpt);\n        options.distance = Point.findLength(options.startpt, options.endpt);\n        options.orientation = options.direction === 'Left' || options.direction === 'Right' ? 'horizontal' : 'vertical';\n        // eslint-disable-next-line no-self-assign\n        options.id = options.id;\n        if (options.orientation === 'horizontal') {\n            options.coord = options.startpt.y;\n            if (options.direction === 'Left') {\n                options.start = options.endpt.x;\n                options.end = options.startpt.x;\n            }\n            else {\n                options.start = options.startpt.x;\n                options.end = options.endpt.x;\n            }\n        }\n        else {\n            options.coord = options.startpt.x;\n            if (options.direction === 'Top') {\n                options.start = options.endpt.y;\n                options.end = options.startpt.y;\n            }\n            else {\n                options.start = options.startpt.y;\n                options.end = options.endpt.y;\n            }\n        }\n        return options;\n    };\n    /** @private */\n    LineDistribution.prototype.distributeLines = function (layout, diagram) {\n        var isHorizontal = layout.orientation === 'LeftToRight'\n            || layout.orientation === 'RightToLeft';\n        var inversespacing = !isHorizontal ? layout.verticalSpacing : layout.horizontalSpacing;\n        var srcdecoratorSize = 8.0;\n        var obstacleCollection = 'obstaclePointCollection';\n        var tardecoratorSize = 10.0;\n        var avaibaleSpace = inversespacing - srcdecoratorSize - tardecoratorSize;\n        var graph = [];\n        var connectorObstacles = [];\n        var globalConnectors = diagram.connectors;\n        for (var i = 0; i < globalConnectors.length; i++) {\n            var connector = globalConnectors[i];\n            var pts = [];\n            for (var key = 0; key < connector.segments.length; key++) {\n                var seg = connector.segments[key];\n                for (var k = 0; k < seg.points.length; k++) {\n                    var pt = seg.points[k];\n                    if (pts.length === 0 || !(Point.equals(pt, pts[pts.length - 1]))) {\n                        pts.push(pt);\n                    }\n                }\n            }\n            var obssegments = [];\n            for (var j = 1; j < pts.length; j++) {\n                var obstacle = this.ObstacleSegment({ startpt: pts[j - 1], endpt: pts[j], id: connector.id });\n                obssegments.push(obstacle);\n            }\n            var connectorObstacle = { wrapper: connector, segments: obssegments };\n            var segments = [];\n            if (!isHorizontal) {\n                for (var key = 0; key < connectorObstacle.segments.length; key++) {\n                    var obstacle = connectorObstacle.segments[key];\n                    if (obstacle.orientation === 'horizontal') {\n                        segments.push(obstacle);\n                    }\n                }\n            }\n            else {\n                for (var key = 0; key < connectorObstacle.segments.length; key++) {\n                    var obstacle = connectorObstacle.segments[key];\n                    if (obstacle.orientation === 'vertical') {\n                        segments.push(obstacle);\n                    }\n                }\n            }\n            for (var j = 0; j < segments.length; j++) {\n                var obstacleSegment = segments[j];\n                if (!this.containsValue(graph, obstacleSegment.coord)) {\n                    graph.push({ key: obstacleSegment.coord, value: [] });\n                }\n                var index = void 0;\n                for (var k = 0; k < graph.length; k++) {\n                    var key = graph[k].key;\n                    if (Number(key) === obstacleSegment.coord) {\n                        index = k;\n                        break;\n                    }\n                }\n                graph[index].value.push(obstacleSegment);\n            }\n            connectorObstacles.push(connectorObstacle);\n        }\n        var modifiedgrap = [];\n        for (var m = 0; m < graph.length; m++) {\n            var row = graph[m];\n            var sortedrow = row.value;\n            sortedrow.sort();\n            var groupby = void 0;\n            groupby = [];\n            var index = 0;\n            var maxEnd = Number.MIN_VALUE;\n            groupby.push([]);\n            for (var n = 0; n < sortedrow.length; n++) {\n                var obstacleSegment = sortedrow[n];\n                if (!(groupby[index].length > 0) || maxEnd >= obstacleSegment.start) {\n                    groupby[index].push(obstacleSegment);\n                    maxEnd = Math.max(maxEnd, groupby[index][groupby[index].length - 1].end);\n                }\n                else {\n                    index++;\n                    groupby.push([]);\n                    groupby[index].push(obstacleSegment);\n                    maxEnd = groupby[index][groupby[index].length - 1].end;\n                }\n            }\n            for (var n = 0; n < groupby.length; n++) {\n                var group = groupby[n];\n                var sortedGroup = [];\n                for (var j = 0; j < group.length; j++) {\n                    var e = group[j];\n                    if (e.start) {\n                        sortedGroup.push(e);\n                    }\n                }\n                var comparingDir = isHorizontal ? 'Bottom' : 'Right';\n                var directed = [];\n                for (var j = 0; j < sortedGroup.length; j++) {\n                    var e = sortedGroup[j];\n                    if (e.direction === comparingDir) {\n                        directed.push(e);\n                    }\n                }\n                var reversedirected = [];\n                for (var j = 0; j < sortedGroup.length; j++) {\n                    var e = sortedGroup[j];\n                    if (e.direction !== comparingDir) {\n                        reversedirected.push(e);\n                    }\n                }\n                var mutual = [];\n                if (directed.length > 0) {\n                    var temp = directed[0].start;\n                    var j = 0;\n                    while (j < reversedirected.length) {\n                        if (reversedirected[j].end > temp) {\n                            mutual.push(reversedirected[j]);\n                            reversedirected.splice(j, 1);\n                        }\n                        else {\n                            j++;\n                        }\n                    }\n                }\n                var mutualRow = [];\n                mutualRow = this.updateSegmentRow(mutual, mutualRow);\n                var directedRow = [];\n                directedRow = [];\n                directedRow = this.updateSegmentRow(reversedirected, directedRow);\n                directed.reverse();\n                directedRow = this.updateSegmentRow(directed, directedRow);\n                if (!(mutualRow[mutualRow.length - 1].length > 0)) {\n                    mutualRow.splice(mutualRow.length - 1, 1);\n                }\n                if (!(directedRow[directedRow.length - 1].length > 0)) {\n                    directedRow.splice(directedRow.length - 1, 1);\n                }\n                var subrow = [];\n                var descAdding = mutual.length > 0 && (sortedGroup[0].direction === mutual[0].direction\n                    || sortedGroup[sortedGroup.length - 1].direction === mutual[mutual.length - 1].direction);\n                if (descAdding) {\n                    subrow = directedRow;\n                    for (var p = 0; p < mutualRow.length; p++) {\n                        var obj = mutualRow[p];\n                        subrow[subrow.length] = obj;\n                    }\n                }\n                else {\n                    subrow = mutualRow;\n                    for (var p = 0; p < directedRow.length; p++) {\n                        var obj = directedRow[p];\n                        subrow[subrow.length] = obj;\n                    }\n                }\n                if (subrow.length > 1) {\n                    var directionModifier = 1;\n                    if (layout.orientation === 'BottomToTop'\n                        || layout.orientation === 'RightToLeft') {\n                        directionModifier = -1;\n                    }\n                    var startCoord = row.key - (directionModifier * avaibaleSpace / 2.0);\n                    var diff = avaibaleSpace / subrow.length;\n                    for (var i = 0; i < subrow.length; i++) {\n                        var newcoord = startCoord + (i * diff * directionModifier);\n                        for (var p = 0; p < subrow[i].length; p++) {\n                            var obstacleSegment = subrow[i][p];\n                            obstacleSegment.coord = newcoord;\n                            if (!this.containsValue(modifiedgrap, obstacleSegment.coord)) {\n                                modifiedgrap.push({ key: obstacleSegment.coord, value: [] });\n                            }\n                            var index_1 = void 0;\n                            for (var k = 0; k < modifiedgrap.length; k++) {\n                                var keyCheck = modifiedgrap[k].key;\n                                if (keyCheck === obstacleSegment.coord) {\n                                    index_1 = k;\n                                    break;\n                                }\n                            }\n                            modifiedgrap[index_1].value.push(obstacleSegment);\n                        }\n                    }\n                }\n            }\n        }\n        for (var m = 0; m < connectorObstacles.length; m++) {\n            var connectorObstacle = connectorObstacles[m];\n            var pts = [];\n            for (var i = 0; i < connectorObstacle.segments.length; i++) {\n                if (i === 0) {\n                    pts.push(this.getObstacleStartPoint(connectorObstacle.segments[i]));\n                }\n                else if (isHorizontal) {\n                    if (connectorObstacle.segments[i].orientation === 'vertical') {\n                        pts[pts.length - 1] = this.getObstacleStartPoint(connectorObstacle.segments[i]);\n                    }\n                }\n                else if (!isHorizontal) {\n                    if (connectorObstacle.segments[i].orientation === 'horizontal') {\n                        pts[pts.length - 1] = this.getObstacleStartPoint(connectorObstacle.segments[i]);\n                    }\n                }\n                pts.push(this.getObstacleEndPoint(connectorObstacle.segments[i]));\n            }\n            /* tslint:disable */\n            connectorObstacle.wrapper[obstacleCollection] = [];\n            for (var j = 0; j < pts.length; j++) {\n                var point = pts[j];\n                if (j === 0 || (j > 0 && !(Point.equals(point, pts[j - 1])))) {\n                    connectorObstacle.wrapper[obstacleCollection].push(this.getPointvalue(point.x, point.y));\n                }\n            }\n            /* tslint:enable */\n            this.resetConnectorPoints(connectorObstacle.wrapper, diagram);\n        }\n    };\n    LineDistribution.prototype.inflate = function (rect, x, y) {\n        rect.x -= x;\n        rect.y -= y;\n        rect.width += 2 * x;\n        rect.height += 2 * y;\n        return rect;\n    };\n    LineDistribution.prototype.updateConnectorPoints = function (connectorPoints, startSegmentSize, intermediatePoint, bounds, orientation) {\n        var layoutBounds = bounds;\n        var isHorizontal = orientation === 'LeftToRight' || orientation === 'RightToLeft';\n        var pts = connectorPoints;\n        if (pts.length > 2) {\n            var newPt = Point.transform(pts[0], Point.findAngle(pts[0], pts[1]), startSegmentSize);\n            var nextPt = Point.transform(newPt, Point.findAngle(pts[1], pts[2]), Point.findLength(pts[1], pts[2]));\n            pts.splice(1, 2, newPt, nextPt);\n            if (intermediatePoint != null) {\n                var index = 2;\n                var ptsCount = pts.length;\n                var newPt1 = Point.transform(pts[ptsCount - 1], Point.findAngle(pts[ptsCount - 1], pts[ptsCount - 2]), startSegmentSize);\n                pts.splice(ptsCount - 1, 0, newPt1);\n                while (index < (pts.length - 2)) {\n                    pts.splice(index, 1);\n                }\n                var edgePt = intermediatePoint;\n                this.inflate(layoutBounds, layoutBounds.width, layoutBounds.height);\n                var line1 = [];\n                line1[0] = this.getPointvalue(edgePt.x, layoutBounds.y);\n                line1[1] = this.getPointvalue(edgePt.x, layoutBounds.y + layoutBounds.height);\n                var line2 = [];\n                line2[0] = this.getPointvalue(layoutBounds.x, pts[1].y);\n                line2[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, pts[1].y);\n                var line3 = [];\n                line3[0] = this.getPointvalue(layoutBounds.x, newPt1.y);\n                line3[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, newPt1.y);\n                if (isHorizontal) {\n                    line1[0] = this.getPointvalue(layoutBounds.x, edgePt.y);\n                    line1[1] = this.getPointvalue(layoutBounds.x + layoutBounds.width, edgePt.y);\n                    line2[0] = this.getPointvalue(pts[1].x, layoutBounds.y);\n                    line2[1] = this.getPointvalue(pts[1].x, layoutBounds.y + layoutBounds.height);\n                    line3[0] = this.getPointvalue(newPt1.x, layoutBounds.y);\n                    line2[1] = this.getPointvalue(newPt1.x, layoutBounds.y + layoutBounds.height);\n                }\n                var intercepts1 = [intersect2(line1[0], line1[1], line2[0], line2[1])];\n                var intercepts2 = [intersect2(line1[0], line1[1], line3[0], line3[1])];\n                if (intercepts2.length > 0) {\n                    pts.splice(2, 0, intercepts2[0]);\n                }\n                if (intercepts1.length > 0) {\n                    pts.splice(2, 0, intercepts1[0]);\n                }\n            }\n        }\n        var i = 1;\n        while (i < pts.length - 1) {\n            if (Point.equals(pts[i - 1], pts[i])) {\n                pts.splice(i, 1);\n            }\n            else if (Point.findAngle(pts[i - 1], pts[i]) === Point.findAngle(pts[i], pts[i + 1])) {\n                pts.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n        return pts;\n    };\n    /* tslint:disable */\n    LineDistribution.prototype.resetConnectorPoints = function (edge, diagram) {\n        var obstacleCollection = 'obstaclePointCollection';\n        if (edge.segments[0].points\n            && edge.segments[0].points.length > 0 && edge[obstacleCollection]) {\n            var connector = edge;\n            connector.sourcePoint = edge[obstacleCollection][0];\n            connector.targetPoint = edge[obstacleCollection][edge[obstacleCollection].length - 1];\n            var segments = void 0;\n            segments = [];\n            for (var i = 0; i < edge[obstacleCollection].length - 1; i++) {\n                var point1 = edge[obstacleCollection][i];\n                var point2 = edge[obstacleCollection][i + 1];\n                var length_1 = findDistance(point1, point2);\n                var direction = getConnectorDirection(point1, point2);\n                if (i === edge[obstacleCollection].length - 2) {\n                    if ((diagram.layout.orientation === 'RightToLeft' && direction === 'Left')\n                        || (diagram.layout.orientation === 'LeftToRight' && direction === 'Right')\n                        || (diagram.layout.orientation === 'TopToBottom' && direction === 'Bottom')\n                        || (diagram.layout.orientation === 'BottomToTop' && direction === 'Top')) {\n                        length_1 = length_1 / 2;\n                    }\n                }\n                /* tslint:enable */\n                var tempSegment = new OrthogonalSegment(edge, 'segments', { type: 'Orthogonal' }, true);\n                tempSegment.length = length_1;\n                tempSegment.direction = direction;\n                segments.push(tempSegment);\n            }\n            connector.segments = segments;\n            connector.type = 'Orthogonal';\n            diagram.connectorPropertyChange(connector, {}, {\n                type: 'Orthogonal',\n                segments: connector.segments\n            });\n        }\n    };\n    LineDistribution.prototype.getObstacleEndPoint = function (segment) {\n        if (segment.orientation === 'horizontal') {\n            if (segment.direction === 'Left') {\n                return this.getPointvalue(segment.start, segment.coord);\n            }\n            return this.getPointvalue(segment.end, segment.coord);\n        }\n        if (segment.direction === 'Top') {\n            return this.getPointvalue(segment.coord, segment.start);\n        }\n        return this.getPointvalue(segment.coord, segment.end);\n    };\n    LineDistribution.prototype.getObstacleStartPoint = function (segment) {\n        if (segment.orientation === 'horizontal') {\n            if (segment.direction === 'Left') {\n                return this.getPointvalue(segment.end, segment.coord);\n            }\n            return this.getPointvalue(segment.start, segment.coord);\n        }\n        if (segment.direction === 'Top') {\n            return this.getPointvalue(segment.coord, segment.end);\n        }\n        return this.getPointvalue(segment.coord, segment.start);\n    };\n    LineDistribution.prototype.updateSegmentRow = function (obstacleSegments, segmentRow) {\n        var k = 0;\n        if (!(segmentRow.length > 0)) {\n            segmentRow[0] = [];\n        }\n        for (var i = 0; i < obstacleSegments.length; i++) {\n            var obstacleSegment = obstacleSegments[i];\n            while (k < segmentRow.length) {\n                if (k === segmentRow.length - 1) {\n                    segmentRow[k + 1] = [];\n                }\n                if (!(segmentRow[k].length > 0)\n                    || segmentRow[k][segmentRow[k].length - 1].end < obstacleSegment.start) {\n                    segmentRow[k].push(obstacleSegment);\n                    break;\n                }\n                k++;\n            }\n        }\n        return segmentRow;\n    };\n    LineDistribution.prototype.portOffsetCalculation = function (port, length, direction, i) {\n        if (direction === 'Top') {\n            port.offset = { x: (i + 1) * (1.0 / (length + 1)), y: 0 };\n        }\n        if (direction === 'Bottom') {\n            port.offset = { x: (i + 1) * (1.0 / (length + 1)), y: 1 };\n        }\n        if (direction === 'Left') {\n            port.offset = { x: 0, y: (i + 1) * (1.0 / (length + 1)) };\n        }\n        if (direction === 'Right') {\n            port.offset = { x: 1, y: (i + 1) * (1.0 / (length + 1)) };\n        }\n    };\n    LineDistribution.prototype.addDynamicPortandDistrrbuteLine = function (layout, node, sourceDirection, targetDirection, diagram) {\n        if ((node.ports && node.ports.length > 0)) {\n            var port = node.ports;\n            diagram.removePorts(node, port);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var existingPorts = node.ports;\n        var outConnectors = node.outEdges;\n        var inConnectors = node.inEdges;\n        this.initPort(outConnectors, diagram, node, sourceDirection, false);\n        this.initPort(inConnectors, diagram, node, targetDirection, true);\n    };\n    /* tslint:disable */\n    LineDistribution.prototype.initPort = function (connectors, diagram, node, targetDirection, inConnectors) {\n        var obstacleCollection = 'obstaclePointCollection';\n        for (var i = 0; i <= connectors.length - 1; i++) {\n            var internalConnector = diagram.nameTable[connectors[i]];\n            internalConnector[obstacleCollection] = [];\n            var newPort = findPort(node, inConnectors ? internalConnector.targetPortID : internalConnector.sourcePortID);\n            var direction = targetDirection;\n            if (newPort === undefined) {\n                newPort = new PointPort(node, 'ports', '', true);\n                newPort.id = randomId() + '_LineDistribution';\n                if (inConnectors) {\n                    internalConnector.targetPortID = newPort.id;\n                }\n                else {\n                    internalConnector.sourcePortID = newPort.id;\n                }\n            }\n            this.portOffsetCalculation(newPort, connectors.length, direction, i);\n            node.ports.push(newPort);\n            var portWrapper = node.initPortWrapper(node.ports[node.ports.length - 1]);\n            node.wrapper.children.push(portWrapper);\n            diagram.connectorPropertyChange(internalConnector, inConnectors ? { targetPortID: '' } : { sourcePortID: '' }, \n            // eslint-disable-next-line\n            inConnectors ? { targetPortID: newPort.id } : { sourcePortID: newPort.id });\n        }\n    };\n    /* tslint:enable */\n    LineDistribution.prototype.shiftMatrixCells = function (value, startingCell, shiftChildren, parentCell, matrixModel) {\n        if (!(value === 0)) {\n            var matrix = matrixModel.matrix;\n            var matrixRow = matrix[startingCell.level].value;\n            var index = matrixRow.indexOf(startingCell);\n            for (var i = index; i < matrixRow.length; i++) {\n                matrixRow[i].offset += value;\n            }\n            if (shiftChildren) {\n                if (startingCell.visitedChildren.length > 0) {\n                    this.shiftMatrixCells(value, startingCell.visitedChildren[0], true, startingCell, matrixModel);\n                }\n                else {\n                    var i = 1;\n                    var nextSibilingwithChild = null;\n                    while (index + i < matrixRow.length) {\n                        var nextCell = matrixRow[index + i];\n                        if (parentCell != null && this.containsValue(nextCell.visitedParents, parentCell)) {\n                            if (nextCell.visitedChildren.length > 0) {\n                                nextSibilingwithChild = nextCell;\n                            }\n                            else {\n                                i++;\n                                continue;\n                            }\n                        }\n                        break;\n                    }\n                    if (nextSibilingwithChild != null) {\n                        this.shiftMatrixCells(value, nextSibilingwithChild.visitedChildren[0], true, nextSibilingwithChild, matrixModel);\n                    }\n                }\n            }\n        }\n    };\n    LineDistribution.prototype.arrangeMatrix = function (cell, parent, matrixModel) {\n        var layoutSettings = matrixModel.model.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight'\n            || layoutSettings.orientation === 'RightToLeft';\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        var matrix = matrixModel.matrix;\n        var matrixRow = matrix[cell.level].value;\n        var matrixIndex = matrixRow.indexOf(cell);\n        if (cell.visitedParents.length > 0) {\n            if (cell.visitedParents.length === 1) {\n                cell.initialOffset = cell.offset;\n            }\n            if (matrixIndex + 1 < matrixRow.length) {\n                var nextCell = matrixRow[matrixIndex + 1];\n                if (nextCell.visitedParents.length > 0) {\n                    if (!this.containsValue(cell.visitedParents, parent)) {\n                        cell.visitedParents.push(parent);\n                        parent.ignoredChildren.push(cell);\n                        return;\n                    }\n                }\n            }\n        }\n        if (!(cell.children.length > 0)) {\n            var validOffset = cell.offset;\n            if (matrixIndex > 0) {\n                var prevCell = matrixRow[matrixIndex - 1];\n                validOffset = prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);\n            }\n            this.shiftMatrixCells(validOffset - cell.offset, cell, false, null, matrixModel);\n        }\n        else {\n            for (var i = 0; i < cell.children.length; i++) {\n                var matrixCellChild = cell.children[i];\n                if (!this.containsValue(cell.visitedChildren, matrixCellChild)) {\n                    this.arrangeMatrix(matrixCellChild, cell, matrixModel);\n                    cell.visitedChildren.push(matrixCellChild);\n                }\n            }\n            if (cell.visitedChildren.length > 0) {\n                var children = cell.visitedChildren.slice();\n                for (var i = 0; i < cell.ignoredChildren.length; i++) {\n                    //let cellIgnoredChild: MatrixCellGroupObject = cell.ignoredChildren[i];\n                    children.splice(0, 1);\n                    cell.visitedChildren.splice(0, 1);\n                }\n                if (children.length > 0) {\n                    var firstChild = cell.visitedChildren[0];\n                    var lastChild = cell.visitedChildren[cell.visitedChildren.length - 1];\n                    var x1 = firstChild.offset - (firstChild.size / 2);\n                    var x2 = lastChild.offset + (lastChild.size / 2);\n                    var newoffset = (x1 + x2) / 2;\n                    if (newoffset < cell.offset) {\n                        this.shiftMatrixCells(cell.offset - newoffset, firstChild, true, cell, matrixModel);\n                    }\n                    else if (newoffset > cell.offset) {\n                        this.shiftMatrixCells(newoffset - cell.offset, cell, false, null, matrixModel);\n                    }\n                }\n            }\n        }\n        if (!this.containsValue(cell.visitedParents, parent)) {\n            cell.visitedParents.push(parent);\n        }\n    };\n    LineDistribution.prototype.getFixedTerminalPoint = function () {\n        var pt = null;\n        return pt;\n    };\n    LineDistribution.prototype.setAbsoluteTerminalPoint = function (point, isSource, edge) {\n        var absolutePoints = 'absolutePoints';\n        if (isSource) {\n            if (edge[absolutePoints] == null) {\n                edge[absolutePoints] = [];\n            }\n            if (edge[absolutePoints].length === 0) {\n                edge[absolutePoints].push(point);\n            }\n            else {\n                edge[absolutePoints][0] = point;\n            }\n        }\n        else {\n            if (edge[absolutePoints] == null) {\n                edge[absolutePoints] = [];\n                edge[absolutePoints].push(null);\n                edge[absolutePoints].push(point);\n            }\n            else if (edge[absolutePoints].length === 1) {\n                edge[absolutePoints].push(point);\n            }\n            else {\n                edge[absolutePoints][edge[absolutePoints].length - 1] = point;\n            }\n        }\n    };\n    LineDistribution.prototype.updateFixedTerminalPoint = function (edge, source) {\n        this.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(), source, edge);\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    LineDistribution.prototype.updateFixedTerminalPoints = function (connectors, diagram) {\n        this.updateFixedTerminalPoint(connectors, true);\n        this.updateFixedTerminalPoint(connectors, false);\n    };\n    LineDistribution.prototype.updatePoints = function (edge, points) {\n        var absolutePoints = 'absolutePoints';\n        if (edge != null) {\n            var pts = [];\n            pts.push(edge[absolutePoints][0]);\n            for (var i = 0; i < points.length; i++) {\n                if (points[i] != null) {\n                    var pt = points[i];\n                    pts.push(pt);\n                }\n            }\n            var tmp = edge[absolutePoints];\n            pts.push(tmp[tmp.length - 1]);\n            edge[absolutePoints] = pts;\n        }\n    };\n    LineDistribution.prototype.updateFloatingTerminalPoint = function (edge, start, end, source) {\n        this.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source, edge);\n    };\n    LineDistribution.prototype.getNextPoint = function (edge, opposite, source) {\n        var absolutePoints = 'absolutePoints';\n        var pts = edge[absolutePoints];\n        var point = null;\n        if (pts != null && pts.length >= 2) {\n            var count = pts.length;\n            point = pts[(source) ? Math.min(1, count - 1) : Math.max(0, count - 2)];\n        }\n        return point;\n    };\n    LineDistribution.prototype.getCenterX = function (start) {\n        if (start.offsetX) {\n            return start.offsetX + start.width;\n        }\n        else {\n            return start.x + start.width;\n        }\n    };\n    LineDistribution.prototype.getCenterY = function (start) {\n        if (start.offsetY) {\n            return start.offsetY + start.height;\n        }\n        else {\n            return start.y + start.height;\n        }\n    };\n    LineDistribution.prototype.getPerimeterBounds = function (border) {\n        //let newBounds: Rect;\n        var newBounds = border.wrapper.outerBounds;\n        return newBounds;\n    };\n    LineDistribution.prototype.getPerimeterFunction = function (bounds, next, orthogonal) {\n        var cx = this.getCenterX(bounds);\n        var cy = this.getCenterY(bounds);\n        var dx = next.x - cx;\n        var dy = next.y - cy;\n        var alpha = Math.atan2(dy, dx);\n        var point = this.getPointvalue(0, 0);\n        var pi = Math.PI;\n        var pi2 = Math.PI / 2;\n        var beta = pi2 - alpha;\n        var t = Math.atan2(bounds.height, bounds.width);\n        if (alpha < -pi + t || alpha > pi - t) {\n            // Left edge\n            point.x = bounds.x;\n            point.y = cy - bounds.width * Math.tan(alpha) / 2;\n        }\n        else if (alpha < -t) {\n            // Top Edge\n            point.y = bounds.y;\n            point.x = cx - bounds.height * Math.tan(beta) / 2;\n        }\n        else if (alpha < t) {\n            // Right Edge\n            point.x = bounds.x + bounds.width;\n            point.y = cy + bounds.width * Math.tan(alpha) / 2;\n        }\n        else {\n            // Bottom Edge\n            point.y = bounds.y + bounds.height;\n            point.x = cx + bounds.height * Math.tan(beta) / 2;\n        }\n        if (orthogonal) {\n            if (next.x >= bounds.x &&\n                next.x <= bounds.x + bounds.width) {\n                point.x = next.x;\n            }\n            else if (next.y >= bounds.y &&\n                next.y <= bounds.y + bounds.height) {\n                point.y = next.y;\n            }\n            if (next.x < bounds.x) {\n                point.x = bounds.x;\n            }\n            else if (next.x > bounds.x + bounds.width) {\n                point.x = bounds.x + bounds.width;\n            }\n            if (next.y < bounds.y) {\n                point.y = bounds.y;\n            }\n            else if (next.y > bounds.y + bounds.height) {\n                point.y = bounds.y + bounds.height;\n            }\n        }\n        return point;\n    };\n    LineDistribution.prototype.getPerimeterPoint = function (terminal, next, orthogonal) {\n        var point = null;\n        if (terminal != null) {\n            if (next != null) {\n                var bounds = this.getPerimeterBounds(terminal);\n                if (bounds.width > 0 || bounds.height > 0) {\n                    point = this.getPointvalue(next.x, next.y);\n                    point = this.getPerimeterFunction(bounds, point, orthogonal);\n                }\n            }\n        }\n        return point;\n    };\n    LineDistribution.prototype.getFloatingTerminalPoint = function (edge, start, end, source) {\n        start = start;\n        var next = this.getNextPoint(edge, end, source);\n        var orth = 1;\n        var alpha = 0;\n        var pt = this.getPerimeterPoint(start, next, alpha === 0 && orth);\n        return pt;\n    };\n    LineDistribution.prototype.updateFloatingTerminalPoints = function (state, source, target) {\n        var absolutePoints = 'absolutePoints';\n        var pts = state[absolutePoints];\n        var p0 = pts[0];\n        var pe = pts[pts.length - 1];\n        if (pe == null && target != null) {\n            this.updateFloatingTerminalPoint(state, target, source, false);\n        }\n        if (p0 == null && source != null) {\n            this.updateFloatingTerminalPoint(state, source, target, true);\n        }\n    };\n    LineDistribution.prototype.getConnectorPoints = function (connectors, diagram) {\n        var absolutePoints = 'absolutePoints';\n        var geometry = 'geometry';\n        this.updateFixedTerminalPoints(connectors, diagram);\n        this.updatePoints(connectors, connectors[geometry].points);\n        this.updateFloatingTerminalPoints(connectors, diagram.nameTable[connectors.sourceID], diagram.nameTable[connectors.targetID]);\n        connectors[absolutePoints][0].y = connectors.sourcePoint.y;\n        connectors[absolutePoints][connectors[absolutePoints].length - 1].y = connectors.targetPoint.y;\n    };\n    LineDistribution.prototype.adjustSegmentPoints = function (temppoints, points, diagram) {\n        if (diagram.layout.orientation === 'TopToBottom' || diagram.layout.orientation === 'BottomToTop') {\n            temppoints[0].x = points[0].x;\n            temppoints[1].x = points[1].x;\n            temppoints[temppoints.length - 1].x = points[points.length - 1].x;\n            temppoints[temppoints.length - 2].x = points[points.length - 2].x;\n            if (diagram.layout.orientation === 'TopToBottom') {\n                temppoints[temppoints.length - 2].y = temppoints[temppoints.length - 1].y - diagram.layout.verticalSpacing / 2;\n                temppoints[1].y = temppoints[0].y + diagram.layout.verticalSpacing / 2;\n            }\n            else {\n                temppoints[1].y = temppoints[0].y - diagram.layout.verticalSpacing / 2;\n                temppoints[temppoints.length - 2].y = temppoints[temppoints.length - 1].y + diagram.layout.verticalSpacing / 2;\n            }\n            temppoints[2].y = temppoints[1].y;\n            temppoints[temppoints.length - 3].y = temppoints[temppoints.length - 2].y;\n        }\n        if (diagram.layout.orientation === 'RightToLeft' || diagram.layout.orientation === 'LeftToRight') {\n            temppoints[0] = points[0];\n            temppoints[1] = points[1];\n            temppoints[temppoints.length - 1] = points[points.length - 1];\n            temppoints[temppoints.length - 2] = points[points.length - 2];\n            if (diagram.layout.orientation === 'RightToLeft') {\n                temppoints[1].x = temppoints[0].x - diagram.layout.verticalSpacing / 2;\n            }\n            if (diagram.layout.orientation === 'LeftToRight') {\n                temppoints[1].x = temppoints[0].x + diagram.layout.verticalSpacing / 2;\n            }\n            temppoints[2].x = temppoints[1].x;\n            if (diagram.layout.orientation === 'RightToLeft') {\n                temppoints[temppoints.length - 2].x = temppoints[temppoints.length - 1].x + diagram.layout.verticalSpacing / 2;\n            }\n            if (diagram.layout.orientation === 'LeftToRight') {\n                temppoints[temppoints.length - 2].x = temppoints[temppoints.length - 1].x - diagram.layout.verticalSpacing / 2;\n            }\n            temppoints[temppoints.length - 3].x = temppoints[temppoints.length - 2].x;\n        }\n    };\n    LineDistribution.prototype.updateConnectorSegmentPoints = function (temppoints, diagram) {\n        if (temppoints.length > 1) {\n            if ((diagram.layout.orientation === 'TopToBottom' || diagram.layout.orientation === 'BottomToTop')) {\n                for (var i = 1; i < temppoints.length - 1; i = i + 2) {\n                    if (temppoints[i].y !== temppoints[i + 1].y && (diagram.layout.orientation === 'TopToBottom'\n                        || diagram.layout.orientation === 'BottomToTop')) {\n                        temppoints[i + 1].y = temppoints[i].y;\n                    }\n                }\n            }\n            else {\n                var check = false;\n                for (var i = temppoints.length - 1; i > 1; i = i = i - 2) {\n                    if (diagram.layout.orientation === 'RightToLeft' || diagram.layout.orientation === 'LeftToRight') {\n                        if (!check) {\n                            temppoints[i - 1].x = temppoints[i - 2].x;\n                            check = true;\n                        }\n                        else {\n                            temppoints[i - 2].x = temppoints[i - 1].x;\n                            check = false;\n                        }\n                    }\n                    else {\n                        temppoints[i + 1].x = temppoints[i].x;\n                    }\n                }\n            }\n        }\n    };\n    LineDistribution.prototype.updateConnectorSegmentPoint = function (connector, diagram) {\n        var absolutePoints = 'absolutePoints';\n        var segments = [];\n        for (var i = 0; i < connector[absolutePoints].length - 1; i++) {\n            var point1 = connector[absolutePoints][i];\n            var point2 = connector[absolutePoints][i + 1];\n            var length_2 = findDistance(point1, point2);\n            var direction = getConnectorDirection(point1, point2);\n            if (i === connector[absolutePoints].length - 2) {\n                if ((diagram.layout.orientation === 'TopToBottom' && direction === 'Bottom')\n                    || (diagram.layout.orientation === 'RightToLeft' && direction === 'Left')\n                    || (diagram.layout.orientation === 'LeftToRight' && direction === 'Right')\n                    || (diagram.layout.orientation === 'BottomToTop' && direction === 'Top')) {\n                    length_2 = length_2 / 2;\n                }\n            }\n            var tempSegment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n            tempSegment.length = length_2;\n            tempSegment.direction = direction;\n            segments.push(tempSegment);\n        }\n        connector.segments = segments;\n        connector.type = 'Orthogonal';\n        diagram.connectorPropertyChange(connector, {}, {\n            type: 'Orthogonal',\n            segments: connector.segments\n        });\n    };\n    /** @private */\n    LineDistribution.prototype.resetConnectorSegments = function (connector) {\n        var segements = connector.segments;\n        for (var i = segements.length; i > 1; i--) {\n            segements.splice(i - 1, 1);\n        }\n    };\n    /* tslint:disable */\n    /** @private */\n    LineDistribution.prototype.resetRoutingSegments = function (connector, diagram, points) {\n        if (connector['levelSkip']) {\n            var absolutePoints = 'absolutePoints';\n            //let temppoints: PointModel[];\n            this.getConnectorPoints(connector, diagram);\n            var temppoints = connector[absolutePoints];\n            this.updateConnectorSegmentPoints(temppoints, diagram);\n            this.adjustSegmentPoints(temppoints, points, diagram);\n            this.updateConnectorSegmentPoint(connector, diagram);\n        }\n    };\n    /* tslint:enable */\n    /** @private */\n    LineDistribution.prototype.arrangeElements = function (matrixModel, layout) {\n        var layoutSettings = matrixModel.model.layout;\n        var isHorizontal;\n        if (layout.orientation === 'LeftToRight' || layout.orientation === 'RightToLeft') {\n            isHorizontal = true;\n        }\n        else {\n            isHorizontal = false;\n        }\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        //let spacingInverse: number = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        // Need to group element before\n        this.groupLayoutCells(matrixModel);\n        this.createMatrixCells(matrixModel);\n        for (var j = 0; j < matrixModel.matrix.length; j++) {\n            var matrixKey = matrixModel.matrix[j].key;\n            var matrixrow = matrixModel.matrix[matrixKey].value;\n            for (var i = 1; i < matrixrow.length; i++) {\n                var cell = matrixrow[i];\n                var prevCell = matrixrow[i - 1];\n                cell.offset += prevCell.offset + (prevCell.size / 2) + spacing + (cell.size / 2);\n            }\n        }\n        for (var j = 0; j < matrixModel.matrix[0].value.length; j++) {\n            var root = matrixModel.matrix[0].value[j];\n            this.arrangeMatrix(root, null, matrixModel);\n        }\n        for (var k = 0; k < matrixModel.matrix.length; k++) {\n            var row = matrixModel.matrix[k].value;\n            for (var i = 0; i < row.length; i++) {\n                var cell = row[i];\n                if (cell.visitedParents.length > 1) {\n                    var firstParent = cell.visitedParents[0];\n                    var lastParent = cell.visitedParents[cell.visitedParents.length - 1];\n                    var firstVertexParent = this.findParentVertexCellGroup(firstParent);\n                    var lastVertexParent = this.findParentVertexCellGroup(lastParent);\n                    if (firstParent !== firstVertexParent && firstVertexParent.offset < firstParent.offset) {\n                        firstParent = firstVertexParent;\n                    }\n                    if (lastParent !== lastVertexParent && lastVertexParent.offset > lastParent.offset) {\n                        lastParent = firstVertexParent;\n                    }\n                    var newoffset = (firstParent.offset + lastParent.offset) / 2;\n                    var availOffsetMin = cell.initialOffset;\n                    var availOffsetMax = cell.offset;\n                    if (!(availOffsetMax === availOffsetMin)) {\n                        if (newoffset >= availOffsetMin && newoffset <= availOffsetMax) {\n                            this.translateMatrixCells(newoffset - cell.offset, cell);\n                        }\n                        else if (newoffset < availOffsetMin) {\n                            this.translateMatrixCells(availOffsetMin - cell.offset, cell);\n                        }\n                    }\n                }\n            }\n        }\n        this.setXYforMatrixCell(matrixModel);\n    };\n    LineDistribution.prototype.findParentVertexCellGroup = function (cell) {\n        if (cell.cells[0]) {\n            return cell;\n        }\n        if (cell.parents.length > 0) {\n            return this.findParentVertexCellGroup(cell.parents[0]);\n        }\n        return cell;\n    };\n    LineDistribution.prototype.setXYforMatrixCell = function (matrixModel) {\n        var layoutSettings = matrixModel.model.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight'\n            || layoutSettings.orientation === 'RightToLeft';\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        for (var i = 0; i < matrixModel.matrix.length; i++) {\n            var matrixrow1 = matrixModel.matrix[i].value;\n            for (var j = 0; j < matrixrow1.length; j++) {\n                var matrixCell = matrixrow1[j];\n                var start = matrixCell.offset - (matrixCell.size / 2);\n                for (var k = 0; k < matrixCell.cells.length; k++) {\n                    var cell = matrixCell.cells[k];\n                    var type = this.getType(cell.type);\n                    if (type === 'internalVertex') {\n                        var internalVertex = cell;\n                        var width = internalVertex.cell.geometry.width;\n                        var height = internalVertex.cell.geometry.height;\n                        if (isHorizontal) {\n                            internalVertex.cell.geometry = new Rect(matrixModel.rowOffset[matrixCell.level] - (width / 2), start, width, height);\n                        }\n                        else {\n                            internalVertex.cell.geometry = new Rect(start, matrixModel.rowOffset[matrixCell.level] - (height / 2), width, height);\n                        }\n                        start += (isHorizontal ? height : width) + spacing;\n                    }\n                    else if (type === 'internalEdge') {\n                        var internalEdges = cell;\n                        var parent_1 = matrixCell.visitedParents[0];\n                        var isContainSibilingVertex = false;\n                        if (parent_1) {\n                            for (var l = 0; l < parent_1.visitedChildren.length; l++) {\n                                var children = parent_1.visitedChildren[l];\n                                var cells = [];\n                                for (var m = 0; m < children.cells.length; m++) {\n                                    var cell_1 = children.cells[m];\n                                    var type_1 = this.getType(cell_1.type);\n                                    if (type_1 === 'internalVertex') {\n                                        cells.push(cell_1);\n                                    }\n                                }\n                                if (cells.length > 0) {\n                                    isContainSibilingVertex = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // Need to updated line width\n                        var lineWidth = 1;\n                        var edgeSpacing = 5;\n                        for (var m = 0; m < internalEdges.edges.length; m++) {\n                            var internalConnector = internalEdges.edges[m];\n                            var pt = this.getPointvalue(start + (lineWidth / 2.0), matrixModel.rowOffset[matrixCell.level]);\n                            if (isHorizontal) {\n                                pt = this.getPointvalue(matrixModel.rowOffset[matrixCell.level], start + (lineWidth / 2.0));\n                            }\n                            if (this.containsValue(this.getEdgeMapper(), internalConnector)) {\n                                var key = void 0;\n                                for (var l = 0; l < this.getEdgeMapper().length; l++) {\n                                    if ((this.getEdgeMapper())[l].key === internalConnector) {\n                                        key = l;\n                                        break;\n                                    }\n                                }\n                                (this.getEdgeMapper())[key].value.push(pt);\n                            }\n                            start += lineWidth + edgeSpacing;\n                        }\n                        start += spacing;\n                    }\n                }\n            }\n        }\n    };\n    LineDistribution.prototype.getEdgeMapper = function () {\n        return this.edgeMapper;\n    };\n    /** @private */\n    LineDistribution.prototype.setEdgeMapper = function (value) {\n        this.edgeMapper.push(value);\n    };\n    LineDistribution.prototype.translateMatrixCells = function (value, cell) {\n        if (!(value === 0)) {\n            cell.offset += value;\n            if (cell.visitedChildren.length > 0) {\n                for (var i = 0; i < cell.visitedChildren.length; i++) {\n                    var cellVisitedChild = cell.visitedChildren[i];\n                    this.translateMatrixCells(value, cellVisitedChild);\n                }\n            }\n        }\n    };\n    LineDistribution.prototype.groupLayoutCells = function (matrixModel) {\n        var ranks = matrixModel.model.ranks;\n        for (var j = ranks.length - 1; j >= 0; j--) {\n            var vertices = [];\n            for (var v = 0; v < ranks[j].length; v++) {\n                var rank = ranks[j][v];\n                var type = this.getType(rank.type);\n                if (type === 'internalVertex') {\n                    vertices.push(ranks[j][v]);\n                }\n            }\n            var edges = [];\n            for (var e = 0; e < ranks[j].length; e++) {\n                var rank = ranks[j][e];\n                var type = this.getType(rank.type);\n                if (type === 'internalEdge') {\n                    edges.push(rank);\n                }\n            }\n            while (vertices.length > 1) {\n                var vertex1 = vertices[0];\n                var parentset1 = this.selectIds(vertex1.connectsAsTarget, true);\n                var childset1 = this.selectIds(vertex1.connectsAsSource, false);\n                while (vertices.length > 1) {\n                    var vertex2 = vertices[1];\n                    var parentset2 = this.selectIds(vertex2.connectsAsTarget, true);\n                    var childset2 = this.selectIds(vertex2.connectsAsSource, false);\n                    var parentequals = this.compareLists(parentset1, parentset2);\n                    var childequals = this.compareLists(childset1, childset2);\n                    if (parentequals && childequals) {\n                        this.updateMutualSharing(vertices[0], vertex2.id);\n                        this.updateMutualSharing(vertices[1], vertex1.id);\n                        vertices.splice(1, 1);\n                        continue;\n                    }\n                    break;\n                }\n                vertices.splice(0, 1);\n            }\n            while (edges.length > 1) {\n                var internalEdge = edges[0];\n                var parentset = internalEdge.source;\n                var childset = internalEdge.target;\n                if (parentset.identicalSibiling != null) {\n                    var groupedges = [];\n                    for (var i = 0; i < edges.length; i++) {\n                        var edge = edges[i];\n                        if (edge.target === childset) {\n                            groupedges.push(edge);\n                        }\n                    }\n                    for (var i = 0; i < groupedges.length; i++) {\n                        var internalEdgese = groupedges[i];\n                        if (this.containsValue(parentset.identicalSibiling, internalEdgese.source.id)) {\n                            internalEdgese.source.identicalSibiling = null;\n                        }\n                    }\n                    internalEdge.source.identicalSibiling = null;\n                }\n                edges.splice(0, 1);\n            }\n        }\n    };\n    LineDistribution.prototype.getType = function (type) {\n        if (type === 'internalVertex') {\n            return 'internalVertex';\n        }\n        else {\n            return 'internalEdge';\n        }\n    };\n    LineDistribution.prototype.selectIds = function (node, source) {\n        var returnIds = [];\n        for (var i = 0; i < node.length; i++) {\n            var connector = node[i];\n            if (source) {\n                {\n                    returnIds.push(connector.source.id);\n                }\n            }\n            else {\n                returnIds.push(connector.target.id);\n            }\n        }\n        return returnIds;\n    };\n    LineDistribution.prototype.compareLists = function (list1, list2) {\n        var newList1 = list1.slice();\n        var newList2 = list2.slice();\n        if (newList1.length === newList2.length) {\n            if (newList1.length === 0) {\n                return true;\n            }\n            else {\n                var isSame = true;\n                for (var i = 0; i < newList2.length; i++) {\n                    var o = newList2[i];\n                    for (var j = i; j < newList1.length; j++) {\n                        if (!(newList1[j] === o)) {\n                            isSame = false;\n                            break;\n                        }\n                    }\n                }\n                return isSame;\n            }\n        }\n        return false;\n    };\n    LineDistribution.prototype.updateMutualSharing = function (cell, id) {\n        if (cell.identicalSibiling != null) {\n            cell.identicalSibiling.push(id);\n        }\n        else {\n            cell.identicalSibiling = [];\n            cell.identicalSibiling.push(id);\n        }\n    };\n    LineDistribution.prototype.matrixCellGroup = function (options) {\n        options.level = options.level;\n        options.parents = options.parents;\n        options.children = options.children;\n        options.visitedChildren = options.visitedChildren;\n        options.visitedParents = options.visitedParents;\n        options.ignoredChildren = options.ignoredChildren;\n        options.cells = options.cells;\n        options.offset = options.offset;\n        options.initialOffset = options.initialOffset;\n        return options;\n    };\n    LineDistribution.prototype.getPointvalue = function (x, y) {\n        return { 'x': Number(x) || 0, 'y': Number(y) || 0 };\n    };\n    LineDistribution.prototype.containsValue = function (list, keyValue) {\n        for (var i = 0; i < list.length; i++) {\n            if (list[i].key === keyValue || list[i] === keyValue) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /* tslint:disable */\n    LineDistribution.prototype.createMatrixCells = function (matrixModel) {\n        var layoutSettings = matrixModel.model.layout;\n        var isHorizontal = layoutSettings.orientation === 'LeftToRight'\n            || layoutSettings.orientation === 'RightToLeft';\n        var spacing = isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        var spacingInverse = !isHorizontal ? layoutSettings.verticalSpacing : layoutSettings.horizontalSpacing;\n        var ranks = matrixModel.model.ranks;\n        var matrixCellMapper = [];\n        var rowoffset = -spacingInverse;\n        for (var j = ranks.length - 1; j >= 0; j--) {\n            var maxDimension = 0.0;\n            var index = (ranks.length - 1) - j;\n            var rank = ranks[j].slice(); //.ToList();\n            // Creating new row and adding it to matrix\n            var matrixRow = [];\n            matrixModel.matrix.push({ key: index, value: matrixRow });\n            // Creating new row mapper\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var tempMatrixRow = [];\n            matrixCellMapper.push({ index: index, value: tempMatrixRow });\n            while (rank.length > 0) //.Any())\n             {\n                var layoutCell = rank[0];\n                // eslint-disable-next-line max-len\n                var matrixCell = this.matrixCellGroup({ level: index, parents: [], children: [], visitedParents: [], visitedChildren: [], ignoredChildren: [], cells: [], size: 0, offset: 0, initialOffset: 0 });\n                matrixRow.push(matrixCell);\n                var type = this.getType(layoutCell.type);\n                if (type === 'internalVertex') {\n                    matrixCell.cells.push(layoutCell);\n                    if (layoutCell.identicalSibiling != null) {\n                        for (var i = 0; i < rank.length; i++) {\n                            var internalVertex = rank[i];\n                            var type_2 = this.getType(internalVertex.type);\n                            if (type_2 === 'internalVertex' && this.containsValue(layoutCell.identicalSibiling, internalVertex.id)) {\n                                matrixCell.cells.push(internalVertex);\n                                if (matrixCell.cells.length > layoutCell.identicalSibiling.length) {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    for (var i = 0; i < matrixCell.cells.length; i++) {\n                        var internalVertex = matrixCell.cells[i];\n                        var type_3 = this.getType(internalVertex.type);\n                        if (type_3 === 'internalVertex') {\n                            var geometry = internalVertex.cell.geometry;\n                            matrixCell.size += isHorizontal ? geometry.height : geometry.width;\n                            maxDimension = Math.max(maxDimension, !isHorizontal ? geometry.height : geometry.width);\n                            tempMatrixRow.push({ key: internalVertex.id, value: matrixCell });\n                            if (internalVertex.connectsAsTarget.length > 0) {\n                                for (var k = 0; k < internalVertex.connectsAsTarget.length; k++) {\n                                    var internalEdgese = internalVertex.connectsAsTarget[k];\n                                    var key = null;\n                                    if (this.containsValue(matrixCellMapper[index - 1].value, internalEdgese.ids)) {\n                                        key = internalEdgese.ids;\n                                    }\n                                    else if (this.containsValue(matrixCellMapper[index - 1].value, internalEdgese.source.id)) {\n                                        key = internalEdgese.source.id;\n                                    }\n                                    if (key != null) {\n                                        var parentcellValue = matrixCellMapper[index - 1].value;\n                                        var parentMartixCell = void 0;\n                                        for (var v = 0; v < parentcellValue.length; v++) {\n                                            if (parentcellValue[v].key === key) {\n                                                parentMartixCell = parentcellValue[v].value;\n                                                break;\n                                            }\n                                        }\n                                        if (!this.containsValue(matrixCell.parents, parentMartixCell)) {\n                                            matrixCell.parents.push(parentMartixCell);\n                                        }\n                                        if (!this.containsValue(parentMartixCell.children, matrixCell)) {\n                                            parentMartixCell.children.push(matrixCell);\n                                        }\n                                    }\n                                }\n                            }\n                            rank.reverse();\n                            rank.pop();\n                            rank.reverse();\n                        }\n                    }\n                    matrixCell.size += (matrixCell.cells.length - 1) * spacing;\n                }\n                else if (type === 'internalEdge') {\n                    matrixCell.cells.push(layoutCell);\n                    for (var i = 0; i < matrixCell.cells.length; i++) {\n                        var internalEdge = matrixCell.cells[i];\n                        var type1 = this.getType(internalEdge.type);\n                        if (type1 === 'internalEdge' && internalEdge.edges != null) {\n                            // need to spacing based on its source and target Node\n                            var edgeSpacing = 5;\n                            var cellSize = -edgeSpacing;\n                            for (var k = 0; k < internalEdge.edges.length; k++) {\n                                //const internalConnector = internalEdge.edges[k];\n                                // need to summ up the line width\n                                cellSize += 1 + edgeSpacing;\n                            }\n                            matrixCell.size += cellSize;\n                        }\n                        tempMatrixRow.push({ key: internalEdge.ids, value: matrixCell });\n                        var key = null;\n                        if (this.containsValue(matrixCellMapper[index - 1].value, internalEdge.ids)) {\n                            key = internalEdge.ids;\n                        }\n                        else if (this.containsValue(matrixCellMapper[index - 1].value, internalEdge.source.id)) {\n                            key = internalEdge.source.id;\n                        }\n                        if (key != null) {\n                            var parentcell = matrixCellMapper[index - 1].value;\n                            var parentMartixCell = void 0;\n                            for (var v = 0; v < parentcell.length; v++) {\n                                if (parentcell[v].key === key) {\n                                    parentMartixCell = parentcell[v].value;\n                                    break;\n                                }\n                            }\n                            if (!this.containsValue(matrixCell.parents, parentMartixCell)) {\n                                matrixCell.parents.push(parentMartixCell);\n                            }\n                            if (!this.containsValue(parentMartixCell.children, matrixCell)) {\n                                parentMartixCell.children.push(matrixCell);\n                            }\n                        }\n                        rank.reverse();\n                        rank.pop();\n                        rank.reverse();\n                    }\n                    matrixCell.size += (matrixCell.cells.length - 1) * spacing;\n                }\n            }\n            matrixModel.rowOffset.push(rowoffset + (maxDimension / 2) + spacingInverse);\n            rowoffset += maxDimension + spacingInverse;\n        }\n    };\n    /* eslint-disable */\n    /** @private */\n    LineDistribution.prototype.updateLayout = function (viewPort, modelBounds, layoutProp, layout, nodeWithMultiEdges, nameTable) {\n        {\n            var trnsX = ((viewPort.x - modelBounds.width) / 2) - modelBounds.x;\n            var trnsY = ((viewPort.y - modelBounds.height) / 2) - modelBounds.y;\n            trnsX = Math.round(trnsX);\n            trnsY = Math.round(trnsY);\n            var modifiedConnectors = [];\n            var transModelBounds = new Rect(modelBounds.x + trnsX, modelBounds.y + trnsY, modelBounds.width, modelBounds.height);\n            var margin = layoutProp.margin;\n            var isHorizontal = layout.orientation === 'RightToLeft' || layout.orientation === 'LeftToRight';\n            var inversespacing = !isHorizontal ? layout.verticalSpacing : layout.horizontalSpacing;\n            for (var i = 0; i < nodeWithMultiEdges.length; i++) {\n                var node = nodeWithMultiEdges[i];\n                if (node.outEdges != null && node.outEdges.length > 0) {\n                    var count = node.outEdges.length;\n                    for (var j = 0; j < count; j++) {\n                        var internalConnector = nameTable[node.outEdges[j]];\n                        internalConnector['pointCollection'] = [];\n                        if (count > 1) {\n                            var segmentsize = inversespacing / 2.0;\n                            var intermediatePoint = null;\n                            var key = void 0;\n                            var edgeMapper = this.getEdgeMapper();\n                            for (var k = 0; k < edgeMapper.length; k++) {\n                                if (edgeMapper[k].key === internalConnector) {\n                                    key = k;\n                                    break;\n                                }\n                            }\n                            if (edgeMapper[key].value.length > 0) {\n                                var edgePoint = edgeMapper[key].value[0];\n                                var dxValue1 = edgePoint.x + margin.left;\n                                var dyValue1 = edgePoint.y + margin.top;\n                                var x1 = dxValue1;\n                                var y1 = dyValue1;\n                                if (layout.orientation === 'BottomToTop') {\n                                    y1 = modelBounds.height - dyValue1;\n                                }\n                                else if (layout.orientation === 'RightToLeft') {\n                                    x1 = modelBounds.width - dxValue1;\n                                }\n                                x1 += trnsX;\n                                y1 += trnsY;\n                                intermediatePoint = this.getPointvalue(x1, y1);\n                            }\n                            var pts = [];\n                            for (var i_1 = 0; i_1 < internalConnector.segments.length; i_1++) {\n                                var pt = internalConnector.segments[i_1].points;\n                                // eslint-disable-next-line guard-for-in\n                                for (var temp in pt) {\n                                    pts.push(pt[temp]);\n                                }\n                            }\n                            // eslint-disable-next-line max-len\n                            pts = this.updateConnectorPoints(pts, segmentsize, intermediatePoint, transModelBounds, layout.orientation);\n                            for (var p = 0; p < pts.length; p++) {\n                                var pt = pts[p];\n                                internalConnector['pointCollection'].push(this.getPointvalue(pt.x, pt.y));\n                            }\n                            this.resetConnectorPoints(internalConnector, this.diagram);\n                        }\n                        modifiedConnectors.push(internalConnector);\n                    }\n                }\n                if (node.inEdges != null && node.inEdges.length > 1) {\n                    var count = node.inEdges.length;\n                    var edgeMapper = this.getEdgeMapper();\n                    for (var j = 0; j < count; j++) {\n                        var internalConnector = nameTable[node.inEdges[j]];\n                        if (!this.containsValue(modifiedConnectors, internalConnector)) {\n                            internalConnector['pointCollection'] = [];\n                        }\n                        if (count > 1) {\n                            var segmentsize = inversespacing / 2.0;\n                            var intermediatePoint = null;\n                            var key = void 0;\n                            var k = void 0;\n                            for (k = 0; k < edgeMapper.length; k++) {\n                                if (edgeMapper[k].key === internalConnector) {\n                                    key = k;\n                                    break;\n                                }\n                            }\n                            if (edgeMapper[key].value.length > 0\n                                && !this.containsValue(modifiedConnectors, internalConnector)) {\n                                var edgePt = edgeMapper[k].value[0];\n                                var dx1 = edgePt.x + margin.left;\n                                var dy1 = edgePt.y + margin.top;\n                                // eslint-disable-next-line one-var\n                                var x1 = dx1, y1 = dy1;\n                                if (layout.orientation === 'BottomToTop') {\n                                    y1 = modelBounds.height - dy1;\n                                }\n                                else if (layout.orientation === 'RightToLeft') {\n                                    x1 = modelBounds.width - dx1;\n                                }\n                                x1 += trnsX;\n                                y1 += trnsY;\n                                intermediatePoint = this.getPointvalue(x1, y1);\n                            }\n                            var pts = [];\n                            for (var p = 0; p < internalConnector.segments.length; p++) {\n                                var pt = internalConnector.segments[p].points;\n                                // eslint-disable-next-line guard-for-in\n                                for (var temp in pt) {\n                                    pts.push(pt[temp]);\n                                }\n                            }\n                            pts.reverse();\n                            // eslint-disable-next-line\n                            pts = this.updateConnectorPoints(pts, segmentsize, intermediatePoint, transModelBounds, layoutProp.orientation);\n                            pts.reverse();\n                            internalConnector['pointCollection'] = [];\n                            for (var p = 0; p < pts.length; p++) {\n                                var pt = pts[p];\n                                internalConnector['pointCollection'].push(this.getPointvalue(pt.x, pt.y));\n                            }\n                            this.resetConnectorPoints(internalConnector, this.diagram);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    return LineDistribution;\n}());\nexport { LineDistribution };\n"]},"metadata":{},"sourceType":"module"}