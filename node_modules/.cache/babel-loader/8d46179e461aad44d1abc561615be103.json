{"ast":null,"code":"/**\n * Matrix module is used to transform points based on offsets, angle\n */\n\n/** @private */\nexport var MatrixTypes;\n\n(function (MatrixTypes) {\n  MatrixTypes[MatrixTypes[\"Identity\"] = 0] = \"Identity\";\n  MatrixTypes[MatrixTypes[\"Translation\"] = 1] = \"Translation\";\n  MatrixTypes[MatrixTypes[\"Scaling\"] = 2] = \"Scaling\";\n  MatrixTypes[MatrixTypes[\"Unknown\"] = 4] = \"Unknown\";\n})(MatrixTypes || (MatrixTypes = {}));\n/** @private */\n\n\nvar Matrix =\n/** @class */\nfunction () {\n  function Matrix(m11, m12, m21, m22, offsetX, offsetY, type) {\n    this.m11 = m11;\n    this.m12 = m12;\n    this.m21 = m21;\n    this.m22 = m22;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY; // if (type === undefined) {\n    //     this.type = MatrixTypes.Unknown;\n    // } else {\n    //     this.type = type;\n    // }\n\n    this.type = type;\n  }\n\n  return Matrix;\n}();\n\nexport { Matrix };\n/**\n * Will identify the  matrix .\\\n *\n * @returns {Matrix}  Will identify the  matrix .\n * @private\n */\n\nexport function identityMatrix() {\n  return new Matrix(1, 0, 0, 1, 0, 0, MatrixTypes.Identity);\n}\n/**\n * Will transform the points by matrix .\\\n *\n * @returns {PointModel[]}  Will transform the points by matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} point -  provide the points value.\n * @private\n */\n\nexport function transformPointByMatrix(matrix, point) {\n  var pt = multiplyPoint(matrix, point.x, point.y);\n  return {\n    x: Math.round(pt.x * 100) / 100,\n    y: Math.round(pt.y * 100) / 100\n  };\n}\n/**\n * Will transform the points by matrix .\\\n *\n * @returns {PointModel[]}  Will transform the points by matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} points -  provide the points value.\n * @private\n */\n\nexport function transformPointsByMatrix(matrix, points) {\n  var transformedPoints = [];\n\n  for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n    var point = points_1[_i];\n    transformedPoints.push(transformPointByMatrix(matrix, point));\n  }\n\n  return transformedPoints;\n}\n/**\n * Will rotate the matrix .\\\n *\n * @returns {void}  Will rotate the matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} angle - provide the angle value.\n * @param {number} centerX - provide the centerX value .\n * @param {number} centerY - provide the centerY value .\n * @private\n */\n\nexport function rotateMatrix(matrix, angle, centerX, centerY) {\n  angle %= 360.0;\n  multiplyMatrix(matrix, createRotationRadians(angle * 0.017453292519943295, centerX ? centerX : 0, centerY ? centerY : 0));\n}\n/**\n * Will scale the matrix .\\\n *\n * @returns {void} Will scale the matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} scaleX - provide the scaleXvalue.\n * @param {number} scaleY - provide the scaleY value .\n * @param {number} centerX - provide the centerX value .\n * @param {number} centerY - provide the centerY value .\n * @private\n */\n\nexport function scaleMatrix(matrix, scaleX, scaleY, centerX, centerY) {\n  if (centerX === void 0) {\n    centerX = 0;\n  }\n\n  if (centerY === void 0) {\n    centerY = 0;\n  }\n\n  multiplyMatrix(matrix, createScaling(scaleX, scaleY, centerX, centerY));\n}\n/**\n * Will translate the matrix .\\\n *\n * @returns {void} Will translate the matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} offsetX - provide the offset x value.\n * @param {number} offsetY - provide the offset y value .\n * @private\n */\n\nexport function translateMatrix(matrix, offsetX, offsetY) {\n  if (matrix.type & MatrixTypes.Identity) {\n    matrix.type = MatrixTypes.Translation;\n    setMatrix(matrix, 1.0, 0.0, 0.0, 1.0, offsetX, offsetY);\n    return;\n  }\n\n  if (matrix.type & MatrixTypes.Unknown) {\n    matrix.offsetX += offsetX;\n    matrix.offsetY += offsetY;\n    return;\n  }\n\n  matrix.offsetX += offsetX;\n  matrix.offsetY += offsetY;\n  matrix.type |= MatrixTypes.Translation;\n}\n/**\n * Will create scaling value .\\\n *\n * @returns {Matrix} Will create scaling value . .\n *\n * @param {Matrix} scaleX - provide the scale x value  .\n * @param {number} scaleY - provide the scale y value.\n * @param {number} centerX - provide the centerX x value .\n * @param {number} centerY - provide the centerX y value .\n * @private\n */\n\nfunction createScaling(scaleX, scaleY, centerX, centerY) {\n  var result = identityMatrix();\n  result.type = !(centerX || centerY) ? MatrixTypes.Scaling : MatrixTypes.Scaling | MatrixTypes.Translation;\n  setMatrix(result, scaleX, 0.0, 0.0, scaleY, centerX - scaleX * centerX, centerY - scaleY * centerY);\n  return result;\n}\n/**\n * Will create the rotation radians.\\\n *\n * @returns {Matrix} Will create the rotation radians .\n *\n * @param {Matrix} angle - provide the angle  .\n * @param {number} centerX - provide the x value .\n * @param {number} centerY - provide the y value .\n * @private\n */\n\n\nfunction createRotationRadians(angle, centerX, centerY) {\n  var result = identityMatrix();\n  var num = Math.sin(angle);\n  var num2 = Math.cos(angle);\n  var offsetX = centerX * (1.0 - num2) + centerY * num;\n  var offsetY = centerY * (1.0 - num2) - centerX * num;\n  result.type = MatrixTypes.Unknown;\n  setMatrix(result, num2, num, -num, num2, offsetX, offsetY);\n  return result;\n}\n/**\n * Multiply the point .\\\n *\n * @returns {void} Multiply the point .\n *\n * @param {Matrix} matrix - Provide the matrix .\n * @param {number} x - provide the x value .\n * @param {number} y - provide the y value .\n * @private\n */\n\n\nfunction multiplyPoint(matrix, x, y) {\n  switch (matrix.type) {\n    case MatrixTypes.Identity:\n      break;\n\n    case MatrixTypes.Translation:\n      x += matrix.offsetX;\n      y += matrix.offsetY;\n      break;\n\n    case MatrixTypes.Scaling:\n      x *= matrix.m11;\n      y *= matrix.m22;\n      break;\n\n    case MatrixTypes.Translation | MatrixTypes.Scaling:\n      x *= matrix.m11;\n      x += matrix.offsetX;\n      y *= matrix.m22;\n      y += matrix.offsetY;\n      break;\n\n    default:\n      // eslint-disable-next-line no-case-declarations\n      var num = y * matrix.m21 + matrix.offsetX; // eslint-disable-next-line no-case-declarations\n\n      var num2 = x * matrix.m12 + matrix.offsetY;\n      x *= matrix.m11;\n      x += num;\n      y *= matrix.m22;\n      y += num2;\n      break;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\n * Will multiply the matrix .\\\n *\n * @returns {void} Will multiply the matrix .\n *\n * @param {Matrix} matrix1 - Provide the matrix 1 value .\n * @param {Matrix} matrix2 - Provide the matrix 2 value .\n * @private\n */\n\n\nexport function multiplyMatrix(matrix1, matrix2) {\n  var type = matrix1.type;\n  var type2 = matrix2.type;\n\n  if (type2 === MatrixTypes.Identity) {\n    return;\n  }\n\n  if (type === MatrixTypes.Identity) {\n    assignMatrix(matrix1, matrix2);\n    matrix1.type = matrix2.type;\n    return;\n  }\n\n  if (type2 === MatrixTypes.Translation) {\n    matrix1.offsetX += matrix2.offsetX;\n    matrix1.offsetY += matrix2.offsetY;\n\n    if (type !== MatrixTypes.Unknown) {\n      matrix1.type |= MatrixTypes.Translation;\n    }\n\n    return;\n  }\n\n  if (type !== MatrixTypes.Translation) {\n    var num = type << 4 | type2;\n\n    switch (num) {\n      case 34:\n        matrix1.m11 *= matrix2.m11;\n        matrix1.m22 *= matrix2.m22;\n        return;\n\n      case 35:\n        matrix1.m11 *= matrix2.m11;\n        matrix1.m22 *= matrix2.m22;\n        matrix1.offsetX = matrix2.offsetX;\n        matrix1.offsetY = matrix2.offsetY;\n        matrix1.type = MatrixTypes.Translation | MatrixTypes.Scaling;\n        return;\n\n      case 36:\n        break;\n\n      default:\n        {\n          switch (num) {\n            case 50:\n              matrix1.m11 *= matrix2.m11;\n              matrix1.m22 *= matrix2.m22;\n              matrix1.offsetX *= matrix2.m11;\n              matrix1.offsetY *= matrix2.m22;\n              return;\n\n            case 51:\n              matrix1.m11 *= matrix2.m11;\n              matrix1.m22 *= matrix2.m22;\n              matrix1.offsetX = matrix2.m11 * matrix1.offsetX + matrix2.offsetX;\n              matrix1.offsetY = matrix2.m22 * matrix1.offsetY + matrix2.offsetY;\n              return;\n\n            case 52:\n              break;\n\n            default:\n              switch (num) {\n                case 66:\n                case 67:\n                case 68:\n                  break;\n\n                default:\n                  return;\n              }\n\n              break;\n          }\n\n          break;\n        }\n    }\n\n    var result = identityMatrix();\n    var m11New = matrix1.m11 * matrix2.m11 + matrix1.m12 * matrix2.m21;\n    var m12New = matrix1.m11 * matrix2.m12 + matrix1.m12 * matrix2.m22;\n    var m21New = matrix1.m21 * matrix2.m11 + matrix1.m22 * matrix2.m21;\n    var m22New = matrix1.m21 * matrix2.m12 + matrix1.m22 * matrix2.m22;\n    var offsetX_1 = matrix1.offsetX * matrix2.m11 + matrix1.offsetY * matrix2.m21 + matrix2.offsetX;\n    var offsetY_1 = matrix1.offsetX * matrix2.m12 + matrix1.offsetY * matrix2.m22 + matrix2.offsetY;\n    setMatrix(result, m11New, m12New, m21New, m22New, offsetX_1, offsetY_1);\n\n    if (result.m21 || result.m12) {\n      result.type = MatrixTypes.Unknown;\n    } else {\n      if (result.m11 && result.m11 !== 1.0 || result.m22 && result.m22 !== 1.0) {\n        result.type = MatrixTypes.Scaling;\n      }\n\n      if (result.offsetX || result.offsetY) {\n        result.type |= MatrixTypes.Translation;\n      }\n\n      if ((result.type & (MatrixTypes.Translation | MatrixTypes.Scaling)) === MatrixTypes.Identity) {\n        result.type = MatrixTypes.Identity;\n      }\n\n      result.type = MatrixTypes.Scaling | MatrixTypes.Translation;\n    }\n\n    assignMatrix(matrix1, result);\n    matrix1.type = result.type;\n    return;\n  }\n\n  var offsetX = matrix1.offsetX;\n  var offsetY = matrix1.offsetY;\n  matrix1.offsetX = offsetX * matrix2.m11 + offsetY * matrix2.m21 + matrix2.offsetX;\n  matrix1.offsetY = offsetX * matrix2.m12 + offsetY * matrix2.m22 + matrix2.offsetY;\n\n  if (type2 === MatrixTypes.Unknown) {\n    matrix1.type = MatrixTypes.Unknown;\n    return;\n  }\n\n  matrix1.type = MatrixTypes.Translation | MatrixTypes.Scaling;\n}\n/**\n * set the matrix .\\\n *\n * @returns {void} set the matrix .\n *\n * @param {Matrix} mat - Provide the matrix 1 value .\n * @param {number} m11 - Provide the matrix m11 value .\n * @param {number} m12 - Provide the matrix m11 value .\n * @param {number} m21 - Provide the matrix m11 value .\n * @param {number} m22 - Provide the matrix m11 value .\n * @param {number} x - Provide the matrix m11 value .\n * @param {number} y - Provide the matrix m11 value .\n * @private\n */\n\nfunction setMatrix(mat, m11, m12, m21, m22, x, y) {\n  mat.m11 = m11;\n  mat.m12 = m12;\n  mat.m21 = m21;\n  mat.m22 = m22;\n  mat.offsetX = x;\n  mat.offsetY = y;\n}\n/**\n * Assign the matrix .\\\n *\n * @returns {void} Assign the matrix .\n *\n * @param {Matrix} matrix1 - Provide the element type as string .\n * @param {Matrix} matrix2 - Provide the element type as string .\n * @private\n */\n\n\nfunction assignMatrix(matrix1, matrix2) {\n  matrix1.m11 = matrix2.m11;\n  matrix1.m12 = matrix2.m12;\n  matrix1.m21 = matrix2.m21;\n  matrix1.m22 = matrix2.m22;\n  matrix1.offsetX = matrix2.offsetX;\n  matrix1.offsetY = matrix2.offsetY;\n  matrix1.type = matrix2.type;\n}","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/primitives/matrix.js"],"names":["MatrixTypes","Matrix","m11","m12","m21","m22","offsetX","offsetY","type","identityMatrix","Identity","transformPointByMatrix","matrix","point","pt","multiplyPoint","x","y","Math","round","transformPointsByMatrix","points","transformedPoints","_i","points_1","length","push","rotateMatrix","angle","centerX","centerY","multiplyMatrix","createRotationRadians","scaleMatrix","scaleX","scaleY","createScaling","translateMatrix","Translation","setMatrix","Unknown","result","Scaling","num","sin","num2","cos","matrix1","matrix2","type2","assignMatrix","m11New","m12New","m21New","m22New","offsetX_1","offsetY_1","mat"],"mappings":"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","sourcesContent":["/**\n * Matrix module is used to transform points based on offsets, angle\n */\n/** @private */\nexport var MatrixTypes;\n(function (MatrixTypes) {\n    MatrixTypes[MatrixTypes[\"Identity\"] = 0] = \"Identity\";\n    MatrixTypes[MatrixTypes[\"Translation\"] = 1] = \"Translation\";\n    MatrixTypes[MatrixTypes[\"Scaling\"] = 2] = \"Scaling\";\n    MatrixTypes[MatrixTypes[\"Unknown\"] = 4] = \"Unknown\";\n})(MatrixTypes || (MatrixTypes = {}));\n/** @private */\nvar Matrix = /** @class */ (function () {\n    function Matrix(m11, m12, m21, m22, offsetX, offsetY, type) {\n        this.m11 = m11;\n        this.m12 = m12;\n        this.m21 = m21;\n        this.m22 = m22;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        // if (type === undefined) {\n        //     this.type = MatrixTypes.Unknown;\n        // } else {\n        //     this.type = type;\n        // }\n        this.type = type;\n    }\n    return Matrix;\n}());\nexport { Matrix };\n/**\n * Will identify the  matrix .\\\n *\n * @returns {Matrix}  Will identify the  matrix .\n * @private\n */\nexport function identityMatrix() {\n    return new Matrix(1, 0, 0, 1, 0, 0, MatrixTypes.Identity);\n}\n/**\n * Will transform the points by matrix .\\\n *\n * @returns {PointModel[]}  Will transform the points by matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} point -  provide the points value.\n * @private\n */\nexport function transformPointByMatrix(matrix, point) {\n    var pt = multiplyPoint(matrix, point.x, point.y);\n    return { x: Math.round(pt.x * 100) / 100, y: Math.round(pt.y * 100) / 100 };\n}\n/**\n * Will transform the points by matrix .\\\n *\n * @returns {PointModel[]}  Will transform the points by matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} points -  provide the points value.\n * @private\n */\nexport function transformPointsByMatrix(matrix, points) {\n    var transformedPoints = [];\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n        var point = points_1[_i];\n        transformedPoints.push(transformPointByMatrix(matrix, point));\n    }\n    return transformedPoints;\n}\n/**\n * Will rotate the matrix .\\\n *\n * @returns {void}  Will rotate the matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} angle - provide the angle value.\n * @param {number} centerX - provide the centerX value .\n * @param {number} centerY - provide the centerY value .\n * @private\n */\nexport function rotateMatrix(matrix, angle, centerX, centerY) {\n    angle %= 360.0;\n    multiplyMatrix(matrix, createRotationRadians(angle * 0.017453292519943295, centerX ? centerX : 0, centerY ? centerY : 0));\n}\n/**\n * Will scale the matrix .\\\n *\n * @returns {void} Will scale the matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} scaleX - provide the scaleXvalue.\n * @param {number} scaleY - provide the scaleY value .\n * @param {number} centerX - provide the centerX value .\n * @param {number} centerY - provide the centerY value .\n * @private\n */\nexport function scaleMatrix(matrix, scaleX, scaleY, centerX, centerY) {\n    if (centerX === void 0) { centerX = 0; }\n    if (centerY === void 0) { centerY = 0; }\n    multiplyMatrix(matrix, createScaling(scaleX, scaleY, centerX, centerY));\n}\n/**\n * Will translate the matrix .\\\n *\n * @returns {void} Will translate the matrix .\n *\n * @param {Matrix} matrix - provide the matrix value  .\n * @param {number} offsetX - provide the offset x value.\n * @param {number} offsetY - provide the offset y value .\n * @private\n */\nexport function translateMatrix(matrix, offsetX, offsetY) {\n    if (matrix.type & MatrixTypes.Identity) {\n        matrix.type = MatrixTypes.Translation;\n        setMatrix(matrix, 1.0, 0.0, 0.0, 1.0, offsetX, offsetY);\n        return;\n    }\n    if (matrix.type & MatrixTypes.Unknown) {\n        matrix.offsetX += offsetX;\n        matrix.offsetY += offsetY;\n        return;\n    }\n    matrix.offsetX += offsetX;\n    matrix.offsetY += offsetY;\n    matrix.type |= MatrixTypes.Translation;\n}\n/**\n * Will create scaling value .\\\n *\n * @returns {Matrix} Will create scaling value . .\n *\n * @param {Matrix} scaleX - provide the scale x value  .\n * @param {number} scaleY - provide the scale y value.\n * @param {number} centerX - provide the centerX x value .\n * @param {number} centerY - provide the centerX y value .\n * @private\n */\nfunction createScaling(scaleX, scaleY, centerX, centerY) {\n    var result = identityMatrix();\n    result.type = !(centerX || centerY) ? MatrixTypes.Scaling : MatrixTypes.Scaling | MatrixTypes.Translation;\n    setMatrix(result, scaleX, 0.0, 0.0, scaleY, centerX - scaleX * centerX, centerY - scaleY * centerY);\n    return result;\n}\n/**\n * Will create the rotation radians.\\\n *\n * @returns {Matrix} Will create the rotation radians .\n *\n * @param {Matrix} angle - provide the angle  .\n * @param {number} centerX - provide the x value .\n * @param {number} centerY - provide the y value .\n * @private\n */\nfunction createRotationRadians(angle, centerX, centerY) {\n    var result = identityMatrix();\n    var num = Math.sin(angle);\n    var num2 = Math.cos(angle);\n    var offsetX = centerX * (1.0 - num2) + centerY * num;\n    var offsetY = centerY * (1.0 - num2) - centerX * num;\n    result.type = MatrixTypes.Unknown;\n    setMatrix(result, num2, num, -num, num2, offsetX, offsetY);\n    return result;\n}\n/**\n * Multiply the point .\\\n *\n * @returns {void} Multiply the point .\n *\n * @param {Matrix} matrix - Provide the matrix .\n * @param {number} x - provide the x value .\n * @param {number} y - provide the y value .\n * @private\n */\nfunction multiplyPoint(matrix, x, y) {\n    switch (matrix.type) {\n        case MatrixTypes.Identity: break;\n        case MatrixTypes.Translation:\n            x += matrix.offsetX;\n            y += matrix.offsetY;\n            break;\n        case MatrixTypes.Scaling:\n            x *= matrix.m11;\n            y *= matrix.m22;\n            break;\n        case MatrixTypes.Translation | MatrixTypes.Scaling:\n            x *= matrix.m11;\n            x += matrix.offsetX;\n            y *= matrix.m22;\n            y += matrix.offsetY;\n            break;\n        default:\n            // eslint-disable-next-line no-case-declarations\n            var num = y * matrix.m21 + matrix.offsetX;\n            // eslint-disable-next-line no-case-declarations\n            var num2 = x * matrix.m12 + matrix.offsetY;\n            x *= matrix.m11;\n            x += num;\n            y *= matrix.m22;\n            y += num2;\n            break;\n    }\n    return { x: x, y: y };\n}\n/**\n * Will multiply the matrix .\\\n *\n * @returns {void} Will multiply the matrix .\n *\n * @param {Matrix} matrix1 - Provide the matrix 1 value .\n * @param {Matrix} matrix2 - Provide the matrix 2 value .\n * @private\n */\nexport function multiplyMatrix(matrix1, matrix2) {\n    var type = matrix1.type;\n    var type2 = matrix2.type;\n    if (type2 === MatrixTypes.Identity) {\n        return;\n    }\n    if (type === MatrixTypes.Identity) {\n        assignMatrix(matrix1, matrix2);\n        matrix1.type = matrix2.type;\n        return;\n    }\n    if (type2 === MatrixTypes.Translation) {\n        matrix1.offsetX += matrix2.offsetX;\n        matrix1.offsetY += matrix2.offsetY;\n        if (type !== MatrixTypes.Unknown) {\n            matrix1.type |= MatrixTypes.Translation;\n        }\n        return;\n    }\n    if (type !== MatrixTypes.Translation) {\n        var num = type << 4 | type2;\n        switch (num) {\n            case 34:\n                matrix1.m11 *= matrix2.m11;\n                matrix1.m22 *= matrix2.m22;\n                return;\n            case 35:\n                matrix1.m11 *= matrix2.m11;\n                matrix1.m22 *= matrix2.m22;\n                matrix1.offsetX = matrix2.offsetX;\n                matrix1.offsetY = matrix2.offsetY;\n                matrix1.type = (MatrixTypes.Translation | MatrixTypes.Scaling);\n                return;\n            case 36: break;\n            default:\n                {\n                    switch (num) {\n                        case 50:\n                            matrix1.m11 *= matrix2.m11;\n                            matrix1.m22 *= matrix2.m22;\n                            matrix1.offsetX *= matrix2.m11;\n                            matrix1.offsetY *= matrix2.m22;\n                            return;\n                        case 51:\n                            matrix1.m11 *= matrix2.m11;\n                            matrix1.m22 *= matrix2.m22;\n                            matrix1.offsetX = matrix2.m11 * matrix1.offsetX + matrix2.offsetX;\n                            matrix1.offsetY = matrix2.m22 * matrix1.offsetY + matrix2.offsetY;\n                            return;\n                        case 52: break;\n                        default:\n                            switch (num) {\n                                case 66:\n                                case 67:\n                                case 68: break;\n                                default: return;\n                            }\n                            break;\n                    }\n                    break;\n                }\n        }\n        var result = identityMatrix();\n        var m11New = matrix1.m11 * matrix2.m11 + matrix1.m12 * matrix2.m21;\n        var m12New = matrix1.m11 * matrix2.m12 + matrix1.m12 * matrix2.m22;\n        var m21New = matrix1.m21 * matrix2.m11 + matrix1.m22 * matrix2.m21;\n        var m22New = matrix1.m21 * matrix2.m12 + matrix1.m22 * matrix2.m22;\n        var offsetX_1 = matrix1.offsetX * matrix2.m11 + matrix1.offsetY * matrix2.m21 + matrix2.offsetX;\n        var offsetY_1 = matrix1.offsetX * matrix2.m12 + matrix1.offsetY * matrix2.m22 + matrix2.offsetY;\n        setMatrix(result, m11New, m12New, m21New, m22New, offsetX_1, offsetY_1);\n        if (result.m21 || result.m12) {\n            result.type = MatrixTypes.Unknown;\n        }\n        else {\n            if (result.m11 && result.m11 !== 1.0 || result.m22 && result.m22 !== 1.0) {\n                result.type = MatrixTypes.Scaling;\n            }\n            if (result.offsetX || result.offsetY) {\n                result.type |= MatrixTypes.Translation;\n            }\n            if ((result.type & (MatrixTypes.Translation | MatrixTypes.Scaling)) === MatrixTypes.Identity) {\n                result.type = MatrixTypes.Identity;\n            }\n            result.type = MatrixTypes.Scaling | MatrixTypes.Translation;\n        }\n        assignMatrix(matrix1, result);\n        matrix1.type = result.type;\n        return;\n    }\n    var offsetX = matrix1.offsetX;\n    var offsetY = matrix1.offsetY;\n    matrix1.offsetX = offsetX * matrix2.m11 + offsetY * matrix2.m21 + matrix2.offsetX;\n    matrix1.offsetY = offsetX * matrix2.m12 + offsetY * matrix2.m22 + matrix2.offsetY;\n    if (type2 === MatrixTypes.Unknown) {\n        matrix1.type = MatrixTypes.Unknown;\n        return;\n    }\n    matrix1.type = (MatrixTypes.Translation | MatrixTypes.Scaling);\n}\n/**\n * set the matrix .\\\n *\n * @returns {void} set the matrix .\n *\n * @param {Matrix} mat - Provide the matrix 1 value .\n * @param {number} m11 - Provide the matrix m11 value .\n * @param {number} m12 - Provide the matrix m11 value .\n * @param {number} m21 - Provide the matrix m11 value .\n * @param {number} m22 - Provide the matrix m11 value .\n * @param {number} x - Provide the matrix m11 value .\n * @param {number} y - Provide the matrix m11 value .\n * @private\n */\nfunction setMatrix(mat, m11, m12, m21, m22, x, y) {\n    mat.m11 = m11;\n    mat.m12 = m12;\n    mat.m21 = m21;\n    mat.m22 = m22;\n    mat.offsetX = x;\n    mat.offsetY = y;\n}\n/**\n * Assign the matrix .\\\n *\n * @returns {void} Assign the matrix .\n *\n * @param {Matrix} matrix1 - Provide the element type as string .\n * @param {Matrix} matrix2 - Provide the element type as string .\n * @private\n */\nfunction assignMatrix(matrix1, matrix2) {\n    matrix1.m11 = matrix2.m11;\n    matrix1.m12 = matrix2.m12;\n    matrix1.m21 = matrix2.m21;\n    matrix1.m22 = matrix2.m22;\n    matrix1.offsetX = matrix2.offsetX;\n    matrix1.offsetY = matrix2.offsetY;\n    matrix1.type = matrix2.type;\n}\n"]},"metadata":{},"sourceType":"module"}