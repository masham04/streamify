{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Point } from '../primitives/point';\nimport { Rect } from '../primitives/rect';\nimport { intersect3, cloneBlazorObject } from '../utility/diagram-util';\nimport { cloneObject } from '../utility/base-util';\nimport { DiagramEvent } from './../enum/enum';\nimport { contains } from './actions';\nimport { getOppositeDirection } from '../utility/connector';\nimport { StraightSegment, OrthogonalSegment } from '../objects/connector';\nimport { ToolBase } from './tool';\nimport { isBlazor } from '@syncfusion/ej2-base';\n/**\n * Multiple segments editing for Connector\n */\n\nvar ConnectorEditing =\n/** @class */\nfunction (_super) {\n  __extends(ConnectorEditing, _super);\n\n  function ConnectorEditing(commandHandler, endPoint) {\n    var _this = _super.call(this, commandHandler, true) || this;\n\n    _this.endPoint = endPoint;\n    return _this;\n  }\n  /**\n   * mouseDown method\\\n   *\n   * @returns {  void }    mouseDown method .\\\n   * @param {MouseEventArgs} args - provide the args value.\n   * @private\n   */\n\n\n  ConnectorEditing.prototype.mouseDown = function (args) {\n    var connectors;\n    var edit = true;\n\n    if (args.source && args.source.connectors) {\n      connectors = args.source.connectors[0];\n    }\n\n    if (args.info) {\n      edit = args.info.ctrlKey && args.actualObject.type !== 'Orthogonal';\n    }\n\n    if (connectors && edit) {\n      this.inAction = true;\n      this.undoElement = cloneObject(args.source);\n\n      _super.prototype.mouseDown.call(this, args); // Sets the selected segment\n\n\n      for (var i = 0; i < connectors.segments.length; i++) {\n        var segment = connectors.segments[i];\n\n        if (this.endPoint === 'OrthoThumb') {\n          for (var j = 0; j < segment.points.length - 1; j++) {\n            var segPoint = {\n              x: 0,\n              y: 0\n            };\n            segPoint.x = (segment.points[j].x + segment.points[j + 1].x) / 2;\n            segPoint.y = (segment.points[j].y + segment.points[j + 1].y) / 2;\n\n            if (contains(this.currentPosition, segPoint, 30)) {\n              this.selectedSegment = segment;\n              this.segmentIndex = j;\n            }\n          }\n        } else {\n          if (contains(this.currentPosition, segment.point, 10)) {\n            this.selectedSegment = segment;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * mouseMove method\\\n   *\n   * @returns {  void }    mouseMove method .\\\n   * @param {MouseEventArgs} args - provide the args value.\n   * @private\n   */\n\n\n  ConnectorEditing.prototype.mouseMove = function (args) {\n    _super.prototype.mouseMove.call(this, args);\n\n    this.currentPosition = args.position;\n\n    if (this.currentPosition && this.prevPosition) {\n      var diffY = this.currentPosition.y - this.prevPosition.y;\n      var diffX = this.currentPosition.x - this.prevPosition.x;\n      this.currentPosition = this.commandHandler.snapConnectorEnd(this.currentPosition);\n      var connector = void 0;\n\n      if (args.source && args.source.connectors) {\n        connector = args.source.connectors[0];\n      }\n\n      if (this.inAction && this.selectedSegment !== undefined && this.endPoint !== undefined && (diffX !== 0 || diffY !== 0)) {\n        if (this.endPoint === 'OrthoThumb') {\n          this.blocked = !this.dragOrthogonalSegment(connector, this.selectedSegment, this.currentPosition, this.segmentIndex);\n        } else {\n          var tx = this.currentPosition.x - this.selectedSegment.point.x;\n          var ty = this.currentPosition.y - this.selectedSegment.point.y;\n          var index = connector.segments.indexOf(this.selectedSegment);\n          this.blocked = !this.commandHandler.dragControlPoint(connector, tx, ty, false, index);\n        }\n\n        this.commandHandler.updateSelector();\n      }\n    }\n\n    this.prevPosition = this.currentPosition;\n    return !this.blocked;\n  };\n  /**\n   * mouseUp method\\\n   *\n   * @returns {  void }    mouseUp method .\\\n   * @param {MouseEventArgs} args - provide the args value.\n   * @private\n   */\n\n\n  ConnectorEditing.prototype.mouseUp = function (args) {\n    var connector;\n    var oldValues;\n\n    if (args.source && args.source.connectors) {\n      connector = args.source.connectors[0];\n      oldValues = {\n        segments: connector.segments\n      };\n    }\n\n    if (args && args.source && args.info && args.info.ctrlKey && args.info.shiftKey && connector.type === 'Straight') {\n      this.addOrRemoveSegment(connector, this.currentPosition);\n    } else {\n      if (this.endPoint === 'OrthoThumb' && this.selectedSegment) {\n        var index = connector.segments.indexOf(this.selectedSegment);\n        var prev = connector.segments[index - 1];\n        var next = connector.segments[index + 1];\n\n        if (index === connector.segments.length - 2 && this.updateLastSegment(connector, this.selectedSegment)) {\n          connector.segments.splice(connector.segments.length - 2, 1);\n        } else {\n          if (prev && Math.abs(prev.length) < 5) {\n            if (index !== 1) {\n              this.removePrevSegment(connector, index);\n            }\n          } else if (next) {\n            var len = Point.distancePoints(next.points[0], next.points[1]);\n            var length_1 = next.length || next.length === 0 ? next.length : len;\n\n            if (Math.abs(length_1) <= 5) {\n              this.removeNextSegment(connector, index);\n            }\n          }\n        }\n\n        this.commandHandler.updateEndPoint(connector, oldValues);\n      }\n    }\n\n    if (this.undoElement) {\n      //let obj: SelectorModel;\n      var obj = cloneObject(args.source);\n      var entry = {\n        type: 'SegmentChanged',\n        redoObject: obj,\n        undoObject: this.undoElement,\n        category: 'Internal'\n      };\n      this.commandHandler.addHistoryEntry(entry);\n    }\n\n    _super.prototype.mouseUp.call(this, args);\n  };\n\n  ConnectorEditing.prototype.removePrevSegment = function (connector, index) {\n    var first = connector.segments[index - 2];\n    var next = connector.segments[index + 1];\n    var length = next.length || next.length === 0 ? next.length : Point.distancePoints(next.points[0], next.points[1]);\n\n    if (!(length <= 5)) {\n      var removeSegments = connector.segments.slice(index - 1, index + 1);\n      var args = {\n        element: connector,\n        removeSegments: removeSegments,\n        type: 'Removal',\n        cancel: false\n      };\n\n      if (isBlazor()) {\n        args = {\n          element: cloneBlazorObject(connector),\n          removeSegments: cloneBlazorObject(removeSegments),\n          type: 'Removal',\n          cancel: args.cancel\n        };\n      }\n\n      this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);\n\n      if (!args.cancel) {\n        var last = connector.segments[index + 1];\n        connector.segments.splice(index - 1, 2);\n        var segment = this.selectedSegment;\n\n        if (segment.direction === 'Left' || segment.direction === 'Right') {\n          first.points[first.points.length - 1].x = last.points[0].x;\n          last.points[0].y = first.points[first.points.length - 1].y;\n        } else {\n          first.points[first.points.length - 1].y = last.points[0].y;\n          last.points[0].x = first.points[first.points.length - 1].x;\n        }\n\n        if (segment.length || segment.length === 0) {\n          this.findSegmentDirection(first);\n        }\n\n        this.findSegmentDirection(last);\n      }\n    }\n  };\n\n  ConnectorEditing.prototype.findSegmentDirection = function (segment) {\n    if (segment.direction && (segment.length || segment.length === 0)) {\n      segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n      segment.direction = Point.direction(segment.points[0], segment.points[segment.points.length - 1]);\n    }\n  };\n\n  ConnectorEditing.prototype.removeNextSegment = function (connector, index) {\n    var segment = this.selectedSegment;\n    var first = connector.segments[index - 1];\n    var last = connector.segments[index + 2];\n    var next = connector.segments[index + 1]; // eslint-disable-next-line\n\n    var removeSegments;\n    var args;\n\n    if (next.length || next.length === 0) {\n      removeSegments = connector.segments.slice(index, 2);\n      args = {\n        element: connector,\n        removeSegments: removeSegments,\n        type: 'Removal',\n        cancel: false\n      };\n      args = {\n        element: cloneBlazorObject(connector),\n        removeSegments: cloneBlazorObject(removeSegments),\n        type: 'Removal',\n        cancel: false\n      };\n\n      if (isBlazor()) {\n        args = {\n          element: cloneBlazorObject(connector),\n          removeSegments: cloneBlazorObject(removeSegments),\n          type: 'Removal',\n          cancel: false\n        };\n      }\n\n      this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);\n\n      if (!args.cancel) {\n        connector.segments.splice(index, 2);\n\n        if (segment.direction === 'Top' || segment.direction === 'Bottom') {\n          last.points[0].y = segment.points[0].y;\n          first.points[first.points.length - 1].x = last.points[0].x;\n        } else {\n          last.points[0].x = segment.points[0].x;\n          first.points[first.points.length - 1].y = last.points[0].y;\n        }\n      }\n    } else {\n      removeSegments = connector.segments.slice(index + 1, 1);\n      args = {\n        element: connector,\n        removeSegments: removeSegments,\n        type: 'Removal',\n        cancel: false\n      };\n\n      if (isBlazor()) {\n        args = {\n          element: connector,\n          removeSegments: removeSegments,\n          type: 'Removal',\n          cancel: false\n        };\n      }\n\n      this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);\n\n      if (!args.cancel) {\n        connector.segments.splice(index + 1, 1);\n\n        if (segment.direction === 'Top' || segment.direction === 'Bottom') {\n          first.points[first.points.length - 1].x = next.points[next.points.length - 1].x;\n        } else {\n          first.points[first.points.length - 1].y = next.points[next.points.length - 1].y;\n        }\n\n        this.findSegmentDirection(first);\n        segment.length = segment.direction = null;\n      }\n    }\n\n    if (first && last && !args.cancel) {\n      first.length = Point.distancePoints(first.points[0], last.points[0]);\n      first.direction = Point.direction(first.points[0], last.points[0]);\n\n      if (last.length || last.length === 0) {\n        last.length = Point.distancePoints(first.points[first.points.length - 1], last.points[last.points.length - 1]);\n        var point1 = first.points;\n        var point2 = last.points;\n        last.direction = Point.direction(point1[point1.length - 1], point2[point2.length - 1]);\n      }\n    }\n  };\n\n  ConnectorEditing.prototype.addOrRemoveSegment = function (connector, point) {\n    var updateSeg;\n    var segmentIndex;\n    var oldValues = {\n      segments: connector.segments\n    };\n\n    for (var i = 0; i < connector.segments.length; i++) {\n      var segment = connector.segments[i];\n\n      if (contains(point, segment.point, connector.hitPadding)) {\n        segmentIndex = i;\n        updateSeg = true;\n      }\n    }\n\n    if (updateSeg && segmentIndex !== undefined) {\n      if (connector.segments && connector.segments[segmentIndex] && connector.segments[segmentIndex].type === 'Straight') {\n        var segment = connector.segments[segmentIndex];\n        var previous = connector.segments[segmentIndex + 1];\n\n        if (previous) {\n          connector.segments.splice(segmentIndex, 1);\n          previous.points[0] = segment.points[0];\n        }\n      }\n    } else {\n      this.commandHandler.enableServerDataBinding(false);\n      var index = this.findIndex(connector, point);\n\n      if (connector.segments && connector.segments[index] && connector.segments[index].type === 'Straight') {\n        var segment = connector.segments[index];\n        var newseg = new StraightSegment(connector, 'segments', {\n          type: 'Straight',\n          point: point\n        }, true);\n        newseg.points[0] = segment.points[0];\n        newseg.points[1] = point;\n        segment.points[0] = point;\n        connector.segments.splice(index, 0, newseg);\n        updateSeg = true;\n      }\n\n      this.commandHandler.enableServerDataBinding(true);\n    }\n\n    if (updateSeg) {\n      this.commandHandler.updateEndPoint(connector, oldValues);\n    }\n  };\n\n  ConnectorEditing.prototype.findIndex = function (connector, point) {\n    var intersectingSegs = [];\n\n    for (var i = 0; i < connector.segments.length; i++) {\n      var segment = connector.segments[i];\n      var rect = Rect.toBounds([segment.points[0], segment.points[1]]);\n      rect.Inflate(connector.hitPadding);\n\n      if (rect.containsPoint(point)) {\n        intersectingSegs.push(segment);\n      }\n    }\n\n    if (intersectingSegs.length === 1) {\n      return connector.segments.indexOf(intersectingSegs[0]);\n    } else {\n      var ratio = void 0;\n      var min = void 0;\n      var index = void 0;\n      var seg = void 0;\n      var v = void 0;\n      var h = void 0;\n\n      for (var i = 0; i < intersectingSegs.length; i++) {\n        seg = intersectingSegs[i];\n        v = (point.y - seg.points[0].y) / (seg.points[1].y - point.y);\n        h = (point.x - seg.points[0].x) / (seg.points[1].x - point.x);\n        ratio = Math.abs(v - h);\n\n        if (i === 0) {\n          min = ratio;\n          index = 0;\n        }\n\n        if (ratio < min) {\n          min = ratio;\n          index = i;\n        }\n      }\n\n      return connector.segments.indexOf(intersectingSegs[index]);\n    }\n  };\n\n  ConnectorEditing.prototype.dragOrthogonalSegment = function (obj, segment, point, segmentIndex) {\n    var segmentPoint = {\n      x: 0,\n      y: 0\n    };\n    var oldValues = {\n      segments: obj.segments\n    };\n    segmentPoint.x = (segment.points[segmentIndex].x + segment.points[segmentIndex + 1].x) / 2;\n    segmentPoint.y = (segment.points[segmentIndex].y + segment.points[segmentIndex + 1].y) / 2;\n    var ty = point.y - segmentPoint.y;\n    var tx = point.x - segmentPoint.x;\n    var index = obj.segments.indexOf(segment);\n    var update = false; //const orientation: string = (segment.points[0].y.toFixed(2) === segment.points[1].y.toFixed(2)) ? 'horizontal' : 'vertical';\n    //const prevSegment: OrthogonalSegmentModel; const nextSegment: OrthogonalSegmentModel;\n\n    if (index !== -1) {\n      if (index === 0 && obj.segments.length === 1 && segment.points.length === 2) {\n        index = this.addSegments(obj, segment, tx, ty, index);\n        update = true;\n      } else if (index === obj.segments.length - 1 && (segment.direction === null || segment.length === null)) {\n        index = this.addTerminalSegment(obj, segment, tx, ty, segmentIndex);\n        update = true;\n      } else if (index === 0) {\n        index = this.insertFirstSegment(obj, segment, tx, ty, index);\n        update = true;\n      }\n\n      if (index) {\n        if (update) {\n          this.selectedSegment = segment = obj.segments[index];\n          this.segmentIndex = 0;\n        }\n\n        this.updateAdjacentSegments(obj, index, tx, ty);\n        this.commandHandler.updateEndPoint(obj, oldValues);\n      }\n    }\n\n    return true;\n  };\n\n  ConnectorEditing.prototype.addSegments = function (obj, segment, tx, ty, coll) {\n    var index;\n    var segments = []; //let len: number;\n\n    var length = Point.distancePoints(segment.points[0], segment.points[1]);\n    var segmentDirection = Point.direction(segment.points[0], segment.points[1]);\n    segments.push(new OrthogonalSegment(obj, 'segments', {\n      type: 'Orthogonal',\n      direction: segmentDirection,\n      length: length / 4\n    }, true));\n    var direction = segment.points[0].y === segment.points[1].y ? ty > 0 ? 'Bottom' : 'Top' : tx > 0 ? 'Right' : 'Left';\n    var len = segment.points[0].x === segment.points[1].x ? ty : tx;\n    segments.push(new OrthogonalSegment(obj, 'segments', {\n      type: 'Orthogonal',\n      direction: direction,\n      length: len\n    }, true));\n    segments.push(new OrthogonalSegment(obj, 'segments', {\n      type: 'Orthogonal',\n      direction: segmentDirection,\n      length: length / 2\n    }, true));\n    var args = {\n      element: obj,\n      addSegments: segments,\n      type: 'Addition',\n      cancel: false\n    };\n\n    if (isBlazor()) {\n      args = {\n        addSegments: cloneBlazorObject(segments),\n        type: 'Addition',\n        cancel: args.cancel,\n        element: cloneBlazorObject(obj)\n      };\n    }\n\n    this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);\n\n    if (!args.cancel) {\n      obj.segments = segments.concat(obj.segments);\n      index = coll + 2;\n    }\n\n    return index;\n  }; // eslint-disable-next-line\n\n\n  ConnectorEditing.prototype.insertFirstSegment = function (obj, segment, tx, ty, coll) {\n    var direction;\n    var length;\n    var segments = [];\n    var segValues;\n    var index;\n    var insertseg;\n\n    if (obj.sourcePortID && segment.length && obj.segments[0].points.length > 2) {\n      var prev = void 0;\n\n      for (var i = 0; i < segment.points.length - 1; i++) {\n        var len = Point.distancePoints(segment.points[i], segment.points[i + 1]);\n        var dir = Point.direction(segment.points[i], segment.points[i + 1]);\n        insertseg = new OrthogonalSegment(obj, 'segments', {\n          type: 'Orthogonal',\n          direction: dir,\n          length: len\n        }, true);\n\n        if (insertseg.length === 0) {\n          if (prev && (prev.direction === 'Top' || prev.direction === 'Bottom')) {\n            insertseg.direction = tx > 0 ? 'Right' : 'Left';\n          } else {\n            insertseg.direction = ty > 0 ? 'Bottom' : 'Top';\n          }\n        }\n\n        prev = insertseg;\n        segments.push(insertseg);\n      }\n    } else {\n      segValues = {\n        type: 'Orthogonal',\n        direction: segment.direction,\n        length: segment.length / 3\n      };\n      segments.push(new OrthogonalSegment(obj, 'segments', segValues, true));\n\n      if (segment.direction === 'Bottom' || segment.direction === 'Top') {\n        length = Math.abs(tx);\n        direction = tx > 0 ? 'Right' : 'Left';\n      } else {\n        length = Math.abs(ty);\n        direction = ty > 0 ? 'Bottom' : 'Top';\n      }\n\n      insertseg = new OrthogonalSegment(obj, 'segments', {\n        type: 'Orthogonal',\n        direction: direction,\n        length: length\n      }, true);\n      segments.push(insertseg);\n    }\n\n    var args = {\n      element: obj,\n      addSegments: segments,\n      type: 'Addition',\n      cancel: false\n    };\n\n    if (isBlazor()) {\n      args = {\n        element: cloneBlazorObject(obj),\n        addSegments: cloneBlazorObject(segments),\n        type: 'Addition',\n        cancel: args.cancel\n      };\n    }\n\n    this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);\n\n    if (!args.cancel) {\n      if (obj.sourcePortID && segment.length && obj.segments[0].points.length > 2) {\n        obj.segments.splice(0, 1);\n        index = 1;\n      } else {\n        var nextseg = obj.segments[1];\n\n        if (nextseg && nextseg.length) {\n          nextseg.length = direction !== nextseg.direction ? nextseg.length + length : nextseg.length - length;\n        }\n\n        index = 2;\n        segment.length = 2 * segment.length / 3;\n      }\n\n      obj.segments = segments.concat(obj.segments);\n    }\n\n    return index;\n  };\n\n  ConnectorEditing.prototype.updateAdjacentSegments = function (obj, index, tx, ty) {\n    var current = obj.segments[index];\n    var endPoint = current.points[current.points.length - 1];\n    var startPoint = current.points[0];\n    var isNextUpdate = true;\n\n    if (current.type === 'Orthogonal') {\n      current.points[0] = startPoint;\n      current.points[current.points.length - 1] = endPoint;\n      var prev = obj.segments[index - 1];\n\n      if (prev) {\n        isNextUpdate = this.updatePreviousSegment(tx, ty, obj, index);\n      }\n\n      if (obj.segments.length - 1 > index && isNextUpdate) {\n        var nextSegment = obj.segments[index + 1];\n        this.updateNextSegment(obj, current, nextSegment, tx, ty);\n      }\n    }\n  };\n\n  ConnectorEditing.prototype.addTerminalSegment = function (connector, segment, tx, ty, segmentIndex) {\n    //const oldValues: Connector = { segments: connector.segments } as Connector;\n    var index = connector.segments.indexOf(segment);\n    var first;\n    var insertseg;\n    var len;\n    var dir;\n    var segments = [];\n    var removeSegment = connector.segments.pop();\n    var last = connector.segments[connector.segments.length - 1];\n    first = last && last.type === 'Orthogonal' ? last : null;\n\n    for (var i = 0; i < segment.points.length - 2; i++) {\n      len = Point.distancePoints(segment.points[i], segment.points[i + 1]);\n      dir = Point.direction(segment.points[i], segment.points[i + 1]);\n      insertseg = new OrthogonalSegment(connector, 'segments', {\n        type: 'Orthogonal',\n        length: len,\n        direction: dir\n      }, true);\n      segments.push(insertseg);\n      first = insertseg;\n    }\n\n    var sec = segmentIndex;\n\n    if (segment.points.length === 2 || sec === segment.points.length - 2) {\n      if (first) {\n        first.length += 5;\n      }\n\n      if (sec !== undefined) {\n        //let newseg: OrthogonalSegment;\n        len = 2 * Point.distancePoints(segment.points[segment.points.length - 2], segment.points[segment.points.length - 1]) / 3;\n        dir = Point.direction(segment.points[segment.points.length - 2], segment.points[segment.points.length - 1]);\n        var newseg = new OrthogonalSegment(connector, 'segments', {\n          type: 'Orthogonal',\n          length: len,\n          direction: dir\n        });\n        segments.push(newseg);\n      }\n    }\n\n    var lastseg = new OrthogonalSegment(connector, 'segments', {\n      type: 'Orthogonal'\n    }, true);\n    segments.push(lastseg);\n    var args = {\n      element: connector,\n      addSegments: segments,\n      type: 'Addition',\n      cancel: false\n    };\n    var args1;\n    args1 = {\n      element: cloneBlazorObject(connector),\n      addSegments: cloneBlazorObject(segments),\n      type: 'Addition',\n      cancel: args.cancel\n    };\n\n    if (isBlazor()) {\n      args1 = {\n        element: cloneBlazorObject(connector),\n        addSegments: cloneBlazorObject(segments),\n        type: 'Addition',\n        cancel: args.cancel\n      };\n    }\n\n    this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args1);\n\n    if (!args1.cancel) {\n      connector.segments = connector.segments.concat(segments);\n      index = index + segmentIndex;\n    } else {\n      connector.segments.push(removeSegment);\n    }\n\n    this.commandHandler.updateEndPoint(connector);\n    return index;\n  }; // eslint-disable-next-line\n\n\n  ConnectorEditing.prototype.updatePortSegment = function (prev, connector, index, tx, ty) {\n    if (index === 1 && prev.points.length === 2 && prev.length < 0) {\n      var source = connector.sourceWrapper.corners;\n      var current = connector.segments[index];\n      var next = connector.segments[index + 1];\n      var newseg = void 0;\n      var segment = [];\n      newseg = new OrthogonalSegment(connector, 'segments', {\n        type: 'Orthogonal',\n        length: 13,\n        direction: prev.direction\n      });\n      segment.push(newseg);\n      var len = void 0;\n\n      if (current.direction === 'Left') {\n        len = current.points[0].x - (source.middleLeft.x - 20);\n      } else if (current.direction === 'Right') {\n        len = source.middleRight.x + 20 - current.points[0].x;\n      } else if (current.direction === 'Bottom') {\n        len = source.bottomCenter.y + 20 - current.points[0].y;\n      } else {\n        len = current.points[0].y - (source.topCenter.y - 20);\n      } //const dir: Direction = current.direction;\n\n\n      newseg = new OrthogonalSegment(connector, 'segments', {\n        type: 'Orthogonal',\n        length: len,\n        direction: current.direction\n      });\n      segment.push(newseg);\n      current.length = current.length - len;\n\n      if (next && next.length && next.direction) {\n        if (next.direction === prev.direction) {\n          next.length -= 13;\n        } else if (next.direction === getOppositeDirection(prev.direction)) {\n          next.length += 13;\n        }\n      }\n\n      connector.segments = segment.concat(connector.segments);\n      this.selectedSegment = connector.segments[3];\n    }\n  };\n\n  ConnectorEditing.prototype.updatePreviousSegment = function (tx, ty, connector, index) {\n    var current = connector.segments[index];\n    var prev = connector.segments[index - 1]; //const firstSegment: boolean = (index === 1) ? true : false;\n\n    prev.points[prev.points.length - 1] = current.points[0];\n    var isSourceNode = connector.sourceID && connector.sourcePortID === '' ? false : true;\n    var isNextUpdate = true;\n\n    if (prev.type === 'Orthogonal') {\n      if (prev.direction === 'Bottom') {\n        prev.length += ty;\n      } else if (prev.direction === 'Top') {\n        prev.length -= ty;\n      } else if (prev.direction === 'Right') {\n        prev.length += tx;\n      } else {\n        prev.length -= tx;\n      }\n\n      if (connector.sourcePortID !== '' && prev.length < 0) {\n        this.updatePortSegment(prev, connector, index, tx, ty);\n      } else if (connector.sourceID && connector.sourcePortID === '' && prev.length < 0 && index === 1) {\n        isNextUpdate = false;\n        this.updateFirstSegment(connector, current);\n      }\n\n      if (isSourceNode) {\n        this.changeSegmentDirection(prev);\n      }\n    }\n\n    return isNextUpdate;\n  };\n\n  ConnectorEditing.prototype.changeSegmentDirection = function (segment) {\n    if (segment.length < 0) {\n      segment.direction = getOppositeDirection(segment.direction);\n      segment.length *= -1;\n    }\n  };\n\n  ConnectorEditing.prototype.updateNextSegment = function (obj, current, next, tx, ty) {\n    next.points[0] = current.points[current.points.length - 1];\n\n    if (next && next.type === 'Orthogonal') {\n      if (next.length || next.length === 0) {\n        if (next.direction === 'Left' || next.direction === 'Right') {\n          if (tx !== 0) {\n            next.length = next.direction === 'Right' ? next.length - tx : next.length + tx;\n\n            if (next.length || next.length === 0) {\n              this.changeSegmentDirection(next);\n            }\n          }\n        } else {\n          if (ty !== 0) {\n            next.length = next.direction === 'Bottom' ? next.length - ty : next.length + ty;\n\n            if (next.length || next.length === 0) {\n              this.changeSegmentDirection(next);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  ConnectorEditing.prototype.updateFirstSegment = function (connector, selectedSegment) {\n    var index = connector.segments.indexOf(selectedSegment);\n    var insertfirst = false;\n    var current = connector.segments[index];\n    var prev = connector.segments[index - 1];\n    var con = connector;\n    var sourcePoint;\n    var oldValues = {\n      segments: connector.segments\n    };\n\n    if (prev.length < 0 && connector.sourceID) {\n      var sourceNode = connector.sourceWrapper.corners;\n      var segments = [];\n      var segValues = void 0;\n      var removeCurrentPrev = false;\n      this.changeSegmentDirection(current);\n      var next = connector.segments[index + 1];\n      var nextNext = connector.segments[index + 2];\n\n      if (next) {\n        this.changeSegmentDirection(next);\n      }\n\n      if (nextNext) {\n        this.changeSegmentDirection(nextNext);\n      }\n\n      switch (prev.direction) {\n        case 'Top':\n        case 'Bottom':\n          sourcePoint = current.length > 0 && current.direction === 'Left' ? sourceNode.middleLeft : sourceNode.middleRight;\n\n          if (current.length > sourceNode.width / 2) {\n            if (Math.abs(prev.length) < sourceNode.height / 2) {\n              prev.length = Point.distancePoints(sourceNode.center, prev.points[prev.points.length - 1]);\n              current.points[0].x = sourcePoint.x;\n              current.length = Point.distancePoints(current.points[0], current.points[current.points.length - 1]);\n              current.length -= 20;\n              insertfirst = true;\n            }\n          } else {\n            if (next && next.direction && next.length) {\n              next.points[0].y = sourcePoint.y;\n              next.points[0].x = next.points[next.points.length - 1].x = current.direction === 'Right' ? sourcePoint.x + 20 : sourcePoint.x - 20;\n            }\n\n            insertfirst = true;\n            removeCurrentPrev = true;\n          }\n\n          break;\n\n        case 'Left':\n        case 'Right':\n          sourcePoint = current.length > 0 && current.direction === 'Top' ? sourceNode.topCenter : sourceNode.bottomCenter;\n\n          if (current.length > sourceNode.height / 2) {\n            if (Math.abs(prev.length) < sourceNode.width / 2) {\n              prev.length = Point.distancePoints(sourceNode.center, prev.points[prev.points.length - 1]);\n              current.points[0].y = sourcePoint.y;\n              current.length = Point.distancePoints(current.points[0], current.points[current.points.length - 1]);\n              current.length -= 20;\n              insertfirst = true;\n            }\n          } else {\n            if (next && next.direction && next.length) {\n              next.points[0].x = sourcePoint.x;\n              next.points[0].y = next.points[next.points.length - 1].y = current.direction === 'Bottom' ? sourcePoint.y + 20 : sourcePoint.y - 20;\n            }\n\n            insertfirst = true;\n            removeCurrentPrev = true;\n          }\n\n          break;\n      }\n\n      this.changeSegmentDirection(prev);\n      this.changeSegmentDirection(current);\n\n      if (insertfirst) {\n        segValues = {\n          type: 'Orthogonal',\n          direction: current.direction,\n          length: 20\n        };\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n\n        if (removeCurrentPrev) {\n          if (next && next.direction && next.length) {\n            next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n          }\n\n          if (nextNext && nextNext.direction && nextNext.length) {\n            nextNext.length = Point.distancePoints(next.points[next.points.length - 1], nextNext.points[nextNext.points.length - 1]);\n          }\n\n          connector.segments.splice(index - 1, 2);\n        }\n\n        connector.segments = segments.concat(connector.segments);\n      }\n\n      this.selectedSegment = removeCurrentPrev ? connector.segments[index - 1] : connector.segments[index + 1];\n      this.commandHandler.updateEndPoint(connector, oldValues);\n    }\n  };\n\n  ConnectorEditing.prototype.updateLastSegment = function (connector, selectedSegment) {\n    if (connector.targetID && connector.targetPortID === '') {\n      var line1Start = void 0;\n      var line1End = void 0;\n      var line2Start = void 0;\n      var line2End = void 0;\n      var corners = connector.targetWrapper.corners;\n      var firstSegPoint = selectedSegment.points[0];\n      var lastSegPoint = selectedSegment.points[selectedSegment.points.length - 1];\n\n      if (selectedSegment.direction === 'Right' || selectedSegment.direction === 'Left') {\n        line1Start = {\n          x: firstSegPoint.x,\n          y: firstSegPoint.y\n        };\n        line1End = {\n          x: selectedSegment.direction === 'Left' ? lastSegPoint.x - corners.width / 2 : lastSegPoint.x + corners.width / 2,\n          y: lastSegPoint.y\n        };\n        line2Start = {\n          x: corners.center.x,\n          y: corners.center.y - corners.height\n        };\n        line2End = {\n          x: corners.center.x,\n          y: corners.center.y + corners.height\n        };\n      } else {\n        line1Start = {\n          x: firstSegPoint.x,\n          y: firstSegPoint.y\n        };\n        line1End = {\n          x: lastSegPoint.x,\n          y: selectedSegment.direction === 'Bottom' ? lastSegPoint.y + corners.height / 2 : lastSegPoint.y - corners.height / 2\n        };\n        line2Start = {\n          x: corners.center.x - corners.width,\n          y: corners.center.y\n        };\n        line2End = {\n          x: corners.center.x + corners.width,\n          y: corners.center.y\n        };\n      }\n\n      var line1 = {\n        x1: line1Start.x,\n        y1: line1Start.y,\n        x2: line1End.x,\n        y2: line1End.y\n      };\n      var line2 = {\n        x1: line2Start.x,\n        y1: line2Start.y,\n        x2: line2End.x,\n        y2: line2End.y\n      };\n      return intersect3(line1, line2).enabled;\n    }\n\n    return false;\n  };\n  /**\n   *To destroy the module\n   *\n   * @returns {void} To destroy the module\n   */\n\n\n  ConnectorEditing.prototype.destroy = function () {\n    /**\n     * Destroys the connector editing module\n     */\n  };\n  /**\n   * Get module name.\n   */\n\n  /**\n   * Get module name.\\\n   *\n   * @returns {  string  }    Get module name.\\\n   */\n\n\n  ConnectorEditing.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'ConnectorEditingTool';\n  };\n\n  return ConnectorEditing;\n}(ToolBase);\n\nexport { ConnectorEditing };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/connector-editing.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Point","Rect","intersect3","cloneBlazorObject","cloneObject","DiagramEvent","contains","getOppositeDirection","StraightSegment","OrthogonalSegment","ToolBase","isBlazor","ConnectorEditing","_super","commandHandler","endPoint","_this","call","mouseDown","args","connectors","edit","source","info","ctrlKey","actualObject","type","inAction","undoElement","i","segments","length","segment","j","points","segPoint","x","y","currentPosition","selectedSegment","segmentIndex","point","mouseMove","position","prevPosition","diffY","diffX","snapConnectorEnd","connector","undefined","blocked","dragOrthogonalSegment","tx","ty","index","indexOf","dragControlPoint","updateSelector","mouseUp","oldValues","shiftKey","addOrRemoveSegment","prev","next","updateLastSegment","splice","Math","abs","removePrevSegment","len","distancePoints","length_1","removeNextSegment","updateEndPoint","obj","entry","redoObject","undoObject","category","addHistoryEntry","first","removeSegments","slice","element","cancel","triggerEvent","segmentCollectionChange","last","direction","findSegmentDirection","point1","point2","updateSeg","hitPadding","previous","enableServerDataBinding","findIndex","newseg","intersectingSegs","rect","toBounds","Inflate","containsPoint","push","ratio","min","seg","v","h","segmentPoint","update","addSegments","addTerminalSegment","insertFirstSegment","updateAdjacentSegments","coll","segmentDirection","concat","segValues","insertseg","sourcePortID","dir","nextseg","current","startPoint","isNextUpdate","updatePreviousSegment","nextSegment","updateNextSegment","removeSegment","pop","sec","lastseg","args1","updatePortSegment","sourceWrapper","corners","middleLeft","middleRight","bottomCenter","topCenter","isSourceNode","sourceID","updateFirstSegment","changeSegmentDirection","insertfirst","con","sourcePoint","sourceNode","removeCurrentPrev","nextNext","width","height","center","targetID","targetPortID","line1Start","line1End","line2Start","line2End","targetWrapper","firstSegPoint","lastSegPoint","line1","x1","y1","x2","y2","line2","enabled","destroy","getModuleName"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Point } from '../primitives/point';\nimport { Rect } from '../primitives/rect';\nimport { intersect3, cloneBlazorObject } from '../utility/diagram-util';\nimport { cloneObject } from '../utility/base-util';\nimport { DiagramEvent } from './../enum/enum';\nimport { contains } from './actions';\nimport { getOppositeDirection } from '../utility/connector';\nimport { StraightSegment, OrthogonalSegment } from '../objects/connector';\nimport { ToolBase } from './tool';\nimport { isBlazor } from '@syncfusion/ej2-base';\n/**\n * Multiple segments editing for Connector\n */\nvar ConnectorEditing = /** @class */ (function (_super) {\n    __extends(ConnectorEditing, _super);\n    function ConnectorEditing(commandHandler, endPoint) {\n        var _this = _super.call(this, commandHandler, true) || this;\n        _this.endPoint = endPoint;\n        return _this;\n    }\n    /**\n     * mouseDown method\\\n     *\n     * @returns {  void }    mouseDown method .\\\n     * @param {MouseEventArgs} args - provide the args value.\n     * @private\n     */\n    ConnectorEditing.prototype.mouseDown = function (args) {\n        var connectors;\n        var edit = true;\n        if (args.source && args.source.connectors) {\n            connectors = args.source.connectors[0];\n        }\n        if (args.info) {\n            edit = args.info.ctrlKey && args.actualObject.type !== 'Orthogonal';\n        }\n        if (connectors && edit) {\n            this.inAction = true;\n            this.undoElement = cloneObject(args.source);\n            _super.prototype.mouseDown.call(this, args);\n            // Sets the selected segment\n            for (var i = 0; i < connectors.segments.length; i++) {\n                var segment = connectors.segments[i];\n                if (this.endPoint === 'OrthoThumb') {\n                    for (var j = 0; j < segment.points.length - 1; j++) {\n                        var segPoint = { x: 0, y: 0 };\n                        segPoint.x = ((segment.points[j].x + segment.points[j + 1].x) / 2);\n                        segPoint.y = ((segment.points[j].y + segment.points[j + 1].y) / 2);\n                        if (contains(this.currentPosition, segPoint, 30)) {\n                            this.selectedSegment = segment;\n                            this.segmentIndex = j;\n                        }\n                    }\n                }\n                else {\n                    if (contains(this.currentPosition, segment.point, 10)) {\n                        this.selectedSegment = segment;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * mouseMove method\\\n     *\n     * @returns {  void }    mouseMove method .\\\n     * @param {MouseEventArgs} args - provide the args value.\n     * @private\n     */\n    ConnectorEditing.prototype.mouseMove = function (args) {\n        _super.prototype.mouseMove.call(this, args);\n        this.currentPosition = args.position;\n        if (this.currentPosition && this.prevPosition) {\n            var diffY = this.currentPosition.y - this.prevPosition.y;\n            var diffX = this.currentPosition.x - this.prevPosition.x;\n            this.currentPosition = this.commandHandler.snapConnectorEnd(this.currentPosition);\n            var connector = void 0;\n            if (args.source && args.source.connectors) {\n                connector = args.source.connectors[0];\n            }\n            if ((this.inAction && this.selectedSegment !== undefined && this.endPoint !== undefined) && (diffX !== 0 || diffY !== 0)) {\n                if (this.endPoint === 'OrthoThumb') {\n                    this.blocked = !this.dragOrthogonalSegment(connector, this.selectedSegment, this.currentPosition, this.segmentIndex);\n                }\n                else {\n                    var tx = this.currentPosition.x - this.selectedSegment.point.x;\n                    var ty = this.currentPosition.y - this.selectedSegment.point.y;\n                    var index = connector.segments.indexOf(this.selectedSegment);\n                    this.blocked = !this.commandHandler.dragControlPoint(connector, tx, ty, false, index);\n                }\n                this.commandHandler.updateSelector();\n            }\n        }\n        this.prevPosition = this.currentPosition;\n        return !this.blocked;\n    };\n    /**\n     * mouseUp method\\\n     *\n     * @returns {  void }    mouseUp method .\\\n     * @param {MouseEventArgs} args - provide the args value.\n     * @private\n     */\n    ConnectorEditing.prototype.mouseUp = function (args) {\n        var connector;\n        var oldValues;\n        if (args.source && args.source.connectors) {\n            connector = args.source.connectors[0];\n            oldValues = { segments: connector.segments };\n        }\n        if (args && args.source && args.info && args.info.ctrlKey && args.info.shiftKey && connector.type === 'Straight') {\n            this.addOrRemoveSegment(connector, this.currentPosition);\n        }\n        else {\n            if (this.endPoint === 'OrthoThumb' && this.selectedSegment) {\n                var index = connector.segments.indexOf(this.selectedSegment);\n                var prev = connector.segments[index - 1];\n                var next = connector.segments[index + 1];\n                if (index === connector.segments.length - 2\n                    && this.updateLastSegment(connector, this.selectedSegment)) {\n                    connector.segments.splice(connector.segments.length - 2, 1);\n                }\n                else {\n                    if (prev && Math.abs(prev.length) < 5) {\n                        if (index !== 1) {\n                            this.removePrevSegment(connector, index);\n                        }\n                    }\n                    else if (next) {\n                        var len = Point.distancePoints(next.points[0], next.points[1]);\n                        var length_1 = ((next.length || next.length === 0) ? next.length : len);\n                        if ((Math.abs(length_1) <= 5)) {\n                            this.removeNextSegment(connector, index);\n                        }\n                    }\n                }\n                this.commandHandler.updateEndPoint(connector, oldValues);\n            }\n        }\n        if (this.undoElement) {\n            //let obj: SelectorModel;\n            var obj = cloneObject(args.source);\n            var entry = {\n                type: 'SegmentChanged', redoObject: obj, undoObject: this.undoElement, category: 'Internal'\n            };\n            this.commandHandler.addHistoryEntry(entry);\n        }\n        _super.prototype.mouseUp.call(this, args);\n    };\n    ConnectorEditing.prototype.removePrevSegment = function (connector, index) {\n        var first = connector.segments[index - 2];\n        var next = connector.segments[index + 1];\n        var length = (next.length || next.length === 0) ? next.length : Point.distancePoints(next.points[0], next.points[1]);\n        if (!(length <= 5)) {\n            var removeSegments = connector.segments.slice(index - 1, index + 1);\n            var args = {\n                element: connector, removeSegments: removeSegments, type: 'Removal', cancel: false\n            };\n            if (isBlazor()) {\n                args = {\n                    element: cloneBlazorObject(connector), removeSegments: cloneBlazorObject(removeSegments),\n                    type: 'Removal', cancel: args.cancel\n                };\n            }\n            this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);\n            if (!args.cancel) {\n                var last = connector.segments[index + 1];\n                connector.segments.splice(index - 1, 2);\n                var segment = this.selectedSegment;\n                if (segment.direction === 'Left' || segment.direction === 'Right') {\n                    first.points[first.points.length - 1].x = last.points[0].x;\n                    last.points[0].y = first.points[first.points.length - 1].y;\n                }\n                else {\n                    first.points[first.points.length - 1].y = last.points[0].y;\n                    last.points[0].x = first.points[first.points.length - 1].x;\n                }\n                if (segment.length || segment.length === 0) {\n                    this.findSegmentDirection(first);\n                }\n                this.findSegmentDirection(last);\n            }\n        }\n    };\n    ConnectorEditing.prototype.findSegmentDirection = function (segment) {\n        if (segment.direction && (segment.length || segment.length === 0)) {\n            segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n            segment.direction = Point.direction(segment.points[0], segment.points[segment.points.length - 1]);\n        }\n    };\n    ConnectorEditing.prototype.removeNextSegment = function (connector, index) {\n        var segment = this.selectedSegment;\n        var first = connector.segments[index - 1];\n        var last = connector.segments[index + 2];\n        var next = connector.segments[index + 1];\n        // eslint-disable-next-line\n        var removeSegments;\n        var args;\n        if (next.length || next.length === 0) {\n            removeSegments = connector.segments.slice(index, 2);\n            args = {\n                element: connector, removeSegments: removeSegments, type: 'Removal', cancel: false\n            };\n            args = {\n                element: cloneBlazorObject(connector), removeSegments: cloneBlazorObject(removeSegments),\n                type: 'Removal', cancel: false\n            };\n            if (isBlazor()) {\n                args = {\n                    element: cloneBlazorObject(connector), removeSegments: cloneBlazorObject(removeSegments),\n                    type: 'Removal', cancel: false\n                };\n            }\n            this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);\n            if (!args.cancel) {\n                connector.segments.splice(index, 2);\n                if (segment.direction === 'Top' || segment.direction === 'Bottom') {\n                    last.points[0].y = segment.points[0].y;\n                    first.points[first.points.length - 1].x = last.points[0].x;\n                }\n                else {\n                    last.points[0].x = segment.points[0].x;\n                    first.points[first.points.length - 1].y = last.points[0].y;\n                }\n            }\n        }\n        else {\n            removeSegments = connector.segments.slice(index + 1, 1);\n            args = {\n                element: connector, removeSegments: removeSegments, type: 'Removal', cancel: false\n            };\n            if (isBlazor()) {\n                args = {\n                    element: connector, removeSegments: removeSegments, type: 'Removal', cancel: false\n                };\n            }\n            this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);\n            if (!args.cancel) {\n                connector.segments.splice(index + 1, 1);\n                if (segment.direction === 'Top' || segment.direction === 'Bottom') {\n                    first.points[first.points.length - 1].x = next.points[next.points.length - 1].x;\n                }\n                else {\n                    first.points[first.points.length - 1].y = next.points[next.points.length - 1].y;\n                }\n                this.findSegmentDirection(first);\n                segment.length = segment.direction = null;\n            }\n        }\n        if (first && last && !args.cancel) {\n            first.length = Point.distancePoints(first.points[0], last.points[0]);\n            first.direction = Point.direction(first.points[0], last.points[0]);\n            if (last.length || last.length === 0) {\n                last.length = Point.distancePoints(first.points[first.points.length - 1], last.points[last.points.length - 1]);\n                var point1 = first.points;\n                var point2 = last.points;\n                last.direction = Point.direction(point1[point1.length - 1], point2[point2.length - 1]);\n            }\n        }\n    };\n    ConnectorEditing.prototype.addOrRemoveSegment = function (connector, point) {\n        var updateSeg;\n        var segmentIndex;\n        var oldValues = { segments: connector.segments };\n        for (var i = 0; i < connector.segments.length; i++) {\n            var segment = (connector.segments)[i];\n            if (contains(point, segment.point, connector.hitPadding)) {\n                segmentIndex = i;\n                updateSeg = true;\n            }\n        }\n        if (updateSeg && segmentIndex !== undefined) {\n            if (connector.segments && connector.segments[segmentIndex] && connector.segments[segmentIndex].type === 'Straight') {\n                var segment = connector.segments[segmentIndex];\n                var previous = connector.segments[segmentIndex + 1];\n                if (previous) {\n                    connector.segments.splice(segmentIndex, 1);\n                    previous.points[0] = segment.points[0];\n                }\n            }\n        }\n        else {\n            this.commandHandler.enableServerDataBinding(false);\n            var index = this.findIndex(connector, point);\n            if (connector.segments && connector.segments[index] && connector.segments[index].type === 'Straight') {\n                var segment = connector.segments[index];\n                var newseg = new StraightSegment(connector, 'segments', { type: 'Straight', point: point }, true);\n                newseg.points[0] = segment.points[0];\n                newseg.points[1] = point;\n                segment.points[0] = point;\n                connector.segments.splice(index, 0, newseg);\n                updateSeg = true;\n            }\n            this.commandHandler.enableServerDataBinding(true);\n        }\n        if (updateSeg) {\n            this.commandHandler.updateEndPoint(connector, oldValues);\n        }\n    };\n    ConnectorEditing.prototype.findIndex = function (connector, point) {\n        var intersectingSegs = [];\n        for (var i = 0; i < connector.segments.length; i++) {\n            var segment = connector.segments[i];\n            var rect = Rect.toBounds([segment.points[0], segment.points[1]]);\n            rect.Inflate(connector.hitPadding);\n            if (rect.containsPoint(point)) {\n                intersectingSegs.push(segment);\n            }\n        }\n        if (intersectingSegs.length === 1) {\n            return connector.segments.indexOf(intersectingSegs[0]);\n        }\n        else {\n            var ratio = void 0;\n            var min = void 0;\n            var index = void 0;\n            var seg = void 0;\n            var v = void 0;\n            var h = void 0;\n            for (var i = 0; i < intersectingSegs.length; i++) {\n                seg = intersectingSegs[i];\n                v = (point.y - seg.points[0].y) / (seg.points[1].y - point.y);\n                h = (point.x - seg.points[0].x) / (seg.points[1].x - point.x);\n                ratio = Math.abs(v - h);\n                if (i === 0) {\n                    min = ratio;\n                    index = 0;\n                }\n                if (ratio < min) {\n                    min = ratio;\n                    index = i;\n                }\n            }\n            return connector.segments.indexOf(intersectingSegs[index]);\n        }\n    };\n    ConnectorEditing.prototype.dragOrthogonalSegment = function (obj, segment, point, segmentIndex) {\n        var segmentPoint = { x: 0, y: 0 };\n        var oldValues = { segments: obj.segments };\n        segmentPoint.x = ((segment.points[segmentIndex].x + segment.points[segmentIndex + 1].x) / 2);\n        segmentPoint.y = ((segment.points[segmentIndex].y + segment.points[segmentIndex + 1].y) / 2);\n        var ty = point.y - segmentPoint.y;\n        var tx = point.x - segmentPoint.x;\n        var index = obj.segments.indexOf(segment);\n        var update = false;\n        //const orientation: string = (segment.points[0].y.toFixed(2) === segment.points[1].y.toFixed(2)) ? 'horizontal' : 'vertical';\n        //const prevSegment: OrthogonalSegmentModel; const nextSegment: OrthogonalSegmentModel;\n        if (index !== -1) {\n            if (index === 0 && obj.segments.length === 1 && segment.points.length === 2) {\n                index = this.addSegments(obj, segment, tx, ty, index);\n                update = true;\n            }\n            else if (index === obj.segments.length - 1 && (segment.direction === null || segment.length === null)) {\n                index = this.addTerminalSegment(obj, segment, tx, ty, segmentIndex);\n                update = true;\n            }\n            else if (index === 0) {\n                index = this.insertFirstSegment(obj, segment, tx, ty, index);\n                update = true;\n            }\n            if (index) {\n                if (update) {\n                    this.selectedSegment = segment = obj.segments[index];\n                    this.segmentIndex = 0;\n                }\n                this.updateAdjacentSegments(obj, index, tx, ty);\n                this.commandHandler.updateEndPoint(obj, oldValues);\n            }\n        }\n        return true;\n    };\n    ConnectorEditing.prototype.addSegments = function (obj, segment, tx, ty, coll) {\n        var index;\n        var segments = []; //let len: number;\n        var length = Point.distancePoints(segment.points[0], segment.points[1]);\n        var segmentDirection = Point.direction(segment.points[0], segment.points[1]);\n        segments.push(new OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: segmentDirection, length: length / 4 }, true));\n        var direction = (segment.points[0].y === segment.points[1].y) ? ((ty > 0) ? 'Bottom' : 'Top') : ((tx > 0) ? 'Right' : 'Left');\n        var len = (segment.points[0].x === segment.points[1].x) ? ty : tx;\n        segments.push(new OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: direction, length: len }, true));\n        segments.push(new OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: segmentDirection, length: length / 2 }, true));\n        var args = {\n            element: obj, addSegments: segments, type: 'Addition', cancel: false\n        };\n        if (isBlazor()) {\n            args = {\n                addSegments: cloneBlazorObject(segments), type: 'Addition',\n                cancel: args.cancel, element: cloneBlazorObject(obj)\n            };\n        }\n        this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);\n        if (!args.cancel) {\n            obj.segments = segments.concat(obj.segments);\n            index = coll + 2;\n        }\n        return index;\n    };\n    // eslint-disable-next-line\n    ConnectorEditing.prototype.insertFirstSegment = function (obj, segment, tx, ty, coll) {\n        var direction;\n        var length;\n        var segments = [];\n        var segValues;\n        var index;\n        var insertseg;\n        if (obj.sourcePortID && segment.length && obj.segments[0].points.length > 2) {\n            var prev = void 0;\n            for (var i = 0; i < segment.points.length - 1; i++) {\n                var len = Point.distancePoints(segment.points[i], segment.points[i + 1]);\n                var dir = Point.direction(segment.points[i], segment.points[i + 1]);\n                insertseg = new OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: dir, length: len }, true);\n                if (insertseg.length === 0) {\n                    if (prev && (prev.direction === 'Top' || prev.direction === 'Bottom')) {\n                        insertseg.direction = tx > 0 ? 'Right' : 'Left';\n                    }\n                    else {\n                        insertseg.direction = ty > 0 ? 'Bottom' : 'Top';\n                    }\n                }\n                prev = insertseg;\n                segments.push(insertseg);\n            }\n        }\n        else {\n            segValues = { type: 'Orthogonal', direction: segment.direction, length: segment.length / 3 };\n            segments.push(new OrthogonalSegment(obj, 'segments', segValues, true));\n            if (segment.direction === 'Bottom' || segment.direction === 'Top') {\n                length = Math.abs(tx);\n                direction = tx > 0 ? 'Right' : 'Left';\n            }\n            else {\n                length = Math.abs(ty);\n                direction = ty > 0 ? 'Bottom' : 'Top';\n            }\n            insertseg = new OrthogonalSegment(obj, 'segments', { type: 'Orthogonal', direction: direction, length: length }, true);\n            segments.push(insertseg);\n        }\n        var args = {\n            element: obj, addSegments: segments, type: 'Addition', cancel: false\n        };\n        if (isBlazor()) {\n            args = {\n                element: cloneBlazorObject(obj), addSegments: cloneBlazorObject(segments), type: 'Addition',\n                cancel: args.cancel\n            };\n        }\n        this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args);\n        if (!args.cancel) {\n            if (obj.sourcePortID && segment.length && obj.segments[0].points.length > 2) {\n                obj.segments.splice(0, 1);\n                index = 1;\n            }\n            else {\n                var nextseg = obj.segments[1];\n                if (nextseg && nextseg.length) {\n                    nextseg.length = (direction !== nextseg.direction) ? nextseg.length + length : nextseg.length - length;\n                }\n                index = 2;\n                segment.length = 2 * segment.length / 3;\n            }\n            obj.segments = segments.concat(obj.segments);\n        }\n        return index;\n    };\n    ConnectorEditing.prototype.updateAdjacentSegments = function (obj, index, tx, ty) {\n        var current = obj.segments[index];\n        var endPoint = current.points[current.points.length - 1];\n        var startPoint = current.points[0];\n        var isNextUpdate = true;\n        if (current.type === 'Orthogonal') {\n            current.points[0] = startPoint;\n            current.points[current.points.length - 1] = endPoint;\n            var prev = obj.segments[index - 1];\n            if (prev) {\n                isNextUpdate = this.updatePreviousSegment(tx, ty, obj, index);\n            }\n            if (obj.segments.length - 1 > index && isNextUpdate) {\n                var nextSegment = obj.segments[index + 1];\n                this.updateNextSegment(obj, current, nextSegment, tx, ty);\n            }\n        }\n    };\n    ConnectorEditing.prototype.addTerminalSegment = function (connector, segment, tx, ty, segmentIndex) {\n        //const oldValues: Connector = { segments: connector.segments } as Connector;\n        var index = connector.segments.indexOf(segment);\n        var first;\n        var insertseg;\n        var len;\n        var dir;\n        var segments = [];\n        var removeSegment = connector.segments.pop();\n        var last = connector.segments[connector.segments.length - 1];\n        first = (last && last.type === 'Orthogonal') ? last : null;\n        for (var i = 0; i < segment.points.length - 2; i++) {\n            len = Point.distancePoints(segment.points[i], segment.points[i + 1]);\n            dir = Point.direction(segment.points[i], segment.points[i + 1]);\n            insertseg = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: len, direction: dir }, true);\n            segments.push(insertseg);\n            first = insertseg;\n        }\n        var sec = segmentIndex;\n        if (segment.points.length === 2 || sec === segment.points.length - 2) {\n            if (first) {\n                first.length += 5;\n            }\n            if (sec !== undefined) {\n                //let newseg: OrthogonalSegment;\n                len = 2 * Point.distancePoints(segment.points[segment.points.length - 2], segment.points[segment.points.length - 1]) / 3;\n                dir = Point.direction(segment.points[segment.points.length - 2], segment.points[segment.points.length - 1]);\n                var newseg = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: len, direction: dir });\n                segments.push(newseg);\n            }\n        }\n        var lastseg = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n        segments.push(lastseg);\n        var args = {\n            element: connector, addSegments: segments, type: 'Addition', cancel: false\n        };\n        var args1;\n        args1 = {\n            element: cloneBlazorObject(connector), addSegments: cloneBlazorObject(segments),\n            type: 'Addition', cancel: args.cancel\n        };\n        if (isBlazor()) {\n            args1 = {\n                element: cloneBlazorObject(connector), addSegments: cloneBlazorObject(segments),\n                type: 'Addition', cancel: args.cancel\n            };\n        }\n        this.commandHandler.triggerEvent(DiagramEvent.segmentCollectionChange, args1);\n        if (!args1.cancel) {\n            connector.segments = connector.segments.concat(segments);\n            index = index + segmentIndex;\n        }\n        else {\n            connector.segments.push(removeSegment);\n        }\n        this.commandHandler.updateEndPoint(connector);\n        return index;\n    };\n    // eslint-disable-next-line\n    ConnectorEditing.prototype.updatePortSegment = function (prev, connector, index, tx, ty) {\n        if (index === 1 && prev.points.length === 2 && prev.length < 0) {\n            var source = connector.sourceWrapper.corners;\n            var current = connector.segments[index];\n            var next = connector.segments[index + 1];\n            var newseg = void 0;\n            var segment = [];\n            newseg = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: 13, direction: prev.direction });\n            segment.push(newseg);\n            var len = void 0;\n            if (current.direction === 'Left') {\n                len = (current.points[0].x - (source.middleLeft.x - 20));\n            }\n            else if (current.direction === 'Right') {\n                len = ((source.middleRight.x + 20) - current.points[0].x);\n            }\n            else if (current.direction === 'Bottom') {\n                len = ((source.bottomCenter.y + 20) - current.points[0].y);\n            }\n            else {\n                len = (current.points[0].y - (source.topCenter.y - 20));\n            }\n            //const dir: Direction = current.direction;\n            newseg = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal', length: len, direction: current.direction });\n            segment.push(newseg);\n            current.length = current.length - len;\n            if (next && next.length && next.direction) {\n                if (next.direction === prev.direction) {\n                    next.length -= 13;\n                }\n                else if (next.direction === getOppositeDirection(prev.direction)) {\n                    next.length += 13;\n                }\n            }\n            connector.segments = segment.concat(connector.segments);\n            this.selectedSegment = connector.segments[3];\n        }\n    };\n    ConnectorEditing.prototype.updatePreviousSegment = function (tx, ty, connector, index) {\n        var current = connector.segments[index];\n        var prev = connector.segments[index - 1];\n        //const firstSegment: boolean = (index === 1) ? true : false;\n        prev.points[prev.points.length - 1] = current.points[0];\n        var isSourceNode = (connector.sourceID && connector.sourcePortID === '') ? false : true;\n        var isNextUpdate = true;\n        if (prev.type === 'Orthogonal') {\n            if (prev.direction === 'Bottom') {\n                prev.length += ty;\n            }\n            else if (prev.direction === 'Top') {\n                prev.length -= ty;\n            }\n            else if (prev.direction === 'Right') {\n                prev.length += tx;\n            }\n            else {\n                prev.length -= tx;\n            }\n            if (connector.sourcePortID !== '' && prev.length < 0) {\n                this.updatePortSegment(prev, connector, index, tx, ty);\n            }\n            else if (connector.sourceID && connector.sourcePortID === '' && prev.length < 0 && index === 1) {\n                isNextUpdate = false;\n                this.updateFirstSegment(connector, current);\n            }\n            if (isSourceNode) {\n                this.changeSegmentDirection(prev);\n            }\n        }\n        return isNextUpdate;\n    };\n    ConnectorEditing.prototype.changeSegmentDirection = function (segment) {\n        if (segment.length < 0) {\n            segment.direction = getOppositeDirection(segment.direction);\n            segment.length *= -1;\n        }\n    };\n    ConnectorEditing.prototype.updateNextSegment = function (obj, current, next, tx, ty) {\n        next.points[0] = current.points[current.points.length - 1];\n        if (next && next.type === 'Orthogonal') {\n            if (next.length || next.length === 0) {\n                if (next.direction === 'Left' || next.direction === 'Right') {\n                    if (tx !== 0) {\n                        next.length = (next.direction === 'Right') ? next.length - tx : next.length + tx;\n                        if (next.length || next.length === 0) {\n                            this.changeSegmentDirection(next);\n                        }\n                    }\n                }\n                else {\n                    if (ty !== 0) {\n                        next.length = (next.direction === 'Bottom') ? next.length - ty : next.length + ty;\n                        if (next.length || next.length === 0) {\n                            this.changeSegmentDirection(next);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    ConnectorEditing.prototype.updateFirstSegment = function (connector, selectedSegment) {\n        var index = connector.segments.indexOf(selectedSegment);\n        var insertfirst = false;\n        var current = connector.segments[index];\n        var prev = connector.segments[index - 1];\n        var con = connector;\n        var sourcePoint;\n        var oldValues = { segments: connector.segments };\n        if (prev.length < 0 && connector.sourceID) {\n            var sourceNode = connector.sourceWrapper.corners;\n            var segments = [];\n            var segValues = void 0;\n            var removeCurrentPrev = false;\n            this.changeSegmentDirection(current);\n            var next = connector.segments[index + 1];\n            var nextNext = connector.segments[index + 2];\n            if (next) {\n                this.changeSegmentDirection(next);\n            }\n            if (nextNext) {\n                this.changeSegmentDirection(nextNext);\n            }\n            switch (prev.direction) {\n                case 'Top':\n                case 'Bottom':\n                    sourcePoint = (current.length > 0 && current.direction === 'Left') ? sourceNode.middleLeft : sourceNode.middleRight;\n                    if (current.length > sourceNode.width / 2) {\n                        if (Math.abs(prev.length) < sourceNode.height / 2) {\n                            prev.length = Point.distancePoints(sourceNode.center, prev.points[prev.points.length - 1]);\n                            current.points[0].x = sourcePoint.x;\n                            current.length = Point.distancePoints(current.points[0], current.points[current.points.length - 1]);\n                            current.length -= 20;\n                            insertfirst = true;\n                        }\n                    }\n                    else {\n                        if (next && next.direction && next.length) {\n                            next.points[0].y = sourcePoint.y;\n                            next.points[0].x = next.points[next.points.length - 1].x = (current.direction === 'Right') ?\n                                sourcePoint.x + 20 : sourcePoint.x - 20;\n                        }\n                        insertfirst = true;\n                        removeCurrentPrev = true;\n                    }\n                    break;\n                case 'Left':\n                case 'Right':\n                    sourcePoint = (current.length > 0 && current.direction === 'Top') ? sourceNode.topCenter : sourceNode.bottomCenter;\n                    if (current.length > sourceNode.height / 2) {\n                        if (Math.abs(prev.length) < sourceNode.width / 2) {\n                            prev.length = Point.distancePoints(sourceNode.center, prev.points[prev.points.length - 1]);\n                            current.points[0].y = sourcePoint.y;\n                            current.length = Point.distancePoints(current.points[0], current.points[current.points.length - 1]);\n                            current.length -= 20;\n                            insertfirst = true;\n                        }\n                    }\n                    else {\n                        if (next && next.direction && next.length) {\n                            next.points[0].x = sourcePoint.x;\n                            next.points[0].y = next.points[next.points.length - 1].y = (current.direction === 'Bottom') ?\n                                sourcePoint.y + 20 : sourcePoint.y - 20;\n                        }\n                        insertfirst = true;\n                        removeCurrentPrev = true;\n                    }\n                    break;\n            }\n            this.changeSegmentDirection(prev);\n            this.changeSegmentDirection(current);\n            if (insertfirst) {\n                segValues = { type: 'Orthogonal', direction: current.direction, length: 20 };\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n                if (removeCurrentPrev) {\n                    if (next && next.direction && next.length) {\n                        next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n                    }\n                    if (nextNext && nextNext.direction && nextNext.length) {\n                        nextNext.length = Point.distancePoints(next.points[next.points.length - 1], nextNext.points[nextNext.points.length - 1]);\n                    }\n                    connector.segments.splice(index - 1, 2);\n                }\n                connector.segments = segments.concat(connector.segments);\n            }\n            this.selectedSegment = ((removeCurrentPrev) ? connector.segments[index - 1] :\n                connector.segments[index + 1]);\n            this.commandHandler.updateEndPoint(connector, oldValues);\n        }\n    };\n    ConnectorEditing.prototype.updateLastSegment = function (connector, selectedSegment) {\n        if (connector.targetID && connector.targetPortID === '') {\n            var line1Start = void 0;\n            var line1End = void 0;\n            var line2Start = void 0;\n            var line2End = void 0;\n            var corners = connector.targetWrapper.corners;\n            var firstSegPoint = selectedSegment.points[0];\n            var lastSegPoint = selectedSegment.points[selectedSegment.points.length - 1];\n            if (selectedSegment.direction === 'Right' || selectedSegment.direction === 'Left') {\n                line1Start = { x: firstSegPoint.x, y: firstSegPoint.y };\n                line1End = {\n                    x: (selectedSegment.direction === 'Left') ? lastSegPoint.x - corners.width / 2 : lastSegPoint.x + corners.width / 2,\n                    y: lastSegPoint.y\n                };\n                line2Start = { x: corners.center.x, y: corners.center.y - corners.height };\n                line2End = { x: corners.center.x, y: corners.center.y + corners.height };\n            }\n            else {\n                line1Start = { x: firstSegPoint.x, y: firstSegPoint.y };\n                line1End = {\n                    x: lastSegPoint.x,\n                    y: (selectedSegment.direction === 'Bottom') ? lastSegPoint.y + corners.height / 2 : lastSegPoint.y - corners.height / 2\n                };\n                line2Start = { x: corners.center.x - corners.width, y: corners.center.y };\n                line2End = { x: corners.center.x + corners.width, y: corners.center.y };\n            }\n            var line1 = { x1: line1Start.x, y1: line1Start.y, x2: line1End.x, y2: line1End.y };\n            var line2 = { x1: line2Start.x, y1: line2Start.y, x2: line2End.x, y2: line2End.y };\n            return (intersect3(line1, line2).enabled);\n        }\n        return false;\n    };\n    /**\n     *To destroy the module\n     *\n     * @returns {void} To destroy the module\n     */\n    ConnectorEditing.prototype.destroy = function () {\n        /**\n         * Destroys the connector editing module\n         */\n    };\n    /**\n     * Get module name.\n     */\n    /**\n     * Get module name.\\\n     *\n     * @returns {  string  }    Get module name.\\\n     */\n    ConnectorEditing.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'ConnectorEditingTool';\n    };\n    return ConnectorEditing;\n}(ToolBase));\nexport { ConnectorEditing };\n"]},"metadata":{},"sourceType":"module"}