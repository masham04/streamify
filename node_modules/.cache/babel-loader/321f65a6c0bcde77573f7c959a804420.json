{"ast":null,"code":"/**\n * These utility methods help to process the data and to convert it to desired dimensions\n */\n\n/**\n * processPathData method \\\n *\n * @returns {Object[]} processPathData method .\\\n * @param { string } data - provide the data  value.\n * @private\n */\nexport function processPathData(data) {\n  var collection = [];\n  var j;\n  var arrayCollection = parsePathData(data);\n\n  if (arrayCollection.length > 0) {\n    for (var i = 0; i < arrayCollection.length; i++) {\n      var ob = arrayCollection[i];\n      var char = '';\n      char = ob[0];\n\n      switch (char.toLowerCase()) {\n        case 'm':\n          for (j = 1; j < ob.length; j++) {\n            collection.push({\n              command: char,\n              x: ob[j],\n              y: ob[j + 1]\n            });\n            j = j + 1;\n\n            if (char === 'm') {\n              char = 'l';\n            } else if (char === 'M') {\n              char = 'L';\n            }\n          }\n\n          break;\n\n        case 'l':\n        case 't':\n          for (j = 1; j < ob.length; j++) {\n            collection.push({\n              command: char,\n              x: ob[j],\n              y: ob[j + 1]\n            });\n            j = j + 1;\n          }\n\n          break;\n\n        case 'h':\n          for (j = 1; j < ob.length; j++) {\n            collection.push({\n              command: char,\n              x: ob[j]\n            });\n          }\n\n          break;\n\n        case 'v':\n          for (j = 1; j < ob.length; j++) {\n            collection.push({\n              command: char,\n              y: ob[j]\n            });\n          }\n\n          break;\n\n        case 'z':\n          collection.push({\n            command: char\n          });\n          break;\n\n        case 'c':\n          for (j = 1; j < ob.length; j++) {\n            collection.push({\n              command: char,\n              x1: ob[j],\n              y1: ob[j + 1],\n              x2: ob[j + 2],\n              y2: ob[j + 3],\n              x: ob[j + 4],\n              y: ob[j + 5]\n            });\n            j = j + 5;\n          }\n\n          break;\n\n        case 's':\n          for (j = 1; j < ob.length; j++) {\n            collection.push({\n              command: char,\n              x2: ob[j],\n              y2: ob[j + 1],\n              x: ob[j + 2],\n              y: ob[j + 3]\n            });\n            j = j + 3;\n          }\n\n          break;\n\n        case 'q':\n          for (j = 1; j < ob.length; j++) {\n            collection.push({\n              command: char,\n              x1: ob[j],\n              y1: ob[j + 1],\n              x: ob[j + 2],\n              y: ob[j + 3]\n            });\n            j = j + 3;\n          }\n\n          break;\n\n        case 'a':\n          for (j = 1; j < ob.length; j++) {\n            collection.push({\n              command: char,\n              r1: ob[j],\n              r2: ob[j + 1],\n              angle: ob[j + 2],\n              largeArc: ob[j + 3],\n              sweep: ob[j + 4],\n              x: ob[j + 5],\n              y: ob[j + 6]\n            });\n            j = j + 6;\n          }\n\n          break;\n      }\n    }\n  }\n\n  return collection;\n}\n/**\n * parsePathData method \\\n *\n * @returns {Object[]} parsePathData method .\\\n * @param { string } data - provide the data  value.\n * @private\n */\n\nexport function parsePathData(data) {\n  var tokenizer = /([a-z]+)|([+-]?(?:\\d+\\.?\\d*|\\.\\d+))/gi;\n  var current = [];\n  var commands = [];\n  var match = {};\n  tokenizer.lastIndex = 0;\n  var isExponential = false;\n  match = tokenizer.exec(data);\n\n  while (match) {\n    if (match[1] === 'e') {\n      //let s1: string = '';\n      isExponential = true;\n    } else if (match[1]) {\n      if (match[1].toLowerCase() === 'zm') {\n        if (current.length) {\n          commands.push(current);\n        }\n\n        commands.push(['Z']);\n        current = [match[1].substring(1, 2)];\n      } else {\n        if (current.length) {\n          commands.push(current);\n        }\n\n        current = [match[1]];\n      }\n\n      isExponential = false;\n    } else {\n      if (!current.length) {\n        current = [];\n      }\n\n      if (!isExponential) {\n        current.push(Number(match[2]));\n      }\n\n      isExponential = false;\n    }\n\n    match = tokenizer.exec(data);\n  }\n\n  if (current.length) {\n    commands.push(current);\n  }\n\n  return commands;\n}\n/**\n * getRectanglePath method \\\n *\n * @returns {string} getRectanglePath method .\\\n * @param { number } cornerRadius - provide the data  value.\n * @param { number } height - provide the height  value.\n * @param { number } width - provide the width  value.\n * @private\n */\n\nexport function getRectanglePath(cornerRadius, height, width) {\n  var x = 0;\n  var y = 0;\n  var path = '';\n  var points = [{\n    x: x + cornerRadius,\n    y: y\n  }, {\n    x: x + width - cornerRadius,\n    y: y\n  }, {\n    x: x + width,\n    y: y + cornerRadius\n  }, {\n    x: x + width,\n    y: y + height - cornerRadius\n  }, {\n    x: x + width - cornerRadius,\n    y: y + height\n  }, {\n    x: x + cornerRadius,\n    y: y + height\n  }, {\n    x: x,\n    y: y + height - cornerRadius\n  }, {\n    x: x,\n    y: y + cornerRadius\n  }];\n  var corners = [{\n    x: x + width,\n    y: y\n  }, {\n    x: x + width,\n    y: y + height\n  }, {\n    x: x,\n    y: y + height\n  }, {\n    x: x,\n    y: y\n  }];\n  var corner = 0;\n  var point2;\n  var next;\n  path = 'M' + points[0].x + ' ' + points[0].y;\n  var i;\n\n  for (i = 0; i < points.length; i = i + 2) {\n    point2 = points[i + 1];\n    path += 'L' + point2.x + ' ' + point2.y;\n    next = points[i + 2] || points[0];\n    path += 'Q' + corners[corner].x + ' ' + corners[corner].y + ' ' + next.x + ' ' + next.y;\n    corner++;\n  }\n\n  return path;\n}\n/**\n * getPolygonPath method \\\n *\n * @returns {string} getPolygonPath method .\\\n * @param { PointModel[] } collection - provide the data  value.\n * @private\n */\n\nexport function getPolygonPath(collection) {\n  var path = '';\n  var seg;\n  path = 'M' + collection[0].x + ' ' + collection[0].y;\n  var i;\n\n  for (i = 1; i < collection.length; i++) {\n    seg = collection[i];\n    path += 'L' + seg.x + ' ' + seg.y;\n  }\n\n  path += 'Z';\n  return path;\n}\n/* eslint-disable */\n\n/**\n * pathSegmentCollection method \\\n *\n * @returns {string} pathSegmentCollection method .\\\n * @param { Object[]} collection - provide the collection  value.\n * @private\n */\n\nexport function pathSegmentCollection(collection) {\n  var x0;\n  var y0;\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n  var x;\n  var y;\n  var length;\n  var i;\n  var initx;\n  var inity;\n  var segments = [];\n\n  for (x = 0, y = 0, i = 0, length = collection.length; i < length; ++i) {\n    var obj = collection[i];\n    var seg = obj;\n    var char = '';\n    char = seg.command;\n\n    if ('y1' in seg) {\n      y1 = seg.y1;\n    }\n\n    if ('y2' in seg) {\n      y2 = seg.y2;\n    }\n\n    if ('x1' in seg) {\n      x1 = seg.x1;\n    }\n\n    if ('x2' in seg) {\n      x2 = seg.x2;\n    }\n\n    if ('x' in seg) {\n      x = seg.x;\n    }\n\n    if ('y' in seg) {\n      y = seg.y;\n    }\n\n    var prev = segments[segments.length - 1];\n\n    switch (char) {\n      case 'M':\n        segments.push({\n          command: 'M',\n          x: x,\n          y: y\n        });\n        break;\n\n      case 'L':\n        segments.push({\n          command: 'L',\n          x0: x0,\n          y0: y0,\n          x: x,\n          y: y\n        });\n        break;\n\n      case 'H':\n        segments.push({\n          command: 'L',\n          x0: x0,\n          y0: y0,\n          x: x,\n          y: y0\n        });\n        break;\n\n      case 'V':\n        segments.push({\n          command: 'L',\n          x0: x0,\n          y0: y0,\n          x: x0,\n          y: y\n        });\n        break;\n\n      case 'C':\n        segments.push({\n          command: 'C',\n          x0: x0,\n          y0: y0,\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          x: x,\n          y: y\n        });\n        break;\n\n      case 'S':\n        if (prev) {\n          var ctrl = void 0;\n\n          if (prev.command === 'C' || prev.command === 'S') {\n            ctrl = {\n              x: prev.x2,\n              y: prev.y2\n            };\n          } else {\n            ctrl = {\n              x: x0,\n              y: y0\n            };\n          }\n\n          var cpt2 = {\n            x: 2 * x0 - ctrl.x,\n            y: 2 * y0 - ctrl.y\n          };\n          segments.push({\n            command: 'C',\n            x0: x0,\n            y0: y0,\n            x1: cpt2.x,\n            y1: cpt2.y,\n            x2: x2,\n            y2: y2,\n            x: x,\n            y: y\n          });\n        }\n\n        break;\n\n      case 'Q':\n        //ctx.quadraticCurveTo(x1, y1, x, y);\n        segments.push({\n          command: 'Q',\n          x0: x0,\n          y0: y0,\n          x1: x1,\n          y1: y1,\n          x: x,\n          y: y\n        });\n        break;\n\n      case 'T':\n        if (prev) {\n          var ctrl = void 0;\n\n          if (prev.command === 'Q') {\n            ctrl = {\n              x: prev.x1,\n              y: prev.y1\n            };\n          } else {\n            ctrl = {\n              x: x0,\n              y: y0\n            };\n          }\n\n          var cpt2 = {\n            x: 2 * x0 - ctrl.x,\n            y: 2 * y0 - ctrl.y\n          };\n          segments.push({\n            command: 'Q',\n            x0: x0,\n            y0: y0,\n            x1: cpt2.x,\n            y1: cpt2.y,\n            x: x,\n            y: y\n          });\n        }\n\n        break;\n\n      case 'A':\n        var newSeg = seg;\n        newSeg.command = 'A';\n        segments.push(newSeg);\n        break;\n\n      case 'Z':\n      case 'z':\n        segments.push({\n          command: 'Z'\n        });\n        x = x0;\n        y = y0;\n        break;\n    }\n\n    if (char === 'M' || char === 'm') {\n      initx = x;\n      inity = y;\n    }\n\n    x0 = x;\n    y0 = y;\n  }\n\n  return segments;\n}\n/**\n * transformPath method \\\n *\n * @returns {string} transformPath method .\\\n * @param { Object[]} arr - provide the collection  value.\n * @param { number} sX - provide the collection  value.\n * @param { number} sY - provide the collection  value.\n * @param { boolean} s - provide the collection  value.\n * @param {number} bX - provide the collection  value.\n * @param { number} bY - provide the collection  value.\n * @param { number} iX - provide the collection  value.\n * @param { number} iY - provide the collection  value.\n * @private\n */\n\nexport function transformPath(arr, sX, sY, s, bX, bY, iX, iY) {\n  var x0;\n  var y0;\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n  var x;\n  var y;\n  var length;\n  var i;\n  var newSeg;\n\n  for (x = 0, y = 0, i = 0, length = arr.length; i < length; ++i) {\n    var obj = arr[i];\n    var seg = obj;\n    var char = seg.command;\n\n    if ('x' in seg) {\n      x = seg.x;\n    }\n\n    if ('y' in seg) {\n      y = seg.y;\n    }\n\n    if ('y1' in seg) {\n      y1 = seg.y1;\n    }\n\n    if ('y2' in seg) {\n      y2 = seg.y2;\n    }\n\n    if ('x1' in seg) {\n      x1 = seg.x1;\n    }\n\n    if ('x2' in seg) {\n      x2 = seg.x2;\n    }\n\n    if (s) {\n      if (x !== undefined) {\n        x = scalePathData(x, sX, bX, iX);\n      }\n\n      if (y !== undefined) {\n        y = scalePathData(y, sY, bY, iY);\n      }\n\n      if (x1 !== undefined) {\n        x1 = scalePathData(x1, sX, bX, iX);\n      }\n\n      if (y1 !== undefined) {\n        y1 = scalePathData(y1, sY, bY, iY);\n      }\n\n      if (x2 !== undefined) {\n        x2 = scalePathData(x2, sX, bX, iX);\n      }\n\n      if (y2 !== undefined) {\n        y2 = scalePathData(y2, sY, bY, iY);\n      }\n    } else {\n      if (x !== undefined) {\n        x = Number((x + sX).toFixed(2));\n      }\n\n      if (y !== undefined) {\n        y = Number((y + sY).toFixed(2));\n      }\n\n      if (x1 !== undefined) {\n        x1 = Number((x1 + sX).toFixed(2));\n      }\n\n      if (y1 !== undefined) {\n        y1 = Number((y1 + sY).toFixed(2));\n      }\n\n      if (x2 !== undefined) {\n        x2 = Number((x2 + sX).toFixed(2));\n      }\n\n      if (y2 !== undefined) {\n        y2 = Number((y2 + sY).toFixed(2));\n      }\n    }\n\n    var scaledPath = {\n      x: x,\n      y: y,\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      r1: seg.r1,\n      r2: seg.r2\n    };\n    newSeg = updatedSegment(seg, char, scaledPath, s, sX, sY);\n\n    if (newSeg) {\n      arr[i] = newSeg;\n    } // Record the start of a subpath\n\n\n    if (char === 'M' || char === 'm') {\n      x0 = x;\n      y0 = y;\n    }\n  }\n\n  var pathData = getPathString(arr);\n  return pathData;\n}\n/**\n * updatedSegment method \\\n *\n * @returns {string} updatedSegment method .\\\n * @param { PathSegment} segment - provide the collection  value.\n * @param { PathSegment} char - provide the collection  value.\n * @param { number} obj - provide the collection  value.\n * @param { boolean} isScale - provide the collection  value.\n * @param {number} sX - provide the collection  value.\n * @param { number} sY - provide the collection  value.\n * @private\n */\n\nexport function updatedSegment(segment, char, obj, isScale, sX, sY) {\n  switch (char) {\n    case 'M':\n      segment.x = obj.x;\n      segment.y = obj.y;\n      break;\n\n    case 'L':\n      segment.x = obj.x;\n      segment.y = obj.y;\n      break;\n\n    case 'H':\n      segment.x = obj.x;\n      break;\n\n    case 'V':\n      segment.y = obj.y;\n      break;\n\n    case 'C':\n      segment.x = obj.x;\n      segment.y = obj.y;\n      segment.x1 = obj.x1;\n      segment.y1 = obj.y1;\n      segment.x2 = obj.x2;\n      segment.y2 = obj.y2;\n      break;\n\n    case 'S':\n      segment.x = obj.x;\n      segment.y = obj.y;\n      segment.x2 = obj.x2;\n      segment.y2 = obj.y2;\n      break;\n\n    case 'Q':\n      segment.x = obj.x;\n      segment.y = obj.y;\n      segment.x1 = obj.x1;\n      segment.y1 = obj.y1;\n      break;\n\n    case 'T':\n      segment.x = obj.x;\n      segment.y = obj.y;\n      break;\n\n    case 'A':\n      var r1 = obj.r1;\n      var r2 = obj.r2;\n\n      if (isScale) {\n        obj.r1 = r1 = r1 * sX;\n        obj.r2 = r2 = r2 * sY;\n      }\n\n      segment.x = obj.x;\n      segment.y = obj.y;\n      segment.r1 = obj.r1;\n      segment.r2 = obj.r2;\n      break;\n\n    case 'z':\n    case 'Z':\n      segment = {\n        command: 'Z'\n      };\n      break;\n  }\n\n  return segment;\n}\n/* eslint-enable */\n\n/**\n * scalePathData method \\\n *\n * @returns {string} scalePathData method .\\\n * @param { number} val - provide the val  value.\n * @param { number} scaleFactor - provide the scaleFactor  value.\n * @param { number} oldOffset - provide the oldOffset  value.\n * @param { number} newOffset - provide the newOffset  value.\n * @private\n */\n\nexport function scalePathData(val, scaleFactor, oldOffset, newOffset) {\n  if (val !== oldOffset) {\n    if (newOffset !== oldOffset) {\n      val = val * scaleFactor - (Number(oldOffset) * scaleFactor - Number(oldOffset)) + (newOffset - Number(oldOffset));\n    } else {\n      val = Number(val) * scaleFactor - (Number(oldOffset) * scaleFactor - Number(oldOffset));\n    }\n  } else {\n    if (newOffset !== oldOffset) {\n      val = newOffset;\n    }\n  }\n\n  return Number(val.toFixed(2));\n}\n/**\n * splitArrayCollection method \\\n *\n * @returns {Object[]} splitArrayCollection method .\\\n * @param { Object[]} arrayCollection - provide the val  value.\n * @private\n */\n\nexport function splitArrayCollection(arrayCollection) {\n  var x0;\n  var y0;\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n  var x;\n  var y;\n  var length;\n  var i;\n\n  for (x = 0, y = 0, i = 0, length = arrayCollection.length; i < length; ++i) {\n    var path = arrayCollection[i];\n    var seg = path;\n    var char = seg.command;\n\n    if (/[MLHVCSQTA]/.test(char)) {\n      if ('x' in seg) {\n        seg.x = x = seg.x;\n      }\n\n      if ('y' in seg) {\n        seg.y = y = seg.y;\n      }\n    } else {\n      if ('x1' in seg) {\n        seg.x1 = x1 = x + seg.x1;\n      }\n\n      if ('x2' in seg) {\n        seg.x2 = x2 = x + seg.x2;\n      }\n\n      if ('y1' in seg) {\n        seg.y1 = y1 = y + seg.y1;\n      }\n\n      if ('y2' in seg) {\n        seg.y2 = y2 = y + seg.y2;\n      }\n\n      if ('x' in seg) {\n        seg.x = x += seg.x;\n      }\n\n      if ('y' in seg) {\n        seg.y = y += seg.y;\n      }\n\n      var newSeg = void 0;\n\n      switch (char) {\n        case 'm':\n        case 'M':\n          newSeg = {\n            command: 'M',\n            x: x,\n            y: y\n          };\n          break;\n\n        case 'l':\n        case 'L':\n          newSeg = {\n            command: 'L',\n            x: x,\n            y: y\n          };\n          break;\n\n        case 'h':\n        case 'H':\n          newSeg = {\n            command: 'H',\n            x: x\n          };\n          break;\n\n        case 'v':\n        case 'V':\n          newSeg = {\n            command: 'V',\n            y: y\n          };\n          break;\n\n        case 'c':\n        case 'C':\n          newSeg = {\n            command: 'C',\n            x: x,\n            y: y,\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n          };\n          break;\n\n        case 's':\n        case 'S':\n          newSeg = {\n            command: 'S',\n            x: x,\n            y: y,\n            x2: x2,\n            y2: y2\n          };\n          break;\n\n        case 'q':\n        case 'Q':\n          newSeg = {\n            command: 'Q',\n            x: x,\n            y: y,\n            x1: x1,\n            y1: y1\n          };\n          break;\n\n        case 't':\n        case 'T':\n          newSeg = {\n            command: 'T',\n            x: x,\n            y: y\n          };\n          break;\n\n        case 'a':\n        case 'A':\n          newSeg = {\n            command: 'A',\n            x: x,\n            y: y\n          };\n          newSeg.r1 = seg.r1;\n          newSeg.r2 = seg.r2;\n          newSeg.angle = seg.angle;\n          newSeg.largeArc = seg.largeArc;\n          newSeg.sweep = seg.sweep;\n          break;\n\n        case 'z':\n        case 'Z':\n          newSeg = {\n            command: 'Z'\n          };\n          x = x0;\n          y = y0;\n          newSeg = arrayCollection[i];\n          break;\n      }\n\n      if (newSeg) {\n        arrayCollection[i] = newSeg;\n      }\n    }\n\n    if (char === 'M' || char === 'm') {\n      x0 = x;\n      y0 = y;\n    }\n  }\n\n  return arrayCollection;\n}\n/**\n * getPathString method \\\n *\n * @returns {string} getPathString method .\\\n * @param { Object[]} arrayCollection - provide the val  value.\n * @private\n */\n\nexport function getPathString(arrayCollection) {\n  var getNewString = '';\n  var i;\n\n  for (i = 0; i < arrayCollection.length; i++) {\n    if (i === 0) {\n      getNewString += getString(arrayCollection[i]);\n    } else {\n      getNewString += ' ' + getString(arrayCollection[i]);\n    }\n  }\n\n  return getNewString;\n}\n/* eslint-disable */\n\n/**\n * getString method \\\n *\n * @returns {string} getString method .\\\n * @param { PathSegment} arrayCollection - provide the val  value.\n * @private\n */\n\nexport function getString(obj) {\n  var string = '';\n\n  switch (obj.command) {\n    case 'Z':\n    case 'z':\n      string = obj.command;\n      break;\n\n    case 'M':\n    case 'm':\n    case 'L':\n    case 'l':\n      string = obj.command + ' ' + obj.x + ' ' + obj.y;\n      break;\n\n    case 'C':\n    case 'c':\n      string = obj.command + ' ' + obj.x1 + ' ' + obj.y1 + ' ' + obj.x2 + ' ' + obj.y2 + ' ' + obj.x + ' ' + obj.y;\n      break;\n\n    case 'Q':\n    case 'q':\n      string = obj.command + ' ' + obj.x1 + ' ' + obj.y1 + ' ' + obj.x + ' ' + obj.y;\n      break;\n\n    case 'A':\n    case 'a':\n      var cmd = obj.command;\n      var ang = obj.angle;\n      var l = obj.largeArc ? '1' : '0';\n      var s = obj.sweep ? '1' : '0';\n      string = cmd + ' ' + obj.r1 + ' ' + obj.r2 + ' ' + ang + ' ' + l + ' ' + s + ' ' + obj.x + ' ' + obj.y;\n      break;\n\n    case 'H':\n    case 'h':\n      string = obj.command + ' ' + obj.x;\n      break;\n\n    case 'V':\n    case 'v':\n      string = obj.command + ' ' + obj.y;\n      break;\n\n    case 'S':\n    case 's':\n      string = obj.command + ' ' + obj.x2 + ' ' + obj.y2 + ' ' + obj.x + ' ' + obj.y;\n      break;\n\n    case 'T':\n    case 't':\n      string = obj.command + ' ' + obj.x + ' ' + obj.y;\n  }\n\n  return string;\n}","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/path-util.js"],"names":["processPathData","data","collection","j","arrayCollection","parsePathData","length","i","ob","char","toLowerCase","push","command","x","y","x1","y1","x2","y2","r1","r2","angle","largeArc","sweep","tokenizer","current","commands","match","lastIndex","isExponential","exec","substring","Number","getRectanglePath","cornerRadius","height","width","path","points","corners","corner","point2","next","getPolygonPath","seg","pathSegmentCollection","x0","y0","initx","inity","segments","obj","prev","ctrl","cpt2","newSeg","transformPath","arr","sX","sY","s","bX","bY","iX","iY","undefined","scalePathData","toFixed","scaledPath","updatedSegment","pathData","getPathString","segment","isScale","val","scaleFactor","oldOffset","newOffset","splitArrayCollection","test","getNewString","getString","string","cmd","ang","l"],"mappings":"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","sourcesContent":["/**\n * These utility methods help to process the data and to convert it to desired dimensions\n */\n/**\n * processPathData method \\\n *\n * @returns {Object[]} processPathData method .\\\n * @param { string } data - provide the data  value.\n * @private\n */\nexport function processPathData(data) {\n    var collection = [];\n    var j;\n    var arrayCollection = parsePathData(data);\n    if (arrayCollection.length > 0) {\n        for (var i = 0; i < arrayCollection.length; i++) {\n            var ob = arrayCollection[i];\n            var char = '';\n            char = ob[0];\n            switch (char.toLowerCase()) {\n                case 'm':\n                    for (j = 1; j < ob.length; j++) {\n                        collection.push({ command: char, x: ob[j], y: ob[j + 1] });\n                        j = j + 1;\n                        if (char === 'm') {\n                            char = 'l';\n                        }\n                        else if (char === 'M') {\n                            char = 'L';\n                        }\n                    }\n                    break;\n                case 'l':\n                case 't':\n                    for (j = 1; j < ob.length; j++) {\n                        collection.push({ command: char, x: ob[j], y: ob[j + 1] });\n                        j = j + 1;\n                    }\n                    break;\n                case 'h':\n                    for (j = 1; j < ob.length; j++) {\n                        collection.push({ command: char, x: ob[j] });\n                    }\n                    break;\n                case 'v':\n                    for (j = 1; j < ob.length; j++) {\n                        collection.push({ command: char, y: ob[j] });\n                    }\n                    break;\n                case 'z':\n                    collection.push({ command: char });\n                    break;\n                case 'c':\n                    for (j = 1; j < ob.length; j++) {\n                        collection.push({\n                            command: char, x1: ob[j], y1: ob[j + 1], x2: ob[j + 2], y2: ob[j + 3], x: ob[j + 4], y: ob[j + 5]\n                        });\n                        j = j + 5;\n                    }\n                    break;\n                case 's':\n                    for (j = 1; j < ob.length; j++) {\n                        collection.push({ command: char, x2: ob[j], y2: ob[j + 1], x: ob[j + 2], y: ob[j + 3] });\n                        j = j + 3;\n                    }\n                    break;\n                case 'q':\n                    for (j = 1; j < ob.length; j++) {\n                        collection.push({ command: char, x1: ob[j], y1: ob[j + 1], x: ob[j + 2], y: ob[j + 3] });\n                        j = j + 3;\n                    }\n                    break;\n                case 'a':\n                    for (j = 1; j < ob.length; j++) {\n                        collection.push({\n                            command: char, r1: ob[j], r2: ob[j + 1], angle: ob[j + 2], largeArc: ob[j + 3],\n                            sweep: ob[j + 4], x: ob[j + 5], y: ob[j + 6]\n                        });\n                        j = j + 6;\n                    }\n                    break;\n            }\n        }\n    }\n    return collection;\n}\n/**\n * parsePathData method \\\n *\n * @returns {Object[]} parsePathData method .\\\n * @param { string } data - provide the data  value.\n * @private\n */\nexport function parsePathData(data) {\n    var tokenizer = /([a-z]+)|([+-]?(?:\\d+\\.?\\d*|\\.\\d+))/gi;\n    var current = [];\n    var commands = [];\n    var match = {};\n    tokenizer.lastIndex = 0;\n    var isExponential = false;\n    match = tokenizer.exec(data);\n    while (match) {\n        if (match[1] === 'e') {\n            //let s1: string = '';\n            isExponential = true;\n        }\n        else if (match[1]) {\n            if (match[1].toLowerCase() === 'zm') {\n                if (current.length) {\n                    commands.push(current);\n                }\n                commands.push(['Z']);\n                current = [match[1].substring(1, 2)];\n            }\n            else {\n                if (current.length) {\n                    commands.push(current);\n                }\n                current = [match[1]];\n            }\n            isExponential = false;\n        }\n        else {\n            if (!current.length) {\n                current = [];\n            }\n            if (!isExponential) {\n                current.push(Number(match[2]));\n            }\n            isExponential = false;\n        }\n        match = tokenizer.exec(data);\n    }\n    if (current.length) {\n        commands.push(current);\n    }\n    return commands;\n}\n/**\n * getRectanglePath method \\\n *\n * @returns {string} getRectanglePath method .\\\n * @param { number } cornerRadius - provide the data  value.\n * @param { number } height - provide the height  value.\n * @param { number } width - provide the width  value.\n * @private\n */\nexport function getRectanglePath(cornerRadius, height, width) {\n    var x = 0;\n    var y = 0;\n    var path = '';\n    var points = [{ x: x + cornerRadius, y: y }, { x: x + width - cornerRadius, y: y },\n        { x: x + width, y: y + cornerRadius }, { x: x + width, y: y + height - cornerRadius },\n        { x: x + width - cornerRadius, y: y + height }, { x: x + cornerRadius, y: y + height },\n        { x: x, y: y + height - cornerRadius }, { x: x, y: y + cornerRadius }\n    ];\n    var corners = [{ x: x + width, y: y }, { x: x + width, y: y + height }, { x: x, y: y + height }, { x: x, y: y }];\n    var corner = 0;\n    var point2;\n    var next;\n    path = 'M' + points[0].x + ' ' + points[0].y;\n    var i;\n    for (i = 0; i < points.length; i = i + 2) {\n        point2 = points[i + 1];\n        path += 'L' + point2.x + ' ' + point2.y;\n        next = points[i + 2] || points[0];\n        path += 'Q' + corners[corner].x + ' ' + corners[corner].y + ' ' + next.x + ' ' + next.y;\n        corner++;\n    }\n    return path;\n}\n/**\n * getPolygonPath method \\\n *\n * @returns {string} getPolygonPath method .\\\n * @param { PointModel[] } collection - provide the data  value.\n * @private\n */\nexport function getPolygonPath(collection) {\n    var path = '';\n    var seg;\n    path = 'M' + collection[0].x + ' ' + collection[0].y;\n    var i;\n    for (i = 1; i < collection.length; i++) {\n        seg = collection[i];\n        path += 'L' + seg.x + ' ' + seg.y;\n    }\n    path += 'Z';\n    return path;\n}\n/* eslint-disable */\n/**\n * pathSegmentCollection method \\\n *\n * @returns {string} pathSegmentCollection method .\\\n * @param { Object[]} collection - provide the collection  value.\n * @private\n */\nexport function pathSegmentCollection(collection) {\n    var x0;\n    var y0;\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    var x;\n    var y;\n    var length;\n    var i;\n    var initx;\n    var inity;\n    var segments = [];\n    for (x = 0, y = 0, i = 0, length = collection.length; i < length; ++i) {\n        var obj = collection[i];\n        var seg = obj;\n        var char = '';\n        char = seg.command;\n        if ('y1' in seg) {\n            y1 = seg.y1;\n        }\n        if ('y2' in seg) {\n            y2 = seg.y2;\n        }\n        if ('x1' in seg) {\n            x1 = seg.x1;\n        }\n        if ('x2' in seg) {\n            x2 = seg.x2;\n        }\n        if ('x' in seg) {\n            x = seg.x;\n        }\n        if ('y' in seg) {\n            y = seg.y;\n        }\n        var prev = segments[segments.length - 1];\n        switch (char) {\n            case 'M':\n                segments.push({ command: 'M', x: x, y: y });\n                break;\n            case 'L':\n                segments.push({ command: 'L', x0: x0, y0: y0, x: x, y: y });\n                break;\n            case 'H':\n                segments.push({ command: 'L', x0: x0, y0: y0, x: x, y: y0 });\n                break;\n            case 'V':\n                segments.push({ command: 'L', x0: x0, y0: y0, x: x0, y: y });\n                break;\n            case 'C':\n                segments.push({ command: 'C', x0: x0, y0: y0, x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y });\n                break;\n            case 'S':\n                if (prev) {\n                    var ctrl = void 0;\n                    if (prev.command === 'C' || prev.command === 'S') {\n                        ctrl = { x: prev.x2, y: prev.y2 };\n                    }\n                    else {\n                        ctrl = { x: x0, y: y0 };\n                    }\n                    var cpt2 = { x: 2 * x0 - ctrl.x, y: 2 * y0 - ctrl.y };\n                    segments.push({ command: 'C', x0: x0, y0: y0, x1: cpt2.x, y1: cpt2.y, x2: x2, y2: y2, x: x, y: y });\n                }\n                break;\n            case 'Q':\n                //ctx.quadraticCurveTo(x1, y1, x, y);\n                segments.push({ command: 'Q', x0: x0, y0: y0, x1: x1, y1: y1, x: x, y: y });\n                break;\n            case 'T':\n                if (prev) {\n                    var ctrl = void 0;\n                    if (prev.command === 'Q') {\n                        ctrl = { x: prev.x1, y: prev.y1 };\n                    }\n                    else {\n                        ctrl = { x: x0, y: y0 };\n                    }\n                    var cpt2 = { x: 2 * x0 - ctrl.x, y: 2 * y0 - ctrl.y };\n                    segments.push({ command: 'Q', x0: x0, y0: y0, x1: cpt2.x, y1: cpt2.y, x: x, y: y });\n                }\n                break;\n            case 'A':\n                var newSeg = seg;\n                newSeg.command = 'A';\n                segments.push(newSeg);\n                break;\n            case 'Z':\n            case 'z':\n                segments.push({ command: 'Z' });\n                x = x0;\n                y = y0;\n                break;\n        }\n        if (char === 'M' || char === 'm') {\n            initx = x;\n            inity = y;\n        }\n        x0 = x;\n        y0 = y;\n    }\n    return segments;\n}\n/**\n * transformPath method \\\n *\n * @returns {string} transformPath method .\\\n * @param { Object[]} arr - provide the collection  value.\n * @param { number} sX - provide the collection  value.\n * @param { number} sY - provide the collection  value.\n * @param { boolean} s - provide the collection  value.\n * @param {number} bX - provide the collection  value.\n * @param { number} bY - provide the collection  value.\n * @param { number} iX - provide the collection  value.\n * @param { number} iY - provide the collection  value.\n * @private\n */\nexport function transformPath(arr, sX, sY, s, bX, bY, iX, iY) {\n    var x0;\n    var y0;\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    var x;\n    var y;\n    var length;\n    var i;\n    var newSeg;\n    for (x = 0, y = 0, i = 0, length = arr.length; i < length; ++i) {\n        var obj = arr[i];\n        var seg = obj;\n        var char = seg.command;\n        if ('x' in seg) {\n            x = seg.x;\n        }\n        if ('y' in seg) {\n            y = seg.y;\n        }\n        if ('y1' in seg) {\n            y1 = seg.y1;\n        }\n        if ('y2' in seg) {\n            y2 = seg.y2;\n        }\n        if ('x1' in seg) {\n            x1 = seg.x1;\n        }\n        if ('x2' in seg) {\n            x2 = seg.x2;\n        }\n        if (s) {\n            if (x !== undefined) {\n                x = scalePathData(x, sX, bX, iX);\n            }\n            if (y !== undefined) {\n                y = scalePathData(y, sY, bY, iY);\n            }\n            if (x1 !== undefined) {\n                x1 = scalePathData(x1, sX, bX, iX);\n            }\n            if (y1 !== undefined) {\n                y1 = scalePathData(y1, sY, bY, iY);\n            }\n            if (x2 !== undefined) {\n                x2 = scalePathData(x2, sX, bX, iX);\n            }\n            if (y2 !== undefined) {\n                y2 = scalePathData(y2, sY, bY, iY);\n            }\n        }\n        else {\n            if (x !== undefined) {\n                x = Number((x + sX).toFixed(2));\n            }\n            if (y !== undefined) {\n                y = Number((y + sY).toFixed(2));\n            }\n            if (x1 !== undefined) {\n                x1 = Number((x1 + sX).toFixed(2));\n            }\n            if (y1 !== undefined) {\n                y1 = Number((y1 + sY).toFixed(2));\n            }\n            if (x2 !== undefined) {\n                x2 = Number((x2 + sX).toFixed(2));\n            }\n            if (y2 !== undefined) {\n                y2 = Number((y2 + sY).toFixed(2));\n            }\n        }\n        var scaledPath = { x: x, y: y, x1: x1, y1: y1, x2: x2, y2: y2, r1: seg.r1, r2: seg.r2 };\n        newSeg = updatedSegment(seg, char, scaledPath, s, sX, sY);\n        if (newSeg) {\n            arr[i] = newSeg;\n        }\n        // Record the start of a subpath\n        if (char === 'M' || char === 'm') {\n            x0 = x;\n            y0 = y;\n        }\n    }\n    var pathData = getPathString(arr);\n    return pathData;\n}\n/**\n * updatedSegment method \\\n *\n * @returns {string} updatedSegment method .\\\n * @param { PathSegment} segment - provide the collection  value.\n * @param { PathSegment} char - provide the collection  value.\n * @param { number} obj - provide the collection  value.\n * @param { boolean} isScale - provide the collection  value.\n * @param {number} sX - provide the collection  value.\n * @param { number} sY - provide the collection  value.\n * @private\n */\nexport function updatedSegment(segment, char, obj, isScale, sX, sY) {\n    switch (char) {\n        case 'M':\n            segment.x = obj.x;\n            segment.y = obj.y;\n            break;\n        case 'L':\n            segment.x = obj.x;\n            segment.y = obj.y;\n            break;\n        case 'H':\n            segment.x = obj.x;\n            break;\n        case 'V':\n            segment.y = obj.y;\n            break;\n        case 'C':\n            segment.x = obj.x;\n            segment.y = obj.y;\n            segment.x1 = obj.x1;\n            segment.y1 = obj.y1;\n            segment.x2 = obj.x2;\n            segment.y2 = obj.y2;\n            break;\n        case 'S':\n            segment.x = obj.x;\n            segment.y = obj.y;\n            segment.x2 = obj.x2;\n            segment.y2 = obj.y2;\n            break;\n        case 'Q':\n            segment.x = obj.x;\n            segment.y = obj.y;\n            segment.x1 = obj.x1;\n            segment.y1 = obj.y1;\n            break;\n        case 'T':\n            segment.x = obj.x;\n            segment.y = obj.y;\n            break;\n        case 'A':\n            var r1 = obj.r1;\n            var r2 = obj.r2;\n            if (isScale) {\n                obj.r1 = r1 = (r1 * sX);\n                obj.r2 = r2 = (r2 * sY);\n            }\n            segment.x = obj.x;\n            segment.y = obj.y;\n            segment.r1 = obj.r1;\n            segment.r2 = obj.r2;\n            break;\n        case 'z':\n        case 'Z':\n            segment = { command: 'Z' };\n            break;\n    }\n    return segment;\n}\n/* eslint-enable */\n/**\n * scalePathData method \\\n *\n * @returns {string} scalePathData method .\\\n * @param { number} val - provide the val  value.\n * @param { number} scaleFactor - provide the scaleFactor  value.\n * @param { number} oldOffset - provide the oldOffset  value.\n * @param { number} newOffset - provide the newOffset  value.\n * @private\n */\nexport function scalePathData(val, scaleFactor, oldOffset, newOffset) {\n    if (val !== oldOffset) {\n        if (newOffset !== oldOffset) {\n            val = (((val * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)))\n                + (newOffset - Number(oldOffset)));\n        }\n        else {\n            val = ((Number(val) * scaleFactor) - (Number(oldOffset) * scaleFactor - Number(oldOffset)));\n        }\n    }\n    else {\n        if (newOffset !== oldOffset) {\n            val = newOffset;\n        }\n    }\n    return Number(val.toFixed(2));\n}\n/**\n * splitArrayCollection method \\\n *\n * @returns {Object[]} splitArrayCollection method .\\\n * @param { Object[]} arrayCollection - provide the val  value.\n * @private\n */\nexport function splitArrayCollection(arrayCollection) {\n    var x0;\n    var y0;\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    var x;\n    var y;\n    var length;\n    var i;\n    for (x = 0, y = 0, i = 0, length = arrayCollection.length; i < length; ++i) {\n        var path = arrayCollection[i];\n        var seg = path;\n        var char = seg.command;\n        if (/[MLHVCSQTA]/.test(char)) {\n            if ('x' in seg) {\n                seg.x = x = seg.x;\n            }\n            if ('y' in seg) {\n                seg.y = y = seg.y;\n            }\n        }\n        else {\n            if ('x1' in seg) {\n                seg.x1 = x1 = x + seg.x1;\n            }\n            if ('x2' in seg) {\n                seg.x2 = x2 = x + seg.x2;\n            }\n            if ('y1' in seg) {\n                seg.y1 = y1 = y + seg.y1;\n            }\n            if ('y2' in seg) {\n                seg.y2 = y2 = y + seg.y2;\n            }\n            if ('x' in seg) {\n                seg.x = x += seg.x;\n            }\n            if ('y' in seg) {\n                seg.y = y += seg.y;\n            }\n            var newSeg = void 0;\n            switch (char) {\n                case 'm':\n                case 'M':\n                    newSeg = { command: 'M', x: x, y: y };\n                    break;\n                case 'l':\n                case 'L':\n                    newSeg = { command: 'L', x: x, y: y };\n                    break;\n                case 'h':\n                case 'H':\n                    newSeg = { command: 'H', x: x };\n                    break;\n                case 'v':\n                case 'V':\n                    newSeg = { command: 'V', y: y };\n                    break;\n                case 'c':\n                case 'C':\n                    newSeg = { command: 'C', x: x, y: y, x1: x1, y1: y1, x2: x2, y2: y2 };\n                    break;\n                case 's':\n                case 'S':\n                    newSeg = { command: 'S', x: x, y: y, x2: x2, y2: y2 };\n                    break;\n                case 'q':\n                case 'Q':\n                    newSeg = { command: 'Q', x: x, y: y, x1: x1, y1: y1 };\n                    break;\n                case 't':\n                case 'T':\n                    newSeg = { command: 'T', x: x, y: y };\n                    break;\n                case 'a':\n                case 'A':\n                    newSeg = { command: 'A', x: x, y: y };\n                    newSeg.r1 = seg.r1;\n                    newSeg.r2 = seg.r2;\n                    newSeg.angle = seg.angle;\n                    newSeg.largeArc = seg.largeArc;\n                    newSeg.sweep = seg.sweep;\n                    break;\n                case 'z':\n                case 'Z':\n                    newSeg = { command: 'Z' };\n                    x = x0;\n                    y = y0;\n                    newSeg = arrayCollection[i];\n                    break;\n            }\n            if (newSeg) {\n                arrayCollection[i] = newSeg;\n            }\n        }\n        if (char === 'M' || char === 'm') {\n            x0 = x;\n            y0 = y;\n        }\n    }\n    return arrayCollection;\n}\n/**\n * getPathString method \\\n *\n * @returns {string} getPathString method .\\\n * @param { Object[]} arrayCollection - provide the val  value.\n * @private\n */\nexport function getPathString(arrayCollection) {\n    var getNewString = '';\n    var i;\n    for (i = 0; i < arrayCollection.length; i++) {\n        if (i === 0) {\n            getNewString += getString(arrayCollection[i]);\n        }\n        else {\n            getNewString += ' ' + getString(arrayCollection[i]);\n        }\n    }\n    return getNewString;\n}\n/* eslint-disable */\n/**\n * getString method \\\n *\n * @returns {string} getString method .\\\n * @param { PathSegment} arrayCollection - provide the val  value.\n * @private\n */\nexport function getString(obj) {\n    var string = '';\n    switch (obj.command) {\n        case 'Z':\n        case 'z':\n            string = obj.command;\n            break;\n        case 'M':\n        case 'm':\n        case 'L':\n        case 'l':\n            string = obj.command + ' ' + obj.x + ' ' + obj.y;\n            break;\n        case 'C':\n        case 'c':\n            string = obj.command + ' ' + obj.x1 + ' ' + obj.y1 + ' ' + obj.x2 + ' ' + obj.y2 + ' ' + obj.x + ' ' + obj.y;\n            break;\n        case 'Q':\n        case 'q':\n            string = obj.command + ' ' + obj.x1 + ' ' + obj.y1 + ' ' + obj.x + ' ' + obj.y;\n            break;\n        case 'A':\n        case 'a':\n            var cmd = obj.command;\n            var ang = obj.angle;\n            var l = (obj.largeArc ? '1' : '0');\n            var s = (obj.sweep ? '1' : '0');\n            string = cmd + ' ' + obj.r1 + ' ' + obj.r2 + ' ' + ang + ' ' + l + ' ' + s + ' ' + obj.x + ' ' + obj.y;\n            break;\n        case 'H':\n        case 'h':\n            string = obj.command + ' ' + obj.x;\n            break;\n        case 'V':\n        case 'v':\n            string = obj.command + ' ' + obj.y;\n            break;\n        case 'S':\n        case 's':\n            string = obj.command + ' ' + obj.x2 + ' ' + obj.y2 + ' ' + obj.x + ' ' + obj.y;\n            break;\n        case 'T':\n        case 't':\n            string = obj.command + ' ' + obj.x + ' ' + obj.y;\n    }\n    return string;\n}\n"]},"metadata":{},"sourceType":"module"}