{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { Connector, getBezierPoints, isEmptyVector } from '../objects/connector';\nimport { Node, BpmnSubEvent, BpmnAnnotation, Native } from '../objects/node';\nimport { PathElement } from '../core/elements/path-element';\nimport { TextElement } from '../core/elements/text-element';\nimport { OrthogonalSegment } from '../objects/connector';\nimport { Rect } from '../primitives/rect';\nimport { Diagram } from '../../diagram/diagram';\nimport { identityMatrix, rotateMatrix, transformPointByMatrix, scaleMatrix } from './../primitives/matrix';\nimport { cloneObject as clone, cloneObject, getBounds, getFunction, getIndex } from './../utility/base-util';\nimport { completeRegion, sort, findObjectIndex, intersect3, getAnnotationPosition, findParentInSwimlane } from './../utility/diagram-util';\nimport { updatePathElement, cloneBlazorObject, getUserHandlePosition, cloneSelectedObjects } from './../utility/diagram-util';\nimport { updateDefaultValues } from './../utility/diagram-util';\nimport { randomId, cornersPointsBeforeRotation } from './../utility/base-util';\nimport { Selector } from '../objects/node';\nimport { hasSelection, isSelected, hasSingleConnection, contains } from './actions';\nimport { DiagramEvent } from '../enum/enum';\nimport { BlazorAction } from '../enum/enum';\nimport { canSelect, canMove, canRotate, canDragSourceEnd, canDragTargetEnd, canSingleSelect, canDrag } from './../utility/constraints-util';\nimport { canMultiSelect, canContinuousDraw } from './../utility/constraints-util';\nimport { canPanX, canPanY, canPageEditable } from './../utility/constraints-util';\nimport { SnapConstraints, DiagramTools, DiagramAction, RealAction } from '../enum/enum';\nimport { getDiagramElement, getAdornerLayerSvg, getHTMLLayer, getAdornerLayer, getSelectorElement } from '../utility/dom-util';\nimport { Point } from '../primitives/point';\nimport { Size } from '../primitives/size';\nimport { getObjectType, getPoint, intersect2, getOffsetOfConnector, canShowCorner } from './../utility/diagram-util';\nimport { selectionHasConnector } from './../utility/diagram-util';\nimport { Layer } from '../diagram/layer';\nimport { SelectorConstraints, DiagramConstraints } from '../enum/enum';\nimport { remove, isBlazor, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { getOppositeDirection, getPortDirection, findAngle } from './../utility/connector';\nimport { swapBounds, findPoint, orthoConnection2Segment, getIntersection } from './../utility/connector';\nimport { ShapeAnnotation, PathAnnotation } from '../objects/annotation';\nimport { renderContainerHelper } from './container-interaction';\nimport { checkChildNodeInContainer, checkParentAsContainer, addChildToContainer } from './container-interaction';\nimport { renderStackHighlighter } from './container-interaction';\nimport { getConnectors, updateConnectorsProperties, canLaneInterchange, findLane } from './../utility/swim-lane-util';\nimport { swimLaneSelection, pasteSwimLane, gridSelection } from '../utility/swim-lane-util';\nimport { DeepDiffMapper } from '../utility/diff-map';\n/**\n * Defines the behavior of commands\n */\n\nvar CommandHandler =\n/** @class */\nfunction () {\n  function CommandHandler(diagram) {\n    /**   @private  */\n    this.clipboardData = {}; // private newNodeObject: Object[] = [];\n    // private newConnectorObject: Object[] = [];\n\n    /**   @private  */\n\n    this.diagramObject = {};\n    /**   @private  */\n\n    this.newSelectedObjects = {};\n    /**   @private  */\n\n    this.oldSelectedObjects = {};\n    /**   @private  */\n\n    this.connectorsTable = [];\n    /**   @private  */\n\n    this.processTable = {};\n    /**   @private  */\n\n    this.deepDiffer = new DeepDiffMapper();\n    /** @private */\n\n    this.isContainer = false;\n    this.childTable = {};\n    this.parentTable = {};\n    this.blazor = 'Blazor';\n    this.blazorInterop = 'sfBlazor';\n    this.cloneGroupChildCollection = [];\n    this.diagram = diagram;\n  }\n\n  Object.defineProperty(CommandHandler.prototype, \"snappingModule\", {\n    /**   @private  */\n    get: function () {\n      return this.diagram.snappingModule;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CommandHandler.prototype, \"layoutAnimateModule\", {\n    /**   @private  */\n    get: function () {\n      return this.diagram.layoutAnimateModule;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * startTransaction method\\\n   *\n   * @returns {  void }    startTransaction method .\\\n   * @param {boolean} protectChange - provide the options value.\n   * @private\n   */\n\n  CommandHandler.prototype.startTransaction = function (protectChange) {\n    this.state = {\n      element: this.diagram.selectedItems,\n      backup: null\n    };\n\n    if (protectChange) {\n      this.diagram.protectPropertyChange(true);\n    }\n\n    getAdornerLayer(this.diagram.element.id).style.pointerEvents = 'none';\n  };\n  /**\n   * endTransaction method\\\n   *\n   * @returns {  void }    endTransaction method .\\\n   * @param {boolean} protectChange - provide the options value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.endTransaction = function (protectChange) {\n    this.state = null;\n\n    if (protectChange) {\n      this.diagram.protectPropertyChange(false);\n    }\n\n    getAdornerLayer(this.diagram.element.id).style.pointerEvents = 'all';\n  };\n  /**\n   * setFocus method\\\n   *\n   * @returns {  void }    setFocus method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.setFocus = function () {\n    document.getElementById(this.diagram.element.id).focus();\n  };\n  /**\n   * showTooltip method\\\n   *\n   * @returns {  void }    showTooltip method .\\\n   * @param {IElement} node - provide the options value.\n   * @param {PointModel} position - provide the position value.\n   * @param {string | HTMLElement} content - provide the content value.\n   * @param {string} toolName - provide the toolName value.\n   * @param {boolean} isTooltipVisible - provide the isTooltipVisible value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.showTooltip = function (node, position, content, toolName, isTooltipVisible) {\n    var _this = this;\n\n    var targetId;\n    var targetEle;\n    var isNative = false;\n\n    if (node instanceof Selector) {\n      if (node.nodes.length == 1 && node.connectors.length == 0) {\n        targetId = node.nodes[0].id;\n\n        if (node.nodes[0].shape && node.nodes[0].shape instanceof Native) {\n          isNative = true;\n        }\n      } else if (node.nodes.length == 0 && node.connectors.length == 1) {\n        targetId = node.connectors[0].id;\n      } else {\n        targetEle = document.getElementById(this.diagram.element.id + '_SelectorElement');\n      }\n    } else if (node instanceof Node) {\n      targetId = node.id;\n\n      if (node.shape && node.shape instanceof Native) {\n        isNative = true;\n      }\n    } else {\n      targetId = node.id;\n    }\n\n    if (isNullOrUndefined(targetEle) && !isNullOrUndefined(targetId)) {\n      var idName = isNative ? '_content_native_element' : '_groupElement';\n      targetEle = document.getElementById(targetId + idName);\n    }\n\n    if (isTooltipVisible) {\n      this.diagram.tooltipObject.position = 'BottomCenter';\n      this.diagram.tooltipObject.animation = {\n        open: {\n          delay: 0,\n          duration: 0\n        }\n      };\n      this.diagram.tooltipObject.openDelay = 0;\n      this.diagram.tooltipObject.closeDelay = 0;\n    }\n\n    if (this.diagram.selectedItems.setTooltipTemplate) {\n      var template = void 0;\n      var setTooltipTemplate = getFunction(this.diagram.selectedItems.setTooltipTemplate);\n\n      if (setTooltipTemplate) {\n        template = setTooltipTemplate(node, this.diagram);\n      }\n\n      if (template instanceof HTMLElement) {\n        content = template.cloneNode(true);\n      } else {\n        content = template ? template : content;\n      }\n    }\n\n    if (isBlazor() && isTooltipVisible) {\n      this.diagram.tooltipObject.close();\n    }\n\n    if (node.tooltip) {\n      this.diagram.tooltipObject.openOn = node.tooltip.openOn;\n    }\n\n    this.diagram.tooltipObject.content = content;\n    this.diagram.tooltipObject.offsetX = 0;\n    this.diagram.tooltipObject.offsetY = 0;\n\n    if (isBlazor()) {\n      this.diagram.tooltipObject.updateTooltip(targetEle);\n    } else {\n      this.diagram.tooltipObject.refresh(targetEle);\n    }\n\n    if (isTooltipVisible) {\n      setTimeout(function () {\n        _this.diagram.tooltipObject.open(targetEle);\n      }, 1);\n    }\n  };\n  /**\n   * closeTooltip method\\\n   *\n   * @returns {  void }    closeTooltip method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.closeTooltip = function () {\n    this.diagram.tooltipObject.close();\n  };\n  /**\n   * canEnableDefaultTooltip method\\\n   *\n   * @returns {  boolean }    canEnableDefaultTooltip method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.canEnableDefaultTooltip = function () {\n    if (this.diagram.selectedItems.constraints & SelectorConstraints.ToolTip) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * updateSelector method\\\n   *\n   * @returns {  void }    updateSelector method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateSelector = function () {\n    this.diagram.updateSelector();\n  };\n  /**\n   * updateConnectorValue method\\\n   *\n   * @returns {  void }    updateConnectorValue method .\\\n   * @param {IBlazorConnectionChangeEventArgs} args - provide the options value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateConnectorValue = function (args) {\n    if (args.cancel) {\n      this.enableCloneObject(true);\n      this.ismouseEvents(true);\n      this.insertBlazorObject(args.connector);\n      var newChanges = {};\n      var oldChanges = {};\n      var connector = this.diagram.nameTable[args.connector.id];\n      var nodeEndId = args.connectorEnd === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n      var portEndId = args.connectorEnd === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n      var connectionEnd = args.connectorEnd === 'ConnectorTargetEnd';\n      var newValue = connectionEnd ? args.newValue.connectorTargetValue : args.newValue.connectorSourceValue;\n      var oldValue = connectionEnd ? args.oldValue.connectorTargetValue : args.oldValue.connectorSourceValue;\n      oldChanges[nodeEndId] = newValue.nodeId;\n      oldChanges[portEndId] = newValue.portId;\n      newChanges[nodeEndId] = oldValue.nodeId;\n      newChanges[portEndId] = oldValue.portId;\n\n      if (args.cancel && args.connectorEnd !== 'ConnectorTargetEnd') {\n        connector.sourceID = oldValue.nodeId;\n\n        if (args.connector.sourcePortID) {\n          connector.sourcePortID = oldValue.portId;\n        }\n\n        this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n      }\n\n      if (args.cancel && args.connectorEnd === 'ConnectorTargetEnd') {\n        if (args.connector.targetPortID) {\n          connector.targetPortID = oldValue.portId;\n        }\n\n        connector.targetID = oldValue.nodeId;\n        this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n      }\n    }\n  };\n  /**\n   * triggerEvent method\\\n   *\n   * @returns {  Promise<void | object | IBlazorConnectionChangeEventArgs> }    triggerEvent method .\\\n   * @param {DiagramEvent} event - provide the options value.\n   * @param {Object} args - provide the args value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.triggerEvent = function (event, args) {\n    return __awaiter(this, void 0, void 0, function () {\n      var temparg;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (event === DiagramEvent.drop || event === DiagramEvent.positionChange || event === DiagramEvent.connectionChange) {\n              if (this.diagram.currentSymbol) {\n                return [2\n                /*return*/\n                ];\n              }\n\n              if (event === DiagramEvent.drop) {\n                args.source = cloneBlazorObject(this.diagram);\n              }\n\n              if (this.diagram.currentDrawingObject && event !== DiagramEvent.positionChange) {\n                return [2\n                /*return*/\n                ];\n              }\n            }\n\n            return [4\n            /*yield*/\n            , this.diagram.triggerEvent(event, args)];\n\n          case 1:\n            temparg = _a.sent();\n            return [2\n            /*return*/\n            , temparg];\n        }\n      });\n    });\n  };\n  /**\n   * dragOverElement method\\\n   *\n   * @returns { void }    dragOverElement method .\\\n   * @param {MouseEventArgs} args - provide the options value.\n   * @param {PointModel} currentPosition - provide the args value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.dragOverElement = function (args, currentPosition) {\n    if (this.diagram.currentSymbol) {\n      var dragOverArg = {\n        element: cloneBlazorObject(args.source),\n        target: cloneBlazorObject(args.target),\n        mousePosition: cloneBlazorObject(currentPosition),\n        diagram: cloneBlazorObject(this.diagram)\n      };\n      this.triggerEvent(DiagramEvent.dragOver, dragOverArg);\n    }\n  };\n  /**\n   * disConnect method\\\n   *\n   * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    disConnect method .\\\n   * @param {IElement} obj - provide the obj value.\n   * @param {string} endPoint - provide the endPoint value.\n   * @param {boolean} canCancel - provide the canCancel value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.disConnect = function (obj, endPoint, canCancel) {\n    var checkBlazor = isBlazor();\n    var oldChanges = {};\n    var newChanges = {};\n    var returnargs;\n    var selectorModel;\n    var connector;\n\n    if (obj instanceof Selector) {\n      selectorModel = obj;\n      connector = selectorModel.connectors[0];\n    } else if (obj instanceof Connector && this.diagram.currentDrawingObject) {\n      connector = this.diagram.currentDrawingObject;\n    }\n\n    if (obj && connector && (hasSingleConnection(this.diagram) || this.diagram.currentDrawingObject)) {\n      if (isBlazor()) {\n        this.diagram.insertValue(cloneObject(connector), false);\n      }\n\n      if (endPoint && (endPoint === 'ConnectorSourceEnd' || endPoint === 'ConnectorTargetEnd')) {\n        var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n\n        if (connector[nodeEndId]) {\n          //connector.sourceID || connector.targetID\n          oldChanges[nodeEndId] = connector[nodeEndId];\n          connector[nodeEndId] = '';\n          newChanges[nodeEndId] = connector[nodeEndId];\n\n          if (connector.sourcePortID || connector.targetPortID) {\n            oldChanges[portEndId] = connector[portEndId];\n            connector[portEndId] = '';\n            newChanges[portEndId] = connector[portEndId];\n          }\n\n          returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);\n        }\n      } else if (endPoint !== 'OrthoThumb' && endPoint !== 'SegmentEnd' && (connector.sourceID || connector.targetID)) {\n        oldChanges = {\n          sourceID: connector.sourceID,\n          sourcePortID: connector.sourcePortID,\n          targetID: connector.targetID,\n          targetPortID: connector.targetPortID\n        };\n        connector.sourceID = '';\n        connector.sourcePortID = '';\n        connector.targetID = '';\n        connector.targetPortID = '';\n        newChanges = {\n          sourceID: connector.sourceID,\n          sourcePortID: connector.sourcePortID,\n          targetID: connector.targetID,\n          targetPortID: connector.targetPortID\n        };\n        var arg = {\n          connector: cloneBlazorObject(connector),\n          oldValue: oldChanges,\n          newValue: newChanges,\n          cancel: false,\n          state: 'Changing',\n          connectorEnd: endPoint\n        };\n\n        if (isBlazor()) {\n          arg = {\n            connector: cloneBlazorObject(connector),\n            oldValue: {\n              connector: cloneBlazorObject(oldChanges)\n            },\n            newValue: {\n              connector: cloneBlazorObject(newChanges)\n            },\n            cancel: false,\n            state: 'Changed',\n            connectorEnd: endPoint\n          };\n          returnargs = arg;\n        }\n\n        if (!checkBlazor) {\n          this.triggerEvent(DiagramEvent.connectionChange, arg);\n        }\n\n        if (arg.cancel) {\n          connector.sourceID = oldChanges.sourceID;\n          connector.sourcePortID = oldChanges.sourcePortID;\n          connector.targetID = oldChanges.targetID;\n          connector.targetPortID = oldChanges.targetPortID;\n        } else {\n          this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n          this.diagram.updateDiagramObject(connector);\n          arg = {\n            connector: connector,\n            oldValue: oldChanges,\n            newValue: newChanges,\n            cancel: false,\n            state: 'Changed',\n            connectorEnd: endPoint\n          };\n\n          if (isBlazor()) {\n            arg = {\n              connector: cloneBlazorObject(connector),\n              oldValue: {\n                connector: oldChanges\n              },\n              newValue: {\n                connector: newChanges\n              },\n              cancel: false,\n              state: 'Changed',\n              connectorEnd: endPoint\n            };\n            returnargs = arg;\n          }\n\n          if (!checkBlazor) {\n            this.triggerEvent(DiagramEvent.connectionChange, arg);\n          }\n        }\n      }\n    }\n\n    return returnargs;\n  };\n\n  CommandHandler.prototype.connectionEventChange = function (connector, oldChanges, newChanges, endPoint, canCancel) {\n    var checkBlazor = isBlazor();\n    var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n    var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n    var connectedNode;\n\n    if (this.enableCloneObject) {\n      connectedNode = this.diagram.nameTable[newChanges[nodeEndId]];\n      var nodeObject = cloneObject(connectedNode);\n      this.diagram.insertValue(nodeObject, true);\n    }\n\n    var returnargs;\n    var arg = {\n      cancel: false,\n      state: 'Changing',\n      connectorEnd: endPoint,\n      connector: cloneBlazorObject(connector),\n      oldValue: {\n        nodeId: oldChanges[nodeEndId],\n        portId: oldChanges[portEndId]\n      },\n      newValue: {\n        nodeId: newChanges[nodeEndId],\n        portId: newChanges[portEndId]\n      }\n    };\n\n    if (isBlazor()) {\n      arg = {\n        connector: cloneBlazorObject(connector),\n        cancel: false,\n        state: 'Changing',\n        connectorEnd: endPoint,\n        oldValue: undefined,\n        newValue: undefined\n      };\n\n      if (endPoint === 'ConnectorSourceEnd') {\n        arg.oldValue = {\n          connectorSourceValue: {\n            portId: oldChanges[portEndId],\n            nodeId: oldChanges[nodeEndId]\n          }\n        };\n        arg.newValue = {\n          connectorSourceValue: {\n            nodeId: newChanges[nodeEndId],\n            portId: newChanges[portEndId]\n          }\n        };\n      } else {\n        arg.oldValue = {\n          connectorTargetValue: {\n            nodeId: oldChanges[nodeEndId],\n            portId: oldChanges[portEndId]\n          }\n        };\n        arg.newValue = {\n          connectorTargetValue: {\n            nodeId: newChanges[nodeEndId],\n            portId: newChanges[portEndId]\n          }\n        };\n      }\n\n      returnargs = arg;\n    }\n\n    if (!checkBlazor) {\n      this.triggerEvent(DiagramEvent.connectionChange, arg);\n    }\n\n    if (arg.cancel || isBlazor() && canCancel) {\n      connector[nodeEndId] = oldChanges[nodeEndId];\n      connector[portEndId] = oldChanges[portEndId];\n      newChanges = oldChanges;\n    } else {\n      this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n      this.diagram.updateDiagramObject(connector);\n      arg = {\n        connector: cloneBlazorObject(connector),\n        oldValue: {\n          nodeId: oldChanges[nodeEndId],\n          portId: oldChanges[portEndId]\n        },\n        newValue: {\n          nodeId: newChanges[nodeEndId],\n          portId: newChanges[portEndId]\n        },\n        cancel: false,\n        state: 'Changing',\n        connectorEnd: endPoint\n      };\n\n      if (isBlazor()) {\n        arg = {\n          connector: cloneBlazorObject(connector),\n          oldValue: undefined,\n          newValue: undefined,\n          cancel: false,\n          state: 'Changing',\n          connectorEnd: endPoint\n        };\n\n        if (endPoint === 'ConnectorSourceEnd') {\n          arg.newValue = {\n            connectorSourceValue: {\n              portId: newChanges[portEndId],\n              nodeId: newChanges[nodeEndId]\n            }\n          };\n          arg.oldValue = {\n            connectorSourceValue: {\n              portId: oldChanges[portEndId],\n              nodeId: oldChanges[nodeEndId]\n            }\n          };\n        } else {\n          arg.oldValue = {\n            connectorTargetValue: {\n              nodeId: oldChanges[nodeEndId],\n              portId: oldChanges[portEndId]\n            }\n          };\n          arg.newValue = {\n            connectorTargetValue: {\n              portId: newChanges[portEndId],\n              nodeId: newChanges[nodeEndId]\n            }\n          };\n        }\n\n        returnargs = arg;\n      }\n    }\n\n    if (this.enableCloneObject) {\n      if (connectedNode === undefined) {\n        connectedNode = this.diagram.nameTable[oldChanges[nodeEndId]];\n        var nodeObject = cloneObject(connectedNode);\n        this.diagram.insertValue(nodeObject, true);\n      }\n    }\n\n    return returnargs;\n  };\n  /**\n   * insertBlazorObject method\\\n   *\n   * @returns { void }    insertBlazorObject method .\\\n   * @param {IElement} object - provide the object value.\n   * @param {boolean} isNode - provide the isNode value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.insertBlazorObject = function (object, isNode) {\n    var node;\n    var connector;\n\n    if (object instanceof Selector) {\n      this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n\n      for (var i = 0; i < object.nodes.length; i++) {\n        node = this.diagram.getObject(object.nodes[i].id);\n        this.diagram.insertValue(cloneObject(node), true);\n      }\n\n      for (var i = 0; i < object.connectors.length; i++) {\n        connector = this.diagram.getObject(object.connectors[i].id);\n        this.diagram.insertValue(cloneObject(connector), false);\n      }\n    } else {\n      object = this.diagram.getObject(object.id);\n      this.diagram.insertValue(cloneObject(object), object instanceof Node ? true : false);\n    }\n  };\n  /**\n   * updatePropertiesToBlazor method\\\n   *\n   * @returns { void }    updatePropertiesToBlazor method .\\\n   * @param {MouseEventArgs} args - provide the args value.\n   * @param {PointModel} labelDrag - provide the labelDrag value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.updatePropertiesToBlazor = function (args, labelDrag) {\n    this.enableCloneObject(false);\n    this.ismouseEvents(false);\n    this.getBlazorOldValues(args, labelDrag);\n    this.updateBlazorSelector();\n  };\n  /**\n   * insertSelectedObjects method\\\n   *\n   * @returns { void }    insertSelectedObjects method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.insertSelectedObjects = function () {\n    this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n  };\n  /**\n   * findTarget method\\\n   *\n   * @returns { NodeModel | PointPortModel | ShapeAnnotationModel | PathAnnotationModel }    findTarget method .\\\n   * @param {DiagramElement} element - provide the element value.\n   * @param {IElement} argsTarget - provide the argsTarget value.\n   * @param {boolean} source - provide the source value.\n   * @param {boolean} connection - provide the connection value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.findTarget = function (element, argsTarget, source, connection) {\n    var target;\n\n    if (argsTarget instanceof Node) {\n      if (element && element.id === argsTarget.id + '_content') {\n        return argsTarget;\n      }\n\n      if (source && argsTarget.shape.type === 'Bpmn' && (!isBlazor() && argsTarget.shape.shape === 'Activity' || isBlazor() && argsTarget.shape.bpmnShape === 'Activity')) {\n        if (argsTarget.shape.activity.subProcess.type === 'Transaction') {\n          var transaction = argsTarget.shape.activity.subProcess.transaction;\n\n          if (transaction.success.visible && element.id.indexOf(argsTarget.id + '_success') === 0) {\n            return transaction.success;\n          }\n\n          if (transaction.cancel.visible && element.id.indexOf(argsTarget.id + '_cancel') === 0) {\n            return transaction.cancel;\n          }\n\n          if (transaction.failure.visible && element.id.indexOf(argsTarget.id + '_failure') === 0) {\n            return transaction.failure;\n          }\n        }\n      }\n\n      if (element instanceof PathElement) {\n        for (var i = 0; i < argsTarget.ports.length; i++) {\n          var port = argsTarget.ports[i];\n\n          if (element.id === argsTarget.id + '_' + port.id) {\n            return port;\n          }\n        }\n      }\n    }\n\n    if (!connection) {\n      var annotation = void 0;\n\n      for (var i = 0; i < argsTarget.annotations.length; i++) {\n        annotation = argsTarget.annotations[i];\n\n        if (element.id === argsTarget.id + '_' + annotation.id) {\n          return annotation;\n        }\n      }\n    }\n\n    return argsTarget;\n  };\n  /**\n   * canDisconnect method\\\n   *\n   * @returns { boolean }    canDisconnect method .\\\n   * @param {string} endPoint - provide the endPoint value.\n   * @param {MouseEventArgs} args - provide the args value.\n   * @param {string} targetPortId - provide the targetPortId value.\n   * @param {string} targetNodeId - provide the targetNodeId value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.canDisconnect = function (endPoint, args, targetPortId, targetNodeId) {\n    var selector;\n    var connect;\n\n    if (args.source instanceof Selector) {\n      selector = args.source;\n      connect = selector.connectors[0];\n    } else if (args.source instanceof Connector && this.diagram.currentDrawingObject) {\n      connect = this.diagram.currentDrawingObject;\n    }\n\n    var targetObject = this.findTarget(args.targetWrapper, args.target, endPoint === 'ConnectorSourceEnd', true);\n    var nodeEnd = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n    var portEnd = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n\n    if (connect[nodeEnd] !== targetNodeId || connect[portEnd] !== targetPortId) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * changeAnnotationDrag method\\\n   *\n   * @returns { void }    changeAnnotationDrag method .\\\n   * @param {MouseEventArgs} args - provide the endPoint value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.changeAnnotationDrag = function (args) {\n    var selectorModel;\n    var connector;\n\n    if (args.source && args.source.connectors && args.source.connectors.length && this.diagram.bpmnModule && this.diagram.bpmnModule.textAnnotationConnectors.indexOf(args.source.connectors[0]) > -1) {\n      if (args.source instanceof Selector) {\n        selectorModel = args.source;\n        connector = selectorModel.connectors[0];\n      }\n\n      var id = connector.id.split('_');\n      var annotationId = id[id.length - 1];\n      var nodeId = id[id.length - 3] || id[0];\n\n      if (args.target && args.target.id !== nodeId && (!isBlazor() && args.target.shape.shape !== 'TextAnnotation' || isBlazor() && args.target.shape.bpmnShape !== 'TextAnnotation')) {\n        this.diagram.startGroupAction();\n        var parentNode = this.diagram.nameTable[id[0]];\n        var clonedNode = this.getAnnotation(parentNode, id[1]);\n        var annotationNode = {\n          id: id[1] + randomId(),\n          angle: Point.findAngle(connector.intermediatePoints[0], connector.intermediatePoints[1]),\n          text: clonedNode.text,\n          length: Point.distancePoints(connector.intermediatePoints[0], connector.intermediatePoints[1]),\n          shape: {\n            shape: 'TextAnnotation',\n            type: 'Bpmn'\n          },\n          nodeId: clonedNode.nodeId\n        };\n        var annotationObj = new BpmnAnnotation(args.target.shape, 'annotations', annotationNode, true);\n        this.diagram.bpmnModule.checkAndRemoveAnnotations(this.diagram.nameTable[connector.targetID], this.diagram);\n        this.diagram.refreshCanvasLayers();\n        annotationObj.id = id[1];\n        this.diagram.addTextAnnotation(annotationObj, args.target);\n        this.diagram.endGroupAction();\n      } else if (connector) {\n        connector.sourceID = nodeId;\n        this.diagram.connectorPropertyChange(connector, {}, {\n          sourceID: nodeId\n        });\n        this.diagram.updateDiagramObject(connector);\n      }\n    }\n  };\n  /* tslint:disable */\n\n  /**\n   * connect method\\\n   *\n   * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    connect method .\\\n   * @param {string} endPoint - provide the endPoint value.\n   * @param {MouseEventArgs} args - provide the args value.\n   * @param {boolean} canCancel - provide the canCancel value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.connect = function (endPoint, args, canCancel) {\n    var checkBlazor;\n    var newChanges = {};\n    var oldChanges = {};\n    var oldNodeId;\n    var oldPortId;\n    var selectorModel;\n    var connector;\n    var returnargs;\n\n    if (args.source instanceof Selector) {\n      selectorModel = args.source;\n      connector = selectorModel.connectors[0];\n    } else if (args.source instanceof Connector && this.diagram.currentDrawingObject) {\n      connector = this.diagram.currentDrawingObject;\n    }\n\n    var target = this.findTarget(args.targetWrapper || args.sourceWrapper, args.target || args.actualObject, endPoint === 'ConnectorSourceEnd', true);\n    var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n    var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n\n    if (target instanceof Node) {\n      oldChanges[nodeEndId] = connector[nodeEndId];\n      connector[nodeEndId] = target.id;\n      newChanges[nodeEndId] = connector[nodeEndId];\n      oldChanges[portEndId] = connector[portEndId];\n      returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);\n    } else {\n      oldNodeId = connector[nodeEndId];\n      oldPortId = connector[portEndId];\n      connector[portEndId] = target.id;\n      connector[nodeEndId] = args.target && args.target.id || args.actualObject.id;\n      newChanges[nodeEndId] = connector[nodeEndId];\n      newChanges[portEndId] = connector[portEndId];\n      var arg = {\n        connector: cloneBlazorObject(connector),\n        oldValue: {\n          nodeId: oldNodeId,\n          portId: oldPortId\n        },\n        newValue: {\n          nodeId: newChanges[nodeEndId],\n          portId: newChanges[portEndId]\n        },\n        cancel: false,\n        state: 'Changing',\n        connectorEnd: endPoint\n      };\n\n      if (isBlazor()) {\n        arg = {\n          connector: cloneBlazorObject(connector),\n          oldValue: undefined,\n          newValue: undefined,\n          cancel: false,\n          state: 'Changing',\n          connectorEnd: endPoint\n        };\n\n        if (endPoint === 'ConnectorSourceEnd') {\n          arg.oldValue = {\n            connectorSourceValue: {\n              portId: oldChanges[portEndId],\n              nodeId: oldChanges[nodeEndId]\n            }\n          };\n          arg.newValue = {\n            connectorSourceValue: {\n              portId: newChanges[portEndId],\n              nodeId: newChanges[nodeEndId]\n            }\n          };\n        } else {\n          arg.newValue = {\n            connectorTargetValue: {\n              portId: newChanges[portEndId],\n              nodeId: newChanges[nodeEndId]\n            }\n          };\n          arg.oldValue = {\n            connectorTargetValue: {\n              portId: oldChanges[portEndId],\n              nodeId: oldChanges[nodeEndId]\n            }\n          };\n        }\n\n        returnargs = arg;\n      }\n\n      if (!checkBlazor) {\n        this.triggerEvent(DiagramEvent.connectionChange, arg);\n      }\n\n      if (arg.cancel || isBlazor() && canCancel) {\n        connector[nodeEndId] = oldNodeId;\n        connector[portEndId] = oldPortId;\n        newChanges[nodeEndId] = oldNodeId;\n        newChanges[portEndId] = oldPortId;\n      } else {\n        this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n        this.diagram.updateDiagramObject(connector);\n        arg = {\n          connector: cloneBlazorObject(connector),\n          oldValue: {\n            nodeId: oldNodeId,\n            portId: oldPortId\n          },\n          newValue: {\n            nodeId: newChanges[nodeEndId],\n            portId: newChanges[portEndId]\n          },\n          cancel: false,\n          state: 'Changing',\n          connectorEnd: endPoint\n        };\n\n        if (isBlazor()) {\n          arg = {\n            newValue: undefined,\n            connector: cloneBlazorObject(connector),\n            oldValue: undefined,\n            cancel: false,\n            state: 'Changing',\n            connectorEnd: endPoint\n          };\n\n          if (endPoint === 'ConnectorSourceEnd') {\n            arg.oldValue = {\n              connectorSourceValue: {\n                portId: oldChanges[portEndId],\n                nodeId: oldChanges[nodeEndId]\n              }\n            };\n            arg.newValue = {\n              connectorTargetValue: {\n                portId: newChanges[portEndId],\n                nodeId: newChanges[nodeEndId]\n              }\n            };\n          } else {\n            arg.oldValue = {\n              connectorTargetValue: {\n                portId: oldChanges[portEndId],\n                nodeId: oldChanges[nodeEndId]\n              }\n            };\n            arg.newValue = {\n              connectorTargetValue: {\n                portId: newChanges[portEndId],\n                nodeId: newChanges[nodeEndId]\n              }\n            };\n          }\n        }\n      }\n    }\n\n    this.renderHighlighter(args, undefined, endPoint === 'ConnectorSourceEnd');\n    return returnargs;\n  };\n  /* tslint:enable */\n\n  /** @private */\n\n  /**\n   * cut method\\\n   *\n   * @returns { void }    cut method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.cut = function () {\n    var index;\n    this.clipboardData.pasteIndex = 0;\n\n    if (this.diagram.undoRedoModule) {\n      this.diagram.historyManager.startGroupAction();\n    }\n\n    this.clipboardData.clipObject = this.copyObjects();\n\n    if (this.diagram.undoRedoModule) {\n      this.diagram.historyManager.endGroupAction();\n    }\n\n    if (this.diagram.mode !== 'SVG') {\n      this.diagram.refreshDiagramLayer();\n    }\n  };\n\n  CommandHandler.prototype.UpdateBlazorDiagramModelLayers = function (layer, isRemove) {\n    var blazorInterop = 'sfBlazor';\n    var updatedModel = cloneBlazorObject(layer);\n    var blazor = 'Blazor';\n\n    if (window && window[blazor]) {\n      var obj = {\n        'methodName': 'UpdateBlazorDiagramModelLayers',\n        'diagramobj': JSON.stringify(updatedModel),\n        'isRemove': isRemove\n      };\n\n      if (!this.diagram.isLoading) {\n        window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n      }\n    }\n  };\n  /**\n   * addLayer method\\\n   *\n   * @returns { void }    addLayer method .\\\n   * @param {LayerModel} layer - provide the endPoint value.\n   * @param {Object[]} objects - provide the args value.\n   * @param {boolean} isServerUpdate - provide the canCancel value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.addLayer = function (layer, objects, isServerUpdate) {\n    if (isServerUpdate === void 0) {\n      isServerUpdate = true;\n    }\n\n    layer.id = layer.id || randomId();\n    layer.zIndex = this.diagram.layers.length;\n    var isEnableServerDatabind = this.diagram.allowServerDataBinding;\n    this.diagram.enableServerDataBinding(false);\n    layer = new Layer(this.diagram, 'layers', layer, true);\n    this.diagram.enableServerDataBinding(isEnableServerDatabind);\n    layer.objectZIndex = -1;\n    layer.zIndexTable = {};\n    this.diagram.layers.push(layer);\n\n    if (isServerUpdate) {\n      this.UpdateBlazorDiagramModelLayers(layer, false);\n    }\n\n    this.diagram.layerZIndexTable[layer.zIndex] = layer.id;\n    this.diagram.activeLayer = layer;\n    var layers = layer.objects;\n\n    if (objects) {\n      for (var i = 0; i < objects.length; i++) {\n        this.diagram.add(objects[i]);\n      }\n    }\n  };\n  /**\n   * getObjectLayer method\\\n   *\n   * @returns { LayerModel }    getObjectLayer method .\\\n   * @param {string} objectName - provide the endPoint value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.getObjectLayer = function (objectName) {\n    var layers = this.diagram.layers;\n\n    for (var i = 0; i < layers.length; i++) {\n      var objIndex = layers[i].objects.indexOf(objectName);\n\n      if (objIndex > -1) {\n        return layers[i];\n      }\n    }\n\n    return this.diagram.activeLayer;\n  };\n  /**\n   * getLayer method\\\n   *\n   * @returns { LayerModel }    getLayer method .\\\n   * @param {string} layerName - provide the endPoint value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.getLayer = function (layerName) {\n    var layers = this.diagram.layers;\n\n    for (var i = 0; i < layers.length; i++) {\n      if (layers[i].id === layerName) {\n        return layers[i];\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * removeLayer method\\\n   *\n   * @returns { void }    removeLayer method .\\\n   * @param {string} layerId - provide the endPoint value.\n   * @param {boolean} isServerUpdate - provide the endPoint value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.removeLayer = function (layerId, isServerUpdate) {\n    if (isServerUpdate === void 0) {\n      isServerUpdate = true;\n    }\n\n    var layers = this.getLayer(layerId);\n\n    if (layers) {\n      var index = this.diagram.layers.indexOf(layers);\n      var layerObject = layers.objects;\n\n      for (var i = layerObject.length - 1; i >= 0; i--) {\n        this.diagram.unSelect(this.diagram.nameTable[layerObject[i]]);\n        this.diagram.remove(this.diagram.nameTable[layerObject[i]]);\n\n        if (layers.id !== 'default_layer') {\n          if (this.diagram.activeLayer.id === layerId) {\n            this.diagram.activeLayer = this.diagram.layers[this.diagram.layers.length - 1];\n          }\n        }\n      }\n\n      if (isServerUpdate) {\n        this.UpdateBlazorDiagramModelLayers(this.diagram.layers[index], true);\n      }\n\n      delete this.diagram.layerZIndexTable[layers.zIndex];\n      this.diagram.layers.splice(index, 1);\n\n      if (this.diagram.mode !== 'SVG') {\n        this.diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /**\n   * moveObjects method\\\n   *\n   * @returns { void }    moveObjects method .\\\n   * @param {string[]]} objects - provide the objects value.\n   * @param {string} targetLayer - provide the targetLayer value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.moveObjects = function (objects, targetLayer) {\n    var layer = this.getLayer(targetLayer) || this.diagram.activeLayer;\n    this.diagram.setActiveLayer(layer.id);\n    var targerNodes;\n\n    for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {\n      var i = objects_1[_i];\n      var layer_1 = this.getObjectLayer(i);\n      var index = layer_1.objects.indexOf(i);\n\n      if (index > -1) {\n        targerNodes = this.diagram.nameTable[i];\n        this.diagram.unSelect(targerNodes);\n        this.diagram.remove(this.diagram.nameTable[i]);\n        this.diagram.add(targerNodes);\n      }\n    }\n  };\n  /**\n   * cloneLayer method\\\n   *\n   * @returns { void }    cloneLayer method .\\\n   * @param {string[]} layerName - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.cloneLayer = function (layerName) {\n    var layers = this.diagram.layers;\n    var layer = this.getLayer(layerName);\n\n    if (layer) {\n      var cloneObject_1 = [];\n      var newlayer = {\n        id: layerName + '_' + randomId(),\n        objects: [],\n        visible: true,\n        lock: false\n      };\n      this.addLayer(newlayer, null, true);\n      newlayer.zIndex = this.diagram.layers.length - 1;\n      var multiSelect = cloneObject_1.length !== 1;\n\n      for (var _i = 0, _a = layer.objects; _i < _a.length; _i++) {\n        var obj = _a[_i];\n        cloneObject_1.push(this.diagram.nameTable[obj]);\n      }\n\n      this.paste(cloneObject_1);\n    }\n  };\n  /**\n   * copy method\\\n   *\n   * @returns { void }    copy method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.copy = function () {\n    this.clipboardData.pasteIndex = 1;\n    this.clipboardData.clipObject = this.copyObjects();\n    return this.clipboardData.clipObject;\n  };\n  /**\n   * copyObjects method\\\n   *\n   * @returns { Object[] }    copyObjects method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.copyObjects = function () {\n    var selectedItems = [];\n    var obj = [];\n    this.clipboardData.childTable = {};\n\n    if (this.diagram.selectedItems.connectors.length > 0) {\n      selectedItems = this.diagram.selectedItems.connectors;\n\n      for (var j = 0; j < selectedItems.length; j++) {\n        var element = void 0;\n\n        if (this.diagram.bpmnModule && this.diagram.bpmnModule.textAnnotationConnectors.indexOf(selectedItems[j]) > -1) {\n          element = cloneObject(this.diagram.nameTable[selectedItems[j].targetID]);\n        } else {\n          element = cloneObject(selectedItems[j]);\n        }\n\n        obj.push(element);\n      }\n    }\n\n    if (this.diagram.selectedItems.nodes.length > 0) {\n      selectedItems = selectedItems.concat(this.diagram.selectedItems.nodes);\n\n      for (var j = 0; j < this.diagram.selectedItems.nodes.length; j++) {\n        if (!selectedItems[j].isPhase) {\n          var node = clone(this.diagram.selectedItems.nodes[j]);\n\n          if (node.wrapper && node.offsetX !== node.wrapper.offsetX) {\n            node.offsetX = node.wrapper.offsetX;\n          }\n\n          if (node.wrapper && node.offsetY !== node.wrapper.offsetY) {\n            node.offsetY = node.wrapper.offsetY;\n          }\n\n          var processTable = {};\n          this.copyProcesses(node);\n          obj.push(clone(node));\n          var matrix = identityMatrix();\n          rotateMatrix(matrix, -node.rotateAngle, node.offsetX, node.offsetY);\n\n          if (node.children) {\n            var childTable = this.clipboardData.childTable;\n            var tempNode = void 0;\n            var elements = [];\n            var nodes = this.getAllDescendants(node, elements, true);\n\n            for (var i = 0; i < nodes.length; i++) {\n              tempNode = this.diagram.nameTable[nodes[i].id];\n              var clonedObject = childTable[tempNode.id] = clone(tempNode);\n              var newOffset = transformPointByMatrix(matrix, {\n                x: clonedObject.wrapper.offsetX,\n                y: clonedObject.wrapper.offsetY\n              });\n\n              if (tempNode instanceof Node) {\n                clonedObject.offsetX = newOffset.x;\n                clonedObject.offsetY = newOffset.y;\n                clonedObject.rotateAngle -= node.rotateAngle;\n              }\n            }\n\n            this.clipboardData.childTable = childTable;\n          }\n\n          if (node.shape.type === 'SwimLane') {\n            var swimlane = this.diagram.getObject(this.diagram.selectedItems.nodes[j].id);\n            var childTable = this.clipboardData.childTable;\n            var connectorsList = getConnectors(this.diagram, swimlane.wrapper.children[0], 0, true);\n\n            for (var i = 0; i < connectorsList.length; i++) {\n              var connector = this.diagram.getObject(connectorsList[i]);\n              childTable[connector.id] = clone(connector);\n            }\n          }\n\n          if (node && node.isLane) {\n            var childTable = this.clipboardData.childTable;\n            var swimlane = this.diagram.getObject(node.parentId);\n            var lane = findLane(node, this.diagram);\n            childTable[node.id] = cloneObject(lane);\n            childTable[node.id].width = swimlane.wrapper.actualSize.width;\n          }\n        }\n      }\n    }\n\n    if (this.clipboardData.pasteIndex === 0) {\n      this.startGroupAction();\n\n      for (var _i = 0, selectedItems_1 = selectedItems; _i < selectedItems_1.length; _i++) {\n        var item = selectedItems_1[_i];\n\n        if (this.diagram.nameTable[item.id]) {\n          if (this.diagram.bpmnModule && this.diagram.bpmnModule.textAnnotationConnectors.indexOf(item) > -1) {\n            this.diagram.remove(this.diagram.nameTable[item.targetID]);\n          } else {\n            this.diagram.remove(item);\n          }\n        }\n      }\n\n      this.endGroupAction();\n    }\n\n    this.sortByZIndex(obj, 'zIndex');\n    return obj;\n  };\n\n  CommandHandler.prototype.copyProcesses = function (node) {\n    if (node.shape.type === 'Bpmn' && node.shape.activity && node.shape.activity.subProcess.processes && node.shape.activity.subProcess.processes.length > 0) {\n      var processes = node.shape.activity.subProcess.processes;\n\n      for (var _i = 0, processes_1 = processes; _i < processes_1.length; _i++) {\n        var i = processes_1[_i];\n        this.processTable[i] = clone(this.diagram.nameTable[i]);\n\n        if (this.processTable[i].shape.activity.subProcess.processes && this.processTable[i].shape.activity.subProcess.processes.length > 0) {\n          this.copyProcesses(this.processTable[i]);\n        }\n      }\n\n      this.clipboardData.processTable = this.processTable;\n    }\n  };\n  /**\n   * group method\\\n   *\n   * @returns { void }    group method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.group = function () {\n    this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n    var propName = 'isProtectedOnChange';\n    var protectedChange = this.diagram[propName];\n    this.diagram.protectPropertyChange(true);\n    this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Group;\n    var selectedItems = [];\n    var obj = {}; //let group: Node | Connector;\n\n    obj.id = 'group' + randomId();\n    obj = new Node(this.diagram, 'nodes', obj, true);\n    obj.children = [];\n    selectedItems = this.diagram.selectedItems.nodes;\n    selectedItems = selectedItems.concat(this.diagram.selectedItems.connectors);\n    var order = selectedItems.sort(function (a, b) {\n      return a.zIndex - b.zIndex;\n    });\n\n    for (var i = 0; i < order.length; i++) {\n      if (!order[i].parentId) {\n        obj.children.push(order[i].id);\n      }\n    }\n\n    var group = this.diagram.add(obj);\n\n    if (group) {\n      this.select(group);\n    }\n\n    var entry = {\n      type: 'Group',\n      undoObject: obj,\n      redoObject: obj,\n      category: 'Internal'\n    };\n    this.addHistoryEntry(entry);\n    this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Group;\n    this.diagram.protectPropertyChange(protectedChange);\n    this.updateBlazorSelector();\n  };\n  /**\n   * unGroup method\\\n   *\n   * @returns {  void }    unGroup method .\\\n   * @param {NodeModel} obj - provide the angle value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.unGroup = function (obj) {\n    var propName = 'isProtectedOnChange';\n    var protectedChange = this.diagram[propName];\n    this.diagram.protectPropertyChange(true);\n    this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Group;\n    var selectedItems = [];\n\n    if (obj) {\n      selectedItems.push(obj);\n    } else {\n      selectedItems = this.diagram.selectedItems.nodes;\n    }\n\n    this.diagram.startGroupAction();\n\n    for (var i = 0; i < selectedItems.length; i++) {\n      var node = selectedItems[i];\n      var undoObject = cloneObject(node);\n      var childCollection = [];\n\n      for (var k = 0; k < node.children.length; k++) {\n        childCollection.push(node.children[k]);\n      }\n\n      if (node.children) {\n        if (node.ports && node.ports.length > 0) {\n          this.diagram.removePorts(node, node.ports);\n        }\n\n        if (node.annotations && node.annotations.length > 0 && (!isBlazor() || isBlazor() && node.annotations[0].content !== '')) {\n          this.diagram.removeLabels(node, node.annotations);\n        }\n\n        var parentNode = this.diagram.nameTable[node.parentId];\n\n        for (var j = node.children.length - 1; j >= 0; j--) {\n          this.diagram.nameTable[node.children[j]].parentId = '';\n          this.diagram.deleteChild(this.diagram.nameTable[node.children[j]], node);\n\n          if (node.parentId && node.children[j]) {\n            this.diagram.addChild(parentNode, node.children[j]);\n          }\n        }\n\n        this.resetDependentConnectors(node.inEdges, true);\n        this.resetDependentConnectors(node.outEdges, false);\n        var entry = {\n          type: 'UnGroup',\n          undoObject: undoObject,\n          redoObject: undoObject,\n          category: 'Internal'\n        };\n\n        if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n          this.addHistoryEntry(entry);\n        }\n\n        if (node.parentId) {\n          this.diagram.deleteChild(node, parentNode);\n        }\n      }\n\n      this.diagram.removeNode(node, childCollection);\n      this.clearSelection();\n    }\n\n    this.diagram.endGroupAction();\n    this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Group;\n    this.diagram.protectPropertyChange(protectedChange);\n  };\n\n  CommandHandler.prototype.resetDependentConnectors = function (edges, isInEdges) {\n    for (var i = 0; i < edges.length; i++) {\n      var newConnector = this.diagram.nameTable[edges[i]];\n      var undoObject = cloneObject(newConnector);\n      var newProp = void 0;\n\n      if (isInEdges) {\n        newConnector.targetID = '';\n        newConnector.targetPortID = '';\n        newProp = {\n          targetID: newConnector.targetID,\n          targetPortID: newConnector.targetPortID\n        };\n      } else {\n        newConnector.sourceID = '';\n        newConnector.sourcePortID = '';\n        newProp = {\n          sourceID: newConnector.sourceID,\n          sourcePortID: newConnector.sourcePortID\n        };\n      }\n\n      this.diagram.connectorPropertyChange(newConnector, {}, newProp);\n      var entry = {\n        type: 'ConnectionChanged',\n        undoObject: {\n          connectors: [undoObject],\n          nodes: []\n        },\n        redoObject: {\n          connectors: [cloneObject(newConnector)],\n          nodes: []\n        },\n        category: 'Internal'\n      };\n\n      if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n        this.addHistoryEntry(entry);\n      }\n    }\n  };\n  /**\n   * paste method\\\n   *\n   * @returns { void }    paste method .\\\n   * @param {(NodeModel | ConnectorModel)[]} obj - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.paste = function (obj) {\n    if (obj || this.clipboardData.clipObject) {\n      this.diagram.protectPropertyChange(true);\n      var copiedItems = obj ? this.getNewObject(obj) : this.clipboardData.clipObject;\n\n      if (copiedItems) {\n        var multiSelect = copiedItems.length !== 1;\n        var groupAction = false;\n        var objectTable = {};\n        var keyTable = {};\n\n        if (this.clipboardData.pasteIndex !== 0) {\n          this.clearSelection();\n        }\n\n        if (this.diagram.undoRedoModule) {\n          groupAction = true;\n          this.diagram.historyManager.startGroupAction();\n        }\n\n        for (var _i = 0, copiedItems_1 = copiedItems; _i < copiedItems_1.length; _i++) {\n          var copy = copiedItems_1[_i];\n          objectTable[copy.id] = copy;\n        }\n\n        var copiedObject = [];\n\n        if (multiSelect) {\n          // This bool is also consider to prevent selection change event is triggered after every object clone\n          this.diagram.isServerUpdate = true;\n        }\n\n        for (var j = 0; j < copiedItems.length; j++) {\n          var copy = copiedItems[j];\n\n          if (getObjectType(copy) === Connector) {\n            var clonedObj = clone(copy);\n            var nodeId = clonedObj.sourceID;\n            clonedObj.sourceID = '';\n\n            if (objectTable[nodeId] && keyTable[nodeId]) {\n              clonedObj.sourceID = keyTable[nodeId];\n            }\n\n            nodeId = clonedObj.targetID;\n            clonedObj.targetID = '';\n\n            if (objectTable[nodeId] && keyTable[nodeId]) {\n              clonedObj.targetID = keyTable[nodeId];\n            }\n\n            var newObj = this.cloneConnector(clonedObj, multiSelect);\n            copiedObject.push(newObj);\n            keyTable[copy.id] = newObj.id;\n          } else {\n            var newNode = this.cloneNode(copy, multiSelect);\n\n            if (isBlazor() && newNode && newNode.children && newNode.children.length > 0) {\n              copiedObject = copiedObject.concat(this.cloneGroupChildCollection);\n              this.cloneGroupChildCollection = [];\n            } else {\n              copiedObject.push(newNode);\n            } //bpmn text annotations will not be pasted\n\n\n            if (newNode) {\n              keyTable[copy.id] = newNode.id;\n              var edges = copy.inEdges;\n\n              if (edges) {\n                for (var _a = 0, edges_1 = edges; _a < edges_1.length; _a++) {\n                  var edge = edges_1[_a];\n\n                  if (objectTable[edge] && keyTable[edge]) {\n                    var newConnector = this.diagram.nameTable[keyTable[edge]];\n                    newConnector.targetID = keyTable[copy.id];\n                    this.diagram.connectorPropertyChange(newConnector, {\n                      targetID: '',\n                      targetPortID: ''\n                    }, {\n                      targetID: newConnector.targetID,\n                      targetPortID: newConnector.targetPortID\n                    });\n                  }\n                }\n              }\n\n              edges = copy.outEdges;\n\n              if (edges) {\n                for (var _b = 0, edges_2 = edges; _b < edges_2.length; _b++) {\n                  var edge = edges_2[_b];\n\n                  if (objectTable[edge] && keyTable[edge]) {\n                    var newConnector = this.diagram.nameTable[keyTable[edge]];\n                    newConnector.sourceID = keyTable[copy.id];\n                    this.diagram.connectorPropertyChange(newConnector, {\n                      sourceID: '',\n                      sourcePortID: ''\n                    }, {\n                      sourceID: newConnector.sourceID,\n                      sourcePortID: newConnector.sourcePortID\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (multiSelect) {\n          this.diagram.isServerUpdate = false;\n          this.diagram.UpdateBlazorDiagramModelCollection(copiedItems[0], copiedObject);\n          this.getBlazorOldValues();\n          this.diagram.select(copiedObject, true);\n        }\n\n        if (groupAction === true) {\n          this.diagram.historyManager.endGroupAction();\n          groupAction = false;\n        }\n\n        if (this.diagram.mode !== 'SVG') {\n          this.diagram.refreshDiagramLayer();\n        }\n\n        this.clipboardData.pasteIndex++;\n        this.diagram.protectPropertyChange(false);\n      }\n    }\n  };\n\n  CommandHandler.prototype.getNewObject = function (obj) {\n    var newObj;\n    var newobjs = [];\n    this.clipboardData.pasteIndex = 1;\n\n    for (var i = 0; i < obj.length; i++) {\n      newObj = cloneObject(obj[i]);\n      newobjs.push(newObj);\n    }\n\n    return newobjs;\n  };\n\n  CommandHandler.prototype.cloneConnector = function (connector, multiSelect) {\n    //let newConnector: Node | Connector;\n    var cloneObject = clone(connector);\n    this.translateObject(cloneObject);\n    cloneObject.zIndex = -1;\n    var newConnector = this.diagram.add(cloneObject);\n\n    if (!this.diagram.isServerUpdate) {\n      this.selectObjects([newConnector], multiSelect);\n    }\n\n    return newConnector;\n  };\n\n  CommandHandler.prototype.cloneNode = function (node, multiSelect, children, groupnodeID) {\n    var newNode;\n    var connectorsTable = {};\n    var cloneObject = clone(node);\n    var process;\n    var temp = this.diagram.nameTable[node.parentId];\n\n    if (node.shape && node.shape.type === 'Bpmn' && node.shape.activity && node.shape.activity.subProcess.processes && node.shape.activity.subProcess.processes.length) {\n      process = cloneObject.shape.activity.subProcess.processes;\n      cloneObject.zIndex = -1;\n      cloneObject.shape.activity.subProcess.processes = undefined;\n    }\n\n    if (node.shape && node.shape.type === 'SwimLane') {\n      pasteSwimLane(node, this.diagram, this.clipboardData);\n    } else if (temp && temp.shape.type === 'SwimLane') {\n      pasteSwimLane(clone(temp), this.diagram, this.clipboardData, node, true);\n    } else if (node.children && node.children.length && (!children || !children.length)) {\n      newNode = this.cloneGroup(node, multiSelect);\n    } else if (node.shape && (!isBlazor() && node.shape.shape === 'TextAnnotation' || isBlazor() && node.shape.bpmnShape === 'TextAnnotation') && node.id.indexOf('_textannotation_') !== -1 && this.diagram.nameTable[node.id]) {\n      var checkAnnotation = node.id.split('_textannotation_'); //const parentNode: Node;\n\n      var annotation = this.diagram.nameTable[node.id];\n\n      for (var j = 0; j < annotation.inEdges.length; j++) {\n        var connector = this.diagram.nameTable[annotation.inEdges[j]];\n\n        if (connector) {\n          var parentNode = this.diagram.nameTable[connector.sourceID];\n          var clonedNode = this.getAnnotation(parentNode, checkAnnotation[1]);\n          var annotationNode = {\n            id: checkAnnotation[1] + randomId(),\n            angle: clonedNode.angle,\n            text: clonedNode.text,\n            length: clonedNode.length,\n            shape: {\n              shape: 'TextAnnotation',\n              type: 'Bpmn'\n            },\n            nodeId: clonedNode.nodeId\n          };\n          this.diagram.addTextAnnotation(annotationNode, parentNode);\n        }\n      }\n    } else {\n      this.translateObject(cloneObject, groupnodeID);\n      cloneObject.zIndex = -1;\n\n      if (children) {\n        cloneObject.children = children;\n      }\n\n      newNode = this.diagram.add(cloneObject);\n    }\n\n    for (var _i = 0, _a = Object.keys(connectorsTable); _i < _a.length; _i++) {\n      var i = _a[_i];\n      this.diagram.add(connectorsTable[i]);\n    }\n\n    if (process && process.length) {\n      newNode.shape.activity.subProcess.processes = process;\n      this.cloneSubProcesses(newNode);\n    }\n\n    if (newNode && !this.diagram.isServerUpdate) {\n      this.selectObjects([newNode], multiSelect);\n    }\n\n    return newNode;\n  };\n\n  CommandHandler.prototype.getAnnotation = function (parent, annotationId) {\n    var currentAnnotation = parent.shape.annotations;\n\n    if (currentAnnotation && currentAnnotation.length) {\n      for (var g = 0; g <= currentAnnotation.length; g++) {\n        if (currentAnnotation[g].id === annotationId) {\n          return currentAnnotation[g];\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  CommandHandler.prototype.cloneSubProcesses = function (node) {\n    var connector = [];\n    var temp = {};\n\n    if (node.shape.type === 'Bpmn' && node.shape.activity && node.shape.activity.subProcess.processes && node.shape.activity.subProcess.processes.length) {\n      var process = node.shape.activity.subProcess.processes;\n\n      for (var g = 0; g < process.length; g++) {\n        var child = this.diagram.nameTable[process[g]] || this.clipboardData.processTable[process[g]];\n\n        for (var _i = 0, _a = child.outEdges; _i < _a.length; _i++) {\n          var j = _a[_i];\n\n          if (connector.indexOf(j) < 0) {\n            connector.push(j);\n          }\n        }\n\n        for (var _b = 0, _c = child.inEdges; _b < _c.length; _b++) {\n          var j = _c[_b];\n\n          if (connector.indexOf(j) < 0) {\n            connector.push(j);\n          }\n        }\n\n        var innerChild = cloneObject(this.clipboardData.processTable[process[g]]);\n        innerChild.processId = node.id;\n        var newNode = this.cloneNode(innerChild, false);\n        temp[process[g]] = newNode.id;\n        process[g] = newNode.id;\n        this.diagram.addProcess(newNode, node.id);\n\n        for (var _d = 0, connector_1 = connector; _d < connector_1.length; _d++) {\n          var i = connector_1[_d];\n          var node_1 = this.diagram.nameTable[i] || this.diagram.connectorTable[i];\n          var clonedNode = cloneObject(node_1);\n\n          if (temp[clonedNode.sourceID] && temp[clonedNode.targetID]) {\n            clonedNode.zIndex = -1;\n            clonedNode.id += randomId();\n            clonedNode.sourceID = temp[clonedNode.sourceID];\n            clonedNode.targetID = temp[clonedNode.targetID];\n            connector.splice(connector.indexOf(i), 1);\n            this.diagram.add(clonedNode);\n          }\n        }\n      }\n    }\n  };\n\n  CommandHandler.prototype.cloneGroup = function (obj, multiSelect) {\n    var value;\n    var newChildren = [];\n    var children = [];\n    var connectorObj = [];\n    var newObj;\n    var oldID = [];\n    children = children.concat(obj.children);\n    var id = randomId();\n    var objectCollection = [];\n    this.diagram.blazorActions |= BlazorAction.GroupClipboardInProcess;\n\n    if (this.clipboardData.childTable || obj.children.length > 0) {\n      for (var i = 0; i < children.length; i++) {\n        var childObj = void 0;\n\n        if (this.clipboardData.childTable) {\n          childObj = this.clipboardData.childTable[children[i]];\n        } else {\n          childObj = this.diagram.nameTable[children[i]];\n        }\n\n        childObj.parentId = '';\n\n        if (childObj) {\n          if (getObjectType(childObj) === Connector) {\n            connectorObj.push(childObj);\n          } else {\n            newObj = this.cloneNode(childObj, multiSelect, undefined, id);\n            oldID.push(childObj.id);\n            newChildren.push(newObj.id);\n            objectCollection.push(newObj);\n          }\n        }\n      }\n    }\n\n    for (var k = 0; k < connectorObj.length; k++) {\n      if (connectorObj[k].sourceID || connectorObj[k].targetID) {\n        for (var j = 0; j < oldID.length; j++) {\n          if (connectorObj[k].sourceID === oldID[j]) {\n            connectorObj[k].sourceID += id;\n          }\n\n          if (connectorObj[k].targetID === oldID[j]) {\n            connectorObj[k].targetID += id;\n          }\n        }\n      }\n\n      newObj = this.cloneConnector(connectorObj[k], multiSelect);\n      newChildren.push(newObj.id);\n      objectCollection.push(newObj);\n    }\n\n    var parentObj = this.cloneNode(obj, multiSelect, newChildren);\n    objectCollection.push(parentObj);\n\n    if (parentObj && parentObj.container && parentObj.shape && parentObj.shape.type === 'UmlClassifier') {\n      this.diagram.updateDiagramObject(parentObj);\n      parentObj.wrapper.measure(new Size());\n    }\n\n    this.diagram.blazorActions &= ~BlazorAction.GroupClipboardInProcess;\n\n    if (!this.diagram.isServerUpdate) {\n      this.diagram.UpdateBlazorDiagramModelCollection(undefined, objectCollection, undefined, true);\n    } else {\n      this.cloneGroupChildCollection = objectCollection;\n    }\n\n    return parentObj;\n  };\n  /**\n   * translateObject method\\\n   *\n   * @returns { Object[] }    translateObject method .\\\n   * @param {Node | Connector} obj - provide the objects value.\n   * @param {string} groupnodeID - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.translateObject = function (obj, groupnodeID) {\n    obj.id += groupnodeID || randomId();\n    var diff = this.clipboardData.pasteIndex * 10;\n\n    if (getObjectType(obj) === Connector) {\n      obj.sourcePoint = {\n        x: obj.sourcePoint.x + diff,\n        y: obj.sourcePoint.y + diff\n      };\n      obj.targetPoint = {\n        x: obj.targetPoint.x + diff,\n        y: obj.targetPoint.y + diff\n      };\n\n      if (obj.type === 'Bezier') {\n        var segments = obj.segments;\n\n        for (var i = 0; i < segments.length; i++) {\n          if (!Point.isEmptyPoint(segments[i].point1)) {\n            segments[i].point1 = {\n              x: segments[i].point1.x + diff,\n              y: segments[i].point1.y + diff\n            };\n          }\n\n          if (!Point.isEmptyPoint(segments[i].point2)) {\n            segments[i].point2 = {\n              x: segments[i].point2.x + diff,\n              y: segments[i].point2.y + diff\n            };\n          }\n        }\n      }\n\n      if (obj.type === 'Straight' || obj.type === 'Bezier') {\n        if (obj.segments && obj.segments.length > 0) {\n          var segments = obj.segments;\n\n          for (var i = 0; i < segments.length - 1; i++) {\n            segments[i].point.x += diff;\n            segments[i].point.y += diff;\n          }\n        }\n      }\n    } else {\n      obj.offsetX += diff;\n      obj.offsetY += diff;\n    }\n  };\n  /**\n   * drawObject method\\\n   *\n   * @returns { Node | Connector }    drawObject method .\\\n   * @param {Node | Connector} obj - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.drawObject = function (obj) {\n    var oldProtectPropertyChangeValue;\n\n    if (isBlazor()) {\n      oldProtectPropertyChangeValue = this.diagram.getProtectPropertyChangeValue();\n      this.diagram.protectPropertyChange(true);\n    }\n\n    var newObj; //let cloneObject: Node | Connector;\n\n    if (obj && obj.shape) {\n      if (obj.shape.type === 'Text') {\n        obj.width = this.diagram.drawingObject.width ? this.diagram.drawingObject.width : 50;\n        obj.height = this.diagram.drawingObject.height ? this.diagram.drawingObject.height : 20;\n      }\n    }\n\n    var cloneObject = clone(this.diagram.drawingObject);\n\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n      var prop = _a[_i];\n      cloneObject[prop] = obj[prop];\n    }\n\n    if (getObjectType(this.diagram.drawingObject) === Node) {\n      newObj = new Node(this.diagram, 'nodes', cloneObject, true);\n      newObj.id = (this.diagram.drawingObject.id || 'node') + randomId();\n    } else {\n      newObj = new Connector(this.diagram, 'connectors', cloneObject, true);\n\n      if (isBlazor() && !this.diagram.drawingObject) {\n        newObj.type === 'Orthogonal';\n      }\n\n      newObj.id = (this.diagram.drawingObject ? this.diagram.drawingObject.id ? this.diagram.drawingObject.id : 'connector' : 'connector') + randomId();\n    }\n\n    if (isBlazor()) {\n      updateDefaultValues(newObj, cloneObject, getObjectType(this.diagram.drawingObject) === Node ? this.diagram.nodeDefaults : this.diagram.connectorDefaults);\n    }\n\n    this.diagram.initObject(newObj);\n    this.diagram.updateDiagramObject(newObj);\n    this.diagram.currentDrawingObject = newObj;\n\n    if (isBlazor()) {\n      this.diagram.protectPropertyChange(oldProtectPropertyChangeValue);\n    }\n\n    return newObj;\n  };\n  /**\n   * addObjectToDiagram method\\\n   *\n   * @returns { void }    addObjectToDiagram method .\\\n   * @param {Node | Connector} obj - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.addObjectToDiagram = function (obj) {\n    //let newObj: Node | Connector;\n    this.diagram.removeFromAQuad(obj);\n    this.diagram.removeObjectsFromLayer(this.diagram.nameTable[obj.id]);\n    delete this.diagram.nameTable[obj.id];\n    var newObj = this.diagram.add(obj);\n\n    if (this.diagram.mode !== 'SVG') {\n      this.diagram.refreshDiagramLayer();\n    }\n\n    this.selectObjects([newObj]);\n\n    if (obj && !canContinuousDraw(this.diagram)) {\n      this.diagram.tool &= ~DiagramTools.DrawOnce;\n      this.diagram.currentDrawingObject = undefined;\n    }\n  };\n  /**\n   * addObjectToDiagram method\\\n   *\n   * @returns { void }    addObjectToDiagram method .\\\n   * @param {boolean} enable - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.enableServerDataBinding = function (enable) {\n    this.diagram.enableServerDataBinding(enable);\n  };\n  /**\n   * addText method\\\n   *\n   * @returns { void }    addText method .\\\n   * @param {boolean} obj - provide the objects value.\n   * @param {PointModel} currentPosition - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.addText = function (obj, currentPosition) {\n    var annotation = this.diagram.findElementUnderMouse(obj, currentPosition);\n    this.diagram.startTextEdit(obj, annotation instanceof TextElement ? annotation.id.split('_')[1] : undefined);\n  };\n\n  CommandHandler.prototype.updateArgsObject = function (obj, arg1, argValue) {\n    if (obj) {\n      var connector = void 0;\n\n      for (var i = 0; i < obj.length; i++) {\n        connector = getObjectType(obj[i]) === Connector;\n\n        if (connector) {\n          // In Blazor web assembly, deserialize the object. Itb takes time. - Suganthi\n          //argValue.connectors.push(cloneBlazorObject(obj[i]));\n          argValue.connectorCollection.push(obj[i].id);\n        } else {\n          //argValue.nodes.push(cloneBlazorObject(obj[i]));\n          argValue.nodeCollection.push(obj[i].id);\n        } //connector ? argValue.connectors.push(cloneBlazorObject(obj[i])) : argValue.nodes.push(cloneBlazorObject(obj[i]));\n\n      }\n    }\n  };\n\n  CommandHandler.prototype.updateSelectionChangeEventArgs = function (arg, obj, oldValue) {\n    if (isBlazor()) {\n      arg = {\n        cause: this.diagram.diagramActions,\n        newValue: {},\n        oldValue: {},\n        state: arg.state,\n        type: arg.type,\n        cancel: false\n      };\n      var argOldValue = arg.oldValue;\n      var argNewValue = arg.newValue;\n      argOldValue.connectors = [];\n      argOldValue.nodes = [];\n      argNewValue.connectors = [];\n      argNewValue.nodes = [];\n      argOldValue.nodeCollection = [];\n      argOldValue.connectorCollection = [];\n      argNewValue.nodeCollection = [];\n      argNewValue.connectorCollection = [];\n      this.updateArgsObject(this.getSelectedObject(), arg, argNewValue);\n      this.updateArgsObject(oldValue, arg, argOldValue);\n      return arg;\n    }\n\n    return arg;\n  };\n  /**\n   * isUserHandle method\\\n   *\n   * @returns { boolean }    isUserHandle method .\\\n   * @param {PointModel} position - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.isUserHandle = function (position) {\n    var handle = this.diagram.selectedItems;\n\n    if (handle.wrapper && canShowCorner(handle.constraints, 'UserHandle')) {\n      for (var _i = 0, _a = handle.userHandles; _i < _a.length; _i++) {\n        var obj = _a[_i];\n\n        if (obj.visible) {\n          var paddedBounds = getUserHandlePosition(handle, obj, this.diagram.scroller.transform);\n\n          if (contains(position, paddedBounds, obj.size / (2 * this.diagram.scroller.transform.scale))) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * selectObjects method\\\n   *\n   * @returns { Promise<void> }    selectObjects method .\\\n   * @param {(NodeModel | ConnectorModel)[]} obj - provide the objects value.\n   * @param {boolean} multipleSelection - provide the objects value.\n   * @param {(NodeModel | ConnectorModel)[]} oldValue - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.selectObjects = function (obj, multipleSelection, oldValue) {\n    return __awaiter(this, void 0, void 0, function () {\n      var arg, select, oldSelectedItems, canDoMultipleSelection, canDoSingleSelection, i, newObj, i_1, parentNode, blazorArgs, eventObj, selectedObjects, i;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            arg = {\n              oldValue: oldValue ? oldValue : this.getSelectedObject(),\n              newValue: obj,\n              cause: this.diagram.diagramActions,\n              state: 'Changing',\n              type: 'Addition',\n              cancel: false\n            };\n            this.diagram.enableServerDataBinding(false);\n            select = true;\n\n            if (!isBlazor()) {\n              this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            } else {\n              this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n            }\n\n            oldSelectedItems = this.diagram.selectedItems.nodes.concat(this.diagram.selectedItems.connectors);\n            canDoMultipleSelection = canMultiSelect(this.diagram);\n            canDoSingleSelection = canSingleSelect(this.diagram);\n\n            if (canDoSingleSelection || canDoMultipleSelection) {\n              if (!canDoMultipleSelection && (obj.length > 1 || multipleSelection && obj.length === 1)) {\n                if (obj.length === 1) {\n                  this.clearSelection();\n                } else {\n                  return [2\n                  /*return*/\n                  ];\n                }\n              }\n\n              if (!(canDoSingleSelection || canDoMultipleSelection) && obj.length === 1 && (!multipleSelection || !hasSelection(this.diagram))) {\n                this.clearSelection();\n                return [2\n                /*return*/\n                ];\n              }\n            }\n\n            if (!!arg.cancel) return [3\n            /*break*/\n            , 5];\n\n            for (i = 0; i < obj.length; i++) {\n              newObj = obj[i];\n\n              if (newObj) {\n                select = true;\n\n                if (!hasSelection(this.diagram)) {\n                  this.select(newObj, i > 0 || multipleSelection, true);\n                } else {\n                  if ((i > 0 || multipleSelection) && newObj.children && !newObj.parentId) {\n                    for (i_1 = 0; i_1 < this.diagram.selectedItems.nodes.length; i_1++) {\n                      parentNode = this.diagram.nameTable[this.diagram.selectedItems.nodes[i_1].parentId];\n\n                      if (parentNode) {\n                        parentNode = this.findParent(parentNode);\n\n                        if (parentNode) {\n                          if (newObj.id === parentNode.id) {\n                            this.selectGroup(newObj);\n                          }\n                        }\n                      }\n                    }\n                  }\n\n                  this.selectProcesses(newObj);\n                  select = this.selectBpmnSubProcesses(newObj);\n\n                  if (select) {\n                    this.select(newObj, i > 0 || multipleSelection, true);\n                  }\n                }\n              }\n            }\n\n            if (oldValue === undefined) {\n              oldValue = oldSelectedItems;\n            }\n\n            arg = {\n              oldValue: oldValue ? oldValue : [],\n              newValue: this.getSelectedObject(),\n              cause: this.diagram.diagramActions,\n              state: 'Changed',\n              type: 'Addition',\n              cancel: false\n            };\n            this.diagram.renderSelector(multipleSelection || obj && obj.length > 1);\n            this.updateBlazorSelectorModel(oldValue);\n\n            if (isBlazor() && this.diagram.selectionChange) {\n              arg = this.updateSelectionChangeEventArgs(arg, obj, oldValue ? oldValue : []);\n              this.updateBlazorSelector();\n            }\n\n            if (!!isBlazor()) return [3\n            /*break*/\n            , 1];\n            this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            return [3\n            /*break*/\n            , 4];\n\n          case 1:\n            blazorArgs = void 0;\n            if (!(window && window[this.blazor] && this.diagram.selectionChange)) return [3\n            /*break*/\n            , 3];\n            eventObj = {\n              'EventName': 'selectionChange',\n              args: JSON.stringify(arg)\n            };\n            return [4\n            /*yield*/\n            , window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram)];\n\n          case 2:\n            blazorArgs = _a.sent();\n            _a.label = 3;\n\n          case 3:\n            // let blazorArgs: void | object = await this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            if (blazorArgs && blazorArgs.cancel) {\n              selectedObjects = [];\n\n              if (blazorArgs.oldValue.nodes.length > 0) {\n                selectedObjects = blazorArgs.oldValue.nodes;\n              }\n\n              if (blazorArgs.oldValue.connectors.length > 0) {\n                selectedObjects = selectedObjects.concat(blazorArgs.oldValue.connectors);\n              }\n\n              if (selectedObjects) {\n                if (selectedObjects.length > 0) {\n                  for (i = 0; i < selectedObjects.length; i++) {\n                    this.select(this.diagram.nameTable[selectedObjects[i].id], i !== 0 && selectedObjects.length > 1 ? true : false);\n                  }\n                } else {\n                  this.clearSelection();\n                }\n              }\n            }\n\n            _a.label = 4;\n\n          case 4:\n            this.diagram.enableServerDataBinding(true);\n            this.updateBlazorSelector();\n            _a.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * updateBlazorSelector method\\\n   *\n   * @returns { void }    updateBlazorSelector method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateBlazorSelector = function () {\n    if (isBlazor() && this.oldSelectedObjects) {\n      this.newSelectedObjects = cloneSelectedObjects(this.diagram);\n      var result = this.deepDiffer.map(cloneObject(this.newSelectedObjects), this.oldSelectedObjects);\n      var diffValue = this.deepDiffer.frameObject({}, result);\n      var diff = this.deepDiffer.removeEmptyValues(diffValue);\n      diff.nodes = [];\n\n      for (var i = 0; i < this.diagram.selectedItems.nodes.length; i++) {\n        diff.nodes.push(this.diagram.selectedItems.nodes[i].id);\n      }\n\n      diff.connectors = [];\n\n      for (var i = 0; i < this.diagram.selectedItems.connectors.length; i++) {\n        diff.connectors.push(this.diagram.selectedItems.connectors[i].id);\n      }\n\n      var blazorInterop = 'sfBlazor';\n      var blazor = 'Blazor';\n\n      if (window && window[blazor]) {\n        var obj = {\n          'methodName': 'UpdateBlazorProperties',\n          'diagramobj': {\n            selectedItems: diff\n          }\n        };\n        window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n      }\n\n      this.oldSelectedObjects = undefined;\n      this.newSelectedObjects = undefined;\n    }\n  };\n  /**\n   * findParent method\\\n   *\n   * @returns { Node }    findParent method .\\\n   * @param {Node} node - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.findParent = function (node) {\n    if (node.parentId) {\n      node = this.diagram.nameTable[node.parentId];\n      this.findParent(node);\n    }\n\n    return node;\n  };\n\n  CommandHandler.prototype.selectProcesses = function (newObj) {\n    if (this.hasProcesses(newObj)) {\n      var processes = newObj.shape.activity.subProcess.processes;\n\n      for (var i = 0; i < processes.length; i++) {\n        var innerChild = this.diagram.nameTable[processes[i]];\n\n        if (this.hasProcesses(innerChild)) {\n          this.selectObjects([innerChild], true);\n        }\n\n        this.unSelect(innerChild);\n      }\n    }\n  };\n\n  CommandHandler.prototype.selectGroup = function (newObj) {\n    for (var j = 0; j < newObj.children.length; j++) {\n      var innerChild = this.diagram.nameTable[newObj.children[j]];\n\n      if (innerChild.children) {\n        this.selectGroup(innerChild);\n      }\n\n      this.unSelect(this.diagram.nameTable[newObj.children[j]]);\n    }\n  };\n\n  CommandHandler.prototype.selectBpmnSubProcesses = function (node) {\n    var select = true;\n    var parent;\n\n    if (node.processId) {\n      if (isSelected(this.diagram, this.diagram.nameTable[node.processId])) {\n        select = false;\n      } else {\n        select = this.selectBpmnSubProcesses(this.diagram.nameTable[node.processId]);\n      }\n    } else if (node instanceof Connector) {\n      if (node.sourceID && this.diagram.nameTable[node.sourceID] && this.diagram.nameTable[node.sourceID].processId) {\n        parent = this.diagram.nameTable[node.sourceID].processId;\n      }\n\n      if (node.targetID && this.diagram.nameTable[node.targetID] && this.diagram.nameTable[node.targetID].processId) {\n        parent = this.diagram.nameTable[node.targetID].processId;\n      }\n\n      if (parent) {\n        if (isSelected(this.diagram, this.diagram.nameTable[parent])) {\n          return false;\n        } else {\n          select = this.selectBpmnSubProcesses(this.diagram.nameTable[parent]);\n        }\n      }\n    } else if (node.parentId && this.diagram.nameTable[node.parentId] && this.diagram.nameTable[node.parentId].shape.type === 'UmlClassifier') {\n      if (isSelected(this.diagram, this.diagram.nameTable[node.parentId])) {\n        select = false;\n      }\n    }\n\n    return select;\n  };\n\n  CommandHandler.prototype.hasProcesses = function (node) {\n    if (node) {\n      if (node.shape.type === 'Bpmn' && node.shape.activity && node.shape.activity.subProcess.processes && node.shape.activity.subProcess.processes.length > 0) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * select method\\\n   *\n   * @returns { void }    select method .\\\n   * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n   * @param {boolean} multipleSelection - provide the objects value.\n   * @param {boolean} preventUpdate - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.select = function (obj, multipleSelection, preventUpdate) {\n    var hasLayer = this.getObjectLayer(obj.id);\n\n    if (canSelect(obj) && !(obj instanceof Selector) && !isSelected(this.diagram, obj) && hasLayer && !hasLayer.lock && hasLayer.visible && obj.wrapper.visible) {\n      multipleSelection = hasSelection(this.diagram) ? multipleSelection : false;\n\n      if (!multipleSelection) {\n        this.clearSelection();\n      }\n\n      this.diagram.enableServerDataBinding(false);\n      var selectorModel = this.diagram.selectedItems;\n      var convert = obj;\n\n      if (convert instanceof Node) {\n        if (obj.isHeader) {\n          var node = this.diagram.nameTable[obj.parentId];\n          selectorModel.nodes.push(node);\n        } else {\n          selectorModel.nodes.push(obj);\n        }\n      } else {\n        selectorModel.connectors.push(obj);\n      }\n\n      if (!multipleSelection) {\n        selectorModel.init(this.diagram);\n\n        if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n          var wrapper = gridSelection(this.diagram, selectorModel);\n\n          if (wrapper) {\n            selectorModel.wrapper.children[0] = wrapper;\n          }\n\n          selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n          selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;\n          selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;\n        }\n      } else {\n        selectorModel.wrapper.rotateAngle = selectorModel.rotateAngle = 0;\n        selectorModel.wrapper.children.push(obj.wrapper);\n      }\n\n      if (!preventUpdate) {\n        this.diagram.renderSelector(multipleSelection);\n      }\n\n      this.diagram.enableServerDataBinding(true);\n    }\n  };\n\n  CommandHandler.prototype.getObjectCollectionId = function (isNode, clearSelection) {\n    var id = [];\n    var i = 0;\n    var selectedObject = isNode ? this.diagram.selectedItems.nodes : this.diagram.selectedItems.connectors;\n\n    while (!clearSelection && i < selectedObject.length) {\n      id[i] = selectedObject[i].id;\n      i++;\n    }\n\n    return id;\n  };\n\n  CommandHandler.prototype.updateBlazorSelectorModel = function (oldItemsCollection, clearSelection) {\n    var blazorInterop = 'sfBlazor';\n\n    if (window && window[blazorInterop]) {\n      var i = 0;\n      var nodes = [];\n      var connectors = [];\n      var oldItems = [];\n\n      while (oldItemsCollection && i < oldItemsCollection.length) {\n        oldItems[i] = oldItemsCollection[i].id;\n        i++;\n      }\n\n      i = 0;\n      nodes = this.getObjectCollectionId(true, clearSelection);\n      connectors = this.getObjectCollectionId(false, clearSelection);\n      var items = {\n        nodes: nodes,\n        connectors: connectors\n      };\n      var newItems = cloneBlazorObject(items);\n\n      if (window[blazorInterop].updateDiagramCollection) {\n        window[blazorInterop].updateDiagramCollection.call(this.diagram, 'selectedItems', newItems, oldItems, false, true);\n      }\n    }\n  };\n  /**\n   * labelSelect method\\\n   *\n   * @returns { void }    labelSelect method .\\\n   * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n   * @param {DiagramElement} textWrapper - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.labelSelect = function (obj, textWrapper) {\n    this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n    var selectorModel = this.diagram.selectedItems;\n    var isEnableServerDatabind = this.diagram.allowServerDataBinding;\n    this.diagram.allowServerDataBinding = false;\n    selectorModel.nodes = selectorModel.connectors = [];\n    this.diagram.allowServerDataBinding = isEnableServerDatabind;\n\n    if (obj instanceof Node) {\n      selectorModel.nodes[0] = obj;\n    } else {\n      selectorModel.connectors[0] = obj;\n    }\n\n    selectorModel.annotation = this.findTarget(textWrapper, obj);\n    selectorModel.init(this.diagram);\n    this.diagram.renderSelector(false);\n    this.updateBlazorSelector();\n  };\n  /**\n   * unSelect method\\\n   *\n   * @returns { void }    unSelect method .\\\n   * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.unSelect = function (obj) {\n    var objArray = [];\n    objArray.push(obj);\n    var items = this.diagram.selectedItems.nodes.concat(this.diagram.selectedItems.connectors);\n    var selectedObjects = items.filter(function (items) {\n      return items.id !== obj.id;\n    });\n    var arg = {\n      oldValue: items,\n      newValue: selectedObjects,\n      cause: this.diagram.diagramActions,\n      state: 'Changing',\n      type: 'Removal',\n      cancel: false\n    };\n\n    if (!this.diagram.currentSymbol) {\n      if (!isBlazor()) {\n        this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n      }\n    }\n\n    if (isSelected(this.diagram, obj)) {\n      var selectormodel = this.diagram.selectedItems;\n      var index = void 0;\n\n      if (obj instanceof Node) {\n        index = selectormodel.nodes.indexOf(obj, 0);\n        selectormodel.nodes.splice(index, 1);\n      } else {\n        index = selectormodel.connectors.indexOf(obj, 0);\n        selectormodel.connectors.splice(index, 1);\n      }\n\n      arg = {\n        oldValue: items,\n        newValue: selectedObjects,\n        cause: this.diagram.diagramActions,\n        state: 'Changed',\n        type: 'Removal',\n        cancel: false\n      };\n      this.updateBlazorSelectorModel(objArray);\n      arg = {\n        oldValue: cloneBlazorObject(items),\n        newValue: selectedObjects,\n        cause: this.diagram.diagramActions,\n        state: 'Changed',\n        type: 'Removal',\n        cancel: arg.cancel\n      };\n\n      if (!arg.cancel) {\n        index = selectormodel.wrapper.children.indexOf(obj.wrapper, 0);\n        selectormodel.wrapper.children.splice(index, 1);\n        this.diagram.updateSelector();\n\n        if (!this.diagram.currentSymbol) {\n          if (isBlazor()) {\n            arg = this.updateSelectionChangeEventArgs(arg, [], objArray);\n            this.updateBlazorSelector();\n\n            if (window && window[this.blazor] && this.diagram.selectionChange) {\n              var eventObj = {\n                'EventName': 'selectionChange',\n                args: JSON.stringify(arg)\n              };\n              window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram);\n            }\n          } else {\n            this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n          }\n        }\n      }\n    }\n  };\n  /**\n   * getChildElements method\\\n   *\n   * @returns { string[] }    getChildElements method .\\\n   * @param {DiagramElement[]} child - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.getChildElements = function (child) {\n    var children = [];\n\n    for (var i = 0; i < child.length; i++) {\n      var childNode = child[i];\n\n      if (childNode.children && childNode.children.length > 0) {\n        children.concat(this.getChildElements(childNode.children));\n      } else {\n        children.push(childNode.id);\n\n        if (childNode instanceof TextElement) {\n          children.push(childNode.id + '_text');\n        }\n      }\n    }\n\n    return children;\n  };\n  /**\n   * moveSvgNode method\\\n   *\n   * @returns { void }    moveSvgNode method .\\\n   * @param {string} nodeId - provide the objects value.\n   * @param {string} targetID - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.moveSvgNode = function (nodeId, targetID) {\n    var diagramDiv = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);\n    var backNode = getDiagramElement(nodeId + '_groupElement', this.diagram.element.id);\n    diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n  };\n  /**\n   * sendLayerBackward method\\\n   *\n   * @returns { void }    sendLayerBackward method .\\\n   * @param {string} layerName - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.sendLayerBackward = function (layerName) {\n    var layer = this.getLayer(layerName);\n\n    if (layer && layer.zIndex !== 0) {\n      var index = layer.zIndex;\n\n      if (this.diagram.mode === 'SVG') {\n        var currentLayerObject = layer.objects;\n        var targetObject = this.getLayer(this.diagram.layerZIndexTable[index - 1]).objects[0];\n\n        if (targetObject) {\n          for (var _i = 0, currentLayerObject_1 = currentLayerObject; _i < currentLayerObject_1.length; _i++) {\n            var obj = currentLayerObject_1[_i];\n            this.moveSvgNode(obj, targetObject);\n          }\n        }\n      }\n\n      var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index - 1]);\n      targetLayer.zIndex = targetLayer.zIndex + 1;\n      layer.zIndex = layer.zIndex - 1;\n      var temp = this.diagram.layerZIndexTable[index];\n      this.diagram.layerZIndexTable[index] = this.diagram.layerZIndexTable[index - 1];\n      this.diagram.layerZIndexTable[index - 1] = temp;\n\n      if (this.diagram.mode === 'Canvas') {\n        this.diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /**\n   * bringLayerForward method\\\n   *\n   * @returns { void }    bringLayerForward method .\\\n   * @param {string} layerName - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.bringLayerForward = function (layerName) {\n    var layer = this.getLayer(layerName);\n\n    if (layer && layer.zIndex < this.diagram.layers.length - 1) {\n      var index = layer.zIndex;\n      var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index + 1]);\n\n      if (this.diagram.mode === 'SVG') {\n        var currentLayerObject = layer.objects[0];\n        var targetLayerObjects = targetLayer.objects;\n\n        for (var _i = 0, targetLayerObjects_1 = targetLayerObjects; _i < targetLayerObjects_1.length; _i++) {\n          var obj = targetLayerObjects_1[_i];\n\n          if (obj) {\n            this.moveSvgNode(obj, currentLayerObject);\n          }\n        }\n      }\n\n      targetLayer.zIndex = targetLayer.zIndex - 1;\n      layer.zIndex = layer.zIndex + 1;\n      var temp = this.diagram.layerZIndexTable[index];\n      this.diagram.layerZIndexTable[index] = this.diagram.layerZIndexTable[index + 1];\n      this.diagram.layerZIndexTable[index + 1] = temp;\n\n      if (this.diagram.mode === 'Canvas') {\n        this.diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /**\n   * sendToBack method\\\n   *\n   * @returns { void }    sendToBack method .\\\n   * @param {NodeModel | ConnectorModel} object - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.sendToBack = function (object) {\n    this.diagram.protectPropertyChange(true);\n\n    if (hasSelection(this.diagram) || object) {\n      var objectId = object && object.id;\n      objectId = objectId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id : this.diagram.selectedItems.connectors[0].id);\n      var index = this.diagram.nameTable[objectId].zIndex;\n      var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n      var zIndexTable = this.diagram.layers[layerNum].zIndexTable;\n      var tempTable = JSON.parse(JSON.stringify(zIndexTable));\n      var undoObject = cloneObject(this.diagram.selectedItems);\n      var tempIndex = 0; //Checks whether the selected node is the only node in the node array.\n      //Checks whether it is not a group and the nodes behind it are not it’s children.\n\n      if (this.diagram.nodes.length !== 1 && (this.diagram.nameTable[objectId].children === undefined || this.checkObjectBehind(objectId, zIndexTable, index))) {\n        var obj = this.diagram.nameTable[objectId];\n\n        for (var i = index; i > 0; i--) {\n          if (zIndexTable[i]) {\n            //When there are empty records in the zindex table\n            if (!zIndexTable[i - 1]) {\n              zIndexTable[i - 1] = zIndexTable[i];\n              this.diagram.nameTable[zIndexTable[i - 1]].zIndex = i;\n              delete zIndexTable[i];\n            } else {\n              //bringing the objects forward\n              zIndexTable[i] = zIndexTable[i - 1];\n              this.diagram.nameTable[zIndexTable[i]].zIndex = i;\n            }\n          }\n        }\n\n        for (var i = index; i > 0; i--) {\n          if (zIndexTable[i]) {\n            this.diagram.nameTable[zIndexTable[i]].zIndex = i;\n          }\n        }\n\n        if (obj.shape.type !== 'SwimLane') {\n          zIndexTable[0] = this.diagram.nameTable[objectId].id;\n          this.diagram.nameTable[objectId].zIndex = 0;\n        } else {\n          tempIndex = this.swapZIndexObjects(index, zIndexTable, objectId, tempTable);\n        }\n\n        if (this.diagram.mode === 'SVG') {\n          var obj_1 = this.diagram.nameTable[objectId];\n          var i = obj_1.shape.type !== 'SwimLane' ? 1 : tempIndex;\n\n          if (i !== tempIndex) {\n            i = obj_1.children && obj_1.children.length > 0 ? index : 1;\n          }\n\n          var target = zIndexTable[i]; // EJ2-49326 - (CR issue fix) An exception raised when send the swimlane back to the normal node.\n\n          while (!target && i < index) {\n            target = zIndexTable[++i];\n          } // EJ2-46656 - CR issue fix\n\n\n          target = this.resetTargetNode(objectId, target, i, zIndexTable);\n          target = this.diagram.nameTable[target].parentId ? this.checkParentExist(target) : target;\n          this.moveSvgNode(objectId, target);\n          this.updateNativeNodeIndex(objectId);\n        } else {\n          this.diagram.refreshCanvasLayers();\n        }\n\n        var redoObject = cloneObject(this.diagram.selectedItems);\n        var entry = {\n          type: 'SendToBack',\n          category: 'Internal',\n          undoObject: undoObject,\n          redoObject: redoObject\n        };\n\n        if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n          this.addHistoryEntry(entry);\n        }\n      }\n    }\n\n    this.diagram.protectPropertyChange(false);\n\n    if (isBlazor()) {\n      this.getZIndexObjects();\n    }\n  };\n\n  CommandHandler.prototype.swapZIndexObjects = function (index, zIndexTable, objectId, tempTable) {\n    var tempIndex = 0;\n    var childCount = 0;\n    var childIndex = -1;\n    var j = 1; // Get the swimlane's Children count\n\n    for (var i = 0; i <= index; i++) {\n      if (zIndexTable[i] && this.diagram.nameTable[zIndexTable[i]].parentId === objectId) {\n        // Get the swimlane's first children position from z index table\n        if (childIndex === -1) {\n          childIndex = i;\n        }\n\n        childCount++;\n      }\n    } // Swap the swimlane children to the top of the z index table\n\n\n    for (var i = 0; i <= index; i++) {\n      if (zIndexTable[i] && j <= childCount) {\n        while (!zIndexTable[childIndex]) {\n          childIndex++;\n        }\n\n        zIndexTable[i] = zIndexTable[childIndex];\n        this.diagram.nameTable[zIndexTable[i]].zIndex = i;\n        childIndex++;\n        j++;\n      }\n    }\n\n    var k = 0; // Get the Z index from ZindexTable in the child's count position. In that position we want to put the swimlane\n\n    for (var i = 0; i < childCount; i++) {\n      while (!zIndexTable[k]) {\n        k++;\n      }\n\n      tempIndex = this.diagram.nameTable[zIndexTable[k]].zIndex;\n      k++;\n    }\n\n    tempIndex = tempIndex + 1; // Check if there is a object in the z index table or not\n\n    while (!zIndexTable[tempIndex]) {\n      ++tempIndex;\n    }\n\n    k = 0; // Place the swimlane at the next position of the swimlane's last children.\n\n    zIndexTable[tempIndex] = this.diagram.nameTable[objectId].id;\n    this.diagram.nameTable[objectId].zIndex = tempIndex;\n    tempIndex = tempIndex + 1; // Now swap the intersect nodes at next position of the swimlane.\n\n    for (var i = tempIndex; i <= index; i++) {\n      if (zIndexTable[i]) {\n        while (!tempTable[k]) {\n          k++;\n        }\n\n        zIndexTable[i] = tempTable[k];\n        this.diagram.nameTable[zIndexTable[i]].zIndex = i;\n        k++;\n      }\n    }\n\n    return tempIndex;\n  };\n\n  CommandHandler.prototype.resetTargetNode = function (objectId, target, i, zIndexTable) {\n    if (this.diagram.nameTable[objectId].shape.type === 'SwimLane' && this.diagram.nameTable[target].parentId != undefined && this.diagram.nameTable[target].parentId != \"\" && this.diagram.nameTable[this.diagram.nameTable[target].parentId].isLane) {\n      i = i + 1;\n\n      if (zIndexTable[i]) {\n        target = zIndexTable[i];\n        return target = this.resetTargetNode(objectId, target, i, zIndexTable);\n      } else {\n        return target;\n      }\n    } else {\n      return target;\n    }\n  };\n\n  CommandHandler.prototype.getZIndexObjects = function () {\n    var element = [];\n    var i;\n    var j;\n\n    for (i = 0; i < this.diagram.nodes.length; i++) {\n      element.push(this.diagram.nodes[i]);\n    }\n\n    for (j = 0; j < this.diagram.connectors.length; j++) {\n      element.push(this.diagram.connectors[j]);\n    }\n\n    this.updateBlazorZIndex(element);\n  };\n\n  CommandHandler.prototype.updateBlazorZIndex = function (element) {\n    var blazorInterop = 'sfBlazor';\n    var blazor = 'Blazor';\n    var diagramobject = {};\n    var nodeObject = [];\n    var connectorObject = [];\n    var k;\n\n    if (element && element.length > 0) {\n      for (k = 0; k < element.length; k++) {\n        var elementObject = element[k];\n\n        if (elementObject instanceof Node) {\n          nodeObject.push(this.getBlazorObject(elementObject));\n        } else if (elementObject instanceof Connector) {\n          connectorObject.push(this.getBlazorObject(elementObject));\n        }\n      }\n    }\n\n    diagramobject = {\n      nodes: nodeObject,\n      connectors: connectorObject\n    };\n\n    if (window && window[blazor]) {\n      var obj = {\n        'methodName': 'UpdateBlazorProperties',\n        'diagramobj': diagramobject\n      };\n      window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n    }\n  };\n\n  CommandHandler.prototype.getBlazorObject = function (objectName) {\n    var object = {\n      sfIndex: getIndex(this.diagram, objectName.id),\n      zIndex: objectName.zIndex\n    };\n    return object;\n  }; //Checks whether the target is a child node.\n\n\n  CommandHandler.prototype.checkParentExist = function (target) {\n    var objBehind = target;\n\n    while (this.diagram.nameTable[objBehind].parentId) {\n      objBehind = this.diagram.nameTable[objBehind].parentId;\n    }\n\n    return objBehind;\n  }; //Checks whether the selected node is not a parent of another node.\n\n\n  CommandHandler.prototype.checkObjectBehind = function (objectId, zIndexTable, index) {\n    for (var i = 0; i < index; i++) {\n      var z = zIndexTable[i];\n\n      if (this.diagram.nameTable[z] && objectId !== this.diagram.nameTable[z].parentId) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * bringToFront method\\\n   *\n   * @returns {  void  }    bringToFront method .\\\n   *  @param {NodeModel | ConnectorModel } obj - Provide the nodeArray element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.bringToFront = function (obj) {\n    var _this = this;\n\n    this.diagram.protectPropertyChange(true);\n\n    if (hasSelection(this.diagram) || obj) {\n      var objectName_1 = obj && obj.id;\n      objectName_1 = objectName_1 || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id : this.diagram.selectedItems.connectors[0].id);\n      var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectName_1));\n      var zIndexTable_1 = this.diagram.layers[layerNum].zIndexTable;\n      var undoObject = cloneObject(this.diagram.selectedItems);\n      var tempTable = JSON.parse(JSON.stringify(zIndexTable_1));\n      var tempIndex = 0; //find the maximum zIndex of the tabel\n\n      var tabelLength = Number(Object.keys(zIndexTable_1).sort(function (a, b) {\n        return Number(a) - Number(b);\n      }).reverse()[0]);\n      var index = this.diagram.nameTable[objectName_1].zIndex;\n      var oldzIndexTable_1 = [];\n      var length_1 = 0;\n\n      for (var i = 0; i <= tabelLength; i++) {\n        oldzIndexTable_1.push(zIndexTable_1[i]);\n      }\n\n      var object = this.diagram.nameTable[objectName_1];\n\n      if (object.shape.type === 'SwimLane') {\n        for (var i = tabelLength; i >= index; i--) {\n          if (zIndexTable_1[i] && !(this.diagram.nameTable[zIndexTable_1[i]].parentId === objectName_1)) {\n            length_1 = i;\n            tabelLength = length_1;\n            break;\n          }\n        }\n      }\n\n      for (var i = index; i < tabelLength; i++) {\n        //When there are empty records in the zindex table\n        if (zIndexTable_1[i]) {\n          if (!zIndexTable_1[i + 1]) {\n            zIndexTable_1[i + 1] = zIndexTable_1[i];\n            this.diagram.nameTable[zIndexTable_1[i + 1]].zIndex = i;\n            delete zIndexTable_1[i];\n          } else {\n            //bringing the objects backward\n            zIndexTable_1[i] = zIndexTable_1[i + 1];\n            this.diagram.nameTable[zIndexTable_1[i]].zIndex = i;\n          }\n        }\n      }\n\n      for (var i = index; i < tabelLength; i++) {\n        if (zIndexTable_1[i]) {\n          this.diagram.nameTable[zIndexTable_1[i]].zIndex = i;\n        }\n      }\n\n      if (object.shape.type !== 'SwimLane') {\n        zIndexTable_1[tabelLength] = this.diagram.nameTable[objectName_1].id;\n        this.diagram.nameTable[objectName_1].zIndex = tabelLength;\n      } else {\n        var childCount = 0;\n        var childIndex = -1;\n        var tempIndex_1 = 0;\n        var laneIndex = 0;\n        var cloneTable = JSON.parse(JSON.stringify(zIndexTable_1));\n\n        for (var i = 0; i <= index; i++) {\n          if (zIndexTable_1[i] && this.diagram.nameTable[zIndexTable_1[i]].parentId === objectName_1) {\n            if (childIndex === -1) {\n              childIndex = i;\n              tempIndex_1 = i;\n              break;\n            }\n          }\n        }\n\n        for (var i = 0; i <= tabelLength; i++) {\n          if (tempTable[i] && tempTable[i] !== objectName_1 && this.diagram.nameTable[tempTable[i]].parentId !== objectName_1) {\n            var node = this.diagram.nameTable[tempTable[i]];\n            var swimlaneObject = this.diagram.nameTable[objectName_1];\n\n            if (node.zIndex >= swimlaneObject.zIndex) {\n              childCount++;\n            }\n          }\n        }\n\n        var k = childIndex;\n\n        for (var i = 0; i <= childCount; i++) {\n          while (!zIndexTable_1[k]) {\n            k++;\n          }\n\n          laneIndex = this.diagram.nameTable[zIndexTable_1[k]].zIndex;\n          k++;\n        }\n\n        for (var i = laneIndex; i <= tabelLength; i++) {\n          while (!cloneTable[childIndex]) {\n            childIndex++;\n          }\n\n          while (!zIndexTable_1[i]) {\n            i++;\n          }\n\n          zIndexTable_1[i] = cloneTable[childIndex];\n          this.diagram.nameTable[zIndexTable_1[i]].zIndex = i;\n          childIndex++;\n        }\n\n        zIndexTable_1[tabelLength] = this.diagram.nameTable[objectName_1].id;\n        this.diagram.nameTable[objectName_1].zIndex = tabelLength;\n        k = index + 1;\n        var j = tempIndex_1;\n\n        for (var i = 0; i < childCount; i++) {\n          while (!tempTable[k]) {\n            k++;\n          }\n\n          while (this.diagram.nameTable[tempTable[k]].parentId === objectName_1) {\n            k++;\n          }\n\n          while (!zIndexTable_1[j]) {\n            j++;\n          }\n\n          zIndexTable_1[j] = tempTable[k];\n          this.diagram.nameTable[zIndexTable_1[j]].zIndex = j;\n          k++;\n          j++;\n        }\n      }\n\n      if (this.diagram.mode === 'SVG') {\n        var diagramLayer = this.diagram.diagramLayer; //const child: string[] = this.getChildElements(this.diagram.nameTable[objectName].wrapper.children);\n        //const targerNodes: Object = [];\n\n        var element = getDiagramElement(objectName_1 + '_groupElement', this.diagram.element.id);\n        var nodes = this.diagram.selectedItems.nodes;\n\n        if (nodes.length > 0 && (nodes[0].shape.type === 'Native' || nodes[0].shape.type === 'HTML')) {\n          element.parentNode.removeChild(element);\n\n          for (var j = 0; j < this.diagram.views.length; j++) {\n            element = getDiagramElement(objectName_1 + (nodes[0].shape.type === 'HTML' ? '_html_element' : '_content_groupElement'), this.diagram.views[j]);\n            var lastChildNode = element.parentNode.lastChild;\n            lastChildNode.parentNode.insertBefore(element, lastChildNode.nextSibling);\n          }\n\n          var htmlLayer = getHTMLLayer(this.diagram.element.id);\n          this.diagram.diagramRenderer.renderElement(this.diagram.nameTable[objectName_1].wrapper, diagramLayer, htmlLayer);\n        } else {\n          Object.keys(zIndexTable_1).forEach(function (key) {\n            var zIndexValue = zIndexTable_1[key];\n\n            if (zIndexValue !== objectName_1 && _this.diagram.nameTable[zIndexValue].parentId !== objectName_1) {\n              //EJ2-42101 - SendToBack and BringToFront not working for connector with group node\n              //Added @Dheepshiva to restrict the objects with lower zIndex\n              if (zIndexValue !== undefined && oldzIndexTable_1.indexOf(objectName_1) < oldzIndexTable_1.indexOf(zIndexValue)) {\n                var objectNode = _this.diagram.nameTable[objectName_1];\n                var zIndexNode = _this.diagram.nameTable[zIndexValue];\n\n                if (objectNode.parentId === '' && zIndexNode.parentId === '' && zIndexNode.parentId === undefined && objectNode.parentId !== zIndexNode.id) {\n                  _this.moveSvgNode(zIndexValue, objectName_1);\n\n                  _this.updateNativeNodeIndex(objectName_1);\n                } else {\n                  if (_this.checkGroupNode(objectName_1, zIndexValue, _this.diagram.nameTable)) {\n                    _this.moveSvgNode(zIndexValue, objectName_1);\n\n                    _this.updateNativeNodeIndex(objectName_1);\n                  }\n                }\n              }\n            }\n          });\n        }\n      } else {\n        this.diagram.refreshCanvasLayers();\n      }\n\n      var redoObject = cloneObject(this.diagram.selectedItems);\n      var entry = {\n        type: 'BringToFront',\n        category: 'Internal',\n        undoObject: undoObject,\n        redoObject: redoObject\n      };\n\n      if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n        this.addHistoryEntry(entry);\n      }\n    }\n\n    this.diagram.protectPropertyChange(false);\n\n    if (isBlazor()) {\n      this.getZIndexObjects();\n    }\n  };\n\n  CommandHandler.prototype.checkGroupNode = function (selectedNodeName, layerObject, nameTable) {\n    return nameTable[layerObject].parentId === nameTable[selectedNodeName].parentId;\n  };\n  /**\n   * sortByZIndex method\\\n   *\n   * @returns {  Object[] }    sortByZIndex method .\\\n   *  @param { Object[] } nodeArray - Provide the nodeArray element .\n   *  @param { string } sortID - Provide the sortID element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.sortByZIndex = function (nodeArray, sortID) {\n    var id = sortID ? sortID : 'zIndex';\n    nodeArray = nodeArray.sort(function (a, b) {\n      return a[id] - b[id];\n    });\n    return nodeArray;\n  };\n  /**\n   * orderCommands method\\\n   *\n   * @returns {  void }    orderCommands method .\\\n   *  @param { boolean } isRedo - Provide the previousObject element .\n   *  @param { Selector } selector - Provide the previousObject element .\n   *  @param { EntryType } action - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.orderCommands = function (isRedo, selector, action) {\n    var selectedObject = selector.nodes;\n    selectedObject = selectedObject.concat(selector.connectors);\n\n    if (isRedo) {\n      if (action === 'SendBackward') {\n        this.sendBackward(selectedObject[0]);\n      } else if (action === 'SendForward') {\n        this.sendForward(selectedObject[0]);\n      } else if (action === 'BringToFront') {\n        this.bringToFront(selectedObject[0]);\n      } else if (action === 'SendToBack') {\n        this.sendToBack(selectedObject[0]);\n      }\n    } else {\n      var startZIndex = selectedObject[0].zIndex;\n      var endZIndex = this.diagram.nameTable[selectedObject[0].id].zIndex;\n      var undoObject = selectedObject[0];\n      var layer = this.getObjectLayer(undoObject.id);\n      var layerIndex = layer.zIndex;\n      var zIndexTable = layer.zIndexTable;\n\n      if (action === 'SendBackward' || action === 'SendForward') {\n        for (var i = 0; i < selectedObject.length; i++) {\n          var undoObject_1 = selectedObject[i];\n          var layer_2 = this.diagram.layers.indexOf(this.getObjectLayer(undoObject_1.id));\n          var node = this.diagram.nameTable[selectedObject[i].id];\n          node.zIndex = undoObject_1.zIndex;\n          this.diagram.layers[layer_2].zIndexTable[undoObject_1.zIndex] = undoObject_1.id;\n        }\n      } else if (action === 'BringToFront') {\n        if (selectedObject[0].shape.type === 'SwimLane') {\n          this.sendToBack(selectedObject[0]);\n        } else {\n          var k = 1;\n\n          for (var j = endZIndex; j > startZIndex; j--) {\n            if (zIndexTable[j]) {\n              if (!zIndexTable[j - k]) {\n                zIndexTable[j - k] = zIndexTable[j];\n                this.diagram.nameTable[zIndexTable[j - k]].zIndex = j;\n                delete zIndexTable[j];\n              } else {\n                zIndexTable[j] = zIndexTable[j - k];\n                this.diagram.nameTable[zIndexTable[j]].zIndex = j;\n              }\n            }\n          }\n        }\n      } else if (action === 'SendToBack') {\n        if (selectedObject[0].shape.type === 'SwimLane') {\n          this.bringToFront(selectedObject[0]);\n        } else {\n          for (var j = endZIndex; j < startZIndex; j++) {\n            if (zIndexTable[j]) {\n              if (!zIndexTable[j + 1]) {\n                zIndexTable[j + 1] = zIndexTable[j];\n                this.diagram.nameTable[zIndexTable[j + 1]].zIndex = j;\n                delete zIndexTable[j];\n              } else {\n                zIndexTable[j] = zIndexTable[j + 1];\n                this.diagram.nameTable[zIndexTable[j]].zIndex = j;\n              }\n            }\n          }\n        }\n      }\n\n      if (action === 'BringToFront' || action === 'SendToBack') {\n        var node = this.diagram.nameTable[selectedObject[0].id];\n        node.zIndex = undoObject.zIndex;\n        this.diagram.layers[layerIndex].zIndexTable[undoObject.zIndex] = undoObject.id;\n      }\n\n      if (this.diagram.mode === 'SVG') {\n        if (action === 'SendBackward') {\n          this.moveObject(selectedObject[1].id, selectedObject[0].id);\n        } else if (action === 'SendForward') {\n          this.moveObject(selectedObject[0].id, selectedObject[1].id);\n        } else if (action === 'BringToFront') {\n          if (selectedObject[0].shape.type !== 'SwimLane') {\n            this.moveObject(selectedObject[0].id, zIndexTable[selectedObject[0].zIndex + 1]);\n          }\n        } else if (action === 'SendToBack') {\n          if (selectedObject[0].shape.type !== 'SwimLane') {\n            var layer_3 = this.getObjectLayer(selectedObject[0].id);\n\n            for (var i = 0; i <= selectedObject[0].zIndex; i++) {\n              if (layer_3.objects[i] !== selectedObject[0].id) {\n                this.moveSvgNode(layer_3.objects[i], selectedObject[0].id);\n                this.updateNativeNodeIndex(selectedObject[0].id);\n              }\n            }\n          }\n        }\n      } else {\n        this.diagram.refreshCanvasLayers();\n      }\n    }\n  };\n\n  CommandHandler.prototype.moveObject = function (sourceId, targetId) {\n    if (targetId) {\n      this.moveSvgNode(sourceId, targetId);\n      this.updateNativeNodeIndex(sourceId, targetId);\n    }\n  };\n  /**\n   * sendForward method\\\n   *\n   * @returns {  void }    sendForward method .\\\n   *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.sendForward = function (obj) {\n    this.diagram.protectPropertyChange(true);\n\n    if (hasSelection(this.diagram) || obj) {\n      var nodeId = obj && obj.id;\n      nodeId = nodeId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id : this.diagram.selectedItems.connectors[0].id);\n      var layerIndex = this.diagram.layers.indexOf(this.getObjectLayer(nodeId));\n      var zIndexTable = this.diagram.layers[layerIndex].zIndexTable; //const tabelLength: number = Object.keys(zIndexTable).length;\n\n      var index = this.diagram.nameTable[nodeId];\n      var intersectArray = [];\n      var temp = this.diagram.spatialSearch.findObjects(index.wrapper.bounds);\n\n      if (temp.length > 2) {\n        temp = this.sortByZIndex(temp);\n      }\n\n      for (var _i = 0, temp_1 = temp; _i < temp_1.length; _i++) {\n        var i = temp_1[_i];\n\n        if (index.id !== i.id) {\n          var currentLayer = this.getObjectLayer(i.id).zIndex;\n\n          if (layerIndex === currentLayer && Number(this.diagram.nameTable[nodeId].zIndex) < Number(i.zIndex) && index.wrapper.bounds.intersects(i.wrapper.bounds)) {\n            intersectArray.push(i);\n            break;\n          }\n        }\n      }\n\n      if (intersectArray.length > 0) {\n        var node = this.diagram.nameTable[zIndexTable[Number(intersectArray[0].zIndex)]];\n\n        if (node.parentId) {\n          var parentId = '';\n          var parent_1 = findParentInSwimlane(node, this.diagram, parentId);\n          var obj_2 = this.diagram.nameTable[parent_1];\n\n          if (obj_2.id !== nodeId) {\n            intersectArray[0] = obj_2;\n          }\n        }\n\n        var overlapObject = intersectArray[0].zIndex;\n        var currentObject = index.zIndex;\n        var temp_2 = zIndexTable[overlapObject]; //swap the nodes\n\n        var undoObject = cloneObject(this.diagram.selectedItems); // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\n        this.diagram.nameTable[temp_2] instanceof Node ? undoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_2])) : undoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_2]));\n        this.diagram.layers[0].zIndexTable[overlapObject] = index.id;\n        this.diagram.nameTable[zIndexTable[overlapObject]].zIndex = overlapObject;\n        this.diagram.layers[0].zIndexTable[currentObject] = intersectArray[0].id;\n        this.diagram.nameTable[zIndexTable[currentObject]].zIndex = currentObject;\n\n        if (this.diagram.mode === 'SVG') {\n          this.moveSvgNode(zIndexTable[Number(intersectArray[0].zIndex)], nodeId);\n          this.updateNativeNodeIndex(zIndexTable[Number(intersectArray[0].zIndex)], nodeId);\n        } else {\n          this.diagram.refreshCanvasLayers();\n        }\n\n        var redo = cloneObject(this.diagram.selectedItems); // eslint-disable-next-line\n\n        this.diagram.nameTable[temp_2] instanceof Node ? redo.nodes.push(cloneObject(this.diagram.nameTable[temp_2])) : redo.connectors.push(cloneObject(this.diagram.nameTable[temp_2]));\n        var historyEntry = {\n          type: 'SendForward',\n          category: 'Internal',\n          undoObject: undoObject,\n          redoObject: redo\n        };\n\n        if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n          this.addHistoryEntry(historyEntry);\n        }\n      }\n\n      if (isBlazor()) {\n        var elements = [];\n        elements.push(index);\n        elements.push(intersectArray[intersectArray.length - 1]);\n        this.updateBlazorZIndex(elements);\n      }\n    }\n\n    this.diagram.protectPropertyChange(false);\n  };\n  /**\n   * sendBackward method\\\n   *\n   * @returns {  void }    sendBackward method .\\\n   *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.sendBackward = function (obj) {\n    this.diagram.protectPropertyChange(true);\n\n    if (hasSelection(this.diagram) || obj) {\n      var objectId = obj && obj.id;\n      objectId = objectId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id : this.diagram.selectedItems.connectors[0].id);\n      var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n      var zIndexTable = this.diagram.layers[layerNum].zIndexTable; //const tabelLength: number = Object.keys(zIndexTable).length;\n\n      var node = this.diagram.nameTable[objectId];\n      var intersectArray = [];\n      var temp = this.diagram.spatialSearch.findObjects(node.wrapper.bounds);\n\n      if (temp.length > 2) {\n        temp = this.sortByZIndex(temp);\n      }\n\n      for (var _i = 0, temp_3 = temp; _i < temp_3.length; _i++) {\n        var i = temp_3[_i];\n\n        if (node.id !== i.id) {\n          var currentLayer = this.getObjectLayer(i.id).zIndex;\n\n          if (layerNum === currentLayer && Number(this.diagram.nameTable[objectId].zIndex) > Number(i.zIndex) && node.wrapper.bounds.intersects(i.wrapper.bounds)) {\n            intersectArray.push(i);\n          }\n        }\n      }\n\n      for (var i = intersectArray.length - 1; i >= 0; i--) {\n        var child = this.diagram.nameTable[intersectArray[i].id];\n\n        if (child.parentId === objectId) {\n          intersectArray.splice(i, 1);\n        }\n      }\n\n      if (intersectArray.length > 0) {\n        var child = this.diagram.nameTable[intersectArray[intersectArray.length - 1].id];\n\n        if (child.parentId) {\n          var parentId = '';\n          var parent_2 = findParentInSwimlane(child, this.diagram, parentId);\n          var obj_3 = this.diagram.nameTable[parent_2];\n\n          if (objectId !== obj_3.id) {\n            intersectArray[intersectArray.length - 1] = obj_3;\n          }\n        }\n\n        var overlapObject = intersectArray[intersectArray.length - 1].zIndex;\n        var currentObject = node.zIndex;\n        var temp_4 = zIndexTable[overlapObject];\n        var undoObject = cloneObject(this.diagram.selectedItems); // eslint-disable-next-line\n\n        this.diagram.nameTable[temp_4] instanceof Node ? undoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_4])) : undoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_4])); //swap the nodes\n\n        zIndexTable[overlapObject] = node.id;\n        this.diagram.nameTable[zIndexTable[overlapObject]].zIndex = overlapObject;\n        zIndexTable[currentObject] = intersectArray[intersectArray.length - 1].id;\n        this.diagram.nameTable[zIndexTable[currentObject]].zIndex = currentObject;\n\n        if (this.diagram.mode === 'SVG') {\n          this.moveSvgNode(objectId, zIndexTable[intersectArray[intersectArray.length - 1].zIndex]);\n          var node_2 = this.diagram.nameTable[zIndexTable[intersectArray[intersectArray.length - 1].zIndex]];\n\n          if (node_2.children && node_2.children.length > 0) {\n            this.updateNativeNodeIndex(objectId);\n          } else {\n            this.updateNativeNodeIndex(objectId, zIndexTable[intersectArray[intersectArray.length - 1].zIndex]);\n          }\n\n          if (isBlazor()) {\n            var elements = [];\n            elements.push(node_2);\n            elements.push(intersectArray[intersectArray.length - 1]);\n            this.updateBlazorZIndex(elements);\n          }\n        } else {\n          this.diagram.refreshCanvasLayers();\n        }\n\n        var redoObject = cloneObject(this.diagram.selectedItems); // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\n        this.diagram.nameTable[temp_4] instanceof Node ? redoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_4])) : redoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_4]));\n        var entry = {\n          type: 'SendBackward',\n          category: 'Internal',\n          undoObject: undoObject,\n          redoObject: redoObject\n        };\n\n        if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n          this.addHistoryEntry(entry);\n        } //swap the nodes\n\n      }\n    }\n\n    this.diagram.protectPropertyChange(false);\n  };\n  /**\n   * updateNativeNodeIndex method\\\n   *\n   * @returns {  void }    updateNativeNodeIndex method .\\\n   *  @param { string } nodeId - Provide the previousObject element .\n   *  @param { string } targetID - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateNativeNodeIndex = function (nodeId, targetID) {\n    var node = this.diagram.selectedItems.nodes[0] || this.diagram.getObject(targetID);\n\n    for (var i = 0; i < this.diagram.views.length; i++) {\n      if (node && (node.shape.type === 'HTML' || node.shape.type === 'Native')) {\n        var id = node.shape.type === 'HTML' ? '_html_element' : '_content_groupElement';\n        var backNode = getDiagramElement(nodeId + id, this.diagram.views[i]);\n        var diagramDiv = targetID ? getDiagramElement(targetID + id, this.diagram.views[i]) : backNode.parentElement.firstChild;\n\n        if (backNode && diagramDiv) {\n          if (backNode.parentNode.id === diagramDiv.parentNode.id) {\n            diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n          }\n        }\n      }\n    }\n  };\n  /**\n   * initSelectorWrapper method\\\n   *\n   * @returns {  void }    initSelectorWrapper method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.initSelectorWrapper = function () {\n    var selectorModel = this.diagram.selectedItems;\n    selectorModel.init(this.diagram);\n\n    if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n      selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n      selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;\n      selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;\n    }\n  };\n  /**\n   * doRubberBandSelection method\\\n   *\n   * @returns {  void }    doRubberBandSelection method .\\\n   *  @param { Rect } region - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.doRubberBandSelection = function (region) {\n    this.clearSelectionRectangle();\n    var selArray = [];\n    var rubberArray = [];\n    selArray = this.diagram.getNodesConnectors(selArray);\n\n    if (this.diagram.selectedItems.rubberBandSelectionMode === 'CompleteIntersect') {\n      rubberArray = completeRegion(region, selArray);\n    } else {\n      rubberArray = this.diagram.spatialSearch.findObjects(region);\n    }\n\n    if (rubberArray.length) {\n      this.selectObjects(rubberArray, true);\n    }\n  };\n\n  CommandHandler.prototype.clearSelectionRectangle = function () {\n    var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);\n    var element = adornerSvg.getElementById(this.diagram.element.id + '_diagramAdorner_selected_region');\n\n    if (element) {\n      remove(element);\n    }\n  };\n  /**\n   * dragConnectorEnds method\\\n   *\n   * @returns {  void }    dragConnectorEnds method .\\\n   *  @param { string } endPoint - Provide the previousObject element .\n   *  @param { IElement } obj - Provide the previousObject element .\n   *  @param { PointModel } point - Provide the point element .\n   *  @param { BezierSegmentModel } segment - Provide the segment element .\n   *  @param { IElement } target - Provide the target element .\n   *  @param { string } targetPortId - Provide the targetPortId element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.dragConnectorEnds = function (endPoint, obj, point, segment, target, targetPortId) {\n    var selectorModel;\n    var connector; //let node: Node;\n\n    var tx; //let segmentPoint: PointModel;\n\n    var ty; //let index: number;\n\n    var checkBezierThumb = false;\n\n    if (obj instanceof Selector) {\n      selectorModel = obj;\n      connector = selectorModel.connectors[0];\n    } else if (obj instanceof Connector && this.diagram.currentDrawingObject) {\n      this.clearSelection();\n      connector = this.diagram.currentDrawingObject;\n    }\n\n    if (endPoint === 'BezierSourceThumb' || endPoint === 'BezierTargetThumb') {\n      checkBezierThumb = true;\n    }\n\n    if (endPoint === 'ConnectorSourceEnd' || endPoint === 'BezierSourceThumb') {\n      tx = point.x - (checkBezierThumb ? segment.bezierPoint1.x : connector.sourcePoint.x);\n      ty = point.y - (checkBezierThumb ? segment.bezierPoint1.y : connector.sourcePoint.y);\n      return this.dragSourceEnd(connector, tx, ty, null, point, endPoint, undefined, target, targetPortId, undefined, segment);\n    } else {\n      tx = point.x - (checkBezierThumb ? segment.bezierPoint2.x : connector.targetPoint.x);\n      ty = point.y - (checkBezierThumb ? segment.bezierPoint2.y : connector.targetPoint.y);\n      return this.dragTargetEnd(connector, tx, ty, null, point, endPoint, undefined, segment);\n    }\n  };\n  /**\n   * getSelectedObject method\\\n   *\n   * @returns {  void }    getSelectedObject method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.getSelectedObject = function () {\n    var selectormodel = this.diagram.selectedItems;\n    return selectormodel.nodes.concat(selectormodel.connectors);\n  };\n  /**\n   * updateBlazorProperties method\\\n   *\n   * @returns {  void }    updateBlazorProperties method .\\\n   *  @param { boolean } isObjectInteraction - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateBlazorProperties = function (isObjectInteraction) {\n    var blazorInterop = 'sfBlazor';\n    var blazor = 'Blazor';\n\n    if (!isObjectInteraction) {\n      if (window && window[blazor]) {\n        var obj = {\n          'methodName': 'UpdateBlazorProperties',\n          'diagramobj': this.diagramObject\n        };\n        window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n      }\n    } else {\n      if (window && window[blazor] && JSON.stringify(this.deepDiffer.diagramObject) !== '{}') {\n        var obj = {\n          'methodName': 'UpdateBlazorProperties',\n          'diagramobj': this.deepDiffer.diagramObject\n        };\n\n        if (!this.diagram.isLoading) {\n          window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n        }\n      }\n    } //this.diagram.enableServerDataBinding(true);\n\n\n    this.deepDiffer.newNodeObject = [];\n    this.deepDiffer.newConnectorObject = [];\n    this.diagramObject = [];\n    this.diagram.oldNodeObjects = [];\n    this.diagram.oldConnectorObjects = [];\n  };\n  /**\n   * enableCloneObject method\\\n   *\n   * @returns {  void }    enableCloneObject method .\\\n   *  @param { boolean } value - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.enableCloneObject = function (value) {\n    if (!this.diagram.lineRoutingModule || !(this.diagram.constraints & DiagramConstraints.LineRouting)) {\n      this.diagram.canEnableBlazorObject = value;\n    }\n  };\n  /**\n   * ismouseEvents method\\\n   *\n   * @returns {  void }    ismouseEvents method .\\\n   *  @param { boolean } value - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.ismouseEvents = function (value) {\n    if (value) {\n      this.diagram.blazorActions = this.diagram.addConstraints(this.diagram.blazorActions, BlazorAction.interaction);\n    } else {\n      this.diagram.blazorActions = this.diagram.removeConstraints(this.diagram.blazorActions, BlazorAction.interaction);\n    }\n  };\n  /**\n   * updateLayerObject method\\\n   *\n   * @returns {  void }    updateLayerObject method .\\\n   *  @param { object } oldDiagram - Provide the previousObject element .\n   *  @param { boolean } temp - Provide the temp element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateLayerObject = function (oldDiagram, temp) {\n    if (isBlazor()) {\n      var diffLayers = {};\n      diffLayers = this.deepDiffer.getLayerObject(oldDiagram, temp, this.diagram);\n      this.diagramObject = diffLayers;\n      this.updateBlazorProperties();\n    }\n  };\n  /* tslint:enable:no-string-literal */\n\n  /**\n   * getDiagramOldValues method\\\n   *\n   * @returns {  void }    getDiagramOldValues method .\\\n   *  @param { object } oldDiagram - Provide the previousObject element .\n   *  @param { string[] } attribute - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.getDiagramOldValues = function (oldDiagram, attribute) {\n    var newDiagram = {};\n\n    for (var i = 0; i < attribute.length; i++) {\n      newDiagram[attribute[i]] = cloneObject(this.diagram[attribute[i]]);\n    }\n\n    var newObject = cloneObject(newDiagram);\n    var result = this.deepDiffer.map(newObject, oldDiagram);\n    var diffValue = this.deepDiffer.frameObject({}, result);\n    var diff = this.deepDiffer.removeEmptyValues(diffValue);\n    diff = this.deepDiffer.changeSegments(diff, newObject);\n    this.diagramObject = diff;\n\n    if (!(this.diagram.blazorActions & BlazorAction.ClearObject)) {\n      this.updateBlazorProperties();\n    }\n  };\n  /* tslint:disable */\n\n  /**\n   * getBlazorOldValues method\\\n   *\n   * @returns {  void }    getBlazorOldValues method .\\\n   *  @param { MouseEventArgs } args - Provide the previousObject element .\n   *  @param { boolean } labelDrag - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.getBlazorOldValues = function (args, labelDrag) {\n    if (isBlazor()) {\n      var oldNodeObject = this.diagram.oldNodeObjects;\n\n      for (var i = 0; i < oldNodeObject.length; i++) {\n        if (oldNodeObject[i].id) {\n          if (this.diagram.oldNodeObjects[i] instanceof Node) {\n            this.diagram.oldNodeObjects[i] = cloneBlazorObject(this.diagram.oldNodeObjects[i]);\n          }\n\n          this.deepDiffer.getDifferenceValues(this.diagram.nameTable[oldNodeObject[i].id], args, labelDrag, this.diagram);\n        }\n      }\n\n      var oldConnectorObject = this.diagram.oldConnectorObjects;\n\n      for (var i = 0; i < oldConnectorObject.length; i++) {\n        if (oldConnectorObject[i].id) {\n          if (this.diagram.oldConnectorObjects[i] instanceof Connector) {\n            this.diagram.oldConnectorObjects[i] = cloneBlazorObject(this.diagram.oldConnectorObjects[i]);\n          }\n\n          this.deepDiffer.getDifferenceValues(this.diagram.nameTable[oldConnectorObject[i].id], args, labelDrag, this.diagram);\n        }\n      }\n\n      if (oldNodeObject.length > 0 || oldConnectorObject.length > 0) {\n        this.updateBlazorProperties(true);\n      }\n    }\n  };\n  /**\n   * getObjectChanges method\\\n   *\n   * @returns {  void }    getObjectChanges method .\\\n   *  @param { Object[] } previousObject - Provide the previousObject element .\n   *  @param { Object[] } currentObject - Provide the previousObject element .\n   *  @param { Object[] } previousObject - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.getObjectChanges = function (previousObject, currentObject, changedNodes) {\n    for (var i = 0; i < previousObject.length; i++) {\n      var value = this.deepDiffer.map(currentObject[i], previousObject[i]);\n      var result = this.deepDiffer.frameObject({}, value);\n      var change = this.deepDiffer.removeEmptyValues(result);\n\n      if (change.children) {\n        change.children = cloneObject(currentObject[i]).children;\n      }\n\n      change = this.deepDiffer.changeSegments(change, currentObject[i]);\n      change.sfIndex = getIndex(this.diagram, currentObject[i].id);\n      changedNodes.push(change);\n    }\n  };\n  /**\n   * clearObjectSelection method\\\n   *\n   * @returns {  void }    clearObjectSelection method .\\\n   *  @param { (NodeModel | ConnectorModel) } mouseDownElement - Provide the triggerAction element .\n   * @private\n   */\n  // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node\n\n\n  CommandHandler.prototype.clearObjectSelection = function (mouseDownElement) {\n    var selectedItems = this.diagram.selectedItems;\n    var list = [];\n    list = list.concat(selectedItems.nodes, selectedItems.connectors);\n\n    if (list.indexOf(mouseDownElement) === -1) {\n      this.clearSelection(list.length > 0 ? true : false);\n      this.selectObjects([mouseDownElement], true);\n    }\n  };\n  /**\n   * clearSelection method\\\n   *\n   * @returns {  void }    clearSelection method .\\\n   *  @param { boolean } triggerAction - Provide the triggerAction element .\n   *  @param { boolean } isTriggered - Provide the isTriggered element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.clearSelection = function (triggerAction, isTriggered) {\n    return __awaiter(this, void 0, void 0, function () {\n      var enableServerDataBinding, selectormodel, arrayNodes, arg, blazarArgs, eventObj, selectNodes, i;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            enableServerDataBinding = this.diagram.allowServerDataBinding;\n            this.diagram.enableServerDataBinding(false);\n            if (!hasSelection(this.diagram)) return [3\n            /*break*/\n            , 5];\n            selectormodel = this.diagram.selectedItems;\n            arrayNodes = this.getSelectedObject();\n\n            if (this.diagram.currentSymbol) {\n              this.diagram.previousSelectedObject = arrayNodes;\n            }\n\n            arg = {\n              oldValue: arrayNodes,\n              newValue: [],\n              cause: this.diagram.diagramActions,\n              state: 'Changing',\n              type: 'Removal',\n              cancel: false\n            };\n            this.updateBlazorSelectorModel(arrayNodes, true);\n\n            if (triggerAction) {\n              if (!isBlazor()) {\n                this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n              } else {\n                this.oldSelectedObjects = cloneObject(selectormodel);\n              }\n            }\n\n            if (!!arg.cancel) return [3\n            /*break*/\n            , 4];\n            selectormodel.offsetX = 0;\n            selectormodel.offsetY = 0;\n            selectormodel.width = 0;\n            selectormodel.height = 0;\n            selectormodel.rotateAngle = 0;\n            selectormodel.nodes = [];\n            selectormodel.connectors = [];\n            selectormodel.wrapper = null;\n            selectormodel.annotation = undefined;\n            this.diagram.clearSelectorLayer();\n            if (!triggerAction) return [3\n            /*break*/\n            , 4];\n            arg = {\n              oldValue: cloneBlazorObject(arrayNodes),\n              newValue: [],\n              cause: this.diagram.diagramActions,\n              state: 'Changed',\n              type: 'Removal',\n              cancel: false\n            };\n\n            if (isBlazor()) {\n              arg = this.updateSelectionChangeEventArgs(arg, [], arrayNodes);\n              this.updateBlazorSelector();\n            }\n\n            if (!!isBlazor()) return [3\n            /*break*/\n            , 1];\n            this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            return [3\n            /*break*/\n            , 4];\n\n          case 1:\n            blazarArgs = void 0;\n            if (!(window && window[this.blazor] && this.diagram.selectionChange)) return [3\n            /*break*/\n            , 3];\n            eventObj = {\n              'EventName': 'selectionChange',\n              args: JSON.stringify(arg)\n            };\n            return [4\n            /*yield*/\n            , window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram)];\n\n          case 2:\n            blazarArgs = _a.sent();\n            _a.label = 3;\n\n          case 3:\n            // let blazarArgs: void | object = await this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            if (blazarArgs && blazarArgs.cancel && !isTriggered) {\n              selectNodes = [];\n\n              if (blazarArgs.oldValue.nodes.length > 0) {\n                selectNodes = blazarArgs.oldValue.nodes;\n              }\n\n              if (blazarArgs.oldValue.connectors.length > 0) {\n                selectNodes = selectNodes.concat(blazarArgs.oldValue.connectors);\n              }\n\n              if (selectNodes) {\n                for (i = 0; i < selectNodes.length; i++) {\n                  this.select(this.diagram.nameTable[selectNodes[i].id], i !== 0 && selectNodes.length > 1 ? true : false);\n                }\n              }\n            }\n\n            _a.label = 4;\n\n          case 4:\n            this.updateBlazorSelector();\n            this.diagram.enableServerDataBinding(enableServerDataBinding);\n            _a.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * clearSelectedItems method\\\n   *\n   * @returns {  void }    clearSelectedItems method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.clearSelectedItems = function () {\n    var selectedNodes = this.diagram.selectedItems.nodes ? this.diagram.selectedItems.nodes.length : 0;\n    var selectedConnectors = this.diagram.selectedItems.connectors ? this.diagram.selectedItems.connectors.length : 0;\n    this.clearSelection(selectedNodes + selectedConnectors > 0 ? true : false);\n  };\n  /**\n   * removeStackHighlighter method\\\n   *\n   * @returns {  void }    removeStackHighlighter method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.removeStackHighlighter = function () {\n    var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);\n    var highlighter = adornerSvg.getElementById(adornerSvg.id + '_stack_highlighter');\n\n    if (highlighter) {\n      highlighter.parentNode.removeChild(highlighter);\n    }\n  };\n  /**\n   * @param {End} args - provide the args  value.\n   * @param {IElement} target - provide the target  value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.renderStackHighlighter = function (args, target) {\n    var source = this.diagram.selectedItems.nodes[0];\n    var symbolDrag;\n    var node;\n    var selectorModel;\n\n    if (!target) {\n      var objects = this.diagram.findObjectsUnderMouse(args.position);\n      target = this.diagram.findObjectUnderMouse(objects, 'Drag', true);\n\n      if (target && !(target.isLane || target.isPhase || target.isHeader)) {\n        for (var i = 0; i < objects.length; i++) {\n          var laneNode = this.diagram.nameTable[objects[i].id];\n\n          if (!laneNode.isLane || laneNode.isPhase || laneNode.isHeader) {\n            target = laneNode;\n            this.diagram.parentObject = target;\n          }\n        }\n      }\n    }\n\n    if (source && target && target.isLane && source.shape && !source.shape.isPhase) {\n      node = this.diagram.nameTable[target.parentId];\n\n      if (this.diagram.currentSymbol && node.shape.type === 'SwimLane') {\n        symbolDrag = true;\n      }\n\n      if (source && !source.parentId && source.shape.type !== 'SwimLane' || source && source.parentId && this.diagram.nameTable[source.parentId] && this.diagram.nameTable[source.parentId].isLane && source.parentId !== target.parentId && source.parentId !== target.id) {\n        selectorModel = this.diagram.selectedItems;\n        var canvas = gridSelection(this.diagram, selectorModel, target.id, true);\n\n        if (canvas) {\n          selectorModel.wrapper.children[0] = canvas;\n        }\n\n        this.diagram.renderSelector(false, true);\n        selectorModel.wrapper.children[0] = selectorModel.nodes[0].wrapper;\n      }\n    }\n\n    if (source && target && target.parentId && source.shape && source.shape.isPhase) {\n      var node_3 = this.diagram.nameTable[target.parentId];\n\n      if (node_3.shape.type === 'SwimLane') {\n        this.diagram.selectedItems.wrapper.children[0] = this.diagram.nameTable[target.parentId].wrapper;\n        this.diagram.renderSelector(false, true);\n      }\n    }\n\n    if (symbolDrag && this.diagram.currentSymbol.shape.isLane || source && target && source.parentId && target.parentId && !source.isPhase && source.parentId === target.parentId && source.id !== target.id && node && node.container && (node.container.type === 'Stack' || node.container.type === 'Grid')) {\n      var canvas = void 0;\n      var value = node.container.orientation === 'Vertical';\n      var isVertical = node.container === 'Stack' ? value : !value;\n\n      if (node.container.type === 'Grid' && target.isLane && (!this.diagram.currentSymbol && node.shape.orientation === 'Horizontal' && target.rowIndex !== source.rowIndex || node.shape.orientation === 'Vertical' && target.columnIndex !== source.columnIndex || this.diagram.currentSymbol && this.diagram.currentSymbol.shape.orientation === node.container.orientation)) {\n        selectorModel = this.diagram.selectedItems;\n\n        if (source.isLane && canLaneInterchange(source, this.diagram) || !source.isLane) {\n          canvas = gridSelection(this.diagram, selectorModel, target.id, symbolDrag);\n        }\n      }\n\n      var wrapper = node.container.type === 'Stack' ? target.wrapper : canvas;\n\n      if (wrapper) {\n        renderStackHighlighter(wrapper, isVertical, args.position, this.diagram, false, true);\n      }\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.insertBlazorConnector = function (obj) {\n    if (obj instanceof Selector) {\n      for (var i = 0; i < obj.connectors.length; i++) {\n        this.diagram.insertBlazorConnector(obj.connectors[i]);\n      }\n    } else {\n      this.diagram.insertBlazorConnector(obj);\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.drag = function (obj, tx, ty) {\n    var tempNode;\n    var elements = [];\n\n    if (canMove(obj) && this.checkBoundaryConstraints(tx, ty, obj.wrapper.bounds) && canPageEditable(this.diagram)) {\n      if (obj instanceof Node) {\n        var oldValues = {\n          offsetX: obj.offsetX,\n          offsetY: obj.offsetY\n        };\n        obj.offsetX += tx;\n        obj.offsetY += ty;\n\n        if (obj.children && !obj.container) {\n          if (!checkParentAsContainer(this.diagram, obj, true)) {\n            this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.isGroupDragging;\n          }\n\n          var nodes = this.getAllDescendants(obj, elements);\n\n          for (var i = 0; i < nodes.length; i++) {\n            tempNode = this.diagram.nameTable[nodes[i].id];\n            this.drag(tempNode, tx, ty);\n          }\n\n          this.updateInnerParentProperties(obj);\n          this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.isGroupDragging;\n        }\n\n        if (checkParentAsContainer(this.diagram, obj, true)) {\n          checkChildNodeInContainer(this.diagram, obj);\n        } else {\n          if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {\n            obj.wrapper.measureChildren = true;\n          }\n\n          this.diagram.nodePropertyChange(obj, oldValues, {\n            offsetX: obj.offsetX,\n            offsetY: obj.offsetY\n          }, undefined, undefined, false);\n          obj.wrapper.measureChildren = false;\n        }\n\n        if (obj.shape.type === 'SwimLane' && !this.diagram.currentSymbol) {\n          var grid = obj.wrapper.children[0];\n          var connectors = getConnectors(this.diagram, grid, 0, true);\n          updateConnectorsProperties(connectors, this.diagram);\n        }\n      } else {\n        var connector = obj;\n        var oldValues = {\n          sourcePoint: connector.sourcePoint,\n          targetPoint: connector.targetPoint\n        };\n        var update = connector.type === 'Bezier' ? true : false;\n        var hasEnds = false;\n\n        if (!connector.sourceWrapper) {\n          this.dragSourceEnd(connector, tx, ty, true, null, '', update);\n        } else {\n          hasEnds = true;\n        }\n\n        if (!connector.targetWrapper) {\n          this.dragTargetEnd(connector, tx, ty, true, null, '', update);\n        } else {\n          hasEnds = true;\n        }\n\n        var canDragPoints = false;\n\n        if (obj instanceof Connector) {\n          canDragPoints = true;\n        }\n\n        if (!hasEnds || canDragPoints) {\n          this.dragControlPoint(connector, tx, ty, true);\n          var conn = {\n            sourcePoint: connector.sourcePoint,\n            targetPoint: connector.targetPoint\n          };\n          this.diagram.connectorPropertyChange(connector, oldValues, conn);\n        }\n      }\n    }\n  };\n  /**   @private  */\n\n\n  CommandHandler.prototype.connectorSegmentChange = function (actualObject, existingInnerBounds, isRotate) {\n    var tx;\n    var ty;\n    var segmentChange = true;\n\n    if (existingInnerBounds.equals(existingInnerBounds, actualObject.wrapper.bounds) === false) {\n      if (actualObject.outEdges.length > 0) {\n        for (var k = 0; k < actualObject.outEdges.length; k++) {\n          var connector = this.diagram.nameTable[actualObject.outEdges[k]];\n\n          if (connector.targetID !== '') {\n            segmentChange = this.isSelected(this.diagram.nameTable[connector.targetID]) ? false : true;\n          } else {\n            segmentChange = this.isSelected(this.diagram.nameTable[connector.id]) ? false : true;\n          }\n\n          if (connector.type === 'Orthogonal' && connector.segments && connector.segments.length > 1) {\n            if (!isRotate) {\n              if (segmentChange) {\n                switch (connector.segments[0].direction) {\n                  case 'Bottom':\n                    tx = actualObject.wrapper.bounds.bottomCenter.x - existingInnerBounds.bottomCenter.x;\n                    ty = actualObject.wrapper.bounds.bottomCenter.y - existingInnerBounds.bottomCenter.y;\n                    break;\n\n                  case 'Top':\n                    tx = actualObject.wrapper.bounds.topCenter.x - existingInnerBounds.topCenter.x;\n                    ty = actualObject.wrapper.bounds.topCenter.y - existingInnerBounds.topCenter.y;\n                    break;\n\n                  case 'Left':\n                    tx = actualObject.wrapper.bounds.middleLeft.x - existingInnerBounds.middleLeft.x;\n                    ty = actualObject.wrapper.bounds.middleLeft.y - existingInnerBounds.middleLeft.y;\n                    break;\n\n                  case 'Right':\n                    tx = actualObject.wrapper.bounds.middleRight.x - existingInnerBounds.middleRight.x;\n                    ty = actualObject.wrapper.bounds.middleRight.y - existingInnerBounds.middleRight.y;\n                    break;\n                }\n\n                this.dragSourceEnd(connector, tx, ty, true, null, 'ConnectorSourceEnd', undefined, undefined, undefined, actualObject.parentId && this.diagram.diagramActions & DiagramAction.isGroupDragging ? false : true);\n              }\n            } else {\n              var firstSegment = connector.segments[0];\n              var secondSegment = connector.segments[1];\n              var cornerPoints = swapBounds(actualObject.wrapper, actualObject.wrapper.corners, actualObject.wrapper.bounds);\n              var sourcePoint = findPoint(cornerPoints, firstSegment.direction);\n              sourcePoint = getIntersection(connector, connector.sourceWrapper, sourcePoint, {\n                x: connector.sourceWrapper.offsetX,\n                y: connector.sourceWrapper.offsetY\n              }, false);\n              var source = {\n                corners: undefined,\n                point: sourcePoint,\n                margin: undefined,\n                direction: firstSegment.direction\n              };\n              var target = {\n                corners: undefined,\n                point: secondSegment.points[1],\n                margin: undefined,\n                direction: undefined\n              };\n              var intermediatePoints = orthoConnection2Segment(source, target);\n              firstSegment.length = Point.distancePoints(intermediatePoints[0], intermediatePoints[1]);\n\n              if (secondSegment.direction && secondSegment.length) {\n                secondSegment.length = Point.distancePoints(intermediatePoints[1], intermediatePoints[2]);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.updateEndPoint = function (connector, oldChanges) {\n    var conn = {\n      sourcePoint: connector.sourcePoint,\n      targetPoint: connector.targetPoint,\n      sourceID: connector.sourceID ? connector.sourceID : undefined,\n      targetID: connector.targetID ? connector.targetID : undefined,\n      sourcePortID: connector.sourcePortID ? connector.sourcePortID : undefined,\n      targetPortID: connector.targetPortID ? connector.targetPortID : undefined,\n      segments: connector.segments ? connector.segments : undefined\n    };\n    var newValue = {\n      sourcePoint: connector.sourcePoint,\n      targetPoint: connector.targetPoint\n    };\n\n    if (connector.sourceID) {\n      newValue.sourceID = connector.sourceID;\n    }\n\n    if (connector.targetID) {\n      newValue.targetID = connector.targetID;\n    }\n\n    if (connector.sourcePortID) {\n      newValue.sourcePortID = connector.sourcePortID;\n    }\n\n    if (connector.targetPortID) {\n      newValue.targetPortID = connector.targetPortID;\n    }\n\n    if (connector.segments) {\n      newValue.segments = connector.segments;\n    }\n\n    this.diagram.connectorPropertyChange(connector, oldChanges ? oldChanges : {}, newValue); // this.diagram.refreshDiagramLayer();\n\n    this.diagram.updateSelector();\n  };\n  /**\n   * @param obj\n   * @param tx\n   * @param ty\n   * @param preventUpdate\n   * @param point\n   * @param endPoint\n   * @param update\n   * @param target\n   * @param targetPortId\n   * @param isDragSource\n   * @param segment\n   * @private\n   */\n\n\n  CommandHandler.prototype.dragSourceEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, target, targetPortId, isDragSource, segment) {\n    var connector = this.diagram.nameTable[obj.id];\n    var oldChanges = {};\n    var checkBoundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);\n\n    if (canDragSourceEnd(connector) && checkBoundaryConstraints && endPoint !== 'BezierSourceThumb' && canPageEditable(this.diagram)) {\n      oldChanges = {\n        sourcePoint: connector.sourcePoint\n      };\n      connector.sourcePoint.x += tx;\n      connector.sourcePoint.y += ty;\n\n      if (endPoint === 'ConnectorSourceEnd' && connector.type === 'Orthogonal') {\n        this.changeSegmentLength(connector, target, targetPortId, isDragSource);\n      }\n\n      if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n        this.updatePathElementOffset(connector);\n      }\n    }\n\n    if (connector.type === 'Bezier') {\n      oldChanges = {\n        sourcePoint: connector.sourcePoint\n      };\n\n      if (segment) {\n        this.translateBezierPoints(obj, endPoint === '' ? 'ConnectorSourceEnd' : endPoint, tx, ty, segment, point, !update);\n      } else {\n        for (var i = 0; i < obj.segments.length; i++) {\n          this.translateBezierPoints(obj, endPoint === '' ? 'ConnectorSourceEnd' : endPoint, tx, ty, obj.segments[i], point, !update);\n        }\n      }\n    }\n\n    if (!preventUpdate) {\n      this.updateEndPoint(connector, oldChanges);\n    }\n\n    if (!(this.diagram.realActions & RealAction.AnimationClick)) {\n      this.diagram.refreshCanvasLayers();\n    }\n\n    return checkBoundaryConstraints;\n  };\n  /**\n   * Update Path Element offset\n   */\n\n\n  CommandHandler.prototype.updatePathElementOffset = function (connector) {\n    connector.wrapper.children.splice(3, 1);\n    var pathElement = new PathElement();\n    var anglePoints = connector.intermediatePoints;\n    pathElement = updatePathElement(anglePoints, connector);\n    connector.wrapper.children.splice(3, 0, pathElement);\n  };\n  /**\n   * Upadte the connector segments when change the source node\n   */\n\n\n  CommandHandler.prototype.changeSegmentLength = function (connector, target, targetPortId, isDragSource) {\n    if (connector.segments && connector.segments[0].direction !== null && (!target && connector.sourceID === '' || isDragSource)) {\n      var first = connector.segments[0];\n      var second = connector.segments[1];\n      var node = this.diagram.nameTable[connector.sourceID];\n      var secPoint = void 0;\n      first.points[0] = connector.sourcePoint;\n\n      if (first.direction === 'Top' || first.direction === 'Bottom') {\n        first.points[first.points.length - 1].x = connector.sourcePoint.x;\n        second.points[0].y = first.points[first.points.length - 1].y;\n      } else {\n        first.points[first.points.length - 1].y = connector.sourcePoint.y;\n        second.points[0].x = first.points[first.points.length - 1].x;\n      }\n\n      if (first.direction && (first.length || first.length === 0)) {\n        first.length = Point.distancePoints(first.points[0], first.points[first.points.length - 1]);\n      }\n\n      if (second.direction && (second.length || second.length === 0)) {\n        second.length = Point.distancePoints(first.points[first.points.length - 1], second.points[second.points.length - 1]);\n        second.direction = Point.direction(first.points[first.points.length - 1], second.points[second.points.length - 1]);\n      }\n\n      if (connector.sourcePortID !== '' && first.length < 10) {\n        if (connector.segments.length > 2) {\n          var next = connector.segments[2];\n          var nextDirection = Point.direction(next.points[0], next.points[1]);\n\n          if (first.direction === getOppositeDirection(nextDirection)) {\n            if (first.direction === 'Right') {\n              next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleRight.x + 20;\n            } else if (first.direction === 'Left') {\n              next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleLeft.x - 20;\n            } else if (first.direction === 'Top') {\n              next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.topCenter.y - 20;\n            } else {\n              next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.bottomCenter.y + 20;\n            }\n\n            if (next.direction && next.length) {\n              next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n            }\n\n            first.length = Point.distancePoints(first.points[0], first.points[first.points.length - 1]);\n          } else if (first.direction === nextDirection && next.direction && next.length) {\n            if (first.direction === 'Top' || first.direction === 'Bottom') {\n              next.points[0] = first.points[0];\n              next.points[next.points.length - 1].x = next.points[0].x;\n            } else {\n              next.points[0] = first.points[0];\n              next.points[next.points.length - 1].y = next.points[0].y;\n            }\n\n            next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n            connector.segments.splice(0, 2);\n          } else {\n            first.length = 20;\n          }\n        } else {\n          first.length = 20;\n        }\n      } else if (first.length < 1) {\n        if (connector.sourceID !== '') {\n          if (second.direction === 'Right') {\n            secPoint = node.wrapper.corners.middleRight;\n            second.points[second.points.length - 1].y = secPoint.y;\n          } else if (second.direction === 'Left') {\n            secPoint = node.wrapper.corners.middleLeft;\n            second.points[second.points.length - 1].y = secPoint.y;\n          } else if (second.direction === 'Top') {\n            secPoint = node.wrapper.corners.topCenter;\n            second.points[second.points.length - 1].x = secPoint.x;\n          } else {\n            secPoint = node.wrapper.corners.bottomCenter;\n            second.points[second.points.length - 1].x = secPoint.x;\n          }\n\n          second.length = Point.distancePoints(secPoint, second.points[second.points.length - 1]);\n\n          if (connector.segments.length > 2) {\n            var next = connector.segments[2];\n\n            if (next.direction && next.length) {\n              next.length = Point.distancePoints(second.points[second.points.length - 1], next.points[next.points.length - 1]);\n            }\n          }\n\n          connector.segments.splice(0, 1);\n        } else {\n          connector.segments.splice(0, 1);\n        }\n      }\n    } else {\n      if (target && !targetPortId && connector.sourceID !== target.id && connector.segments && connector.segments[0].direction !== null && target && target instanceof Node) {\n        this.changeSourceEndToNode(connector, target);\n      }\n\n      if (target && targetPortId && connector.sourcePortID !== targetPortId && connector.segments && connector.segments[0].direction !== null && target && target instanceof Node) {\n        this.changeSourceEndToPort(connector, target, targetPortId);\n      }\n    }\n  };\n  /**\n   * Change the connector endPoint to port\n   */\n\n\n  CommandHandler.prototype.changeSourceEndToPort = function (connector, target, targetPortId) {\n    var port = this.diagram.getWrapper(target.wrapper, targetPortId);\n    var point = {\n      x: port.offsetX,\n      y: port.offsetY\n    };\n    var direction = getPortDirection(point, cornersPointsBeforeRotation(target.wrapper), target.wrapper.bounds, false);\n    var firstSegment = connector.segments[0];\n    var secondSegment = connector.segments[1];\n\n    if (firstSegment.direction !== direction) {\n      var segments = [];\n      var segValues = {};\n\n      if (firstSegment.direction === getOppositeDirection(direction)) {\n        segValues = {};\n        var segValues1 = void 0;\n\n        if (direction === 'Top' || direction === 'Bottom') {\n          segValues1 = direction === 'Top' ? {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: direction,\n            length: Math.abs(firstSegment.points[0].y - point.y)\n          } : {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: direction,\n            length: Math.abs(point.y - firstSegment.points[0].y)\n          };\n          segValues = firstSegment.points[0].x > point.x ? {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: 'Right',\n            length: firstSegment.points[0].x - point.x\n          } : {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: 'Left',\n            length: point.x - firstSegment.points[0].x\n          };\n        } else {\n          segValues1 = direction === 'Right' ? {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: direction,\n            length: Math.abs(firstSegment.points[0].x - point.x)\n          } : {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: direction,\n            length: Math.abs(point.x - firstSegment.points[0].x)\n          };\n          segValues = firstSegment.points[0].y > point.y ? {\n            type: 'Orthogonal',\n            direction: 'Top',\n            isTerminal: true,\n            length: firstSegment.points[0].y - point.y\n          } : {\n            type: 'Orthogonal',\n            direction: 'Bottom',\n            isTerminal: true,\n            length: point.y - firstSegment.points[0].y\n          };\n        }\n\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues1, true));\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n      } else {\n        segValues = {\n          type: 'Orthogonal',\n          direction: direction,\n          length: 20,\n          isTerminal: true\n        };\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n      }\n\n      if (firstSegment.direction !== getOppositeDirection(direction)) {\n        if (direction === 'Top' || direction === 'Bottom') {\n          firstSegment.points[0].x = point.x;\n          firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = direction === 'Top' ? point.y - 20 : point.y + 20;\n        } else {\n          firstSegment.points[0].y = point.y;\n          firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = direction === 'Right' ? point.x + 20 : point.x - 20;\n        }\n\n        firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n        secondSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);\n      }\n\n      connector.segments = segments.concat(connector.segments);\n    } else {\n      firstSegment.points[0] = point;\n\n      if (direction === 'Top' || direction === 'Bottom') {\n        firstSegment.points[firstSegment.points.length - 1].x = point.x;\n      } else {\n        firstSegment.points[firstSegment.points.length - 1].y = point.y;\n      }\n\n      firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n      secondSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);\n    }\n  };\n  /**\n   * @param connector\n   * @param changeTerminal\n   * @private\n  Remove terinal segment in initial\n   */\n\n\n  CommandHandler.prototype.removeTerminalSegment = function (connector, changeTerminal) {\n    for (var i = 0; i < connector.segments.length - 2; i++) {\n      var segment = connector.segments[0];\n\n      if (segment.isTerminal) {\n        if (changeTerminal) {\n          segment.isTerminal = false;\n        } else {\n          connector.segments.splice(i, 1);\n          i--;\n        }\n      }\n    }\n  };\n  /**\n   * Change the connector endPoint from point to node\n   */\n\n\n  CommandHandler.prototype.changeSourceEndToNode = function (connector, target) {\n    this.removeTerminalSegment(connector);\n    var sourceWrapper = target.wrapper.children[0].corners;\n    var sourcePoint;\n    var sourcePoint2;\n    var firstSegment = connector.segments[0];\n    var nextSegment = connector.segments[1];\n    var segments = [];\n\n    if (firstSegment.direction === 'Right' || firstSegment.direction === 'Left') {\n      sourcePoint = firstSegment.direction === 'Left' ? sourceWrapper.middleLeft : sourceWrapper.middleRight;\n\n      if (firstSegment.length > sourceWrapper.width || firstSegment.direction === 'Left' && sourcePoint.x >= firstSegment.points[0].x || firstSegment.direction === 'Right' && sourcePoint.x <= firstSegment.points[0].x) {\n        firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = sourcePoint.y;\n        firstSegment.points[0].x = sourcePoint.x;\n        firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n        nextSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);\n      } else {\n        var direction = void 0;\n\n        if (nextSegment.direction) {\n          direction = nextSegment.direction;\n        } else {\n          direction = Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);\n        }\n\n        sourcePoint2 = direction === 'Bottom' ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;\n\n        if (nextSegment.length && nextSegment.direction) {\n          nextSegment.length = direction === 'Top' ? firstSegment.points[firstSegment.points.length - 1].y - (sourcePoint2.y + 20) : sourcePoint2.y + 20 - firstSegment.points[firstSegment.points.length - 1].y;\n        }\n\n        firstSegment.length = firstSegment.points[firstSegment.points.length - 1].x - sourcePoint2.x;\n        firstSegment.direction = firstSegment.length > 0 ? 'Right' : 'Left';\n        var segValues = {\n          type: 'Orthogonal',\n          direction: direction,\n          length: 20\n        };\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n        connector.segments = segments.concat(connector.segments);\n      }\n    } else {\n      sourcePoint = firstSegment.direction === 'Bottom' ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;\n\n      if (firstSegment.length > sourceWrapper.height || firstSegment.direction === 'Top' && sourcePoint.y >= firstSegment.points[0].y || firstSegment.direction === 'Bottom' && sourcePoint.y <= firstSegment.points[0].y) {\n        firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = sourcePoint.x;\n        firstSegment.points[0].y = sourcePoint.y;\n        firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n        nextSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);\n      } else {\n        sourcePoint2 = nextSegment.direction === 'Left' ? sourceWrapper.middleLeft : sourceWrapper.middleRight;\n        var direction = void 0;\n\n        if (nextSegment.direction) {\n          direction = nextSegment.direction;\n        } else {\n          direction = Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);\n        }\n\n        if (nextSegment.length && nextSegment.direction) {\n          nextSegment.length = direction === 'Left' ? firstSegment.points[firstSegment.points.length - 1].x - (sourcePoint2.x + 20) : sourcePoint2.x + 20 - firstSegment.points[firstSegment.points.length - 1].x;\n        }\n\n        firstSegment.length = firstSegment.points[firstSegment.points.length - 1].y - sourcePoint2.y;\n        firstSegment.direction = firstSegment.length > 0 ? 'Bottom' : 'Top';\n        var segValues = {\n          type: 'Orthogonal',\n          direction: direction,\n          length: 20\n        };\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n        connector.segments = segments.concat(connector.segments);\n      }\n    }\n  }; //Translate the bezier points during the interaction\n\n\n  CommandHandler.prototype.translateBezierPoints = function (connector, value, tx, ty, seg, point, update) {\n    var index = connector.segments.indexOf(seg);\n    var segment = connector.segments[index];\n\n    if (segment) {\n      if (value === 'BezierSourceThumb' && (segment.vector1.angle || segment.vector1.distance)) {\n        segment.vector1 = {\n          distance: connector.distance(connector.sourcePoint, point),\n          angle: Point.findAngle(connector.sourcePoint, point)\n        };\n      } else if (value === 'BezierTargetThumb' && (segment.vector2.angle || segment.vector2.distance)) {\n        segment.vector2 = {\n          distance: connector.distance(connector.targetPoint, point),\n          angle: Point.findAngle(connector.targetPoint, point)\n        };\n      } else if ((value === 'ConnectorSourceEnd' && !connector.sourceID || value === 'ConnectorTargetEnd' && !connector.targetID) && update && isEmptyVector(segment.vector1) && isEmptyVector(segment.vector2)) {\n        if (Point.isEmptyPoint(segment.point1)) {\n          segment.bezierPoint1 = getBezierPoints(connector.sourcePoint, connector.targetPoint);\n        }\n\n        if (Point.isEmptyPoint(segment.point2)) {\n          segment.bezierPoint2 = getBezierPoints(connector.targetPoint, connector.sourcePoint);\n        }\n      } else if (value === 'BezierSourceThumb' || value === 'ConnectorSourceEnd' && !update && isEmptyVector(segment.vector1)) {\n        segment.bezierPoint1.x += tx;\n        segment.bezierPoint1.y += ty;\n\n        if (!Point.isEmptyPoint(segment.point1) || update) {\n          segment.point1 = {\n            x: segment.bezierPoint1.x,\n            y: segment.bezierPoint1.y\n          };\n        }\n      } else if (value === 'BezierTargetThumb' || value === 'ConnectorTargetEnd' && !update && isEmptyVector(segment.vector2)) {\n        segment.bezierPoint2.x += tx;\n        segment.bezierPoint2.y += ty;\n\n        if (!Point.isEmptyPoint(segment.point2) || update) {\n          segment.point2 = {\n            x: segment.bezierPoint2.x,\n            y: segment.bezierPoint2.y\n          };\n        }\n      }\n    }\n  };\n  /**\n   * dragTargetEnd method \\\n   *\n   * @returns { void }     dragTargetEnd method .\\\n   * @param {ConnectorModel} obj - provide the obj value.\n   * @param {number} tx - provide the tx value.\n   * @param {number} ty - provide the ty value.\n   * @param {boolean} preventUpdate - provide the preventUpdate value.\n   * @param {PointModel} point - provide the point value.\n   * @param {string} endPoint - provide the endPoint value.\n   * @param {boolean} update - provide the update value.\n   * @param {OrthogonalSegmentModel | BezierSegmentModel | StraightSegmentModel} segment - provide the segment value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.dragTargetEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, segment) {\n    var connector = this.diagram.nameTable[obj.id];\n    var oldChanges;\n    var boundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);\n\n    if (canDragTargetEnd(connector) && endPoint !== 'BezierTargetThumb' && boundaryConstraints && canPageEditable(this.diagram)) {\n      oldChanges = {\n        targetPoint: connector.targetPoint\n      };\n      connector.targetPoint.x += tx;\n      connector.targetPoint.y += ty;\n\n      if (endPoint === 'ConnectorTargetEnd' && connector.type === 'Orthogonal' && connector.segments && connector.segments.length > 0) {\n        var prev = connector.segments[connector.segments.length - 2];\n\n        if (prev && connector.segments[connector.segments.length - 1].points.length === 2) {\n          if (prev.direction === 'Left' || prev.direction === 'Right') {\n            prev.points[prev.points.length - 1].x = connector.targetPoint.x;\n          } else {\n            prev.points[prev.points.length - 1].y = connector.targetPoint.y;\n          }\n\n          prev.length = Point.distancePoints(prev.points[0], prev.points[prev.points.length - 1]);\n          prev.direction = Point.direction(prev.points[0], prev.points[prev.points.length - 1]);\n        }\n      }\n\n      if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n        this.updatePathElementOffset(connector);\n      }\n    }\n\n    if (connector.type === 'Bezier') {\n      oldChanges = {\n        targetPoint: connector.targetPoint\n      };\n\n      if (segment) {\n        this.translateBezierPoints(obj, endPoint === '' ? 'ConnectorTargetEnd' : endPoint, tx, ty, segment, point, !update);\n      } else {\n        for (var i = 0; i < obj.segments.length; i++) {\n          this.translateBezierPoints(obj, endPoint === '' ? 'ConnectorTargetEnd' : endPoint, tx, ty, obj.segments[i], point, !update);\n        }\n      }\n    }\n\n    if (!preventUpdate) {\n      this.updateEndPoint(connector, oldChanges);\n    }\n\n    if (!(this.diagram.realActions & RealAction.AnimationClick)) {\n      this.diagram.refreshCanvasLayers();\n    }\n\n    return boundaryConstraints;\n  };\n  /**\n   * dragControlPoint method \\\n   *\n   * @returns { void }     dragControlPoint method .\\\n   * @param {ConnectorModel} obj - provide the obj value.\n   * @param {number} tx - provide the tx value.\n   * @param {number} ty - provide the ty value.\n   * @param {boolean} preventUpdate - provide the preventUpdate value.\n   * @param {number} segmentNumber - provide the segmentNumber value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.dragControlPoint = function (obj, tx, ty, preventUpdate, segmentNumber) {\n    var connector = this.diagram.nameTable[obj.id];\n\n    if ((connector.type === 'Straight' || connector.type === 'Bezier') && connector.segments.length > 0) {\n      if (segmentNumber !== undefined && connector.segments[segmentNumber]) {\n        connector.segments[segmentNumber].point.x += tx;\n        connector.segments[segmentNumber].point.y += ty;\n      } else {\n        for (var i = 0; i < connector.segments.length - 1; i++) {\n          connector.segments[i].point.x += tx;\n          connector.segments[i].point.y += ty;\n        }\n      }\n\n      if (!preventUpdate) {\n        this.updateEndPoint(connector);\n      }\n    }\n\n    return true;\n  };\n  /**\n   * rotatePropertyChnage method \\\n   *\n   * @returns { void }     rotatePropertyChnage method .\\\n   * @param {number} angle - provide the obj value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.rotatePropertyChnage = function (angle) {\n    var selectedItems = this.diagram.selectedItems;\n    var objects = [];\n    objects = objects.concat(selectedItems.nodes);\n    objects = objects.concat(selectedItems.connectors);\n    var pivotValue = {\n      x: selectedItems.offsetX,\n      y: selectedItems.offsetY\n    };\n    this.rotateObjects(selectedItems, objects, angle - selectedItems.rotateAngle, pivotValue);\n    selectedItems.wrapper.rotateAngle = selectedItems.rotateAngle = angle;\n    this.diagram.updateSelector();\n  };\n  /**\n   * rotateObjects method \\\n   *\n   * @returns { void }     rotateObjects method .\\\n   * @param {NodeModel | SelectorModel} parent - provide the parent value.\n   * @param {(NodeModel | ConnectorModel)[]} objects - provide the objects value.\n   * @param {number} angle - provide the angle value.\n   * @param {PointModel} pivot - provide the pivot value.\n   * @param {boolean} includeParent - provide the includeParent value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.rotateObjects = function (parent, objects, angle, pivot, includeParent) {\n    pivot = pivot || {};\n    var matrix = identityMatrix();\n    rotateMatrix(matrix, angle, pivot.x, pivot.y);\n    var oldValues;\n\n    for (var _i = 0, objects_2 = objects; _i < objects_2.length; _i++) {\n      var obj = objects_2[_i];\n\n      if (obj instanceof Node) {\n        if (canRotate(obj) && canPageEditable(this.diagram)) {\n          if (includeParent !== false || parent !== obj) {\n            oldValues = {\n              rotateAngle: obj.rotateAngle\n            };\n            obj.rotateAngle += angle;\n            obj.rotateAngle = (obj.rotateAngle + 360) % 360;\n            var newOffset = transformPointByMatrix(matrix, {\n              x: obj.offsetX,\n              y: obj.offsetY\n            });\n            obj.offsetX = newOffset.x;\n            obj.offsetY = newOffset.y;\n            this.diagram.nodePropertyChange(obj, {}, {\n              offsetX: obj.offsetX,\n              offsetY: obj.offsetY,\n              rotateAngle: obj.rotateAngle\n            });\n          }\n\n          if (obj.processId) {\n            var parent_3 = this.diagram.nameTable[obj.processId];\n            var bound = this.diagram.bpmnModule.getChildrenBound(parent_3, obj.id, this.diagram);\n            this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);\n          }\n\n          if (obj.children && obj.children.length && !obj.container) {\n            this.getChildren(obj, objects);\n          }\n        }\n      } else {\n        this.rotatePoints(obj, angle, pivot || {\n          x: obj.wrapper.offsetX,\n          y: obj.wrapper.offsetY\n        });\n      }\n\n      this.diagram.updateDiagramObject(obj);\n    }\n\n    this.diagram.refreshCanvasLayers();\n    this.diagram.updateSelector();\n  };\n  /**\n   * snapConnectorEnd method \\\n   *\n   * @returns { PointModel }     snapConnectorEnd method .\\\n   * @param {PointModel} currentPosition - provide the parent value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.snapConnectorEnd = function (currentPosition) {\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines && this.snappingModule) {\n      this.diagram.snappingModule.snapConnectorEnd(currentPosition);\n    }\n\n    return currentPosition;\n  };\n  /**\n   * snapAngle method \\\n   *\n   * @returns { number }     snapAngle method .\\\n   * @param {number} angle - provide the parent value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.snapAngle = function (angle) {\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines && this.snappingModule) {\n      return this.snappingModule.snapAngle(this.diagram, angle);\n    } else {\n      return 0;\n    }\n  };\n  /**\n   * rotatePoints method \\\n   *\n   * @returns { number }     rotatePoints method .\\\n   * @param {Connector} conn - provide the parent value.\n   * @param {number} angle - provide the parent value.\n   * @param {PointModel} pivot - provide the parent value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.rotatePoints = function (conn, angle, pivot) {\n    if (!conn.sourceWrapper || !conn.targetWrapper) {\n      var matrix = identityMatrix();\n      rotateMatrix(matrix, angle, pivot.x, pivot.y);\n      conn.sourcePoint = transformPointByMatrix(matrix, conn.sourcePoint);\n      conn.targetPoint = transformPointByMatrix(matrix, conn.targetPoint);\n\n      if (conn.shape.type === 'Bpmn' && conn.shape.sequence === 'Default') {\n        this.updatePathElementOffset(conn);\n      }\n\n      var newProp = {\n        sourcePoint: conn.sourcePoint,\n        targetPoint: conn.targetPoint\n      };\n      this.diagram.connectorPropertyChange(conn, {}, newProp);\n\n      if (conn.segments && conn.segments.length > 0) {\n        this.diagram.protectPropertyChange(true);\n        var connector = conn;\n        connector.segments = [];\n        this.diagram.connectorPropertyChange(connector, {}, {\n          segments: connector.segments\n        });\n        this.diagram.protectPropertyChange(false);\n      }\n    }\n  };\n\n  CommandHandler.prototype.updateInnerParentProperties = function (tempNode) {\n    var elements = [];\n    var protect = 'isProtectedOnChange';\n    var protectChange = this.diagram[protect];\n    this.diagram.protectPropertyChange(true);\n    var innerParents = this.getAllDescendants(tempNode, elements, false, true);\n\n    for (var i = 0; i < innerParents.length; i++) {\n      var obj = this.diagram.nameTable[innerParents[i].id];\n      obj.offsetX = obj.wrapper.offsetX;\n      obj.offsetY = obj.wrapper.offsetY;\n      obj.width = obj.wrapper.width;\n      obj.height = obj.wrapper.height;\n    }\n\n    this.diagram.protectPropertyChange(protectChange);\n  };\n  /**\n   * scale method \\\n   *\n   * @returns { boolean }     scale method .\\\n   * @param {NodeModel | ConnectorModel} obj - provide the parent value.\n   * @param {number} sw - provide the parent value.\n   * @param {number} sh - provide the parent value.\n   * @param {number} pivot - provide the parent value.\n   * @param {number} refObject - provide the parent value.\n   * @param {boolean} isOutsideBoundary - provide the parent value.\n   *\n   * @private\n   */\n  // eslint-disable-next-line max-len\n\n\n  CommandHandler.prototype.scale = function (obj, sw, sh, pivot, refObject, isOutsideBoundary) {\n    var node = this.diagram.nameTable[obj.id];\n    var tempNode = node;\n    var elements = [];\n    var element = node.wrapper;\n\n    if (!refObject) {\n      refObject = obj;\n    }\n\n    var refWrapper = refObject.wrapper;\n    var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;\n    var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;\n    var refPoint = getPoint(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);\n\n    if (element.actualSize.width !== undefined && element.actualSize.height !== undefined && canPageEditable(this.diagram)) {\n      if (tempNode.children && !tempNode.container) {\n        var nodes = this.getAllDescendants(tempNode, elements);\n\n        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n          var temp = nodes_1[_i];\n          this.scaleObject(sw, sh, refPoint, temp, element, refObject);\n        }\n\n        obj.wrapper.measure(new Size());\n        obj.wrapper.arrange(obj.wrapper.desiredSize);\n        this.diagram.updateGroupOffset(node);\n        this.updateInnerParentProperties(tempNode);\n      } else {\n        this.scaleObject(sw, sh, refPoint, node, element, refObject);\n      }\n\n      var bounds = getBounds(obj.wrapper);\n      var checkBoundaryConstraints = this.checkBoundaryConstraints(undefined, undefined, bounds);\n\n      if (!checkBoundaryConstraints && isOutsideBoundary) {\n        this.scale(obj, 1 / sw, 1 / sh, pivot, undefined, true);\n        return false;\n      }\n\n      this.diagram.updateDiagramObject(obj);\n    }\n\n    return true;\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.getAllDescendants = function (node, nodes, includeParent, innerParent) {\n    var temp = node;\n    var parentNodes = [];\n\n    for (var i = 0; i < temp.children.length; i++) {\n      node = this.diagram.nameTable[temp.children[i]];\n\n      if (node) {\n        if (!node.children) {\n          nodes.push(node);\n        } else {\n          if (includeParent) {\n            nodes.push(node);\n          }\n\n          if (innerParent) {\n            parentNodes.push(node);\n          }\n\n          nodes = this.getAllDescendants(node, nodes);\n        }\n      }\n    }\n\n    return innerParent ? parentNodes : nodes;\n  };\n  /**\n   * getChildren method \\\n   *\n   * @returns { (NodeModel | ConnectorModel)[]): (NodeModel | ConnectorModel)[] }     getChildren method .\\\n   * @param {NodeModel} node - provide the sw value.\n   * @param {(NodeModel | ConnectorModel)[]} nodes - provide the sw value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.getChildren = function (node, nodes) {\n    var temp = node;\n\n    if (node.children) {\n      for (var i = 0; i < temp.children.length; i++) {\n        node = this.diagram.nameTable[temp.children[i]];\n        nodes.push(node);\n      }\n    }\n\n    return nodes;\n  };\n  /**\n   * scaleObject method \\\n   *\n   * @returns { NodeModel }     scaleObject method .\\\n   * @param {string} id - provide the sw value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.cloneChild = function (id) {\n    var node = this.diagram.nameTable[id];\n    return node;\n  };\n  /**\n   * scaleObject method \\\n   *\n   * @returns { void }     scaleObject method .\\\n   * @param {End} sw - provide the sw value.\n   * @param {End} sh - provide the sh value.\n   * @param {PointModel} pivot - provide the pivot value.\n   * @param {IElement} obj - provide the pivot value.\n   * @param {DiagramElement} element - provide the element value.\n   * @param {IElement} refObject - provide the refObject value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.scaleObject = function (sw, sh, pivot, obj, element, refObject, canUpdate) {\n    sw = sw < 0 ? 1 : sw;\n    sh = sh < 0 ? 1 : sh;\n    var oldValues = {};\n\n    if (sw !== 1 || sh !== 1) {\n      var width = void 0;\n      var height = void 0;\n\n      if (obj instanceof Node) {\n        var node = obj;\n        var isResize = void 0;\n        var bound = void 0;\n        oldValues = {\n          width: obj.wrapper.actualSize.width,\n          height: obj.wrapper.actualSize.height,\n          offsetX: obj.wrapper.offsetX,\n          offsetY: obj.wrapper.offsetY,\n          margin: {\n            top: node.margin.top,\n            left: node.margin.left\n          }\n        };\n\n        if (node.shape.type === 'Bpmn' && node.shape.activity.subProcess.processes && node.shape.activity.subProcess.processes.length > 0) {\n          bound = this.diagram.bpmnModule.getChildrenBound(node, node.id, this.diagram);\n          isResize = node.wrapper.bounds.containsRect(bound);\n        }\n\n        width = node.wrapper.actualSize.width * sw;\n        height = node.wrapper.actualSize.height * sh;\n\n        if (node.maxWidth !== undefined && node.maxWidth !== 0) {\n          width = Math.min(node.maxWidth, width);\n        }\n\n        if (node.minWidth !== undefined && node.minWidth !== 0) {\n          width = Math.max(node.minWidth, width);\n        }\n\n        if (node.maxHeight !== undefined && node.maxHeight !== 0) {\n          height = Math.min(node.maxHeight, height);\n        }\n\n        if (node.minHeight !== undefined && node.minHeight !== 0) {\n          height = Math.max(node.minHeight, height);\n        }\n\n        if (isResize) {\n          width = Math.max(width, bound.right - node.wrapper.bounds.x);\n          height = Math.max(height, bound.bottom - node.wrapper.bounds.y);\n        }\n\n        sw = width / node.actualSize.width;\n        sh = height / node.actualSize.height;\n      }\n\n      var matrix = identityMatrix(); // let refWrapper: DiagramElement;\n\n      if (!refObject) {\n        refObject = obj;\n      }\n\n      var refWrapper = refObject.wrapper;\n      rotateMatrix(matrix, -refWrapper.rotateAngle, pivot.x, pivot.y);\n      scaleMatrix(matrix, sw, sh, pivot.x, pivot.y);\n      rotateMatrix(matrix, refWrapper.rotateAngle, pivot.x, pivot.y);\n\n      if (obj instanceof Node) {\n        var node = obj; //let left: number; let top: number;\n\n        var newPosition = transformPointByMatrix(matrix, {\n          x: node.wrapper.offsetX,\n          y: node.wrapper.offsetY\n        });\n        var oldleft = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;\n        var oldtop = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;\n\n        if (width > 0) {\n          if (node.processId) {\n            var parent_4 = this.diagram.nameTable[node.processId];\n\n            if (!parent_4.maxWidth || node.margin.left + width < parent_4.maxWidth) {\n              node.width = width;\n              node.offsetX = newPosition.x;\n            }\n          } else {\n            node.width = width;\n            node.offsetX = newPosition.x;\n          }\n        }\n\n        if (height > 0) {\n          if (node.processId) {\n            var parent_5 = this.diagram.nameTable[node.processId];\n\n            if (!parent_5.maxHeight || node.margin.top + height < parent_5.maxHeight) {\n              node.height = height;\n              node.offsetY = newPosition.y;\n            }\n          } else {\n            node.height = height;\n            node.offsetY = newPosition.y;\n          }\n        }\n\n        var left = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;\n        var top_1 = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;\n        var parent_6 = this.diagram.nameTable[node.processId];\n\n        if (parent_6 && (node.margin.top + (top_1 - oldtop) <= 0 || node.margin.left + (left - oldleft) <= 0)) {\n          this.diagram.nodePropertyChange(obj, {}, {\n            margin: {\n              top: node.margin.top,\n              left: node.margin.left\n            }\n          });\n        } else {\n          if (checkParentAsContainer(this.diagram, obj, true)) {\n            checkChildNodeInContainer(this.diagram, obj);\n          } else {\n            if (!canUpdate) {\n              this.diagram.nodePropertyChange(obj, oldValues, {\n                width: node.width,\n                height: node.height,\n                offsetX: node.offsetX,\n                offsetY: node.offsetY,\n                margin: {\n                  top: node.margin.top + (top_1 - oldtop),\n                  left: node.margin.left + (left - oldleft)\n                }\n              });\n            }\n          }\n        }\n      } else {\n        var connector = obj;\n        var oldValues_1 = {\n          sourcePoint: connector.sourcePoint,\n          targetPoint: connector.targetPoint\n        };\n\n        if (!connector.sourceWrapper || !connector.targetWrapper) {\n          this.scaleConnector(connector, matrix, oldValues_1, sw, sh, pivot);\n        }\n      }\n\n      var parentNode = this.diagram.nameTable[obj.processId];\n\n      if (parentNode) {\n        var parent_7 = parentNode.wrapper.bounds;\n        var child = obj.wrapper.bounds;\n        var bound = this.diagram.bpmnModule.getChildrenBound(parentNode, obj.id, this.diagram);\n        this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);\n      }\n    }\n  };\n\n  CommandHandler.prototype.scaleConnector = function (connector, matrix, oldValues, sw, sh, pivot) {\n    connector.sourcePoint = transformPointByMatrix(matrix, connector.sourcePoint);\n    connector.targetPoint = transformPointByMatrix(matrix, connector.targetPoint);\n\n    if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n      this.updatePathElementOffset(connector);\n    }\n\n    var newProp = {\n      sourcePoint: connector.sourcePoint,\n      targetPoint: connector.targetPoint\n    };\n    this.diagram.connectorPropertyChange(connector, oldValues, newProp);\n    var selector = this.diagram.selectedItems;\n\n    if (selectionHasConnector(this.diagram, selector)) {\n      var clonedSelectedItems = cloneObject(this.diagram.selectedItems);\n      var nodeModel = {\n        offsetX: clonedSelectedItems.offsetX,\n        offsetY: clonedSelectedItems.offsetY,\n        height: clonedSelectedItems.height,\n        width: clonedSelectedItems.width,\n        rotateAngle: clonedSelectedItems.rotateAngle\n      };\n      var obj = new Node(this.diagram, 'nodes', nodeModel, true);\n      obj.wrapper = clonedSelectedItems.wrapper;\n      obj.wrapper.rotateAngle = selector.rotateAngle;\n      this.scaleObject(sw, sh, pivot, obj, obj.wrapper, obj, true);\n      selector.wrapper.actualSize.width = obj.width;\n      selector.wrapper.actualSize.height = obj.height;\n      selector.wrapper.offsetX = obj.offsetX;\n      selector.wrapper.offsetY = obj.offsetY;\n      var child = this.diagram.selectedItems.connectors[0];\n\n      if (child.id !== connector.id) {\n        this.measureSelector(selector);\n      }\n    }\n  };\n\n  CommandHandler.prototype.measureSelector = function (selector) {\n    var desiredBounds = undefined; //Measuring the children\n\n    var clonedSelectedItems = cloneObject(this.diagram.selectedItems);\n    var objects = [];\n    var bounds;\n    objects = clonedSelectedItems.connectors;\n    var pivot = {\n      x: this.diagram.selectedItems.offsetX,\n      y: this.diagram.selectedItems.offsetY\n    };\n\n    for (var i = 0; i < objects.length; i++) {\n      var matrix_1 = identityMatrix();\n      rotateMatrix(matrix_1, -selector.rotateAngle, pivot.x, pivot.y);\n      objects[i].sourcePoint = transformPointByMatrix(matrix_1, objects[i].sourcePoint);\n      objects[i].targetPoint = transformPointByMatrix(matrix_1, objects[i].targetPoint);\n      var p1 = {\n        x: objects[i].sourcePoint.x,\n        y: objects[i].sourcePoint.y\n      };\n      var p2 = {\n        x: objects[i].targetPoint.x,\n        y: objects[i].targetPoint.y\n      };\n      bounds = this.calculateBounds(p1, p2);\n\n      if (desiredBounds === undefined) {\n        desiredBounds = bounds;\n      } else {\n        desiredBounds.uniteRect(bounds);\n      }\n    }\n\n    var offsetPt = {};\n\n    if (desiredBounds !== undefined) {\n      offsetPt = {\n        x: desiredBounds.x + desiredBounds.width * selector.wrapper.pivot.x,\n        y: desiredBounds.y + desiredBounds.height * selector.wrapper.pivot.y\n      };\n    }\n\n    var nodeModel = {\n      offsetX: offsetPt.x,\n      offsetY: offsetPt.y,\n      height: desiredBounds.height,\n      width: desiredBounds.width,\n      rotateAngle: 0\n    };\n    var obj = new Node(this.diagram, 'nodes', nodeModel, true);\n    var matrix = identityMatrix();\n    rotateMatrix(matrix, selector.rotateAngle, pivot.x, pivot.y);\n    obj.rotateAngle += selector.rotateAngle;\n    obj.rotateAngle = (obj.rotateAngle + 360) % 360;\n    var newOffset = transformPointByMatrix(matrix, {\n      x: obj.offsetX,\n      y: obj.offsetY\n    });\n    obj.offsetX = newOffset.x;\n    obj.offsetY = newOffset.y;\n    selector.wrapper.actualSize.width = desiredBounds.width;\n    selector.wrapper.actualSize.height = desiredBounds.height;\n    selector.wrapper.offsetX = obj.offsetX;\n    selector.wrapper.offsetY = obj.offsetY;\n    var selectorEle = getSelectorElement(this.diagram.element.id);\n    this.diagram.diagramRenderer.renderResizeHandle(selector.wrapper, selectorEle, selector.thumbsConstraints, this.diagram.scroller.currentZoom, selector.constraints, this.diagram.scroller.transform, false, canMove(selector));\n  };\n\n  CommandHandler.prototype.calculateBounds = function (p1, p2) {\n    var left = Math.min(p1.x, p2.x);\n    var right = Math.max(p1.x, p2.x);\n    var top = Math.min(p1.y, p2.y);\n    var bottom = Math.max(p1.y, p2.y);\n    var width = right - left;\n    var height = bottom - top;\n    var rect = new Rect(left, top, width, height);\n    return rect;\n  };\n  /**\n   * portDrag method \\\n   *\n   * @returns { void }     portDrag method .\\\n   * @param { NodeModel | ConnectorModel} obj - provide the obj value.\n   * @param {DiagramElement} portElement - provide the portElement value.\n   * @param {number} tx - provide the tx value.\n   * @param {number} ty - provide the tx value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.portDrag = function (obj, portElement, tx, ty) {\n    var oldValues;\n    var changedvalues;\n    var port = this.findTarget(portElement, obj);\n    var bounds = getBounds(obj.wrapper);\n\n    if (port && canDrag(port, this.diagram)) {\n      oldValues = this.getPortChanges(obj, port);\n      port.offset.x += tx / bounds.width;\n      port.offset.y += ty / bounds.height;\n      changedvalues = this.getPortChanges(obj, port);\n      this.diagram.nodePropertyChange(obj, oldValues, changedvalues);\n      this.diagram.updateDiagramObject(obj);\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.labelDrag = function (obj, textElement, tx, ty) {\n    //let changedvalues: Object;\n    //let label: ShapeAnnotationModel | PathAnnotationModel;\n    // eslint-disable-next-line max-len\n    var label = this.findTarget(textElement, obj);\n    var bounds = cornersPointsBeforeRotation(obj.wrapper);\n    var oldValues = this.getAnnotationChanges(obj, label);\n\n    if (label instanceof ShapeAnnotation) {\n      label.offset.x += tx / bounds.width;\n      label.offset.y += ty / bounds.height;\n    } else {\n      this.updatePathAnnotationOffset(obj, label, tx, ty);\n\n      if (label instanceof PathAnnotation) {\n        label.alignment = 'Center';\n      }\n    }\n\n    var changedvalues = this.getAnnotationChanges(obj, label);\n\n    if (obj instanceof Node) {\n      this.diagram.nodePropertyChange(obj, oldValues, changedvalues);\n    } else {\n      this.diagram.connectorPropertyChange(obj, oldValues, changedvalues);\n    }\n\n    this.diagram.updateDiagramObject(obj);\n\n    if (!isSelected(this.diagram, label, false, textElement)) {\n      this.labelSelect(obj, textElement);\n    }\n  };\n\n  CommandHandler.prototype.updatePathAnnotationOffset = function (object, label, tx, ty, newPosition, size) {\n    var textWrapper = this.diagram.getWrapper(object.wrapper, label.id);\n    var offsetX = textWrapper.offsetX;\n    var offsetY = textWrapper.offsetY;\n    var offset;\n    var intermediatePoints = object.intermediatePoints;\n    var prev;\n    var pointLength = 0;\n    var totalLength = 0;\n    var intersectingOffset;\n    var currentPosition = newPosition ? newPosition : {\n      x: offsetX + tx,\n      y: offsetY + ty\n    };\n    var intersetingPts = this.getInterceptWithSegment(currentPosition, intermediatePoints);\n    var newOffset = intermediatePoints[intermediatePoints.length - 1];\n    totalLength = Point.getLengthFromListOfPoints(intermediatePoints);\n\n    if (intersetingPts.length > 0) {\n      if (label.dragLimit.top || label.dragLimit.bottom || label.dragLimit.left || label.dragLimit.right) {\n        var minDistance = {\n          minDistance: null\n        };\n        newOffset = this.getRelativeOffset(currentPosition, intermediatePoints, minDistance);\n        var distance = {\n          minDistance: null\n        };\n        intersectingOffset = this.getRelativeOffset(currentPosition, intersetingPts, distance);\n\n        if (minDistance != null && distance.minDistance < minDistance.minDistance) {\n          newOffset = intersectingOffset;\n        } else {\n          var connectorOffset = getOffsetOfConnector(object.intermediatePoints, label);\n          newOffset = connectorOffset.point;\n        }\n      } else {\n        intersectingOffset = intersetingPts[intersetingPts.length - 1];\n        newOffset = intersectingOffset;\n      }\n\n      if (newOffset) {\n        var p = void 0;\n        var bounds = void 0;\n\n        for (p = 0; p < intermediatePoints.length; p++) {\n          if (prev != null) {\n            bounds = Rect.toBounds([prev, intermediatePoints[p]]);\n\n            if (bounds.containsPoint(newOffset)) {\n              pointLength += Point.findLength(prev, newOffset);\n              break;\n            } else {\n              pointLength += Point.findLength(prev, intermediatePoints[p]);\n            }\n          }\n\n          prev = intermediatePoints[p];\n        }\n\n        offset = {\n          x: pointLength / totalLength,\n          y: 0\n        };\n      }\n\n      this.updateLabelMargin(object, label, offset, currentPosition, size, tx, ty);\n    } else {\n      this.updateLabelMargin(object, label, null, currentPosition, size, tx, ty);\n    }\n  };\n\n  CommandHandler.prototype.getRelativeOffset = function (currentPosition, points, minDistance) {\n    var newOffset;\n    var distance;\n    var pt;\n    var i;\n\n    for (i = 0; i < points.length; i++) {\n      pt = points[i];\n      distance = Math.round(Math.sqrt(Math.pow(currentPosition.x - pt.x, 2) + Math.pow(currentPosition.y - pt.y, 2)));\n\n      if (minDistance.minDistance === null || Math.min(Math.abs(minDistance.minDistance), Math.abs(distance)) === Math.abs(distance)) {\n        newOffset = pt;\n        minDistance.minDistance = distance;\n      }\n    }\n\n    return newOffset;\n  };\n\n  CommandHandler.prototype.dragLimitValue = function (label, point, tempPt, contentDimension) {\n    var x = false;\n    var y = false;\n\n    if (tempPt.x >= point.x - label.dragLimit.left - contentDimension.width / 2 && tempPt.x <= point.x + label.dragLimit.right + contentDimension.width / 2) {\n      x = true;\n    }\n\n    if (tempPt.y >= point.y - label.dragLimit.top - contentDimension.height / 2 && tempPt.y <= point.y + label.dragLimit.bottom + contentDimension.height / 2) {\n      y = true;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /* eslint-disable */\n\n\n  CommandHandler.prototype.updateLabelMargin = function (node, label, offset, tempPt, size, tx, ty) {\n    offset = offset ? offset : {\n      x: label.offset,\n      y: 0\n    };\n\n    if (label && offset && offset.x > 0 && offset.x < 1) {\n      //let point: PointModel;\n      var length_2 = Point.getLengthFromListOfPoints(node.intermediatePoints);\n      var point = this.getPointAtLength(length_2 * offset.x, node.intermediatePoints, 0);\n      var curZoomfactor = this.diagram.scrollSettings.currentZoom;\n      var dragLimit = label.dragLimit;\n\n      if (dragLimit.top || dragLimit.bottom || dragLimit.left || dragLimit.right) {\n        var labelBounds = this.diagram.getWrapper(node.wrapper, label.id);\n        var contentDimension = new Rect(0, 0, 0, 0);\n        var annotationWrtapper = this.diagram.getWrapper(node.wrapper, label.id);\n        contentDimension.x = annotationWrtapper.offsetX / curZoomfactor + tx;\n        contentDimension.y = annotationWrtapper.offsetY / curZoomfactor + ty;\n        contentDimension.width = annotationWrtapper.bounds.width / curZoomfactor;\n        contentDimension.height = annotationWrtapper.bounds.height / curZoomfactor;\n        var draggableBounds = new Rect(point.x - (dragLimit.left || 0) - contentDimension.width / 2, point.y - (dragLimit.top || 0) - contentDimension.height / 2, (dragLimit.left || 0) + (dragLimit.right || 0) + contentDimension.width, (dragLimit.top || 0) + (dragLimit.bottom || 0) + contentDimension.height);\n\n        if (draggableBounds.containsPoint(tempPt)) {\n          tempPt = tempPt;\n        } else {\n          var lineIntersects = void 0;\n          var line1 = [point, tempPt];\n          lineIntersects = this.boundsInterSects(line1, draggableBounds, false);\n\n          for (var _i = 0, lineIntersects_1 = lineIntersects; _i < lineIntersects_1.length; _i++) {\n            var i = lineIntersects_1[_i];\n            var ptt = i;\n            tempPt = ptt;\n          }\n        }\n\n        var cursorLimit = this.dragLimitValue(label, point, tempPt, contentDimension);\n        label.margin = {\n          left: cursorLimit.x ? tempPt.x - point.x : label.margin.left,\n          top: cursorLimit.y ? tempPt.y - point.y : label.margin.top,\n          right: 0,\n          bottom: 0\n        };\n      } else {\n        label.margin = {\n          left: tempPt.x - point.x,\n          top: tempPt.y - point.y,\n          right: 0,\n          bottom: 0\n        };\n      }\n\n      label.offset = offset.x;\n\n      if (size) {\n        label.width = size.width;\n        label.height = size.height;\n      }\n    }\n  };\n\n  CommandHandler.prototype.boundsInterSects = function (polyLine, bounds, self) {\n    var intersects;\n\n    if (bounds) {\n      var polyLine2 = [{\n        x: bounds.x,\n        y: bounds.y\n      }, {\n        x: bounds.x + bounds.width,\n        y: bounds.y\n      }, {\n        x: bounds.x + bounds.width,\n        y: bounds.y + bounds.height\n      }, {\n        x: bounds.x,\n        y: bounds.y + bounds.height\n      }, {\n        x: bounds.x,\n        y: bounds.y\n      }];\n      intersects = this.intersect(polyLine, polyLine2, self);\n    }\n\n    return intersects;\n  };\n\n  CommandHandler.prototype.intersect = function (polyLine1, polyLine2, self) {\n    var intersect = [];\n\n    for (var i = 0; i < polyLine1.length - 1; i++) {\n      for (var j = 0; j < polyLine2.length - 1; j++) {\n        var p = intersect2(polyLine1[i], polyLine1[i + 1], polyLine2[j], polyLine2[j + 1]);\n\n        if (p.x !== 0 && p.y !== 0) {\n          intersect.push(p);\n        }\n      }\n    }\n\n    return intersect;\n  };\n\n  CommandHandler.prototype.getPointAtLength = function (length, points, angle) {\n    angle = 0;\n    var run = 0;\n    var pre;\n    var found = {\n      x: 0,\n      y: 0\n    };\n    var pt;\n\n    for (var i = 0; i < points.length; i++) {\n      pt = points[i];\n\n      if (!pre) {\n        pre = pt;\n        continue;\n      } else {\n        var l = Point.findLength(pre, pt);\n        var r = void 0;\n        var deg = void 0;\n        var x = void 0;\n        var y = void 0;\n\n        if (run + l >= length) {\n          r = length - run;\n          deg = Point.findAngle(pre, pt);\n          x = r * Math.cos(deg * Math.PI / 180);\n          y = r * Math.sin(deg * Math.PI / 180);\n          found = {\n            x: pre.x + x,\n            y: pre.y + y\n          };\n          angle = deg;\n          break;\n        } else {\n          run += l;\n        }\n      }\n\n      pre = pt;\n    }\n\n    return found;\n  };\n\n  CommandHandler.prototype.getInterceptWithSegment = function (currentPosition, conPoints) {\n    var intercepts = [];\n    var imgLine = [];\n    var segemnt = [];\n    var tarAngle;\n    var srcAngle; //let maxLength: number;\n\n    var maxLength = Point.findLength({\n      x: 0,\n      y: 0\n    }, {\n      x: this.diagram.scroller.viewPortWidth,\n      y: this.diagram.scroller.viewPortHeight\n    });\n\n    for (var i = 1; i < conPoints.length; i++) {\n      segemnt = [conPoints[i - 1], conPoints[i]];\n      imgLine = [];\n      srcAngle = Math.round(Point.findAngle(segemnt[0], segemnt[1]) % 360);\n      tarAngle = Math.round(Point.findAngle(segemnt[1], segemnt[0]) % 360);\n      var angleAdd = srcAngle > 0 && srcAngle <= 90 || srcAngle > 180 && srcAngle <= 270 ? 90 : -90;\n      imgLine.push(Point.transform(currentPosition, srcAngle + angleAdd, maxLength));\n      imgLine.push(Point.transform(currentPosition, tarAngle + angleAdd, maxLength));\n      var lineUtil1 = {\n        x1: segemnt[0].x,\n        y1: segemnt[0].y,\n        x2: segemnt[1].x,\n        y2: segemnt[1].y\n      };\n      var lineUtil2 = {\n        x1: imgLine[0].x,\n        y1: imgLine[0].y,\n        x2: imgLine[1].x,\n        y2: imgLine[1].y\n      };\n      var line3 = intersect3(lineUtil1, lineUtil2);\n\n      if (line3.enabled) {\n        intercepts.push(line3.intersectPt);\n      }\n    }\n\n    return intercepts;\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.getAnnotationChanges = function (object, label) {\n    var index = findObjectIndex(object, label.id, true);\n    var annotations = {};\n    annotations[index] = {\n      width: label.width,\n      height: label.height,\n      offset: object instanceof Node ? {\n        x: label.offset.x,\n        y: label.offset.y\n      } : label.offset,\n      rotateAngle: label.rotateAngle,\n      margin: {\n        left: label.margin.left,\n        right: label.margin.right,\n        top: label.margin.top,\n        bottom: label.margin.bottom\n      },\n      horizontalAlignment: label.horizontalAlignment,\n      verticalAlignment: label.verticalAlignment,\n      alignment: object instanceof Connector ? label.alignment : undefined\n    };\n    return {\n      annotations: annotations\n    };\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.getPortChanges = function (object, port) {\n    var index = findObjectIndex(object, port.id, false);\n    var ports = {};\n    ports[index] = {\n      offset: port.offset\n    };\n    return {\n      ports: ports\n    };\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.labelRotate = function (object, label, currentPosition, selector) {\n    var oldValues;\n    var changedvalues;\n    oldValues = this.getAnnotationChanges(object, label);\n    var matrix = identityMatrix();\n    var rotateAngle = label.rotateAngle;\n    var labelWrapper = this.diagram.getWrapper(object.wrapper, label.id);\n    var angle = findAngle({\n      x: labelWrapper.offsetX,\n      y: labelWrapper.offsetY\n    }, currentPosition) + 90;\n    var snapAngle = this.snapAngle(angle);\n    angle = snapAngle !== 0 ? snapAngle : angle;\n\n    if (label instanceof PathAnnotation && label.segmentAngle) {\n      var getPointloop = getAnnotationPosition(object.intermediatePoints, label, object.wrapper.bounds);\n      angle -= getPointloop.angle;\n    }\n\n    angle = (angle + 360) % 360;\n    label.rotateAngle += angle - (label.rotateAngle + labelWrapper.parentTransform);\n    label.margin.bottom += labelWrapper.verticalAlignment === 'Top' ? -label.height / 2 : labelWrapper.verticalAlignment === 'Bottom' ? label.height / 2 : 0;\n    label.margin.right += labelWrapper.horizontalAlignment === 'Left' ? -label.width / 2 : labelWrapper.horizontalAlignment === 'Right' ? label.width / 2 : 0;\n\n    if (label instanceof PathAnnotation) {\n      label.alignment = 'Center';\n    } else {\n      label.horizontalAlignment = label.verticalAlignment = 'Center';\n    }\n\n    selector.wrapper.rotateAngle = selector.rotateAngle = label.rotateAngle;\n    changedvalues = this.getAnnotationChanges(object, label);\n\n    if (object instanceof Node) {\n      this.diagram.nodePropertyChange(object, oldValues, changedvalues);\n    } else {\n      this.diagram.connectorPropertyChange(object, oldValues, changedvalues);\n    }\n\n    this.diagram.updateDiagramObject(object);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.labelResize = function (node, label, deltaWidth, deltaHeight, pivot, selector) {\n    var oldValues;\n    var changedvalues;\n    var rotateAngle;\n    oldValues = this.getAnnotationChanges(node, label);\n    var textElement = selector.wrapper.children[0];\n\n    if (deltaWidth && deltaWidth !== 1 || deltaHeight && deltaHeight !== 1) {\n      var newMat = identityMatrix();\n      var matrix = identityMatrix();\n      rotateMatrix(newMat, -node.rotateAngle, node.offsetX, node.offsetY);\n      rotateAngle = (textElement.rotateAngle + (node instanceof Node ? node.rotateAngle : 0) + 360) % 360;\n      rotateMatrix(matrix, -rotateAngle, pivot.x, pivot.y);\n      scaleMatrix(matrix, deltaWidth, deltaHeight, pivot.x, pivot.y);\n      rotateMatrix(matrix, rotateAngle, pivot.x, pivot.y);\n      var newPosition = transformPointByMatrix(matrix, {\n        x: textElement.offsetX,\n        y: textElement.offsetY\n      });\n      var height = textElement.actualSize.height * deltaHeight;\n      var width = textElement.actualSize.width * deltaWidth;\n      var shape = this.findTarget(textElement, node);\n\n      if (shape instanceof PathAnnotation) {\n        this.updatePathAnnotationOffset(node, label, 0, 0, newPosition, new Size(width, height));\n      } else {\n        var bounds = cornersPointsBeforeRotation(node.wrapper);\n        newPosition = transformPointByMatrix(newMat, newPosition);\n        newPosition.x = newPosition.x - textElement.margin.left + textElement.margin.right;\n        newPosition.y = newPosition.y - textElement.margin.top + textElement.margin.bottom;\n        newPosition.y += shape.verticalAlignment === 'Top' ? -height / 2 : shape.verticalAlignment === 'Bottom' ? height / 2 : 0;\n        newPosition.x += shape.horizontalAlignment === 'Left' ? -width / 2 : shape.horizontalAlignment === 'Right' ? width / 2 : 0;\n        var offsetx = bounds.width / (newPosition.x - bounds.x);\n        var offsety = bounds.height / (newPosition.y - bounds.y);\n\n        if (width > 1) {\n          shape.width = width;\n          shape.offset.x = 1 / offsetx;\n        }\n\n        if (height > 1) {\n          shape.height = height;\n          shape.offset.y = 1 / offsety;\n        }\n      }\n    }\n\n    if (label instanceof PathAnnotation) {\n      label.alignment = 'Center';\n    }\n\n    changedvalues = this.getAnnotationChanges(node, label);\n\n    if (node instanceof Node) {\n      this.diagram.nodePropertyChange(node, oldValues, changedvalues);\n    } else {\n      this.diagram.connectorPropertyChange(node, oldValues, changedvalues);\n    }\n\n    this.diagram.updateDiagramObject(node);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.getSubProcess = function (source) {\n    var selector = {\n      nodes: [],\n      connectors: []\n    };\n    var process;\n\n    if (source instanceof Node) {\n      process = source.processId;\n    } else if (source && source.nodes && source.nodes.length && source.nodes[0].processId) {\n      process = source.nodes[0].processId;\n    }\n\n    if (process) {\n      selector.nodes.push(clone(this.diagram.nameTable[process]));\n      return selector;\n    }\n\n    return selector;\n  };\n  /**   @private  */\n\n\n  CommandHandler.prototype.checkBoundaryConstraints = function (tx, ty, nodeBounds) {\n    var pageSettings = this.diagram.pageSettings;\n    var boundaryConstraints = this.diagram.pageSettings.boundaryConstraints;\n    var scroller = this.diagram.scroller;\n\n    if (boundaryConstraints === 'Page' || boundaryConstraints === 'Diagram') {\n      var selectorBounds = !nodeBounds ? this.diagram.selectedItems.wrapper.bounds : undefined;\n      var width = boundaryConstraints === 'Page' ? pageSettings.width : scroller.viewPortWidth;\n      var height = boundaryConstraints === 'Page' ? pageSettings.height : scroller.viewPortHeight;\n      var bounds = nodeBounds;\n      var right = (nodeBounds ? bounds.right : selectorBounds.right) + (tx || 0);\n      var left = (nodeBounds ? bounds.left : selectorBounds.left) + (tx || 0);\n      var top_2 = (nodeBounds ? bounds.top : selectorBounds.top) + (ty || 0);\n      var bottom = (nodeBounds ? bounds.bottom : selectorBounds.bottom) + (ty || 0);\n\n      if (right <= width && left >= 0 && bottom <= height && top_2 >= 0) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return true;\n  }; //interfaces\n\n  /** @private */\n\n\n  CommandHandler.prototype.dragSelectedObjects = function (tx, ty) {\n    var obj = this.diagram.selectedItems;\n\n    if (this.state && !this.state.backup) {\n      this.state.backup = {};\n      this.state.backup.offsetX = obj.offsetX;\n      this.state.backup.offsetY = obj.offsetY;\n    }\n\n    obj = renderContainerHelper(this.diagram, obj) || obj;\n\n    if (this.checkBoundaryConstraints(tx, ty)) {\n      this.diagram.diagramActions = this.diagram.diagramActions | (DiagramAction.PreventZIndexOnDragging | DiagramAction.DragUsingMouse);\n      var actualObject = this.diagram.selectedObject.actualObject;\n\n      if (actualObject && actualObject instanceof Node && actualObject.isLane && canLaneInterchange(actualObject, this.diagram) || !actualObject || !actualObject.isLane) {\n        this.diagram.drag(obj, tx, ty);\n      }\n\n      this.diagram.diagramActions = this.diagram.diagramActions & ~(DiagramAction.PreventZIndexOnDragging | DiagramAction.DragUsingMouse);\n      this.diagram.refreshCanvasLayers();\n      return true;\n    }\n\n    return false;\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.scaleSelectedItems = function (sx, sy, pivot) {\n    var obj = this.diagram.selectedItems;\n\n    if (this.state && !this.state.backup) {\n      this.state.backup = {};\n      this.state.backup.offsetX = obj.offsetX;\n      this.state.backup.offsetY = obj.offsetY;\n      this.state.backup.width = obj.width;\n      this.state.backup.height = obj.height;\n      this.state.backup.pivot = pivot;\n    }\n\n    obj = renderContainerHelper(this.diagram, obj) || obj;\n    return this.diagram.scale(obj, sx, sy, pivot);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.rotateSelectedItems = function (angle) {\n    var obj = this.diagram.selectedItems;\n\n    if (this.state && !this.state.backup) {\n      this.state.backup = {};\n      this.state.backup.angle = obj.rotateAngle;\n    }\n\n    obj = renderContainerHelper(this.diagram, obj) || obj;\n    return this.diagram.rotate(obj, angle);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.hasSelection = function () {\n    return hasSelection(this.diagram);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.isSelected = function (element) {\n    return isSelected(this.diagram, element);\n  };\n  /**\n   * initExpand is used for layout expand and collapse interaction\n   */\n\n\n  CommandHandler.prototype.initExpand = function (args) {\n    var propName = 'isProtectedOnChange';\n    var protectedChange = this.diagram[propName];\n    this.diagram.protectPropertyChange(true);\n    var node = args.target || args.source;\n    var oldValues = {\n      isExpanded: node.isExpanded\n    };\n    node.isExpanded = !node.isExpanded;\n    this.diagram.preventNodesUpdate = true;\n    this.diagram.diagramActions |= DiagramAction.PreventIconsUpdate;\n    this.diagram.nodePropertyChange(node, oldValues, {\n      isExpanded: node.isExpanded\n    });\n    this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.PreventIconsUpdate;\n    this.diagram.preventNodesUpdate = false;\n\n    for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n      var temp = _a[_i];\n      var view = this.diagram.views[temp];\n\n      if (!(view instanceof Diagram)) {\n        this.diagram.refreshCanvasDiagramLayer(view);\n      }\n    }\n\n    this.diagram.protectPropertyChange(protectedChange);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.expandNode = function (node, diagram, canLayout) {\n    var animation; //let objects: ILayout;\n\n    var preventNodesUpdate = this.diagram.preventNodesUpdate;\n    var expand = node.isExpanded;\n    this.diagram.preventNodesUpdate = true;\n    this.diagram.preventConnectorsUpdate = true;\n    this.expandCollapse(node, expand, this.diagram);\n    node.isExpanded = expand;\n    var fixedNode = this.diagram.layout.fixedNode;\n    this.diagram.layout.fixedNode = node.id;\n\n    if (this.diagram.diagramActions != DiagramAction.Render && this.diagram.layoutAnimateModule && this.diagram.layout.enableAnimation && this.diagram.organizationalChartModule) {\n      this.diagram.organizationalChartModule.isAnimation = true;\n    }\n\n    this.diagram.blazorActions |= BlazorAction.expandNode;\n    var objects = {};\n\n    if (!canLayout) {\n      objects = this.diagram.doLayout();\n    }\n\n    this.diagram.blazorActions &= ~BlazorAction.expandNode;\n    this.diagram.preventNodesUpdate = preventNodesUpdate;\n    this.diagram.preventConnectorsUpdate = false;\n\n    if (this.diagram.layoutAnimateModule && this.diagram.organizationalChartModule && !canLayout) {\n      this.diagram.allowServerDataBinding = false;\n      this.layoutAnimateModule.expand(this.diagram.layout.enableAnimation, objects, node, this.diagram);\n    } else {\n      var arg = {\n        element: cloneBlazorObject(clone(node)),\n        state: node.isExpanded ? true : false\n      };\n      this.triggerEvent(DiagramEvent.expandStateChange, arg);\n\n      if (this.diagram.lineRoutingModule && this.diagram.constraints & DiagramConstraints.LineRouting) {\n        this.diagram.resetSegments();\n      }\n    }\n\n    this.diagram.layout.fixedNode = fixedNode === '' ? '' : this.diagram.layout.fixedNode;\n    return objects;\n  };\n\n  CommandHandler.prototype.getparentexpand = function (target, diagram, visibility, connector) {\n    var boolean;\n\n    for (var i = 0; i < target.inEdges.length; i++) {\n      var newConnector = diagram.nameTable[target.inEdges[i]];\n      var previousNode = diagram.nameTable[newConnector.sourceID];\n\n      if (previousNode.isExpanded && !visibility && previousNode.id !== connector.sourceID && newConnector.visible) {\n        return false;\n      } else {\n        boolean = true;\n      }\n    }\n\n    return boolean;\n  };\n  /**\n   * Setinterval and Clear interval for layout animation\n   */\n\n  /** @private */\n\n\n  CommandHandler.prototype.expandCollapse = function (source, visibility, diagram) {\n    for (var i = 0; i < source.outEdges.length; i++) {\n      var connector = diagram.nameTable[source.outEdges[i]];\n      var target = diagram.nameTable[connector.targetID];\n      var value = this.getparentexpand(target, diagram, visibility, connector);\n      connector.visible = visibility;\n      var oldValues = {\n        visible: target.visible,\n        style: {\n          opacity: target.wrapper.style.opacity\n        }\n      };\n      var newValues = {\n        visible: target.visible,\n        style: {\n          opacity: target.wrapper.style.opacity\n        }\n      };\n\n      if (value) {\n        if (target.isExpanded) {\n          this.expandCollapse(target, visibility, diagram);\n        }\n\n        target.visible = visibility;\n        target.style.opacity = this.diagram.layoutAnimateModule && this.diagram.layout.enableAnimation && visibility ? 0.1 : target.style.opacity;\n        diagram.nodePropertyChange(target, oldValues, newValues);\n      }\n\n      diagram.connectorPropertyChange(connector, oldValues, newValues);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateNodeDimension = function (obj, rect) {\n    if (obj instanceof Node) {\n      obj.offsetX = rect.x + rect.width / 2;\n      obj.offsetY = rect.y + rect.height / 2;\n      obj.width = rect.width;\n      obj.height = rect.height;\n      obj.wrapper.children[0].canMeasurePath = true;\n      this.diagram.nodePropertyChange(obj, {}, {\n        width: rect.width,\n        height: rect.height,\n        offsetX: obj.offsetX,\n        offsetY: obj.offsetY\n      });\n\n      if (this.diagram.mode !== 'SVG') {\n        this.diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateConnectorPoints = function (obj, rect) {\n    if (obj instanceof Connector) {\n      this.diagram.connectorPropertyChange(obj, {}, {\n        targetPoint: obj.targetPoint\n      });\n      this.diagram.updateDiagramObject(obj);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateSelectedNodeProperties = function (object) {\n    if (this.diagram.lineRoutingModule && this.diagram.constraints & DiagramConstraints.LineRouting) {\n      var previousNodeObject = [];\n      var previousConnectorObject = [];\n      var updateNodeObject = [];\n      var updateConnectorObject = [];\n      var changeNodes = [];\n      var changeConnectors = [];\n      this.diagram.protectPropertyChange(true);\n      var objects = [];\n      var connectors = [];\n      var actualObject = this.diagram.selectedObject.actualObject;\n      var helperObject = this.diagram.selectedObject.helperObject;\n\n      if (helperObject && actualObject) {\n        var offsetX = helperObject.offsetX - actualObject.offsetX;\n        var offsetY = helperObject.offsetY - actualObject.offsetY;\n        var width = helperObject.width - actualObject.width;\n        var height = helperObject.height - actualObject.height;\n        var rotateAngle = helperObject.rotateAngle - actualObject.rotateAngle;\n\n        if (this.diagram.selectedItems.nodes.length + this.diagram.selectedItems.connectors.length > 0) {\n          this.diagram.selectedItems.wrapper.rotateAngle = this.diagram.selectedItems.rotateAngle = helperObject.rotateAngle;\n        }\n\n        if (actualObject instanceof Node && actualObject.shape.type !== 'SwimLane' && !actualObject.isLane && !actualObject.isPhase && !actualObject.isHeader) {\n          if (actualObject.offsetX !== actualObject.wrapper.offsetX || actualObject.offsetY !== actualObject.wrapper.offsetY || actualObject.width !== actualObject.wrapper.width || actualObject.height !== actualObject.wrapper.height || actualObject.rotateAngle !== actualObject.wrapper.rotateAngle) {\n            if (isBlazor()) {\n              previousNodeObject.push(cloneObject(actualObject, undefined, undefined, true));\n            }\n\n            actualObject.offsetX += offsetX;\n            actualObject.offsetY += offsetY;\n            actualObject.width += width;\n            actualObject.height += height;\n            actualObject.rotateAngle += rotateAngle;\n            this.diagram.nodePropertyChange(actualObject, {}, {\n              offsetX: actualObject.offsetX,\n              offsetY: actualObject.offsetY,\n              width: actualObject.width,\n              height: actualObject.height,\n              rotateAngle: actualObject.rotateAngle\n            });\n\n            if (isBlazor()) {\n              updateNodeObject.push(cloneObject(actualObject, undefined, undefined, true));\n            }\n          }\n\n          objects = this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds);\n        } else if (actualObject instanceof Selector) {\n          for (var i = 0; i < actualObject.nodes.length; i++) {\n            var node = actualObject.nodes[i];\n\n            if (node instanceof Node && node.shape.type !== 'SwimLane' && !node.isLane && !node.isPhase && !node.isHeader) {\n              node.offsetX += offsetX;\n              node.offsetY += offsetY;\n              node.width += width;\n              node.height += height;\n              node.rotateAngle += rotateAngle;\n              this.diagram.nodePropertyChange(node, {}, {\n                offsetX: node.offsetX,\n                offsetY: node.offsetY,\n                width: node.width,\n                height: node.height,\n                rotateAngle: node.rotateAngle\n              });\n              objects = objects.concat(this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds));\n            }\n          }\n        }\n      } else {\n        if (object instanceof Connector) {\n          objects.push(object);\n        } else if (object instanceof Selector && object.connectors.length) {\n          objects = objects.concat(object.connectors);\n        }\n      }\n\n      for (var i = 0; i < objects.length; i++) {\n        if (objects[i] instanceof Connector && connectors.indexOf(objects[i].id) === -1) {\n          connectors.push(objects[i].id);\n        }\n      }\n\n      this.diagram.lineRoutingModule.renderVirtualRegion(this.diagram, true);\n\n      for (var i = 0; i < connectors.length; i++) {\n        var connector = this.diagram.nameTable[connectors[i]];\n\n        if (connector instanceof Connector && connector.type === 'Orthogonal') {\n          if (isBlazor()) {\n            previousConnectorObject.push(cloneObject(connector, undefined, undefined, true));\n          }\n\n          this.diagram.lineRoutingModule.refreshConnectorSegments(this.diagram, connector, true);\n\n          if (isBlazor()) {\n            updateConnectorObject.push(cloneObject(connector, undefined, undefined, true));\n          }\n        }\n      }\n\n      this.updateSelector();\n\n      if (isBlazor()) {\n        this.getObjectChanges(previousNodeObject, updateNodeObject, changeNodes);\n        this.getObjectChanges(previousConnectorObject, updateConnectorObject, changeConnectors);\n        var blazorInterop = 'sfBlazor';\n        var blazor = 'Blazor';\n        var diagramObject = {\n          nodes: changeNodes,\n          connectors: changeConnectors\n        };\n\n        if (window && window[blazor] && changeConnectors.length + changeNodes.length) {\n          var obj = {\n            'methodName': 'UpdateBlazorProperties',\n            'diagramobj': diagramObject\n          };\n          window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n        }\n      }\n\n      this.diagram.protectPropertyChange(false);\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.drawSelectionRectangle = function (x, y, width, height) {\n    this.diagram.drawSelectionRectangle(x, y, width, height);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.startGroupAction = function () {\n    this.diagram.startGroupAction();\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.endGroupAction = function () {\n    this.diagram.endGroupAction();\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.removeChildFromBPmn = function (child, newTarget, oldTarget) {\n    var obj = this.diagram.nameTable[child.id] || child.nodes[0];\n\n    if (oldTarget) {\n      if (obj && obj.processId && obj.processId === oldTarget.wrapper.id) {\n        var node = clone(obj);\n        node.processId = obj.processId;\n        this.diagram.startGroupAction();\n        var edges = [];\n        edges = edges.concat(obj.outEdges, obj.inEdges);\n\n        for (var i = edges.length - 1; i >= 0; i--) {\n          var connector = this.diagram.nameTable[edges[i]];\n\n          if (connector) {\n            this.diagram.remove(connector);\n          }\n        } //let nodeCollection: string[];\n\n\n        var nodeCollection = this.diagram.nameTable[obj.processId].shape.activity.subProcess.processes || [];\n        nodeCollection.splice(nodeCollection.indexOf(obj.id), 1);\n        this.diagram.bpmnModule.removeChildFromBPMN(this.diagram.nameTable[obj.processId].wrapper, obj.id);\n        this.diagram.nameTable[obj.id].processId = '';\n        obj.offsetX = obj.wrapper.offsetX;\n        obj.offsetY = obj.wrapper.offsetY;\n        var undoElement = clone(obj);\n        var entry = {\n          type: 'PositionChanged',\n          redoObject: {\n            nodes: [undoElement]\n          },\n          undoObject: {\n            nodes: [node]\n          },\n          category: 'Internal'\n        };\n        this.addHistoryEntry(entry);\n        this.diagram.endGroupAction();\n      }\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.isDroppable = function (source, targetNodes) {\n    var node = this.diagram.nameTable[source.id] || source.nodes[0];\n\n    if (node) {\n      if (!isBlazor() && node.shape.shape === 'TextAnnotation' || isBlazor() && node.shape.bpmnShape === 'TextAnnotation') {\n        return true;\n      }\n\n      if (node && node.shape.type === 'Bpmn') {\n        if (node.processId === targetNodes.id || node.id === targetNodes.processId || targetNodes.shape.type === 'Bpmn' && targetNodes.shape.activity.subProcess.collapsed) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.renderHighlighter = function (args, connectHighlighter, source) {\n    var bounds = new Rect();\n\n    if (args.target instanceof Node || connectHighlighter && args.source instanceof Node) {\n      var tgt = connectHighlighter ? args.source : args.target;\n      var tgtWrap = connectHighlighter ? args.sourceWrapper : args.targetWrapper;\n      var target = this.findTarget(tgtWrap, tgt, source, true);\n      var element = void 0;\n\n      if (target instanceof BpmnSubEvent) {\n        var portId = target.id;\n        var node = args.target;\n        var parent_8 = node.wrapper.children[0].children[0].children[2];\n\n        for (var _i = 0, _a = parent_8.children; _i < _a.length; _i++) {\n          var child = _a[_i];\n\n          if (child.id === node.id + '_' + portId) {\n            element = child.children[0];\n            break;\n          }\n        }\n      } else {\n        element = target instanceof Node ? target.wrapper : connectHighlighter ? args.sourceWrapper : args.targetWrapper;\n      }\n\n      this.diagram.renderHighlighter(element);\n    }\n  }; //additional events\n\n  /** @private */\n\n\n  CommandHandler.prototype.mouseOver = function (source, target, position) {\n    //mouse over\n    //returns whether the source can move over the target or not\n    return true;\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.snapPoint = function (startPoint, endPoint, tx, ty) {\n    var obj = this.diagram.selectedItems;\n    var point;\n    var towardsLeft = endPoint.x < startPoint.x;\n    var towardsTop = endPoint.y < startPoint.y;\n    point = {\n      x: tx,\n      y: ty\n    };\n    var snappedPoint = point;\n\n    if (this.snappingModule) {\n      snappedPoint = this.diagram.snappingModule.snapPoint(this.diagram, obj, towardsLeft, towardsTop, point, startPoint, endPoint);\n    }\n\n    return snappedPoint;\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.removeSnap = function () {\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && this.snappingModule) {\n      this.snappingModule.removeGuidelines(this.diagram);\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.dropAnnotation = function (source, target) {\n    var node = source instanceof Node ? source : source.nodes[0];\n\n    if (this.diagram.bpmnModule && target.shape.type === 'Bpmn' && (!isBlazor() && node.shape.shape === 'TextAnnotation' || isBlazor() && node.shape.bpmnShape === 'TextAnnotation')) {\n      var hasTarget = 'hasTarget';\n      node[hasTarget] = target.id;\n      node.shape.annotation.nodeId = target.id;\n\n      if (!this.diagram.currentSymbol) {\n        this.diagram.addTextAnnotation(node.shape.annotation, target);\n        node.shape.annotation.nodeId = '';\n        this.diagram.remove(node);\n      }\n\n      this.diagram.refreshDiagramLayer();\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.drop = function (source, target, position) {\n    //drop\n    if (this.diagram.bpmnModule) {\n      var sourcenode = source instanceof Node ? source : source.nodes[0];\n\n      if (sourcenode && sourcenode.shape.type === 'Bpmn' && target.shape.type === 'Bpmn') {\n        this.diagram.bpmnModule.dropBPMNchild(target, source instanceof Node ? source : source.nodes[0], this.diagram);\n        this.diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.addHistoryEntry = function (entry) {\n    this.diagram.addHistoryEntry(entry);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.align = function (objects, option, type) {\n    if (objects.length > 0) {\n      var i = 0;\n      objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];\n      var bounds = type === 'Object' ? getBounds(objects[0].wrapper) : this.diagram.selectedItems.wrapper.bounds;\n      var undoObj = {\n        nodes: [],\n        connectors: []\n      };\n      var redoObj = {\n        nodes: [],\n        connectors: []\n      };\n\n      for (i = type === 'Object' ? i + 1 : i; i < objects.length; i++) {\n        var tx = 0;\n        var ty = 0;\n        objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];\n        var objectBounds = getBounds(objects[i].wrapper);\n\n        if (option === 'Left') {\n          tx = bounds.left + objectBounds.width / 2 - objectBounds.center.x;\n        } else if (option === 'Right') {\n          tx = bounds.right - objectBounds.width / 2 - objectBounds.center.x;\n        } else if (option === 'Top') {\n          ty = bounds.top + objectBounds.height / 2 - objectBounds.center.y;\n        } else if (option === 'Bottom') {\n          ty = bounds.bottom - objectBounds.height / 2 - objectBounds.center.y;\n        } else if (option === 'Center') {\n          tx = bounds.center.x - objectBounds.center.x;\n        } else if (option === 'Middle') {\n          ty = bounds.center.y - objectBounds.center.y;\n        }\n\n        undoObj = this.storeObject(undoObj, objects[i]);\n        this.drag(objects[i], tx, ty);\n        this.diagram.updateSelector();\n        redoObj = this.storeObject(redoObj, objects[i]);\n      }\n\n      undoObj = clone(undoObj);\n      redoObj = clone(redoObj);\n      var entry = {\n        type: 'Align',\n        category: 'Internal',\n        undoObject: cloneObject(undoObj),\n        redoObject: cloneObject(redoObj)\n      };\n      this.addHistoryEntry(entry);\n    }\n  };\n  /**\n   * distribute method \\\n   *\n   * @returns { void }     distribute method .\\\n   * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.\n   * @param {SizingOptions} option - provide the target value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.distribute = function (objects, option) {\n    if (objects.length > 0) {\n      var i = 0; //const j: number = 0;\n      //const rect: Rect = new Rect();\n      //const b: Rect[] = [];\n      //let temp: NodeModel | ConnectorModel;\n\n      var right = 0;\n      var left = 0;\n      var top_3 = 0;\n      var bottom = 0;\n      var center = 0;\n      var middle = 0;\n      var btt = 0; //const sum: number = 0;\n\n      var undoSelectorObj = {\n        nodes: [],\n        connectors: []\n      };\n      var redoSelectorObj = {\n        nodes: [],\n        connectors: []\n      };\n\n      for (i = 0; i < objects.length; i++) {\n        objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];\n      }\n\n      objects = sort(objects, option);\n\n      for (i = 1; i < objects.length; i++) {\n        right = right + objects[i].wrapper.bounds.topRight.x - objects[i - 1].wrapper.bounds.topRight.x;\n        left = left + objects[i].wrapper.bounds.topLeft.x - objects[i - 1].wrapper.bounds.topLeft.x;\n        top_3 = top_3 + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.topRight.y;\n        bottom = bottom + objects[i].wrapper.bounds.bottomRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;\n        center = center + objects[i].wrapper.bounds.center.x - objects[i - 1].wrapper.bounds.center.x;\n        middle = middle + objects[i].wrapper.bounds.center.y - objects[i - 1].wrapper.bounds.center.y;\n        btt = btt + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;\n      }\n\n      for (i = 1; i < objects.length - 1; i++) {\n        var tx = 0;\n        var ty = 0;\n        var prev = getBounds(objects[i - 1].wrapper);\n        var current = getBounds(objects[i].wrapper);\n\n        if (option === 'RightToLeft' || option === 'Center') {\n          tx = prev.center.x - current.center.x + center / (objects.length - 1);\n        } else if (option === 'Right') {\n          tx = prev.topRight.x - current.topRight.x + right / (objects.length - 1);\n        } else if (option === 'Left') {\n          tx = prev.topLeft.x - current.topLeft.x + left / (objects.length - 1);\n        } else if (option === 'Middle') {\n          ty = prev.center.y - current.center.y + middle / (objects.length - 1);\n        } else if (option === 'Top') {\n          ty = prev.topRight.y - current.topRight.y + top_3 / (objects.length - 1);\n        } else if (option === 'Bottom') {\n          ty = prev.bottomRight.y - current.bottomRight.y + bottom / (objects.length - 1);\n        } else if (option === 'BottomToTop') {\n          ty = prev.bottomRight.y - current.topRight.y + btt / (objects.length - 1);\n        }\n\n        undoSelectorObj = this.storeObject(undoSelectorObj, objects[i]);\n        this.drag(objects[i], tx, ty);\n        this.diagram.updateSelector();\n        redoSelectorObj = this.storeObject(redoSelectorObj, objects[i]);\n      }\n\n      undoSelectorObj = clone(undoSelectorObj);\n      redoSelectorObj = clone(redoSelectorObj);\n      var entry = {\n        type: 'Distribute',\n        category: 'Internal',\n        undoObject: cloneObject(undoSelectorObj),\n        redoObject: cloneObject(redoSelectorObj)\n      };\n      this.addHistoryEntry(entry);\n    }\n  };\n  /* eslint-enable */\n\n  /**\n   * sameSize method \\\n   *\n   * @returns { void }     sameSize method .\\\n   * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.\n   * @param {SizingOptions} option - provide the target value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.sameSize = function (objects, option) {\n    if (objects.length > 0) {\n      var i = 0; //let pivot: PointModel;\n\n      var pivot = {\n        x: 0.5,\n        y: 0.5\n      };\n      objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];\n      var bounds = getBounds(objects[0].wrapper);\n      var undoObject = {\n        nodes: [],\n        connectors: []\n      };\n      var redoObject = {\n        nodes: [],\n        connectors: []\n      };\n\n      for (i = 1; i < objects.length; i++) {\n        objects[i] = this.diagram.nameTable[objects[i].id] || objects[0];\n        var rect = getBounds(objects[i].wrapper);\n        var sw = 1;\n        var sh = 1;\n\n        if (option === 'Width') {\n          sw = bounds.width / rect.width;\n        } else if (option === 'Height') {\n          sh = bounds.height / rect.height;\n        } else if (option === 'Size') {\n          sw = bounds.width / rect.width;\n          sh = bounds.height / rect.height;\n        }\n\n        undoObject = this.storeObject(undoObject, objects[i]);\n        this.scale(objects[i], sw, sh, pivot);\n        redoObject = this.storeObject(redoObject, objects[i]);\n      }\n\n      this.diagram.updateSelector();\n      undoObject = clone(undoObject);\n      redoObject = clone(redoObject);\n      var entry = {\n        type: 'Sizing',\n        category: 'Internal',\n        undoObject: cloneObject(undoObject),\n        redoObject: cloneObject(redoObject)\n      };\n      this.addHistoryEntry(entry);\n    }\n  };\n\n  CommandHandler.prototype.storeObject = function (selectorObject, obj) {\n    if (obj instanceof Node) {\n      selectorObject.nodes.push(clone(obj));\n    } else {\n      selectorObject.connectors.push(clone(obj));\n    }\n\n    return selectorObject;\n  };\n  /**\n   * updatePanState method \\\n   *\n   * @returns { any }     updatePanState method .\\\n   * @param {number} eventCheck - provide the eventCheck value.\n   *\n   * @private\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  CommandHandler.prototype.updatePanState = function (eventCheck) {\n    if (eventCheck) {\n      this.diagram.realActions = this.diagram.realActions | RealAction.PanInProgress;\n    } else {\n      this.diagram.dataBind();\n      var diagramScrollSettings = this.diagram.scrollSettings;\n      this.diagram.realActions = this.diagram.realActions & ~RealAction.PanInProgress;\n      var Values = {\n        VerticalOffset: diagramScrollSettings.verticalOffset,\n        HorizontalOffset: diagramScrollSettings.horizontalOffset,\n        ViewportHeight: diagramScrollSettings.viewPortHeight,\n        ViewportWidth: diagramScrollSettings.viewPortWidth,\n        CurrentZoom: diagramScrollSettings.currentZoom\n      };\n      var arg = {\n        oldValue: Values,\n        newValue: Values,\n        source: this.diagram,\n        panState: 'Completed'\n      };\n      this.triggerEvent(DiagramEvent.scrollChange, arg);\n    }\n  };\n  /**\n   * dataBinding method \\\n   *\n   * @returns { void }     dataBinding method .\\\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.dataBinding = function () {\n    this.diagram.dataBind();\n  };\n\n  CommandHandler.prototype.setBlazorDiagramProps = function (arg) {\n    this.diagram.setBlazorDiagramProps(arg);\n  };\n  /**\n   * scroll method \\\n   *\n   * @returns { void }     scroll method .\\\n   * @param {number} scrollX - provide the source value.\n   * @param {number} scrollY - provide the target value.\n   * @param {PointModel} focusPoint - provide the layoutOrientation value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.scroll = function (scrollX, scrollY, focusPoint) {\n    var panx = canPanX(this.diagram);\n    var pany = canPanY(this.diagram);\n\n    if (isBlazor()) {\n      this.diagram.setCursor('grabbing');\n      this.diagram.scroller.zoom(1, (scrollX = panx ? scrollX : 0) * this.diagram.scroller.currentZoom, (scrollY = pany ? scrollY : 0) * this.diagram.scroller.currentZoom, focusPoint);\n    } else {\n      this.diagram.pan((scrollX = panx ? scrollX : 0) * this.diagram.scroller.currentZoom, (scrollY = pany ? scrollY : 0) * this.diagram.scroller.currentZoom, focusPoint);\n    }\n  };\n  /**\n   * drawHighlighter method \\\n   *\n   * @returns { NodeModel | ConnectorModel }     drawHighlighter method .\\\n   * @param {IElement} element - provide the element value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.drawHighlighter = function (element) {\n    this.diagram.renderHighlighter(element.wrapper);\n  };\n  /**\n   * removeHighlighter method \\\n   *\n   * @returns { void }     removeHighlighter method .\\\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.removeHighlighter = function () {\n    this.diagram.clearHighlighter();\n  };\n  /**\n   * renderContainerHelper method \\\n   *\n   * @returns { NodeModel | ConnectorModel }     renderContainerHelper method .\\\n   * @param {NodeModel | SelectorModel | ConnectorModel} node - provide the parent value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.renderContainerHelper = function (node) {\n    return renderContainerHelper(this.diagram, node);\n  };\n  /**\n   * isParentAsContainer method \\\n   *\n   * @returns { boolean }     isParentAsContainer method .\\\n   * @param {NodeModel} node - provide the parent value.\n   * @param {boolean} isChild - provide the target value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.isParentAsContainer = function (node, isChild) {\n    return checkParentAsContainer(this.diagram, node, isChild);\n  };\n  /**\n   * dropChildToContainer method \\\n   *\n   * @returns { void }     dropChildToContainer method .\\\n   * @param {NodeModel} parent - provide the parent value.\n   * @param {NodeModel} node - provide the target value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.dropChildToContainer = function (parent, node) {\n    if (!(this.diagram.diagramActions & DiagramAction.PreventLaneContainerUpdate)) {\n      addChildToContainer(this.diagram, parent, node);\n    }\n  };\n  /**\n  *\n  * @private\n  */\n\n\n  CommandHandler.prototype.updateLaneChildrenZindex = function (node, target) {\n    var lowerIndexobject = this.findLeastIndexObject(node, target);\n    var swimlane = this.diagram.nameTable[target.parentId];\n\n    if (swimlane && swimlane.zIndex > lowerIndexobject.zIndex) {\n      var layerIndex = this.diagram.layers.indexOf(this.diagram.getActiveLayer());\n      var layerZIndexTable = this.diagram.layers[layerIndex].zIndexTable;\n      var tempTable = JSON.parse(JSON.stringify(layerZIndexTable));\n      var startIndex = lowerIndexobject.zIndex;\n      var endIndex = swimlane.zIndex;\n\n      for (var i = endIndex; i >= startIndex; i--) {\n        if (startIndex !== i) {\n          if (!layerZIndexTable[i - 1]) {\n            layerZIndexTable[i - 1] = layerZIndexTable[i];\n            this.diagram.nameTable[layerZIndexTable[i - 1]].zIndex = i;\n            delete layerZIndexTable[i];\n          } else {\n            //bringing the objects forward\n            layerZIndexTable[i] = layerZIndexTable[i - 1];\n            this.diagram.nameTable[layerZIndexTable[i]].zIndex = i;\n          }\n        } else {\n          var tempIndex = this.swapZIndexObjects(endIndex, layerZIndexTable, swimlane.id, tempTable);\n        }\n      }\n\n      if (this.diagram.mode === 'SVG') {\n        this.moveSvgNode(target.parentId, lowerIndexobject.id);\n        this.updateNativeNodeIndex(target.parentId, lowerIndexobject.id);\n      } else {\n        this.diagram.refreshCanvasLayers();\n      }\n    }\n  };\n\n  CommandHandler.prototype.findLeastIndexConnector = function (edges, target, index) {\n    for (var i = 0; i < edges.length; i++) {\n      var connector = this.diagram.nameTable[edges[i]];\n\n      if (index.zIndex > connector.zIndex) {\n        index = connector;\n      }\n    }\n\n    return index;\n  };\n\n  CommandHandler.prototype.findLeastIndexObject = function (node, target) {\n    var lowerIndexobject = node;\n\n    if (node instanceof Node) {\n      lowerIndexobject = this.findLeastIndexConnector(node.inEdges, target, lowerIndexobject);\n      lowerIndexobject = this.findLeastIndexConnector(node.outEdges, target, lowerIndexobject);\n    }\n\n    return lowerIndexobject;\n  };\n  /**\n   * checkSelection method \\\n   *\n   * @returns { void }     checkSelection method .\\\n   * @param {SelectorModel} selector - provide the source value.\n   * @param {string} corner - provide the target value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.checkSelection = function (selector, corner) {\n    var node; // let wrapper: GridPanel; let child: Container; let index: number; let shape: SwimLaneModel;\n\n    if (selector.nodes.length === 1 && selector.connectors.length === 0) {\n      if (checkParentAsContainer(this.diagram, selector.nodes[0], true)) {\n        node = selector.nodes[0].shape === 'SwimLane' ? selector.nodes[0] : this.diagram.nameTable[selector.nodes[0].parentId];\n        var child = selector.nodes[0];\n\n        if (node.shape.type === 'SwimLane') {\n          var orientation_1 = node.shape.orientation === 'Horizontal' ? true : false;\n\n          if (child.isPhase && (orientation_1 && corner === 'ResizeSouth' || !orientation_1 && corner === 'ResizeEast') || child.isLane && (orientation_1 && corner === 'ResizeEast' || !orientation_1 && corner === 'ResizeSouth')) {\n            swimLaneSelection(this.diagram, node, corner);\n          }\n        } else if (node.container.type === 'Grid') {\n          if (node.container.orientation === 'Horizontal' && child.rowIndex === 1 || node.container.orientation === 'Vertical' && child.rowIndex > 0 && child.columnIndex > 0) {\n            if (corner === 'ResizeSouth') {\n              for (var i = 0; i < this.diagram.nodes.length; i++) {\n                var obj = this.diagram.nodes[i];\n\n                if (obj.rowIndex === node.rows.length - 1 && obj.columnIndex === 0) {\n                  this.select(obj);\n                  break;\n                }\n              }\n            }\n          } else {\n            if (corner === 'ResizeEast') {\n              for (var i = 0; i < this.diagram.nodes.length; i++) {\n                var obj = this.diagram.nodes[i];\n\n                if (obj.rowIndex === 1 && obj.columnIndex === node.columns.length - 1) {\n                  this.select(obj);\n                  break;\n                }\n              }\n            }\n          }\n        }\n      } else {\n        swimLaneSelection(this.diagram, selector.nodes[0], corner);\n      }\n    }\n  };\n  /**\n   * zoom method \\\n   *\n   * @returns { void }     zoom method .\\\n   * @param {number} scale - provide the source value.\n   * @param {number} scrollX - provide the target value.\n   * @param {number} scrollY - provide the layoutOrientation value.\n   * @param {PointModel} focusPoint - provide the layoutOrientation value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.zoom = function (scale, scrollX, scrollY, focusPoint) {\n    this.diagram.scroller.zoom(scale, scrollX * this.diagram.scroller.currentZoom, scrollY * this.diagram.scroller.currentZoom, focusPoint);\n  };\n\n  return CommandHandler;\n}();\n\nexport { CommandHandler };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/command-manager.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","Connector","getBezierPoints","isEmptyVector","Node","BpmnSubEvent","BpmnAnnotation","Native","PathElement","TextElement","OrthogonalSegment","Rect","Diagram","identityMatrix","rotateMatrix","transformPointByMatrix","scaleMatrix","cloneObject","clone","getBounds","getFunction","getIndex","completeRegion","sort","findObjectIndex","intersect3","getAnnotationPosition","findParentInSwimlane","updatePathElement","cloneBlazorObject","getUserHandlePosition","cloneSelectedObjects","updateDefaultValues","randomId","cornersPointsBeforeRotation","Selector","hasSelection","isSelected","hasSingleConnection","contains","DiagramEvent","BlazorAction","canSelect","canMove","canRotate","canDragSourceEnd","canDragTargetEnd","canSingleSelect","canDrag","canMultiSelect","canContinuousDraw","canPanX","canPanY","canPageEditable","SnapConstraints","DiagramTools","DiagramAction","RealAction","getDiagramElement","getAdornerLayerSvg","getHTMLLayer","getAdornerLayer","getSelectorElement","Point","Size","getObjectType","getPoint","intersect2","getOffsetOfConnector","canShowCorner","selectionHasConnector","Layer","SelectorConstraints","DiagramConstraints","remove","isBlazor","isNullOrUndefined","getOppositeDirection","getPortDirection","findAngle","swapBounds","findPoint","orthoConnection2Segment","getIntersection","ShapeAnnotation","PathAnnotation","renderContainerHelper","checkChildNodeInContainer","checkParentAsContainer","addChildToContainer","renderStackHighlighter","getConnectors","updateConnectorsProperties","canLaneInterchange","findLane","swimLaneSelection","pasteSwimLane","gridSelection","DeepDiffMapper","CommandHandler","diagram","clipboardData","diagramObject","newSelectedObjects","oldSelectedObjects","connectorsTable","processTable","deepDiffer","isContainer","childTable","parentTable","blazor","blazorInterop","cloneGroupChildCollection","Object","defineProperty","prototype","get","snappingModule","enumerable","configurable","layoutAnimateModule","startTransaction","protectChange","state","element","selectedItems","backup","protectPropertyChange","id","style","pointerEvents","endTransaction","setFocus","document","getElementById","focus","showTooltip","node","position","content","toolName","isTooltipVisible","_this","targetId","targetEle","isNative","nodes","connectors","shape","idName","tooltipObject","animation","open","delay","duration","openDelay","closeDelay","setTooltipTemplate","template","HTMLElement","cloneNode","close","tooltip","openOn","offsetX","offsetY","updateTooltip","refresh","setTimeout","closeTooltip","canEnableDefaultTooltip","constraints","ToolTip","updateSelector","updateConnectorValue","args","cancel","enableCloneObject","ismouseEvents","insertBlazorObject","connector","newChanges","oldChanges","nameTable","nodeEndId","connectorEnd","portEndId","connectionEnd","newValue","connectorTargetValue","connectorSourceValue","oldValue","nodeId","portId","sourceID","sourcePortID","connectorPropertyChange","targetPortID","targetID","triggerEvent","event","temparg","_a","drop","positionChange","connectionChange","currentSymbol","source","currentDrawingObject","dragOverElement","currentPosition","dragOverArg","target","mousePosition","dragOver","disConnect","obj","endPoint","canCancel","checkBlazor","returnargs","selectorModel","insertValue","connectionEventChange","arg","updateDiagramObject","connectedNode","nodeObject","undefined","object","isNode","i","getObject","updatePropertiesToBlazor","labelDrag","getBlazorOldValues","updateBlazorSelector","insertSelectedObjects","findTarget","argsTarget","connection","type","bpmnShape","activity","subProcess","transaction","success","visible","indexOf","failure","ports","port","annotation","annotations","canDisconnect","targetPortId","targetNodeId","selector","connect","targetObject","targetWrapper","nodeEnd","portEnd","changeAnnotationDrag","bpmnModule","textAnnotationConnectors","split","annotationId","startGroupAction","parentNode","clonedNode","getAnnotation","annotationNode","angle","intermediatePoints","text","distancePoints","annotationObj","checkAndRemoveAnnotations","refreshCanvasLayers","addTextAnnotation","endGroupAction","oldNodeId","oldPortId","sourceWrapper","actualObject","renderHighlighter","cut","index","pasteIndex","undoRedoModule","historyManager","clipObject","copyObjects","mode","refreshDiagramLayer","UpdateBlazorDiagramModelLayers","layer","isRemove","updatedModel","window","JSON","stringify","isLoading","updateBlazorProperties","addLayer","objects","isServerUpdate","zIndex","layers","isEnableServerDatabind","allowServerDataBinding","enableServerDataBinding","objectZIndex","zIndexTable","layerZIndexTable","activeLayer","add","getObjectLayer","objectName","objIndex","getLayer","layerName","removeLayer","layerId","layerObject","unSelect","splice","moveObjects","targetLayer","setActiveLayer","targerNodes","_i","objects_1","layer_1","cloneLayer","cloneObject_1","newlayer","lock","multiSelect","paste","copy","j","concat","isPhase","wrapper","copyProcesses","matrix","rotateAngle","children","tempNode","elements","getAllDescendants","clonedObject","newOffset","x","swimlane","connectorsList","isLane","parentId","lane","width","actualSize","selectedItems_1","item","sortByZIndex","processes","processes_1","group","propName","protectedChange","diagramActions","Group","order","a","b","select","entry","undoObject","redoObject","category","addHistoryEntry","unGroup","childCollection","k","removePorts","removeLabels","deleteChild","addChild","resetDependentConnectors","inEdges","outEdges","UndoRedo","removeNode","clearSelection","edges","isInEdges","newConnector","newProp","copiedItems","getNewObject","groupAction","objectTable","keyTable","copiedItems_1","copiedObject","clonedObj","newObj","cloneConnector","newNode","edges_1","edge","_b","edges_2","UpdateBlazorDiagramModelCollection","newobjs","translateObject","selectObjects","groupnodeID","process","temp","cloneGroup","checkAnnotation","keys","cloneSubProcesses","parent","currentAnnotation","child","_c","innerChild","processId","addProcess","_d","connector_1","node_1","connectorTable","newChildren","connectorObj","oldID","objectCollection","blazorActions","GroupClipboardInProcess","childObj","parentObj","container","measure","diff","sourcePoint","targetPoint","segments","isEmptyPoint","point1","point2","point","drawObject","oldProtectPropertyChangeValue","getProtectPropertyChangeValue","drawingObject","height","prop","nodeDefaults","connectorDefaults","initObject","addObjectToDiagram","removeFromAQuad","removeObjectsFromLayer","tool","DrawOnce","enable","addText","findElementUnderMouse","startTextEdit","updateArgsObject","arg1","argValue","connectorCollection","nodeCollection","updateSelectionChangeEventArgs","cause","argOldValue","argNewValue","getSelectedObject","isUserHandle","handle","userHandles","paddedBounds","scroller","transform","size","scale","multipleSelection","oldSelectedItems","canDoMultipleSelection","canDoSingleSelection","i_1","blazorArgs","eventObj","selectedObjects","selectionChange","findParent","selectGroup","selectProcesses","selectBpmnSubProcesses","renderSelector","updateBlazorSelectorModel","updateBlazorDiagramEvents","map","diffValue","frameObject","removeEmptyValues","hasProcesses","preventUpdate","hasLayer","convert","isHeader","init","pivot","getObjectCollectionId","selectedObject","oldItemsCollection","oldItems","items","newItems","updateDiagramCollection","labelSelect","textWrapper","objArray","filter","selectormodel","getChildElements","childNode","moveSvgNode","diagramDiv","backNode","insertBefore","sendLayerBackward","currentLayerObject","currentLayerObject_1","bringLayerForward","targetLayerObjects","targetLayerObjects_1","sendToBack","objectId","layerNum","tempTable","parse","tempIndex","checkObjectBehind","swapZIndexObjects","obj_1","resetTargetNode","checkParentExist","updateNativeNodeIndex","getZIndexObjects","childCount","childIndex","updateBlazorZIndex","diagramobject","connectorObject","elementObject","getBlazorObject","sfIndex","objBehind","z","bringToFront","objectName_1","zIndexTable_1","tabelLength","Number","reverse","oldzIndexTable_1","length_1","tempIndex_1","laneIndex","cloneTable","swimlaneObject","diagramLayer","removeChild","views","lastChildNode","lastChild","nextSibling","htmlLayer","diagramRenderer","renderElement","forEach","key","zIndexValue","objectNode","zIndexNode","checkGroupNode","selectedNodeName","nodeArray","sortID","orderCommands","isRedo","action","sendBackward","sendForward","startZIndex","endZIndex","layerIndex","undoObject_1","layer_2","moveObject","layer_3","sourceId","intersectArray","spatialSearch","findObjects","bounds","temp_1","currentLayer","intersects","parent_1","obj_2","overlapObject","currentObject","temp_2","redo","historyEntry","temp_3","parent_2","obj_3","temp_4","node_2","parentElement","firstChild","initSelectorWrapper","doRubberBandSelection","region","clearSelectionRectangle","selArray","rubberArray","getNodesConnectors","rubberBandSelectionMode","adornerSvg","dragConnectorEnds","segment","tx","ty","checkBezierThumb","bezierPoint1","dragSourceEnd","bezierPoint2","dragTargetEnd","isObjectInteraction","newNodeObject","newConnectorObject","oldNodeObjects","oldConnectorObjects","lineRoutingModule","LineRouting","canEnableBlazorObject","addConstraints","interaction","removeConstraints","updateLayerObject","oldDiagram","diffLayers","getLayerObject","getDiagramOldValues","attribute","newDiagram","newObject","changeSegments","ClearObject","oldNodeObject","getDifferenceValues","oldConnectorObject","getObjectChanges","previousObject","changedNodes","change","clearObjectSelection","mouseDownElement","list","triggerAction","isTriggered","arrayNodes","blazarArgs","selectNodes","previousSelectedObject","clearSelectorLayer","clearSelectedItems","selectedNodes","selectedConnectors","removeStackHighlighter","highlighter","symbolDrag","findObjectsUnderMouse","findObjectUnderMouse","laneNode","parentObject","canvas","node_3","orientation","isVertical","rowIndex","columnIndex","insertBlazorConnector","drag","checkBoundaryConstraints","oldValues","isGroupDragging","updateInnerParentProperties","measureChildren","nodePropertyChange","grid","update","hasEnds","canDragPoints","dragControlPoint","conn","connectorSegmentChange","existingInnerBounds","isRotate","segmentChange","equals","direction","bottomCenter","topCenter","middleLeft","middleRight","firstSegment","secondSegment","cornerPoints","corners","margin","points","updateEndPoint","isDragSource","changeSegmentLength","sequence","updatePathElementOffset","translateBezierPoints","realActions","AnimationClick","pathElement","anglePoints","first","second","secPoint","nextDirection","changeSourceEndToNode","changeSourceEndToPort","getWrapper","segValues","segValues1","isTerminal","Math","abs","removeTerminalSegment","changeTerminal","sourcePoint2","nextSegment","seg","vector1","distance","vector2","boundaryConstraints","prev","segmentNumber","rotatePropertyChnage","pivotValue","rotateObjects","includeParent","objects_2","parent_3","bound","getChildrenBound","updateSubProcessess","getChildren","rotatePoints","snapConnectorEnd","snapSettings","SnapToLines","snapAngle","protect","innerParents","sw","sh","refObject","isOutsideBoundary","refWrapper","refPoint","nodes_1","scaleObject","arrange","desiredSize","updateGroupOffset","innerParent","parentNodes","cloneChild","canUpdate","isResize","top","left","containsRect","maxWidth","min","minWidth","max","maxHeight","minHeight","right","bottom","newPosition","oldleft","oldtop","parent_4","parent_5","top_1","parent_6","oldValues_1","scaleConnector","parent_7","clonedSelectedItems","nodeModel","measureSelector","desiredBounds","matrix_1","p1","p2","calculateBounds","uniteRect","offsetPt","selectorEle","renderResizeHandle","thumbsConstraints","currentZoom","rect","portDrag","portElement","changedvalues","getPortChanges","offset","textElement","getAnnotationChanges","updatePathAnnotationOffset","alignment","pointLength","totalLength","intersectingOffset","intersetingPts","getInterceptWithSegment","getLengthFromListOfPoints","dragLimit","minDistance","getRelativeOffset","connectorOffset","p","toBounds","containsPoint","findLength","updateLabelMargin","pt","round","sqrt","pow","dragLimitValue","tempPt","contentDimension","length_2","getPointAtLength","curZoomfactor","scrollSettings","labelBounds","annotationWrtapper","draggableBounds","lineIntersects","line1","boundsInterSects","lineIntersects_1","ptt","cursorLimit","polyLine","self","polyLine2","intersect","polyLine1","run","pre","found","l","r","deg","cos","PI","sin","conPoints","intercepts","imgLine","segemnt","tarAngle","srcAngle","maxLength","viewPortWidth","viewPortHeight","angleAdd","lineUtil1","x1","y1","x2","y2","lineUtil2","line3","enabled","intersectPt","horizontalAlignment","verticalAlignment","labelRotate","labelWrapper","segmentAngle","getPointloop","parentTransform","labelResize","deltaWidth","deltaHeight","newMat","offsetx","offsety","getSubProcess","nodeBounds","pageSettings","selectorBounds","top_2","dragSelectedObjects","PreventZIndexOnDragging","DragUsingMouse","scaleSelectedItems","sx","sy","rotateSelectedItems","rotate","initExpand","isExpanded","preventNodesUpdate","PreventIconsUpdate","view","refreshCanvasDiagramLayer","expandNode","canLayout","expand","preventConnectorsUpdate","expandCollapse","fixedNode","layout","Render","enableAnimation","organizationalChartModule","isAnimation","doLayout","expandStateChange","resetSegments","getparentexpand","visibility","boolean","previousNode","opacity","newValues","updateNodeDimension","canMeasurePath","updateConnectorPoints","updateSelectedNodeProperties","previousNodeObject","previousConnectorObject","updateNodeObject","updateConnectorObject","changeNodes","changeConnectors","helperObject","outerBounds","renderVirtualRegion","refreshConnectorSegments","drawSelectionRectangle","removeChildFromBPmn","newTarget","oldTarget","removeChildFromBPMN","undoElement","isDroppable","targetNodes","collapsed","connectHighlighter","tgt","tgtWrap","parent_8","mouseOver","snapPoint","startPoint","towardsLeft","towardsTop","snappedPoint","removeSnap","SnapToObject","removeGuidelines","dropAnnotation","hasTarget","sourcenode","dropBPMNchild","align","option","undoObj","redoObj","objectBounds","center","storeObject","distribute","top_3","middle","btt","undoSelectorObj","redoSelectorObj","topRight","topLeft","bottomRight","current","sameSize","selectorObject","updatePanState","eventCheck","PanInProgress","dataBind","diagramScrollSettings","Values","VerticalOffset","verticalOffset","HorizontalOffset","horizontalOffset","ViewportHeight","ViewportWidth","CurrentZoom","panState","scrollChange","dataBinding","setBlazorDiagramProps","scroll","scrollX","scrollY","focusPoint","panx","pany","setCursor","zoom","pan","drawHighlighter","removeHighlighter","clearHighlighter","isParentAsContainer","isChild","dropChildToContainer","PreventLaneContainerUpdate","updateLaneChildrenZindex","lowerIndexobject","findLeastIndexObject","getActiveLayer","startIndex","endIndex","findLeastIndexConnector","checkSelection","corner","orientation_1","rows","columns"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Connector, getBezierPoints, isEmptyVector } from '../objects/connector';\nimport { Node, BpmnSubEvent, BpmnAnnotation, Native } from '../objects/node';\nimport { PathElement } from '../core/elements/path-element';\nimport { TextElement } from '../core/elements/text-element';\nimport { OrthogonalSegment } from '../objects/connector';\nimport { Rect } from '../primitives/rect';\nimport { Diagram } from '../../diagram/diagram';\nimport { identityMatrix, rotateMatrix, transformPointByMatrix, scaleMatrix } from './../primitives/matrix';\nimport { cloneObject as clone, cloneObject, getBounds, getFunction, getIndex } from './../utility/base-util';\nimport { completeRegion, sort, findObjectIndex, intersect3, getAnnotationPosition, findParentInSwimlane } from './../utility/diagram-util';\nimport { updatePathElement, cloneBlazorObject, getUserHandlePosition, cloneSelectedObjects } from './../utility/diagram-util';\nimport { updateDefaultValues } from './../utility/diagram-util';\nimport { randomId, cornersPointsBeforeRotation } from './../utility/base-util';\nimport { Selector } from '../objects/node';\nimport { hasSelection, isSelected, hasSingleConnection, contains } from './actions';\nimport { DiagramEvent } from '../enum/enum';\nimport { BlazorAction } from '../enum/enum';\nimport { canSelect, canMove, canRotate, canDragSourceEnd, canDragTargetEnd, canSingleSelect, canDrag } from './../utility/constraints-util';\nimport { canMultiSelect, canContinuousDraw } from './../utility/constraints-util';\nimport { canPanX, canPanY, canPageEditable } from './../utility/constraints-util';\nimport { SnapConstraints, DiagramTools, DiagramAction, RealAction } from '../enum/enum';\nimport { getDiagramElement, getAdornerLayerSvg, getHTMLLayer, getAdornerLayer, getSelectorElement } from '../utility/dom-util';\nimport { Point } from '../primitives/point';\nimport { Size } from '../primitives/size';\nimport { getObjectType, getPoint, intersect2, getOffsetOfConnector, canShowCorner } from './../utility/diagram-util';\nimport { selectionHasConnector } from './../utility/diagram-util';\nimport { Layer } from '../diagram/layer';\nimport { SelectorConstraints, DiagramConstraints } from '../enum/enum';\nimport { remove, isBlazor, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { getOppositeDirection, getPortDirection, findAngle } from './../utility/connector';\nimport { swapBounds, findPoint, orthoConnection2Segment, getIntersection } from './../utility/connector';\nimport { ShapeAnnotation, PathAnnotation } from '../objects/annotation';\nimport { renderContainerHelper } from './container-interaction';\nimport { checkChildNodeInContainer, checkParentAsContainer, addChildToContainer } from './container-interaction';\nimport { renderStackHighlighter } from './container-interaction';\nimport { getConnectors, updateConnectorsProperties, canLaneInterchange, findLane } from './../utility/swim-lane-util';\nimport { swimLaneSelection, pasteSwimLane, gridSelection } from '../utility/swim-lane-util';\nimport { DeepDiffMapper } from '../utility/diff-map';\n/**\n * Defines the behavior of commands\n */\nvar CommandHandler = /** @class */ (function () {\n    function CommandHandler(diagram) {\n        /**   @private  */\n        this.clipboardData = {};\n        // private newNodeObject: Object[] = [];\n        // private newConnectorObject: Object[] = [];\n        /**   @private  */\n        this.diagramObject = {};\n        /**   @private  */\n        this.newSelectedObjects = {};\n        /**   @private  */\n        this.oldSelectedObjects = {};\n        /**   @private  */\n        this.connectorsTable = [];\n        /**   @private  */\n        this.processTable = {};\n        /**   @private  */\n        this.deepDiffer = new DeepDiffMapper();\n        /** @private */\n        this.isContainer = false;\n        this.childTable = {};\n        this.parentTable = {};\n        this.blazor = 'Blazor';\n        this.blazorInterop = 'sfBlazor';\n        this.cloneGroupChildCollection = [];\n        this.diagram = diagram;\n    }\n    Object.defineProperty(CommandHandler.prototype, \"snappingModule\", {\n        /**   @private  */\n        get: function () {\n            return this.diagram.snappingModule;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CommandHandler.prototype, \"layoutAnimateModule\", {\n        /**   @private  */\n        get: function () {\n            return this.diagram.layoutAnimateModule;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * startTransaction method\\\n     *\n     * @returns {  void }    startTransaction method .\\\n     * @param {boolean} protectChange - provide the options value.\n     * @private\n     */\n    CommandHandler.prototype.startTransaction = function (protectChange) {\n        this.state = { element: this.diagram.selectedItems, backup: null };\n        if (protectChange) {\n            this.diagram.protectPropertyChange(true);\n        }\n        getAdornerLayer(this.diagram.element.id).style.pointerEvents = 'none';\n    };\n    /**\n     * endTransaction method\\\n     *\n     * @returns {  void }    endTransaction method .\\\n     * @param {boolean} protectChange - provide the options value.\n     * @private\n     */\n    CommandHandler.prototype.endTransaction = function (protectChange) {\n        this.state = null;\n        if (protectChange) {\n            this.diagram.protectPropertyChange(false);\n        }\n        getAdornerLayer(this.diagram.element.id).style.pointerEvents = 'all';\n    };\n    /**\n     * setFocus method\\\n     *\n     * @returns {  void }    setFocus method .\\\n     * @private\n     */\n    CommandHandler.prototype.setFocus = function () {\n        document.getElementById(this.diagram.element.id).focus();\n    };\n    /**\n     * showTooltip method\\\n     *\n     * @returns {  void }    showTooltip method .\\\n     * @param {IElement} node - provide the options value.\n     * @param {PointModel} position - provide the position value.\n     * @param {string | HTMLElement} content - provide the content value.\n     * @param {string} toolName - provide the toolName value.\n     * @param {boolean} isTooltipVisible - provide the isTooltipVisible value.\n     * @private\n     */\n    CommandHandler.prototype.showTooltip = function (node, position, content, toolName, isTooltipVisible) {\n        var _this = this;\n        var targetId;\n        var targetEle;\n        var isNative = false;\n        if (node instanceof Selector) {\n            if ((node.nodes.length == 1) && node.connectors.length == 0) {\n                targetId = node.nodes[0].id;\n                if (node.nodes[0].shape && node.nodes[0].shape instanceof Native) {\n                    isNative = true;\n                }\n            }\n            else if ((node.nodes.length == 0) && node.connectors.length == 1) {\n                targetId = node.connectors[0].id;\n            }\n            else {\n                targetEle = document.getElementById(this.diagram.element.id + '_SelectorElement');\n            }\n        }\n        else if (node instanceof Node) {\n            targetId = node.id;\n            if (node.shape && (node.shape instanceof Native)) {\n                isNative = true;\n            }\n        }\n        else {\n            targetId = node.id;\n        }\n        if (isNullOrUndefined(targetEle) && !isNullOrUndefined(targetId)) {\n            var idName = isNative ? '_content_native_element' : '_groupElement';\n            targetEle = document.getElementById(targetId + idName);\n        }\n        if (isTooltipVisible) {\n            this.diagram.tooltipObject.position = 'BottomCenter';\n            this.diagram.tooltipObject.animation = { open: { delay: 0, duration: 0 } };\n            this.diagram.tooltipObject.openDelay = 0;\n            this.diagram.tooltipObject.closeDelay = 0;\n        }\n        if (this.diagram.selectedItems.setTooltipTemplate) {\n            var template = void 0;\n            var setTooltipTemplate = getFunction(this.diagram.selectedItems.setTooltipTemplate);\n            if (setTooltipTemplate) {\n                template = setTooltipTemplate(node, this.diagram);\n            }\n            if (template instanceof HTMLElement) {\n                content = template.cloneNode(true);\n            }\n            else {\n                content = template ? template : content;\n            }\n        }\n        if (isBlazor() && isTooltipVisible) {\n            this.diagram.tooltipObject.close();\n        }\n        if (node.tooltip) {\n            this.diagram.tooltipObject.openOn = node.tooltip.openOn;\n        }\n        this.diagram.tooltipObject.content = content;\n        this.diagram.tooltipObject.offsetX = 0;\n        this.diagram.tooltipObject.offsetY = 0;\n        if (isBlazor()) {\n            this.diagram.tooltipObject.updateTooltip(targetEle);\n        }\n        else {\n            this.diagram.tooltipObject.refresh(targetEle);\n        }\n        if (isTooltipVisible) {\n            setTimeout(function () {\n                _this.diagram.tooltipObject.open(targetEle);\n            }, 1);\n        }\n    };\n    /**\n     * closeTooltip method\\\n     *\n     * @returns {  void }    closeTooltip method .\\\n     * @private\n     */\n    CommandHandler.prototype.closeTooltip = function () {\n        this.diagram.tooltipObject.close();\n    };\n    /**\n     * canEnableDefaultTooltip method\\\n     *\n     * @returns {  boolean }    canEnableDefaultTooltip method .\\\n     * @private\n     */\n    CommandHandler.prototype.canEnableDefaultTooltip = function () {\n        if (this.diagram.selectedItems.constraints & SelectorConstraints.ToolTip) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * updateSelector method\\\n     *\n     * @returns {  void }    updateSelector method .\\\n     * @private\n     */\n    CommandHandler.prototype.updateSelector = function () {\n        this.diagram.updateSelector();\n    };\n    /**\n     * updateConnectorValue method\\\n     *\n     * @returns {  void }    updateConnectorValue method .\\\n     * @param {IBlazorConnectionChangeEventArgs} args - provide the options value.\n     * @private\n     */\n    CommandHandler.prototype.updateConnectorValue = function (args) {\n        if (args.cancel) {\n            this.enableCloneObject(true);\n            this.ismouseEvents(true);\n            this.insertBlazorObject(args.connector);\n            var newChanges = {};\n            var oldChanges = {};\n            var connector = this.diagram.nameTable[args.connector.id];\n            var nodeEndId = args.connectorEnd === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n            var portEndId = args.connectorEnd === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n            var connectionEnd = args.connectorEnd === 'ConnectorTargetEnd';\n            var newValue = connectionEnd ? args.newValue.connectorTargetValue : args.newValue.connectorSourceValue;\n            var oldValue = connectionEnd ? args.oldValue.connectorTargetValue : args.oldValue.connectorSourceValue;\n            oldChanges[nodeEndId] = newValue.nodeId;\n            oldChanges[portEndId] = newValue.portId;\n            newChanges[nodeEndId] = oldValue.nodeId;\n            newChanges[portEndId] = oldValue.portId;\n            if (args.cancel && args.connectorEnd !== 'ConnectorTargetEnd') {\n                connector.sourceID = oldValue.nodeId;\n                if (args.connector.sourcePortID) {\n                    connector.sourcePortID = oldValue.portId;\n                }\n                this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n            }\n            if (args.cancel && args.connectorEnd === 'ConnectorTargetEnd') {\n                if (args.connector.targetPortID) {\n                    connector.targetPortID = oldValue.portId;\n                }\n                connector.targetID = oldValue.nodeId;\n                this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n            }\n        }\n    };\n    /**\n     * triggerEvent method\\\n     *\n     * @returns {  Promise<void | object | IBlazorConnectionChangeEventArgs> }    triggerEvent method .\\\n     * @param {DiagramEvent} event - provide the options value.\n     * @param {Object} args - provide the args value.\n     * @private\n     */\n    CommandHandler.prototype.triggerEvent = function (event, args) {\n        return __awaiter(this, void 0, void 0, function () {\n            var temparg;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (event === DiagramEvent.drop || event === DiagramEvent.positionChange ||\n                            event === DiagramEvent.connectionChange) {\n                            if (this.diagram.currentSymbol) {\n                                return [2 /*return*/];\n                            }\n                            if (event === DiagramEvent.drop) {\n                                args.source = cloneBlazorObject(this.diagram);\n                            }\n                            if (this.diagram.currentDrawingObject && event !== DiagramEvent.positionChange) {\n                                return [2 /*return*/];\n                            }\n                        }\n                        return [4 /*yield*/, this.diagram.triggerEvent(event, args)];\n                    case 1:\n                        temparg = _a.sent();\n                        return [2 /*return*/, temparg];\n                }\n            });\n        });\n    };\n    /**\n     * dragOverElement method\\\n     *\n     * @returns { void }    dragOverElement method .\\\n     * @param {MouseEventArgs} args - provide the options value.\n     * @param {PointModel} currentPosition - provide the args value.\n     * @private\n     */\n    CommandHandler.prototype.dragOverElement = function (args, currentPosition) {\n        if (this.diagram.currentSymbol) {\n            var dragOverArg = {\n                element: cloneBlazorObject(args.source), target: cloneBlazorObject(args.target),\n                mousePosition: cloneBlazorObject(currentPosition), diagram: cloneBlazorObject(this.diagram)\n            };\n            this.triggerEvent(DiagramEvent.dragOver, dragOverArg);\n        }\n    };\n    /**\n     * disConnect method\\\n     *\n     * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    disConnect method .\\\n     * @param {IElement} obj - provide the obj value.\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {boolean} canCancel - provide the canCancel value.\n     * @private\n     */\n    CommandHandler.prototype.disConnect = function (obj, endPoint, canCancel) {\n        var checkBlazor = isBlazor();\n        var oldChanges = {};\n        var newChanges = {};\n        var returnargs;\n        var selectorModel;\n        var connector;\n        if (obj instanceof Selector) {\n            selectorModel = obj;\n            connector = selectorModel.connectors[0];\n        }\n        else if (obj instanceof Connector && this.diagram.currentDrawingObject) {\n            connector = this.diagram.currentDrawingObject;\n        }\n        if (obj && connector && (hasSingleConnection(this.diagram) || this.diagram.currentDrawingObject)) {\n            if (isBlazor()) {\n                this.diagram.insertValue(cloneObject(connector), false);\n            }\n            if (endPoint && (endPoint === 'ConnectorSourceEnd' || endPoint === 'ConnectorTargetEnd')) {\n                var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n                var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n                if (connector[nodeEndId]) { //connector.sourceID || connector.targetID\n                    oldChanges[nodeEndId] = connector[nodeEndId];\n                    connector[nodeEndId] = '';\n                    newChanges[nodeEndId] = connector[nodeEndId];\n                    if (connector.sourcePortID || connector.targetPortID) {\n                        oldChanges[portEndId] = connector[portEndId];\n                        connector[portEndId] = '';\n                        newChanges[portEndId] = connector[portEndId];\n                    }\n                    returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);\n                }\n            }\n            else if ((endPoint !== 'OrthoThumb' && endPoint !== 'SegmentEnd') && (connector.sourceID || connector.targetID)) {\n                oldChanges = {\n                    sourceID: connector.sourceID, sourcePortID: connector.sourcePortID,\n                    targetID: connector.targetID, targetPortID: connector.targetPortID\n                };\n                connector.sourceID = '';\n                connector.sourcePortID = '';\n                connector.targetID = '';\n                connector.targetPortID = '';\n                newChanges = {\n                    sourceID: connector.sourceID, sourcePortID: connector.sourcePortID,\n                    targetID: connector.targetID, targetPortID: connector.targetPortID\n                };\n                var arg = {\n                    connector: cloneBlazorObject(connector), oldValue: oldChanges,\n                    newValue: newChanges, cancel: false, state: 'Changing', connectorEnd: endPoint\n                };\n                if (isBlazor()) {\n                    arg = {\n                        connector: cloneBlazorObject(connector),\n                        oldValue: { connector: cloneBlazorObject(oldChanges) },\n                        newValue: { connector: cloneBlazorObject(newChanges) },\n                        cancel: false, state: 'Changed', connectorEnd: endPoint\n                    };\n                    returnargs = arg;\n                }\n                if (!checkBlazor) {\n                    this.triggerEvent(DiagramEvent.connectionChange, arg);\n                }\n                if (arg.cancel) {\n                    connector.sourceID = oldChanges.sourceID;\n                    connector.sourcePortID = oldChanges.sourcePortID;\n                    connector.targetID = oldChanges.targetID;\n                    connector.targetPortID = oldChanges.targetPortID;\n                }\n                else {\n                    this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n                    this.diagram.updateDiagramObject(connector);\n                    arg = {\n                        connector: connector, oldValue: oldChanges,\n                        newValue: newChanges, cancel: false, state: 'Changed', connectorEnd: endPoint\n                    };\n                    if (isBlazor()) {\n                        arg = {\n                            connector: cloneBlazorObject(connector), oldValue: { connector: oldChanges },\n                            newValue: { connector: newChanges }, cancel: false, state: 'Changed', connectorEnd: endPoint\n                        };\n                        returnargs = arg;\n                    }\n                    if (!checkBlazor) {\n                        this.triggerEvent(DiagramEvent.connectionChange, arg);\n                    }\n                }\n            }\n        }\n        return returnargs;\n    };\n    CommandHandler.prototype.connectionEventChange = function (connector, oldChanges, newChanges, endPoint, canCancel) {\n        var checkBlazor = isBlazor();\n        var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n        var connectedNode;\n        if (this.enableCloneObject) {\n            connectedNode = this.diagram.nameTable[newChanges[nodeEndId]];\n            var nodeObject = cloneObject(connectedNode);\n            this.diagram.insertValue(nodeObject, true);\n        }\n        var returnargs;\n        var arg = {\n            cancel: false, state: 'Changing', connectorEnd: endPoint,\n            connector: cloneBlazorObject(connector), oldValue: { nodeId: oldChanges[nodeEndId], portId: oldChanges[portEndId] },\n            newValue: { nodeId: newChanges[nodeEndId], portId: newChanges[portEndId] }\n        };\n        if (isBlazor()) {\n            arg = {\n                connector: cloneBlazorObject(connector),\n                cancel: false, state: 'Changing', connectorEnd: endPoint,\n                oldValue: undefined, newValue: undefined\n            };\n            if (endPoint === 'ConnectorSourceEnd') {\n                arg.oldValue = {\n                    connectorSourceValue: {\n                        portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId]\n                    }\n                };\n                arg.newValue = {\n                    connectorSourceValue: { nodeId: newChanges[nodeEndId], portId: newChanges[portEndId] }\n                };\n            }\n            else {\n                arg.oldValue = {\n                    connectorTargetValue: { nodeId: oldChanges[nodeEndId], portId: oldChanges[portEndId] }\n                };\n                arg.newValue = {\n                    connectorTargetValue: { nodeId: newChanges[nodeEndId], portId: newChanges[portEndId] }\n                };\n            }\n            returnargs = arg;\n        }\n        if (!checkBlazor) {\n            this.triggerEvent(DiagramEvent.connectionChange, arg);\n        }\n        if (arg.cancel || (isBlazor() && canCancel)) {\n            connector[nodeEndId] = oldChanges[nodeEndId];\n            connector[portEndId] = oldChanges[portEndId];\n            newChanges = oldChanges;\n        }\n        else {\n            this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n            this.diagram.updateDiagramObject(connector);\n            arg = {\n                connector: cloneBlazorObject(connector), oldValue: { nodeId: oldChanges[nodeEndId], portId: oldChanges[portEndId] },\n                newValue: {\n                    nodeId: newChanges[nodeEndId],\n                    portId: newChanges[portEndId]\n                },\n                cancel: false, state: 'Changing', connectorEnd: endPoint\n            };\n            if (isBlazor()) {\n                arg = {\n                    connector: cloneBlazorObject(connector),\n                    oldValue: undefined,\n                    newValue: undefined,\n                    cancel: false, state: 'Changing', connectorEnd: endPoint\n                };\n                if (endPoint === 'ConnectorSourceEnd') {\n                    arg.newValue = {\n                        connectorSourceValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                    };\n                    arg.oldValue = {\n                        connectorSourceValue: { portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId] }\n                    };\n                }\n                else {\n                    arg.oldValue = {\n                        connectorTargetValue: { nodeId: oldChanges[nodeEndId], portId: oldChanges[portEndId] }\n                    };\n                    arg.newValue = {\n                        connectorTargetValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                    };\n                }\n                returnargs = arg;\n            }\n        }\n        if (this.enableCloneObject) {\n            if (connectedNode === undefined) {\n                connectedNode = this.diagram.nameTable[oldChanges[nodeEndId]];\n                var nodeObject = cloneObject(connectedNode);\n                this.diagram.insertValue(nodeObject, true);\n            }\n        }\n        return returnargs;\n    };\n    /**\n     * insertBlazorObject method\\\n     *\n     * @returns { void }    insertBlazorObject method .\\\n     * @param {IElement} object - provide the object value.\n     * @param {boolean} isNode - provide the isNode value.\n     * @private\n     */\n    CommandHandler.prototype.insertBlazorObject = function (object, isNode) {\n        var node;\n        var connector;\n        if (object instanceof Selector) {\n            this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n            for (var i = 0; i < object.nodes.length; i++) {\n                node = this.diagram.getObject(object.nodes[i].id);\n                this.diagram.insertValue(cloneObject(node), true);\n            }\n            for (var i = 0; i < object.connectors.length; i++) {\n                connector = this.diagram.getObject(object.connectors[i].id);\n                this.diagram.insertValue(cloneObject(connector), false);\n            }\n        }\n        else {\n            object = this.diagram.getObject(object.id);\n            this.diagram.insertValue(cloneObject(object), (object instanceof Node) ? true : false);\n        }\n    };\n    /**\n     * updatePropertiesToBlazor method\\\n     *\n     * @returns { void }    updatePropertiesToBlazor method .\\\n     * @param {MouseEventArgs} args - provide the args value.\n     * @param {PointModel} labelDrag - provide the labelDrag value.\n     * @private\n     */\n    CommandHandler.prototype.updatePropertiesToBlazor = function (args, labelDrag) {\n        this.enableCloneObject(false);\n        this.ismouseEvents(false);\n        this.getBlazorOldValues(args, labelDrag);\n        this.updateBlazorSelector();\n    };\n    /**\n     * insertSelectedObjects method\\\n     *\n     * @returns { void }    insertSelectedObjects method .\\\n     * @private\n     */\n    CommandHandler.prototype.insertSelectedObjects = function () {\n        this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n    };\n    /**\n     * findTarget method\\\n     *\n     * @returns { NodeModel | PointPortModel | ShapeAnnotationModel | PathAnnotationModel }    findTarget method .\\\n     * @param {DiagramElement} element - provide the element value.\n     * @param {IElement} argsTarget - provide the argsTarget value.\n     * @param {boolean} source - provide the source value.\n     * @param {boolean} connection - provide the connection value.\n     * @private\n     */\n    CommandHandler.prototype.findTarget = function (element, argsTarget, source, connection) {\n        var target;\n        if (argsTarget instanceof Node) {\n            if (element && element.id === argsTarget.id + '_content') {\n                return argsTarget;\n            }\n            if (source && argsTarget.shape.type === 'Bpmn' && ((!isBlazor() && argsTarget.shape.shape === 'Activity') ||\n                (isBlazor() && argsTarget.shape.bpmnShape === 'Activity'))) {\n                if (argsTarget.shape.activity.subProcess.type === 'Transaction') {\n                    var transaction = argsTarget.shape.activity.subProcess.transaction;\n                    if (transaction.success.visible && element.id.indexOf(argsTarget.id + '_success') === 0) {\n                        return transaction.success;\n                    }\n                    if (transaction.cancel.visible && element.id.indexOf(argsTarget.id + '_cancel') === 0) {\n                        return transaction.cancel;\n                    }\n                    if (transaction.failure.visible && element.id.indexOf(argsTarget.id + '_failure') === 0) {\n                        return transaction.failure;\n                    }\n                }\n            }\n            if (element instanceof PathElement) {\n                for (var i = 0; i < argsTarget.ports.length; i++) {\n                    var port = argsTarget.ports[i];\n                    if (element.id === argsTarget.id + '_' + port.id) {\n                        return port;\n                    }\n                }\n            }\n        }\n        if (!connection) {\n            var annotation = void 0;\n            for (var i = 0; i < argsTarget.annotations.length; i++) {\n                annotation = argsTarget.annotations[i];\n                if (element.id === argsTarget.id + '_' + annotation.id) {\n                    return annotation;\n                }\n            }\n        }\n        return argsTarget;\n    };\n    /**\n     * canDisconnect method\\\n     *\n     * @returns { boolean }    canDisconnect method .\\\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {MouseEventArgs} args - provide the args value.\n     * @param {string} targetPortId - provide the targetPortId value.\n     * @param {string} targetNodeId - provide the targetNodeId value.\n     * @private\n     */\n    CommandHandler.prototype.canDisconnect = function (endPoint, args, targetPortId, targetNodeId) {\n        var selector;\n        var connect;\n        if (args.source instanceof Selector) {\n            selector = args.source;\n            connect = selector.connectors[0];\n        }\n        else if (args.source instanceof Connector && this.diagram.currentDrawingObject) {\n            connect = this.diagram.currentDrawingObject;\n        }\n        var targetObject = this.findTarget(args.targetWrapper, args.target, endPoint === 'ConnectorSourceEnd', true);\n        var nodeEnd = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEnd = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n        if (connect[nodeEnd] !== targetNodeId || connect[portEnd] !== targetPortId) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * changeAnnotationDrag method\\\n     *\n     * @returns { void }    changeAnnotationDrag method .\\\n     * @param {MouseEventArgs} args - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.changeAnnotationDrag = function (args) {\n        var selectorModel;\n        var connector;\n        if (args.source && args.source.connectors &&\n            args.source.connectors.length && this.diagram.bpmnModule &&\n            this.diagram.bpmnModule.textAnnotationConnectors.indexOf(args.source.connectors[0]) > -1) {\n            if (args.source instanceof Selector) {\n                selectorModel = args.source;\n                connector = selectorModel.connectors[0];\n            }\n            var id = connector.id.split('_');\n            var annotationId = id[id.length - 1];\n            var nodeId = id[id.length - 3] || id[0];\n            if (args.target && args.target.id !== nodeId &&\n                ((!isBlazor() && args.target.shape.shape !== 'TextAnnotation') ||\n                    (isBlazor() && args.target.shape.bpmnShape !== 'TextAnnotation'))) {\n                this.diagram.startGroupAction();\n                var parentNode = this.diagram.nameTable[id[0]];\n                var clonedNode = this.getAnnotation(parentNode, id[1]);\n                var annotationNode = {\n                    id: id[1] + randomId(),\n                    angle: Point.findAngle(connector.intermediatePoints[0], connector.intermediatePoints[1]),\n                    text: clonedNode.text,\n                    length: Point.distancePoints(connector.intermediatePoints[0], connector.intermediatePoints[1]),\n                    shape: { shape: 'TextAnnotation', type: 'Bpmn' },\n                    nodeId: clonedNode.nodeId\n                };\n                var annotationObj = new BpmnAnnotation(args.target.shape, 'annotations', annotationNode, true);\n                this.diagram.bpmnModule.checkAndRemoveAnnotations(this.diagram.nameTable[connector.targetID], this.diagram);\n                this.diagram.refreshCanvasLayers();\n                annotationObj.id = id[1];\n                this.diagram.addTextAnnotation(annotationObj, args.target);\n                this.diagram.endGroupAction();\n            }\n            else if (connector) {\n                connector.sourceID = nodeId;\n                this.diagram.connectorPropertyChange(connector, {}, { sourceID: nodeId });\n                this.diagram.updateDiagramObject(connector);\n            }\n        }\n    };\n    /* tslint:disable */\n    /**\n     * connect method\\\n     *\n     * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    connect method .\\\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {MouseEventArgs} args - provide the args value.\n     * @param {boolean} canCancel - provide the canCancel value.\n     * @private\n     */\n    CommandHandler.prototype.connect = function (endPoint, args, canCancel) {\n        var checkBlazor;\n        var newChanges = {};\n        var oldChanges = {};\n        var oldNodeId;\n        var oldPortId;\n        var selectorModel;\n        var connector;\n        var returnargs;\n        if (args.source instanceof Selector) {\n            selectorModel = args.source;\n            connector = selectorModel.connectors[0];\n        }\n        else if (args.source instanceof Connector && this.diagram.currentDrawingObject) {\n            connector = this.diagram.currentDrawingObject;\n        }\n        var target = this.findTarget((args.targetWrapper || args.sourceWrapper), (args.target || args.actualObject), endPoint === 'ConnectorSourceEnd', true);\n        var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n        if (target instanceof Node) {\n            oldChanges[nodeEndId] = connector[nodeEndId];\n            connector[nodeEndId] = target.id;\n            newChanges[nodeEndId] = connector[nodeEndId];\n            oldChanges[portEndId] = connector[portEndId];\n            returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);\n        }\n        else {\n            oldNodeId = connector[nodeEndId];\n            oldPortId = connector[portEndId];\n            connector[portEndId] = target.id;\n            connector[nodeEndId] = (args.target && args.target.id || args.actualObject.id);\n            newChanges[nodeEndId] = connector[nodeEndId];\n            newChanges[portEndId] = connector[portEndId];\n            var arg = {\n                connector: cloneBlazorObject(connector), oldValue: { nodeId: oldNodeId, portId: oldPortId },\n                newValue: { nodeId: newChanges[nodeEndId], portId: newChanges[portEndId] },\n                cancel: false, state: 'Changing', connectorEnd: endPoint\n            };\n            if (isBlazor()) {\n                arg = {\n                    connector: cloneBlazorObject(connector),\n                    oldValue: undefined,\n                    newValue: undefined,\n                    cancel: false, state: 'Changing', connectorEnd: endPoint\n                };\n                if (endPoint === 'ConnectorSourceEnd') {\n                    arg.oldValue = {\n                        connectorSourceValue: { portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId] }\n                    };\n                    arg.newValue = {\n                        connectorSourceValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                    };\n                }\n                else {\n                    arg.newValue = {\n                        connectorTargetValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                    };\n                    arg.oldValue = {\n                        connectorTargetValue: { portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId] }\n                    };\n                }\n                returnargs = arg;\n            }\n            if (!checkBlazor) {\n                this.triggerEvent(DiagramEvent.connectionChange, arg);\n            }\n            if (arg.cancel || (isBlazor() && canCancel)) {\n                connector[nodeEndId] = oldNodeId;\n                connector[portEndId] = oldPortId;\n                newChanges[nodeEndId] = oldNodeId;\n                newChanges[portEndId] = oldPortId;\n            }\n            else {\n                this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n                this.diagram.updateDiagramObject(connector);\n                arg = {\n                    connector: cloneBlazorObject(connector), oldValue: { nodeId: oldNodeId, portId: oldPortId },\n                    newValue: { nodeId: newChanges[nodeEndId], portId: newChanges[portEndId] }, cancel: false,\n                    state: 'Changing', connectorEnd: endPoint\n                };\n                if (isBlazor()) {\n                    arg = {\n                        newValue: undefined,\n                        connector: cloneBlazorObject(connector),\n                        oldValue: undefined,\n                        cancel: false, state: 'Changing', connectorEnd: endPoint\n                    };\n                    if (endPoint === 'ConnectorSourceEnd') {\n                        arg.oldValue = {\n                            connectorSourceValue: { portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId] }\n                        };\n                        arg.newValue = {\n                            connectorTargetValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                        };\n                    }\n                    else {\n                        arg.oldValue = {\n                            connectorTargetValue: { portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId] }\n                        };\n                        arg.newValue = {\n                            connectorTargetValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                        };\n                    }\n                }\n            }\n        }\n        this.renderHighlighter(args, undefined, endPoint === 'ConnectorSourceEnd');\n        return returnargs;\n    };\n    /* tslint:enable */\n    /** @private */\n    /**\n     * cut method\\\n     *\n     * @returns { void }    cut method .\\\n     * @private\n     */\n    CommandHandler.prototype.cut = function () {\n        var index;\n        this.clipboardData.pasteIndex = 0;\n        if (this.diagram.undoRedoModule) {\n            this.diagram.historyManager.startGroupAction();\n        }\n        this.clipboardData.clipObject = this.copyObjects();\n        if (this.diagram.undoRedoModule) {\n            this.diagram.historyManager.endGroupAction();\n        }\n        if (this.diagram.mode !== 'SVG') {\n            this.diagram.refreshDiagramLayer();\n        }\n    };\n    CommandHandler.prototype.UpdateBlazorDiagramModelLayers = function (layer, isRemove) {\n        var blazorInterop = 'sfBlazor';\n        var updatedModel = cloneBlazorObject(layer);\n        var blazor = 'Blazor';\n        if (window && window[blazor]) {\n            var obj = {\n                'methodName': 'UpdateBlazorDiagramModelLayers',\n                'diagramobj': JSON.stringify(updatedModel), 'isRemove': isRemove\n            };\n            if (!this.diagram.isLoading) {\n                window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n            }\n        }\n    };\n    /**\n     * addLayer method\\\n     *\n     * @returns { void }    addLayer method .\\\n     * @param {LayerModel} layer - provide the endPoint value.\n     * @param {Object[]} objects - provide the args value.\n     * @param {boolean} isServerUpdate - provide the canCancel value.\n     * @private\n     */\n    CommandHandler.prototype.addLayer = function (layer, objects, isServerUpdate) {\n        if (isServerUpdate === void 0) { isServerUpdate = true; }\n        layer.id = layer.id || randomId();\n        layer.zIndex = this.diagram.layers.length;\n        var isEnableServerDatabind = this.diagram.allowServerDataBinding;\n        this.diagram.enableServerDataBinding(false);\n        layer = new Layer(this.diagram, 'layers', layer, true);\n        this.diagram.enableServerDataBinding(isEnableServerDatabind);\n        layer.objectZIndex = -1;\n        layer.zIndexTable = {};\n        this.diagram.layers.push(layer);\n        if (isServerUpdate) {\n            this.UpdateBlazorDiagramModelLayers(layer, false);\n        }\n        this.diagram.layerZIndexTable[layer.zIndex] = layer.id;\n        this.diagram.activeLayer = layer;\n        var layers = layer.objects;\n        if (objects) {\n            for (var i = 0; i < objects.length; i++) {\n                this.diagram.add(objects[i]);\n            }\n        }\n    };\n    /**\n     * getObjectLayer method\\\n     *\n     * @returns { LayerModel }    getObjectLayer method .\\\n     * @param {string} objectName - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.getObjectLayer = function (objectName) {\n        var layers = this.diagram.layers;\n        for (var i = 0; i < layers.length; i++) {\n            var objIndex = layers[i].objects.indexOf(objectName);\n            if (objIndex > -1) {\n                return layers[i];\n            }\n        }\n        return this.diagram.activeLayer;\n    };\n    /**\n     * getLayer method\\\n     *\n     * @returns { LayerModel }    getLayer method .\\\n     * @param {string} layerName - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.getLayer = function (layerName) {\n        var layers = this.diagram.layers;\n        for (var i = 0; i < layers.length; i++) {\n            if (layers[i].id === layerName) {\n                return layers[i];\n            }\n        }\n        return undefined;\n    };\n    /**\n     * removeLayer method\\\n     *\n     * @returns { void }    removeLayer method .\\\n     * @param {string} layerId - provide the endPoint value.\n     * @param {boolean} isServerUpdate - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.removeLayer = function (layerId, isServerUpdate) {\n        if (isServerUpdate === void 0) { isServerUpdate = true; }\n        var layers = this.getLayer(layerId);\n        if (layers) {\n            var index = this.diagram.layers.indexOf(layers);\n            var layerObject = layers.objects;\n            for (var i = layerObject.length - 1; i >= 0; i--) {\n                this.diagram.unSelect(this.diagram.nameTable[layerObject[i]]);\n                this.diagram.remove(this.diagram.nameTable[layerObject[i]]);\n                if (layers.id !== 'default_layer') {\n                    if (this.diagram.activeLayer.id === layerId) {\n                        this.diagram.activeLayer = this.diagram.layers[this.diagram.layers.length - 1];\n                    }\n                }\n            }\n            if (isServerUpdate) {\n                this.UpdateBlazorDiagramModelLayers(this.diagram.layers[index], true);\n            }\n            delete this.diagram.layerZIndexTable[layers.zIndex];\n            this.diagram.layers.splice(index, 1);\n            if (this.diagram.mode !== 'SVG') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * moveObjects method\\\n     *\n     * @returns { void }    moveObjects method .\\\n     * @param {string[]]} objects - provide the objects value.\n     * @param {string} targetLayer - provide the targetLayer value.\n     * @private\n     */\n    CommandHandler.prototype.moveObjects = function (objects, targetLayer) {\n        var layer = this.getLayer(targetLayer) || this.diagram.activeLayer;\n        this.diagram.setActiveLayer(layer.id);\n        var targerNodes;\n        for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {\n            var i = objects_1[_i];\n            var layer_1 = this.getObjectLayer(i);\n            var index = layer_1.objects.indexOf(i);\n            if (index > -1) {\n                targerNodes = this.diagram.nameTable[i];\n                this.diagram.unSelect(targerNodes);\n                this.diagram.remove(this.diagram.nameTable[i]);\n                this.diagram.add(targerNodes);\n            }\n        }\n    };\n    /**\n     * cloneLayer method\\\n     *\n     * @returns { void }    cloneLayer method .\\\n     * @param {string[]} layerName - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.cloneLayer = function (layerName) {\n        var layers = this.diagram.layers;\n        var layer = this.getLayer(layerName);\n        if (layer) {\n            var cloneObject_1 = [];\n            var newlayer = {\n                id: layerName + '_' + randomId(), objects: [], visible: true, lock: false\n            };\n            this.addLayer(newlayer, null, true);\n            newlayer.zIndex = this.diagram.layers.length - 1;\n            var multiSelect = cloneObject_1.length !== 1;\n            for (var _i = 0, _a = layer.objects; _i < _a.length; _i++) {\n                var obj = _a[_i];\n                cloneObject_1.push(this.diagram.nameTable[obj]);\n            }\n            this.paste(cloneObject_1);\n        }\n    };\n    /**\n     * copy method\\\n     *\n     * @returns { void }    copy method .\\\n     * @private\n     */\n    CommandHandler.prototype.copy = function () {\n        this.clipboardData.pasteIndex = 1;\n        this.clipboardData.clipObject = this.copyObjects();\n        return this.clipboardData.clipObject;\n    };\n    /**\n     * copyObjects method\\\n     *\n     * @returns { Object[] }    copyObjects method .\\\n     * @private\n     */\n    CommandHandler.prototype.copyObjects = function () {\n        var selectedItems = [];\n        var obj = [];\n        this.clipboardData.childTable = {};\n        if (this.diagram.selectedItems.connectors.length > 0) {\n            selectedItems = this.diagram.selectedItems.connectors;\n            for (var j = 0; j < selectedItems.length; j++) {\n                var element = void 0;\n                if (this.diagram.bpmnModule &&\n                    this.diagram.bpmnModule.textAnnotationConnectors.indexOf(selectedItems[j]) > -1) {\n                    element = cloneObject((this.diagram.nameTable[selectedItems[j].targetID]));\n                }\n                else {\n                    element = cloneObject((selectedItems[j]));\n                }\n                obj.push(element);\n            }\n        }\n        if (this.diagram.selectedItems.nodes.length > 0) {\n            selectedItems = selectedItems.concat(this.diagram.selectedItems.nodes);\n            for (var j = 0; j < this.diagram.selectedItems.nodes.length; j++) {\n                if (!selectedItems[j].isPhase) {\n                    var node = clone(this.diagram.selectedItems.nodes[j]);\n                    if (node.wrapper && (node.offsetX !== node.wrapper.offsetX)) {\n                        node.offsetX = node.wrapper.offsetX;\n                    }\n                    if (node.wrapper && (node.offsetY !== node.wrapper.offsetY)) {\n                        node.offsetY = node.wrapper.offsetY;\n                    }\n                    var processTable = {};\n                    this.copyProcesses(node);\n                    obj.push(clone(node));\n                    var matrix = identityMatrix();\n                    rotateMatrix(matrix, -node.rotateAngle, node.offsetX, node.offsetY);\n                    if (node.children) {\n                        var childTable = this.clipboardData.childTable;\n                        var tempNode = void 0;\n                        var elements = [];\n                        var nodes = this.getAllDescendants(node, elements, true);\n                        for (var i = 0; i < nodes.length; i++) {\n                            tempNode = this.diagram.nameTable[nodes[i].id];\n                            var clonedObject = childTable[tempNode.id] = clone(tempNode);\n                            var newOffset = transformPointByMatrix(matrix, { x: clonedObject.wrapper.offsetX, y: clonedObject.wrapper.offsetY });\n                            if (tempNode instanceof Node) {\n                                clonedObject.offsetX = newOffset.x;\n                                clonedObject.offsetY = newOffset.y;\n                                clonedObject.rotateAngle -= node.rotateAngle;\n                            }\n                        }\n                        this.clipboardData.childTable = childTable;\n                    }\n                    if (node.shape.type === 'SwimLane') {\n                        var swimlane = this.diagram.getObject(this.diagram.selectedItems.nodes[j].id);\n                        var childTable = this.clipboardData.childTable;\n                        var connectorsList = getConnectors(this.diagram, swimlane.wrapper.children[0], 0, true);\n                        for (var i = 0; i < connectorsList.length; i++) {\n                            var connector = this.diagram.getObject(connectorsList[i]);\n                            childTable[connector.id] = clone(connector);\n                        }\n                    }\n                    if (node && node.isLane) {\n                        var childTable = this.clipboardData.childTable;\n                        var swimlane = this.diagram.getObject(node.parentId);\n                        var lane = findLane(node, this.diagram);\n                        childTable[node.id] = cloneObject(lane);\n                        childTable[node.id].width = swimlane.wrapper.actualSize.width;\n                    }\n                }\n            }\n        }\n        if (this.clipboardData.pasteIndex === 0) {\n            this.startGroupAction();\n            for (var _i = 0, selectedItems_1 = selectedItems; _i < selectedItems_1.length; _i++) {\n                var item = selectedItems_1[_i];\n                if (this.diagram.nameTable[item.id]) {\n                    if (this.diagram.bpmnModule &&\n                        this.diagram.bpmnModule.textAnnotationConnectors.indexOf(item) > -1) {\n                        this.diagram.remove(this.diagram.nameTable[item.targetID]);\n                    }\n                    else {\n                        this.diagram.remove(item);\n                    }\n                }\n            }\n            this.endGroupAction();\n        }\n        this.sortByZIndex(obj, 'zIndex');\n        return obj;\n    };\n    CommandHandler.prototype.copyProcesses = function (node) {\n        if (node.shape.type === 'Bpmn' && node.shape.activity &&\n            node.shape.activity.subProcess.processes &&\n            node.shape.activity.subProcess.processes.length > 0) {\n            var processes = node.shape.activity.subProcess.processes;\n            for (var _i = 0, processes_1 = processes; _i < processes_1.length; _i++) {\n                var i = processes_1[_i];\n                this.processTable[i] = (clone(this.diagram.nameTable[i]));\n                if (this.processTable[i].shape.activity.subProcess.processes &&\n                    this.processTable[i].shape.activity.subProcess.processes.length > 0) {\n                    this.copyProcesses(this.processTable[i]);\n                }\n            }\n            this.clipboardData.processTable = this.processTable;\n        }\n    };\n    /**\n     * group method\\\n     *\n     * @returns { void }    group method .\\\n     * @private\n     */\n    CommandHandler.prototype.group = function () {\n        this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n        var propName = 'isProtectedOnChange';\n        var protectedChange = this.diagram[propName];\n        this.diagram.protectPropertyChange(true);\n        this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Group;\n        var selectedItems = [];\n        var obj = {};\n        //let group: Node | Connector;\n        obj.id = 'group' + randomId();\n        obj = new Node(this.diagram, 'nodes', obj, true);\n        obj.children = [];\n        selectedItems = this.diagram.selectedItems.nodes;\n        selectedItems = selectedItems.concat(this.diagram.selectedItems.connectors);\n        var order = selectedItems.sort(function (a, b) {\n            return a.zIndex - b.zIndex;\n        });\n        for (var i = 0; i < order.length; i++) {\n            if (!order[i].parentId) {\n                obj.children.push(order[i].id);\n            }\n        }\n        var group = this.diagram.add(obj);\n        if (group) {\n            this.select(group);\n        }\n        var entry = { type: 'Group', undoObject: obj, redoObject: obj, category: 'Internal' };\n        this.addHistoryEntry(entry);\n        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Group;\n        this.diagram.protectPropertyChange(protectedChange);\n        this.updateBlazorSelector();\n    };\n    /**\n     * unGroup method\\\n     *\n     * @returns {  void }    unGroup method .\\\n     * @param {NodeModel} obj - provide the angle value.\n     * @private\n     */\n    CommandHandler.prototype.unGroup = function (obj) {\n        var propName = 'isProtectedOnChange';\n        var protectedChange = this.diagram[propName];\n        this.diagram.protectPropertyChange(true);\n        this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Group;\n        var selectedItems = [];\n        if (obj) {\n            selectedItems.push(obj);\n        }\n        else {\n            selectedItems = this.diagram.selectedItems.nodes;\n        }\n        this.diagram.startGroupAction();\n        for (var i = 0; i < selectedItems.length; i++) {\n            var node = selectedItems[i];\n            var undoObject = cloneObject(node);\n            var childCollection = [];\n            for (var k = 0; k < node.children.length; k++) {\n                childCollection.push(node.children[k]);\n            }\n            if (node.children) {\n                if (node.ports && node.ports.length > 0) {\n                    this.diagram.removePorts(node, node.ports);\n                }\n                if (node.annotations && node.annotations.length > 0\n                    && (!isBlazor() || isBlazor() && node.annotations[0].content !== '')) {\n                    this.diagram.removeLabels(node, node.annotations);\n                }\n                var parentNode = this.diagram.nameTable[node.parentId];\n                for (var j = node.children.length - 1; j >= 0; j--) {\n                    (this.diagram.nameTable[node.children[j]]).parentId = '';\n                    this.diagram.deleteChild(this.diagram.nameTable[node.children[j]], node);\n                    if (node.parentId && node.children[j]) {\n                        this.diagram.addChild(parentNode, node.children[j]);\n                    }\n                }\n                this.resetDependentConnectors(node.inEdges, true);\n                this.resetDependentConnectors(node.outEdges, false);\n                var entry = {\n                    type: 'UnGroup', undoObject: undoObject,\n                    redoObject: undoObject, category: 'Internal'\n                };\n                if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    this.addHistoryEntry(entry);\n                }\n                if (node.parentId) {\n                    this.diagram.deleteChild(node, parentNode);\n                }\n            }\n            this.diagram.removeNode(node, childCollection);\n            this.clearSelection();\n        }\n        this.diagram.endGroupAction();\n        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Group;\n        this.diagram.protectPropertyChange(protectedChange);\n    };\n    CommandHandler.prototype.resetDependentConnectors = function (edges, isInEdges) {\n        for (var i = 0; i < edges.length; i++) {\n            var newConnector = this.diagram.nameTable[edges[i]];\n            var undoObject = cloneObject(newConnector);\n            var newProp = void 0;\n            if (isInEdges) {\n                newConnector.targetID = '';\n                newConnector.targetPortID = '';\n                newProp = { targetID: newConnector.targetID, targetPortID: newConnector.targetPortID };\n            }\n            else {\n                newConnector.sourceID = '';\n                newConnector.sourcePortID = '';\n                newProp = { sourceID: newConnector.sourceID, sourcePortID: newConnector.sourcePortID };\n            }\n            this.diagram.connectorPropertyChange(newConnector, {}, newProp);\n            var entry = {\n                type: 'ConnectionChanged', undoObject: { connectors: [undoObject], nodes: [] },\n                redoObject: { connectors: [cloneObject(newConnector)], nodes: [] }, category: 'Internal'\n            };\n            if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                this.addHistoryEntry(entry);\n            }\n        }\n    };\n    /**\n     * paste method\\\n     *\n     * @returns { void }    paste method .\\\n     * @param {(NodeModel | ConnectorModel)[]} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.paste = function (obj) {\n        if (obj || this.clipboardData.clipObject) {\n            this.diagram.protectPropertyChange(true);\n            var copiedItems = obj ? this.getNewObject(obj) :\n                this.clipboardData.clipObject;\n            if (copiedItems) {\n                var multiSelect = copiedItems.length !== 1;\n                var groupAction = false;\n                var objectTable = {};\n                var keyTable = {};\n                if (this.clipboardData.pasteIndex !== 0) {\n                    this.clearSelection();\n                }\n                if (this.diagram.undoRedoModule) {\n                    groupAction = true;\n                    this.diagram.historyManager.startGroupAction();\n                }\n                for (var _i = 0, copiedItems_1 = copiedItems; _i < copiedItems_1.length; _i++) {\n                    var copy = copiedItems_1[_i];\n                    objectTable[copy.id] = copy;\n                }\n                var copiedObject = [];\n                if (multiSelect) {\n                    // This bool is also consider to prevent selection change event is triggered after every object clone\n                    this.diagram.isServerUpdate = true;\n                }\n                for (var j = 0; j < copiedItems.length; j++) {\n                    var copy = copiedItems[j];\n                    if (getObjectType(copy) === Connector) {\n                        var clonedObj = clone(copy);\n                        var nodeId = clonedObj.sourceID;\n                        clonedObj.sourceID = '';\n                        if (objectTable[nodeId] && keyTable[nodeId]) {\n                            clonedObj.sourceID = keyTable[nodeId];\n                        }\n                        nodeId = clonedObj.targetID;\n                        clonedObj.targetID = '';\n                        if (objectTable[nodeId] && keyTable[nodeId]) {\n                            clonedObj.targetID = keyTable[nodeId];\n                        }\n                        var newObj = this.cloneConnector(clonedObj, multiSelect);\n                        copiedObject.push(newObj);\n                        keyTable[copy.id] = newObj.id;\n                    }\n                    else {\n                        var newNode = this.cloneNode(copy, multiSelect);\n                        if (isBlazor() && newNode && newNode.children && newNode.children.length > 0) {\n                            copiedObject = copiedObject.concat(this.cloneGroupChildCollection);\n                            this.cloneGroupChildCollection = [];\n                        }\n                        else {\n                            copiedObject.push(newNode);\n                        }\n                        //bpmn text annotations will not be pasted\n                        if (newNode) {\n                            keyTable[copy.id] = newNode.id;\n                            var edges = copy.inEdges;\n                            if (edges) {\n                                for (var _a = 0, edges_1 = edges; _a < edges_1.length; _a++) {\n                                    var edge = edges_1[_a];\n                                    if (objectTable[edge] && keyTable[edge]) {\n                                        var newConnector = this.diagram.nameTable[keyTable[edge]];\n                                        newConnector.targetID = keyTable[copy.id];\n                                        this.diagram.connectorPropertyChange(newConnector, { targetID: '', targetPortID: '' }, { targetID: newConnector.targetID, targetPortID: newConnector.targetPortID });\n                                    }\n                                }\n                            }\n                            edges = copy.outEdges;\n                            if (edges) {\n                                for (var _b = 0, edges_2 = edges; _b < edges_2.length; _b++) {\n                                    var edge = edges_2[_b];\n                                    if (objectTable[edge] && keyTable[edge]) {\n                                        var newConnector = this.diagram.nameTable[keyTable[edge]];\n                                        newConnector.sourceID = keyTable[copy.id];\n                                        this.diagram.connectorPropertyChange(newConnector, { sourceID: '', sourcePortID: '' }, { sourceID: newConnector.sourceID, sourcePortID: newConnector.sourcePortID });\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (multiSelect) {\n                    this.diagram.isServerUpdate = false;\n                    this.diagram.UpdateBlazorDiagramModelCollection(copiedItems[0], copiedObject);\n                    this.getBlazorOldValues();\n                    this.diagram.select(copiedObject, true);\n                }\n                if (groupAction === true) {\n                    this.diagram.historyManager.endGroupAction();\n                    groupAction = false;\n                }\n                if (this.diagram.mode !== 'SVG') {\n                    this.diagram.refreshDiagramLayer();\n                }\n                this.clipboardData.pasteIndex++;\n                this.diagram.protectPropertyChange(false);\n            }\n        }\n    };\n    CommandHandler.prototype.getNewObject = function (obj) {\n        var newObj;\n        var newobjs = [];\n        this.clipboardData.pasteIndex = 1;\n        for (var i = 0; i < obj.length; i++) {\n            newObj = cloneObject(obj[i]);\n            newobjs.push(newObj);\n        }\n        return newobjs;\n    };\n    CommandHandler.prototype.cloneConnector = function (connector, multiSelect) {\n        //let newConnector: Node | Connector;\n        var cloneObject = clone(connector);\n        this.translateObject(cloneObject);\n        cloneObject.zIndex = -1;\n        var newConnector = this.diagram.add(cloneObject);\n        if (!this.diagram.isServerUpdate) {\n            this.selectObjects([newConnector], multiSelect);\n        }\n        return newConnector;\n    };\n    CommandHandler.prototype.cloneNode = function (node, multiSelect, children, groupnodeID) {\n        var newNode;\n        var connectorsTable = {};\n        var cloneObject = clone(node);\n        var process;\n        var temp = this.diagram.nameTable[node.parentId];\n        if (node.shape && node.shape.type === 'Bpmn' && node.shape.activity &&\n            node.shape.activity.subProcess.processes\n            && node.shape.activity.subProcess.processes.length) {\n            process = cloneObject.shape.activity.subProcess.processes;\n            cloneObject.zIndex = -1;\n            cloneObject.shape.activity.subProcess.processes = undefined;\n        }\n        if (node.shape && node.shape.type === 'SwimLane') {\n            pasteSwimLane(node, this.diagram, this.clipboardData);\n        }\n        else if (temp && temp.shape.type === 'SwimLane') {\n            pasteSwimLane(clone(temp), this.diagram, this.clipboardData, node, true);\n        }\n        else if (node.children && node.children.length && (!children || !children.length)) {\n            newNode = this.cloneGroup(node, multiSelect);\n        }\n        else if (node.shape && ((!isBlazor() && node.shape.shape === 'TextAnnotation') ||\n            (isBlazor() && node.shape.bpmnShape === 'TextAnnotation')) && node.id.indexOf('_textannotation_') !== -1 &&\n            this.diagram.nameTable[node.id]) {\n            var checkAnnotation = node.id.split('_textannotation_');\n            //const parentNode: Node;\n            var annotation = this.diagram.nameTable[node.id];\n            for (var j = 0; j < annotation.inEdges.length; j++) {\n                var connector = this.diagram.nameTable[annotation.inEdges[j]];\n                if (connector) {\n                    var parentNode = this.diagram.nameTable[connector.sourceID];\n                    var clonedNode = this.getAnnotation(parentNode, checkAnnotation[1]);\n                    var annotationNode = {\n                        id: checkAnnotation[1] + randomId(),\n                        angle: clonedNode.angle,\n                        text: clonedNode.text,\n                        length: clonedNode.length,\n                        shape: { shape: 'TextAnnotation', type: 'Bpmn' },\n                        nodeId: clonedNode.nodeId\n                    };\n                    this.diagram.addTextAnnotation(annotationNode, parentNode);\n                }\n            }\n        }\n        else {\n            this.translateObject(cloneObject, groupnodeID);\n            cloneObject.zIndex = -1;\n            if (children) {\n                cloneObject.children = children;\n            }\n            newNode = this.diagram.add(cloneObject);\n        }\n        for (var _i = 0, _a = Object.keys(connectorsTable); _i < _a.length; _i++) {\n            var i = _a[_i];\n            this.diagram.add(connectorsTable[i]);\n        }\n        if (process && process.length) {\n            newNode.shape.activity.subProcess.processes = process;\n            this.cloneSubProcesses(newNode);\n        }\n        if (newNode && !this.diagram.isServerUpdate) {\n            this.selectObjects([newNode], multiSelect);\n        }\n        return newNode;\n    };\n    CommandHandler.prototype.getAnnotation = function (parent, annotationId) {\n        var currentAnnotation = parent.shape.annotations;\n        if (currentAnnotation && currentAnnotation.length) {\n            for (var g = 0; g <= currentAnnotation.length; g++) {\n                if (currentAnnotation[g].id === annotationId) {\n                    return currentAnnotation[g];\n                }\n            }\n        }\n        return undefined;\n    };\n    CommandHandler.prototype.cloneSubProcesses = function (node) {\n        var connector = [];\n        var temp = {};\n        if (node.shape.type === 'Bpmn' && node.shape.activity &&\n            node.shape.activity.subProcess.processes\n            && node.shape.activity.subProcess.processes.length) {\n            var process = node.shape.activity.subProcess.processes;\n            for (var g = 0; g < process.length; g++) {\n                var child = this.diagram.nameTable[process[g]] || this.clipboardData.processTable[process[g]];\n                for (var _i = 0, _a = child.outEdges; _i < _a.length; _i++) {\n                    var j = _a[_i];\n                    if (connector.indexOf(j) < 0) {\n                        connector.push(j);\n                    }\n                }\n                for (var _b = 0, _c = child.inEdges; _b < _c.length; _b++) {\n                    var j = _c[_b];\n                    if (connector.indexOf(j) < 0) {\n                        connector.push(j);\n                    }\n                }\n                var innerChild = cloneObject(this.clipboardData.processTable[process[g]]);\n                innerChild.processId = node.id;\n                var newNode = this.cloneNode(innerChild, false);\n                temp[process[g]] = newNode.id;\n                process[g] = newNode.id;\n                this.diagram.addProcess(newNode, node.id);\n                for (var _d = 0, connector_1 = connector; _d < connector_1.length; _d++) {\n                    var i = connector_1[_d];\n                    var node_1 = this.diagram.nameTable[i] || this.diagram.connectorTable[i];\n                    var clonedNode = cloneObject(node_1);\n                    if (temp[clonedNode.sourceID] && temp[clonedNode.targetID]) {\n                        clonedNode.zIndex = -1;\n                        clonedNode.id += randomId();\n                        clonedNode.sourceID = temp[clonedNode.sourceID];\n                        clonedNode.targetID = temp[clonedNode.targetID];\n                        connector.splice(connector.indexOf(i), 1);\n                        this.diagram.add(clonedNode);\n                    }\n                }\n            }\n        }\n    };\n    CommandHandler.prototype.cloneGroup = function (obj, multiSelect) {\n        var value;\n        var newChildren = [];\n        var children = [];\n        var connectorObj = [];\n        var newObj;\n        var oldID = [];\n        children = children.concat(obj.children);\n        var id = randomId();\n        var objectCollection = [];\n        this.diagram.blazorActions |= BlazorAction.GroupClipboardInProcess;\n        if (this.clipboardData.childTable || obj.children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n                var childObj = void 0;\n                if (this.clipboardData.childTable) {\n                    childObj = this.clipboardData.childTable[children[i]];\n                }\n                else {\n                    childObj = this.diagram.nameTable[children[i]];\n                }\n                childObj.parentId = '';\n                if (childObj) {\n                    if (getObjectType(childObj) === Connector) {\n                        connectorObj.push(childObj);\n                    }\n                    else {\n                        newObj = this.cloneNode(childObj, multiSelect, undefined, id);\n                        oldID.push(childObj.id);\n                        newChildren.push(newObj.id);\n                        objectCollection.push(newObj);\n                    }\n                }\n            }\n        }\n        for (var k = 0; k < connectorObj.length; k++) {\n            if (connectorObj[k].sourceID || connectorObj[k].targetID) {\n                for (var j = 0; j < oldID.length; j++) {\n                    if (connectorObj[k].sourceID === (oldID[j])) {\n                        connectorObj[k].sourceID += id;\n                    }\n                    if (connectorObj[k].targetID === (oldID[j])) {\n                        connectorObj[k].targetID += id;\n                    }\n                }\n            }\n            newObj = this.cloneConnector(connectorObj[k], multiSelect);\n            newChildren.push(newObj.id);\n            objectCollection.push(newObj);\n        }\n        var parentObj = this.cloneNode(obj, multiSelect, newChildren);\n        objectCollection.push(parentObj);\n        if (parentObj && parentObj.container && parentObj.shape && parentObj.shape.type === 'UmlClassifier') {\n            this.diagram.updateDiagramObject(parentObj);\n            parentObj.wrapper.measure(new Size());\n        }\n        this.diagram.blazorActions &= ~BlazorAction.GroupClipboardInProcess;\n        if (!this.diagram.isServerUpdate) {\n            this.diagram.UpdateBlazorDiagramModelCollection(undefined, objectCollection, undefined, true);\n        }\n        else {\n            this.cloneGroupChildCollection = objectCollection;\n        }\n        return parentObj;\n    };\n    /**\n     * translateObject method\\\n     *\n     * @returns { Object[] }    translateObject method .\\\n     * @param {Node | Connector} obj - provide the objects value.\n     * @param {string} groupnodeID - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.translateObject = function (obj, groupnodeID) {\n        obj.id += groupnodeID || randomId();\n        var diff = this.clipboardData.pasteIndex * 10;\n        if (getObjectType(obj) === Connector) {\n            obj.sourcePoint = {\n                x: obj.sourcePoint.x + diff, y: obj.sourcePoint.y + diff\n            };\n            obj.targetPoint = {\n                x: obj.targetPoint.x + diff, y: obj.targetPoint.y + diff\n            };\n            if (obj.type === 'Bezier') {\n                var segments = obj.segments;\n                for (var i = 0; i < segments.length; i++) {\n                    if (!Point.isEmptyPoint(segments[i].point1)) {\n                        segments[i].point1 = {\n                            x: segments[i].point1.x + diff, y: segments[i].point1.y + diff\n                        };\n                    }\n                    if (!Point.isEmptyPoint(segments[i].point2)) {\n                        segments[i].point2 = {\n                            x: segments[i].point2.x + diff, y: segments[i].point2.y + diff\n                        };\n                    }\n                }\n            }\n            if (obj.type === 'Straight' || obj.type === 'Bezier') {\n                if (obj.segments && obj.segments.length > 0) {\n                    var segments = obj.segments;\n                    for (var i = 0; i < segments.length - 1; i++) {\n                        segments[i].point.x += diff;\n                        segments[i].point.y += diff;\n                    }\n                }\n            }\n        }\n        else {\n            obj.offsetX += diff;\n            obj.offsetY += diff;\n        }\n    };\n    /**\n     * drawObject method\\\n     *\n     * @returns { Node | Connector }    drawObject method .\\\n     * @param {Node | Connector} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.drawObject = function (obj) {\n        var oldProtectPropertyChangeValue;\n        if (isBlazor()) {\n            oldProtectPropertyChangeValue = this.diagram.getProtectPropertyChangeValue();\n            this.diagram.protectPropertyChange(true);\n        }\n        var newObj;\n        //let cloneObject: Node | Connector;\n        if (obj && obj.shape) {\n            if (obj.shape.type === 'Text') {\n                obj.width = this.diagram.drawingObject.width ? this.diagram.drawingObject.width : 50;\n                obj.height = this.diagram.drawingObject.height ? this.diagram.drawingObject.height : 20;\n            }\n        }\n        var cloneObject = clone(this.diagram.drawingObject);\n        for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n            var prop = _a[_i];\n            cloneObject[prop] = obj[prop];\n        }\n        if (getObjectType(this.diagram.drawingObject) === Node) {\n            newObj = new Node(this.diagram, 'nodes', cloneObject, true);\n            newObj.id = (this.diagram.drawingObject.id || 'node') + randomId();\n        }\n        else {\n            newObj = new Connector(this.diagram, 'connectors', cloneObject, true);\n            if (isBlazor() && !this.diagram.drawingObject) {\n                newObj.type === 'Orthogonal';\n            }\n            newObj.id = (this.diagram.drawingObject ? (this.diagram.drawingObject.id ? this.diagram.drawingObject.id : 'connector')\n                : 'connector') + randomId();\n        }\n        if (isBlazor()) {\n            updateDefaultValues(newObj, cloneObject, (getObjectType(this.diagram.drawingObject) === Node) ? this.diagram.nodeDefaults : this.diagram.connectorDefaults);\n        }\n        this.diagram.initObject(newObj);\n        this.diagram.updateDiagramObject(newObj);\n        this.diagram.currentDrawingObject = newObj;\n        if (isBlazor()) {\n            this.diagram.protectPropertyChange(oldProtectPropertyChangeValue);\n        }\n        return newObj;\n    };\n    /**\n     * addObjectToDiagram method\\\n     *\n     * @returns { void }    addObjectToDiagram method .\\\n     * @param {Node | Connector} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.addObjectToDiagram = function (obj) {\n        //let newObj: Node | Connector;\n        this.diagram.removeFromAQuad(obj);\n        this.diagram.removeObjectsFromLayer(this.diagram.nameTable[obj.id]);\n        delete this.diagram.nameTable[obj.id];\n        var newObj = this.diagram.add(obj);\n        if (this.diagram.mode !== 'SVG') {\n            this.diagram.refreshDiagramLayer();\n        }\n        this.selectObjects([newObj]);\n        if (obj && (!(canContinuousDraw(this.diagram)))) {\n            this.diagram.tool &= ~DiagramTools.DrawOnce;\n            this.diagram.currentDrawingObject = undefined;\n        }\n    };\n    /**\n     * addObjectToDiagram method\\\n     *\n     * @returns { void }    addObjectToDiagram method .\\\n     * @param {boolean} enable - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.enableServerDataBinding = function (enable) {\n        this.diagram.enableServerDataBinding(enable);\n    };\n    /**\n     * addText method\\\n     *\n     * @returns { void }    addText method .\\\n     * @param {boolean} obj - provide the objects value.\n     * @param {PointModel} currentPosition - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.addText = function (obj, currentPosition) {\n        var annotation = this.diagram.findElementUnderMouse(obj, currentPosition);\n        this.diagram.startTextEdit(obj, annotation instanceof TextElement ? (annotation.id).split('_')[1] : undefined);\n    };\n    CommandHandler.prototype.updateArgsObject = function (obj, arg1, argValue) {\n        if (obj) {\n            var connector = void 0;\n            for (var i = 0; i < obj.length; i++) {\n                connector = (getObjectType(obj[i]) === Connector);\n                if (connector) {\n                    // In Blazor web assembly, deserialize the object. Itb takes time. - Suganthi\n                    //argValue.connectors.push(cloneBlazorObject(obj[i]));\n                    argValue.connectorCollection.push(obj[i].id);\n                }\n                else {\n                    //argValue.nodes.push(cloneBlazorObject(obj[i]));\n                    argValue.nodeCollection.push(obj[i].id);\n                }\n                //connector ? argValue.connectors.push(cloneBlazorObject(obj[i])) : argValue.nodes.push(cloneBlazorObject(obj[i]));\n            }\n        }\n    };\n    CommandHandler.prototype.updateSelectionChangeEventArgs = function (arg, obj, oldValue) {\n        if (isBlazor()) {\n            arg = {\n                cause: this.diagram.diagramActions, newValue: {}, oldValue: {},\n                state: arg.state, type: arg.type, cancel: false\n            };\n            var argOldValue = arg.oldValue;\n            var argNewValue = arg.newValue;\n            argOldValue.connectors = [];\n            argOldValue.nodes = [];\n            argNewValue.connectors = [];\n            argNewValue.nodes = [];\n            argOldValue.nodeCollection = [];\n            argOldValue.connectorCollection = [];\n            argNewValue.nodeCollection = [];\n            argNewValue.connectorCollection = [];\n            this.updateArgsObject(this.getSelectedObject(), arg, argNewValue);\n            this.updateArgsObject(oldValue, arg, argOldValue);\n            return arg;\n        }\n        return arg;\n    };\n    /**\n     * isUserHandle method\\\n     *\n     * @returns { boolean }    isUserHandle method .\\\n     * @param {PointModel} position - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.isUserHandle = function (position) {\n        var handle = this.diagram.selectedItems;\n        if (handle.wrapper && canShowCorner(handle.constraints, 'UserHandle')) {\n            for (var _i = 0, _a = handle.userHandles; _i < _a.length; _i++) {\n                var obj = _a[_i];\n                if (obj.visible) {\n                    var paddedBounds = getUserHandlePosition(handle, obj, this.diagram.scroller.transform);\n                    if (contains(position, paddedBounds, obj.size / (2 * this.diagram.scroller.transform.scale))) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * selectObjects method\\\n     *\n     * @returns { Promise<void> }    selectObjects method .\\\n     * @param {(NodeModel | ConnectorModel)[]} obj - provide the objects value.\n     * @param {boolean} multipleSelection - provide the objects value.\n     * @param {(NodeModel | ConnectorModel)[]} oldValue - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.selectObjects = function (obj, multipleSelection, oldValue) {\n        return __awaiter(this, void 0, void 0, function () {\n            var arg, select, oldSelectedItems, canDoMultipleSelection, canDoSingleSelection, i, newObj, i_1, parentNode, blazorArgs, eventObj, selectedObjects, i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        arg = {\n                            oldValue: oldValue ? oldValue : this.getSelectedObject(),\n                            newValue: obj, cause: this.diagram.diagramActions,\n                            state: 'Changing', type: 'Addition', cancel: false\n                        };\n                        this.diagram.enableServerDataBinding(false);\n                        select = true;\n                        if (!isBlazor()) {\n                            this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                        }\n                        else {\n                            this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n                        }\n                        oldSelectedItems = (this.diagram.selectedItems.nodes.concat(this.diagram.selectedItems.connectors));\n                        canDoMultipleSelection = canMultiSelect(this.diagram);\n                        canDoSingleSelection = canSingleSelect(this.diagram);\n                        if (canDoSingleSelection || canDoMultipleSelection) {\n                            if (!canDoMultipleSelection && ((obj.length > 1) || (multipleSelection && obj.length === 1))) {\n                                if (obj.length === 1) {\n                                    this.clearSelection();\n                                }\n                                else {\n                                    return [2 /*return*/];\n                                }\n                            }\n                            if (!(canDoSingleSelection || canDoMultipleSelection) && obj.length === 1\n                                && (!multipleSelection || !hasSelection(this.diagram))) {\n                                this.clearSelection();\n                                return [2 /*return*/];\n                            }\n                        }\n                        if (!!arg.cancel) return [3 /*break*/, 5];\n                        for (i = 0; i < obj.length; i++) {\n                            newObj = obj[i];\n                            if (newObj) {\n                                select = true;\n                                if (!hasSelection(this.diagram)) {\n                                    this.select(newObj, i > 0 || multipleSelection, true);\n                                }\n                                else {\n                                    if ((i > 0 || multipleSelection) && newObj.children && !newObj.parentId) {\n                                        for (i_1 = 0; i_1 < this.diagram.selectedItems.nodes.length; i_1++) {\n                                            parentNode = this.diagram.nameTable[this.diagram.selectedItems.nodes[i_1].parentId];\n                                            if (parentNode) {\n                                                parentNode = this.findParent(parentNode);\n                                                if (parentNode) {\n                                                    if (newObj.id === parentNode.id) {\n                                                        this.selectGroup(newObj);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    this.selectProcesses(newObj);\n                                    select = this.selectBpmnSubProcesses(newObj);\n                                    if (select) {\n                                        this.select(newObj, i > 0 || multipleSelection, true);\n                                    }\n                                }\n                            }\n                        }\n                        if (oldValue === undefined) {\n                            oldValue = oldSelectedItems;\n                        }\n                        arg = {\n                            oldValue: oldValue ? oldValue : [],\n                            newValue: this.getSelectedObject(),\n                            cause: this.diagram.diagramActions, state: 'Changed', type: 'Addition', cancel: false\n                        };\n                        this.diagram.renderSelector(multipleSelection || (obj && obj.length > 1));\n                        this.updateBlazorSelectorModel(oldValue);\n                        if (isBlazor() && this.diagram.selectionChange) {\n                            arg = this.updateSelectionChangeEventArgs(arg, obj, oldValue ? oldValue : []);\n                            this.updateBlazorSelector();\n                        }\n                        if (!!isBlazor()) return [3 /*break*/, 1];\n                        this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                        return [3 /*break*/, 4];\n                    case 1:\n                        blazorArgs = void 0;\n                        if (!(window && window[this.blazor] && this.diagram.selectionChange)) return [3 /*break*/, 3];\n                        eventObj = { 'EventName': 'selectionChange', args: JSON.stringify(arg) };\n                        return [4 /*yield*/, window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram)];\n                    case 2:\n                        blazorArgs = _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        // let blazorArgs: void | object = await this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                        if (blazorArgs && blazorArgs.cancel) {\n                            selectedObjects = [];\n                            if (blazorArgs.oldValue.nodes.length > 0) {\n                                selectedObjects = blazorArgs.oldValue.nodes;\n                            }\n                            if (blazorArgs.oldValue.connectors.length > 0) {\n                                selectedObjects = selectedObjects.concat(blazorArgs.oldValue.connectors);\n                            }\n                            if (selectedObjects) {\n                                if (selectedObjects.length > 0) {\n                                    for (i = 0; i < selectedObjects.length; i++) {\n                                        this.select(this.diagram.nameTable[selectedObjects[i].id], (i !== 0 && selectedObjects.length > 1) ? true : false);\n                                    }\n                                }\n                                else {\n                                    this.clearSelection();\n                                }\n                            }\n                        }\n                        _a.label = 4;\n                    case 4:\n                        this.diagram.enableServerDataBinding(true);\n                        this.updateBlazorSelector();\n                        _a.label = 5;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * updateBlazorSelector method\\\n     *\n     * @returns { void }    updateBlazorSelector method .\\\n     * @private\n     */\n    CommandHandler.prototype.updateBlazorSelector = function () {\n        if (isBlazor() && this.oldSelectedObjects) {\n            this.newSelectedObjects = cloneSelectedObjects(this.diagram);\n            var result = this.deepDiffer.map(cloneObject(this.newSelectedObjects), this.oldSelectedObjects);\n            var diffValue = this.deepDiffer.frameObject({}, result);\n            var diff = this.deepDiffer.removeEmptyValues(diffValue);\n            diff.nodes = [];\n            for (var i = 0; i < this.diagram.selectedItems.nodes.length; i++) {\n                diff.nodes.push(this.diagram.selectedItems.nodes[i].id);\n            }\n            diff.connectors = [];\n            for (var i = 0; i < this.diagram.selectedItems.connectors.length; i++) {\n                diff.connectors.push(this.diagram.selectedItems.connectors[i].id);\n            }\n            var blazorInterop = 'sfBlazor';\n            var blazor = 'Blazor';\n            if (window && window[blazor]) {\n                var obj = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': { selectedItems: diff } };\n                window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n            }\n            this.oldSelectedObjects = undefined;\n            this.newSelectedObjects = undefined;\n        }\n    };\n    /**\n     * findParent method\\\n     *\n     * @returns { Node }    findParent method .\\\n     * @param {Node} node - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.findParent = function (node) {\n        if (node.parentId) {\n            node = this.diagram.nameTable[node.parentId];\n            this.findParent(node);\n        }\n        return node;\n    };\n    CommandHandler.prototype.selectProcesses = function (newObj) {\n        if (this.hasProcesses(newObj)) {\n            var processes = (newObj).shape.activity.subProcess.processes;\n            for (var i = 0; i < processes.length; i++) {\n                var innerChild = this.diagram.nameTable[processes[i]];\n                if (this.hasProcesses(innerChild)) {\n                    this.selectObjects([innerChild], true);\n                }\n                this.unSelect(innerChild);\n            }\n        }\n    };\n    CommandHandler.prototype.selectGroup = function (newObj) {\n        for (var j = 0; j < newObj.children.length; j++) {\n            var innerChild = this.diagram.nameTable[newObj.children[j]];\n            if (innerChild.children) {\n                this.selectGroup(innerChild);\n            }\n            this.unSelect(this.diagram.nameTable[newObj.children[j]]);\n        }\n    };\n    CommandHandler.prototype.selectBpmnSubProcesses = function (node) {\n        var select = true;\n        var parent;\n        if (node.processId) {\n            if (isSelected(this.diagram, this.diagram.nameTable[node.processId])) {\n                select = false;\n            }\n            else {\n                select = this.selectBpmnSubProcesses(this.diagram.nameTable[node.processId]);\n            }\n        }\n        else if (node instanceof Connector) {\n            if (node.sourceID && this.diagram.nameTable[node.sourceID] &&\n                this.diagram.nameTable[node.sourceID].processId) {\n                parent = this.diagram.nameTable[node.sourceID].processId;\n            }\n            if (node.targetID && this.diagram.nameTable[node.targetID] &&\n                this.diagram.nameTable[node.targetID].processId) {\n                parent = this.diagram.nameTable[node.targetID].processId;\n            }\n            if (parent) {\n                if (isSelected(this.diagram, this.diagram.nameTable[parent])) {\n                    return false;\n                }\n                else {\n                    select = this.selectBpmnSubProcesses(this.diagram.nameTable[parent]);\n                }\n            }\n        }\n        else if (node.parentId && this.diagram.nameTable[node.parentId] &&\n            this.diagram.nameTable[node.parentId].shape.type === 'UmlClassifier') {\n            if (isSelected(this.diagram, this.diagram.nameTable[node.parentId])) {\n                select = false;\n            }\n        }\n        return select;\n    };\n    CommandHandler.prototype.hasProcesses = function (node) {\n        if (node) {\n            if ((node.shape.type === 'Bpmn') && node.shape.activity &&\n                node.shape.activity.subProcess.processes &&\n                node.shape.activity.subProcess.processes.length > 0) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * select method\\\n     *\n     * @returns { void }    select method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n     * @param {boolean} multipleSelection - provide the objects value.\n     * @param {boolean} preventUpdate - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.select = function (obj, multipleSelection, preventUpdate) {\n        var hasLayer = this.getObjectLayer(obj.id);\n        if ((canSelect(obj) && !(obj instanceof Selector) && !isSelected(this.diagram, obj))\n            && (hasLayer && !hasLayer.lock && hasLayer.visible) && obj.wrapper.visible) {\n            multipleSelection = hasSelection(this.diagram) ? multipleSelection : false;\n            if (!multipleSelection) {\n                this.clearSelection();\n            }\n            this.diagram.enableServerDataBinding(false);\n            var selectorModel = this.diagram.selectedItems;\n            var convert = obj;\n            if (convert instanceof Node) {\n                if (obj.isHeader) {\n                    var node = this.diagram.nameTable[obj.parentId];\n                    selectorModel.nodes.push(node);\n                }\n                else {\n                    selectorModel.nodes.push(obj);\n                }\n            }\n            else {\n                selectorModel.connectors.push(obj);\n            }\n            if (!multipleSelection) {\n                selectorModel.init(this.diagram);\n                if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n                    var wrapper = gridSelection(this.diagram, selectorModel);\n                    if (wrapper) {\n                        selectorModel.wrapper.children[0] = wrapper;\n                    }\n                    selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n                    selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;\n                    selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;\n                }\n            }\n            else {\n                selectorModel.wrapper.rotateAngle = selectorModel.rotateAngle = 0;\n                selectorModel.wrapper.children.push(obj.wrapper);\n            }\n            if (!preventUpdate) {\n                this.diagram.renderSelector(multipleSelection);\n            }\n            this.diagram.enableServerDataBinding(true);\n        }\n    };\n    CommandHandler.prototype.getObjectCollectionId = function (isNode, clearSelection) {\n        var id = [];\n        var i = 0;\n        var selectedObject = isNode ? this.diagram.selectedItems.nodes\n            : this.diagram.selectedItems.connectors;\n        while (!clearSelection && i < selectedObject.length) {\n            id[i] = selectedObject[i].id;\n            i++;\n        }\n        return id;\n    };\n    CommandHandler.prototype.updateBlazorSelectorModel = function (oldItemsCollection, clearSelection) {\n        var blazorInterop = 'sfBlazor';\n        if (window && window[blazorInterop]) {\n            var i = 0;\n            var nodes = [];\n            var connectors = [];\n            var oldItems = [];\n            while (oldItemsCollection && i < oldItemsCollection.length) {\n                oldItems[i] = oldItemsCollection[i].id;\n                i++;\n            }\n            i = 0;\n            nodes = this.getObjectCollectionId(true, clearSelection);\n            connectors = this.getObjectCollectionId(false, clearSelection);\n            var items = { nodes: nodes, connectors: connectors };\n            var newItems = cloneBlazorObject(items);\n            if (window[blazorInterop].updateDiagramCollection) {\n                window[blazorInterop].updateDiagramCollection.call(this.diagram, 'selectedItems', newItems, oldItems, false, true);\n            }\n        }\n    };\n    /**\n     * labelSelect method\\\n     *\n     * @returns { void }    labelSelect method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n     * @param {DiagramElement} textWrapper - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.labelSelect = function (obj, textWrapper) {\n        this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n        var selectorModel = (this.diagram.selectedItems);\n        var isEnableServerDatabind = this.diagram.allowServerDataBinding;\n        this.diagram.allowServerDataBinding = false;\n        selectorModel.nodes = selectorModel.connectors = [];\n        this.diagram.allowServerDataBinding = isEnableServerDatabind;\n        if (obj instanceof Node) {\n            selectorModel.nodes[0] = obj;\n        }\n        else {\n            selectorModel.connectors[0] = obj;\n        }\n        selectorModel.annotation = (this.findTarget(textWrapper, obj));\n        selectorModel.init(this.diagram);\n        this.diagram.renderSelector(false);\n        this.updateBlazorSelector();\n    };\n    /**\n     * unSelect method\\\n     *\n     * @returns { void }    unSelect method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.unSelect = function (obj) {\n        var objArray = [];\n        objArray.push(obj);\n        var items = (this.diagram.selectedItems.nodes.concat(this.diagram.selectedItems.connectors));\n        var selectedObjects = items.filter(function (items) {\n            return items.id !== obj.id;\n        });\n        var arg = {\n            oldValue: items, newValue: selectedObjects, cause: this.diagram.diagramActions,\n            state: 'Changing', type: 'Removal', cancel: false\n        };\n        if (!this.diagram.currentSymbol) {\n            if (!isBlazor()) {\n                this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            }\n        }\n        if (isSelected(this.diagram, obj)) {\n            var selectormodel = this.diagram.selectedItems;\n            var index = void 0;\n            if (obj instanceof Node) {\n                index = selectormodel.nodes.indexOf(obj, 0);\n                selectormodel.nodes.splice(index, 1);\n            }\n            else {\n                index = selectormodel.connectors.indexOf(obj, 0);\n                selectormodel.connectors.splice(index, 1);\n            }\n            arg = {\n                oldValue: items, newValue: selectedObjects, cause: this.diagram.diagramActions,\n                state: 'Changed', type: 'Removal', cancel: false\n            };\n            this.updateBlazorSelectorModel(objArray);\n            arg = {\n                oldValue: cloneBlazorObject(items), newValue: selectedObjects, cause: this.diagram.diagramActions,\n                state: 'Changed', type: 'Removal', cancel: arg.cancel\n            };\n            if (!arg.cancel) {\n                index = selectormodel.wrapper.children.indexOf(obj.wrapper, 0);\n                selectormodel.wrapper.children.splice(index, 1);\n                this.diagram.updateSelector();\n                if (!this.diagram.currentSymbol) {\n                    if (isBlazor()) {\n                        arg = this.updateSelectionChangeEventArgs(arg, [], objArray);\n                        this.updateBlazorSelector();\n                        if (window && window[this.blazor] && this.diagram.selectionChange) {\n                            var eventObj = { 'EventName': 'selectionChange', args: JSON.stringify(arg) };\n                            window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram);\n                        }\n                    }\n                    else {\n                        this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * getChildElements method\\\n     *\n     * @returns { string[] }    getChildElements method .\\\n     * @param {DiagramElement[]} child - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.getChildElements = function (child) {\n        var children = [];\n        for (var i = 0; i < child.length; i++) {\n            var childNode = child[i];\n            if (childNode.children && childNode.children.length > 0) {\n                children.concat(this.getChildElements(childNode.children));\n            }\n            else {\n                children.push(childNode.id);\n                if (childNode instanceof TextElement) {\n                    children.push(childNode.id + '_text');\n                }\n            }\n        }\n        return children;\n    };\n    /**\n     * moveSvgNode method\\\n     *\n     * @returns { void }    moveSvgNode method .\\\n     * @param {string} nodeId - provide the objects value.\n     * @param {string} targetID - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.moveSvgNode = function (nodeId, targetID) {\n        var diagramDiv = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);\n        var backNode = getDiagramElement(nodeId + '_groupElement', this.diagram.element.id);\n        diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n    };\n    /**\n     * sendLayerBackward method\\\n     *\n     * @returns { void }    sendLayerBackward method .\\\n     * @param {string} layerName - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.sendLayerBackward = function (layerName) {\n        var layer = this.getLayer(layerName);\n        if (layer && layer.zIndex !== 0) {\n            var index = layer.zIndex;\n            if (this.diagram.mode === 'SVG') {\n                var currentLayerObject = layer.objects;\n                var targetObject = this.getLayer(this.diagram.layerZIndexTable[index - 1]).objects[0];\n                if (targetObject) {\n                    for (var _i = 0, currentLayerObject_1 = currentLayerObject; _i < currentLayerObject_1.length; _i++) {\n                        var obj = currentLayerObject_1[_i];\n                        this.moveSvgNode(obj, targetObject);\n                    }\n                }\n            }\n            var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index - 1]);\n            targetLayer.zIndex = targetLayer.zIndex + 1;\n            layer.zIndex = layer.zIndex - 1;\n            var temp = this.diagram.layerZIndexTable[index];\n            this.diagram.layerZIndexTable[index] = this.diagram.layerZIndexTable[index - 1];\n            this.diagram.layerZIndexTable[index - 1] = temp;\n            if (this.diagram.mode === 'Canvas') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * bringLayerForward method\\\n     *\n     * @returns { void }    bringLayerForward method .\\\n     * @param {string} layerName - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.bringLayerForward = function (layerName) {\n        var layer = this.getLayer(layerName);\n        if (layer && layer.zIndex < this.diagram.layers.length - 1) {\n            var index = layer.zIndex;\n            var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index + 1]);\n            if (this.diagram.mode === 'SVG') {\n                var currentLayerObject = layer.objects[0];\n                var targetLayerObjects = targetLayer.objects;\n                for (var _i = 0, targetLayerObjects_1 = targetLayerObjects; _i < targetLayerObjects_1.length; _i++) {\n                    var obj = targetLayerObjects_1[_i];\n                    if (obj) {\n                        this.moveSvgNode(obj, currentLayerObject);\n                    }\n                }\n            }\n            targetLayer.zIndex = targetLayer.zIndex - 1;\n            layer.zIndex = layer.zIndex + 1;\n            var temp = this.diagram.layerZIndexTable[index];\n            this.diagram.layerZIndexTable[index] = this.diagram.layerZIndexTable[index + 1];\n            this.diagram.layerZIndexTable[index + 1] = temp;\n            if (this.diagram.mode === 'Canvas') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * sendToBack method\\\n     *\n     * @returns { void }    sendToBack method .\\\n     * @param {NodeModel | ConnectorModel} object - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.sendToBack = function (object) {\n        this.diagram.protectPropertyChange(true);\n        if (hasSelection(this.diagram) || object) {\n            var objectId = (object && object.id);\n            objectId = objectId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id\n                : this.diagram.selectedItems.connectors[0].id);\n            var index = this.diagram.nameTable[objectId].zIndex;\n            var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n            var zIndexTable = this.diagram.layers[layerNum].zIndexTable;\n            var tempTable = JSON.parse(JSON.stringify(zIndexTable));\n            var undoObject = cloneObject(this.diagram.selectedItems);\n            var tempIndex = 0;\n            //Checks whether the selected node is the only node in the node array.\n            //Checks whether it is not a group and the nodes behind it are not it’s children.\n            if (this.diagram.nodes.length !== 1 && (this.diagram.nameTable[objectId].children === undefined ||\n                this.checkObjectBehind(objectId, zIndexTable, index))) {\n                var obj = this.diagram.nameTable[objectId];\n                for (var i = index; i > 0; i--) {\n                    if (zIndexTable[i]) {\n                        //When there are empty records in the zindex table\n                        if (!zIndexTable[i - 1]) {\n                            zIndexTable[i - 1] = zIndexTable[i];\n                            this.diagram.nameTable[zIndexTable[i - 1]].zIndex = i;\n                            delete zIndexTable[i];\n                        }\n                        else {\n                            //bringing the objects forward\n                            zIndexTable[i] = zIndexTable[i - 1];\n                            this.diagram.nameTable[zIndexTable[i]].zIndex = i;\n                        }\n                    }\n                }\n                for (var i = index; i > 0; i--) {\n                    if (zIndexTable[i]) {\n                        this.diagram.nameTable[zIndexTable[i]].zIndex = i;\n                    }\n                }\n                if (obj.shape.type !== 'SwimLane') {\n                    zIndexTable[0] = this.diagram.nameTable[objectId].id;\n                    this.diagram.nameTable[objectId].zIndex = 0;\n                }\n                else {\n                    tempIndex = this.swapZIndexObjects(index, zIndexTable, objectId, tempTable);\n                }\n                if (this.diagram.mode === 'SVG') {\n                    var obj_1 = this.diagram.nameTable[objectId];\n                    var i = obj_1.shape.type !== 'SwimLane' ? 1 : tempIndex;\n                    if (i !== tempIndex) {\n                        i = (obj_1.children && obj_1.children.length > 0) ? index : 1;\n                    }\n                    var target = zIndexTable[i];\n                    // EJ2-49326 - (CR issue fix) An exception raised when send the swimlane back to the normal node.\n                    while (!target && i < index) {\n                        target = zIndexTable[++i];\n                    }\n                    // EJ2-46656 - CR issue fix\n                    target = this.resetTargetNode(objectId, target, i, zIndexTable);\n                    target = this.diagram.nameTable[target].parentId ? this.checkParentExist(target) : target;\n                    this.moveSvgNode(objectId, target);\n                    this.updateNativeNodeIndex(objectId);\n                }\n                else {\n                    this.diagram.refreshCanvasLayers();\n                }\n                var redoObject = cloneObject(this.diagram.selectedItems);\n                var entry = { type: 'SendToBack', category: 'Internal', undoObject: undoObject, redoObject: redoObject };\n                if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    this.addHistoryEntry(entry);\n                }\n            }\n        }\n        this.diagram.protectPropertyChange(false);\n        if (isBlazor()) {\n            this.getZIndexObjects();\n        }\n    };\n    CommandHandler.prototype.swapZIndexObjects = function (index, zIndexTable, objectId, tempTable) {\n        var tempIndex = 0;\n        var childCount = 0;\n        var childIndex = -1;\n        var j = 1;\n        // Get the swimlane's Children count\n        for (var i = 0; i <= index; i++) {\n            if (zIndexTable[i] && this.diagram.nameTable[zIndexTable[i]].parentId === objectId) {\n                // Get the swimlane's first children position from z index table\n                if (childIndex === -1) {\n                    childIndex = i;\n                }\n                childCount++;\n            }\n        }\n        // Swap the swimlane children to the top of the z index table\n        for (var i = 0; i <= index; i++) {\n            if (zIndexTable[i] && j <= childCount) {\n                while (!zIndexTable[childIndex]) {\n                    childIndex++;\n                }\n                zIndexTable[i] = zIndexTable[childIndex];\n                this.diagram.nameTable[zIndexTable[i]].zIndex = i;\n                childIndex++;\n                j++;\n            }\n        }\n        var k = 0;\n        // Get the Z index from ZindexTable in the child's count position. In that position we want to put the swimlane\n        for (var i = 0; i < childCount; i++) {\n            while (!zIndexTable[k]) {\n                k++;\n            }\n            tempIndex = this.diagram.nameTable[zIndexTable[k]].zIndex;\n            k++;\n        }\n        tempIndex = tempIndex + 1;\n        // Check if there is a object in the z index table or not\n        while (!zIndexTable[tempIndex]) {\n            ++tempIndex;\n        }\n        k = 0;\n        // Place the swimlane at the next position of the swimlane's last children.\n        zIndexTable[tempIndex] = this.diagram.nameTable[objectId].id;\n        this.diagram.nameTable[objectId].zIndex = tempIndex;\n        tempIndex = tempIndex + 1;\n        // Now swap the intersect nodes at next position of the swimlane.\n        for (var i = tempIndex; i <= index; i++) {\n            if (zIndexTable[i]) {\n                while (!tempTable[k]) {\n                    k++;\n                }\n                zIndexTable[i] = tempTable[k];\n                this.diagram.nameTable[zIndexTable[i]].zIndex = i;\n                k++;\n            }\n        }\n        return tempIndex;\n    };\n    CommandHandler.prototype.resetTargetNode = function (objectId, target, i, zIndexTable) {\n        if (this.diagram.nameTable[objectId].shape.type === 'SwimLane'\n            && this.diagram.nameTable[target].parentId != undefined && this.diagram.nameTable[target].parentId != \"\" && this.diagram.nameTable[this.diagram.nameTable[target].parentId].isLane) {\n            i = i + 1;\n            if (zIndexTable[i]) {\n                target = zIndexTable[i];\n                return target = this.resetTargetNode(objectId, target, i, zIndexTable);\n            }\n            else {\n                return target;\n            }\n        }\n        else {\n            return target;\n        }\n    };\n    CommandHandler.prototype.getZIndexObjects = function () {\n        var element = [];\n        var i;\n        var j;\n        for (i = 0; i < this.diagram.nodes.length; i++) {\n            element.push(this.diagram.nodes[i]);\n        }\n        for (j = 0; j < this.diagram.connectors.length; j++) {\n            element.push(this.diagram.connectors[j]);\n        }\n        this.updateBlazorZIndex(element);\n    };\n    CommandHandler.prototype.updateBlazorZIndex = function (element) {\n        var blazorInterop = 'sfBlazor';\n        var blazor = 'Blazor';\n        var diagramobject = {};\n        var nodeObject = [];\n        var connectorObject = [];\n        var k;\n        if (element && element.length > 0) {\n            for (k = 0; k < element.length; k++) {\n                var elementObject = element[k];\n                if (elementObject instanceof Node) {\n                    nodeObject.push(this.getBlazorObject(elementObject));\n                }\n                else if (elementObject instanceof Connector) {\n                    connectorObject.push(this.getBlazorObject(elementObject));\n                }\n            }\n        }\n        diagramobject = {\n            nodes: nodeObject,\n            connectors: connectorObject\n        };\n        if (window && window[blazor]) {\n            var obj = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': diagramobject };\n            window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n        }\n    };\n    CommandHandler.prototype.getBlazorObject = function (objectName) {\n        var object = {\n            sfIndex: getIndex(this.diagram, objectName.id),\n            zIndex: objectName.zIndex\n        };\n        return object;\n    };\n    //Checks whether the target is a child node.\n    CommandHandler.prototype.checkParentExist = function (target) {\n        var objBehind = target;\n        while (this.diagram.nameTable[objBehind].parentId) {\n            objBehind = this.diagram.nameTable[objBehind].parentId;\n        }\n        return objBehind;\n    };\n    //Checks whether the selected node is not a parent of another node.\n    CommandHandler.prototype.checkObjectBehind = function (objectId, zIndexTable, index) {\n        for (var i = 0; i < index; i++) {\n            var z = zIndexTable[i];\n            if (this.diagram.nameTable[z] && objectId !== this.diagram.nameTable[z].parentId) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * bringToFront method\\\n     *\n     * @returns {  void  }    bringToFront method .\\\n     *  @param {NodeModel | ConnectorModel } obj - Provide the nodeArray element .\n     * @private\n     */\n    CommandHandler.prototype.bringToFront = function (obj) {\n        var _this = this;\n        this.diagram.protectPropertyChange(true);\n        if (hasSelection(this.diagram) || obj) {\n            var objectName_1 = (obj && obj.id);\n            objectName_1 = objectName_1 || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id\n                : this.diagram.selectedItems.connectors[0].id);\n            var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectName_1));\n            var zIndexTable_1 = this.diagram.layers[layerNum].zIndexTable;\n            var undoObject = cloneObject(this.diagram.selectedItems);\n            var tempTable = JSON.parse(JSON.stringify(zIndexTable_1));\n            var tempIndex = 0;\n            //find the maximum zIndex of the tabel\n            var tabelLength = Number(Object.keys(zIndexTable_1).sort(function (a, b) { return Number(a) - Number(b); }).reverse()[0]);\n            var index = this.diagram.nameTable[objectName_1].zIndex;\n            var oldzIndexTable_1 = [];\n            var length_1 = 0;\n            for (var i = 0; i <= tabelLength; i++) {\n                oldzIndexTable_1.push(zIndexTable_1[i]);\n            }\n            var object = this.diagram.nameTable[objectName_1];\n            if (object.shape.type === 'SwimLane') {\n                for (var i = tabelLength; i >= index; i--) {\n                    if (zIndexTable_1[i] && !(this.diagram.nameTable[zIndexTable_1[i]].parentId === objectName_1)) {\n                        length_1 = i;\n                        tabelLength = length_1;\n                        break;\n                    }\n                }\n            }\n            for (var i = index; i < tabelLength; i++) {\n                //When there are empty records in the zindex table\n                if (zIndexTable_1[i]) {\n                    if (!zIndexTable_1[i + 1]) {\n                        zIndexTable_1[i + 1] = zIndexTable_1[i];\n                        this.diagram.nameTable[zIndexTable_1[i + 1]].zIndex = i;\n                        delete zIndexTable_1[i];\n                    }\n                    else {\n                        //bringing the objects backward\n                        zIndexTable_1[i] = zIndexTable_1[i + 1];\n                        this.diagram.nameTable[zIndexTable_1[i]].zIndex = i;\n                    }\n                }\n            }\n            for (var i = index; i < tabelLength; i++) {\n                if (zIndexTable_1[i]) {\n                    this.diagram.nameTable[zIndexTable_1[i]].zIndex = i;\n                }\n            }\n            if (object.shape.type !== 'SwimLane') {\n                zIndexTable_1[tabelLength] = this.diagram.nameTable[objectName_1].id;\n                this.diagram.nameTable[objectName_1].zIndex = tabelLength;\n            }\n            else {\n                var childCount = 0;\n                var childIndex = -1;\n                var tempIndex_1 = 0;\n                var laneIndex = 0;\n                var cloneTable = JSON.parse(JSON.stringify(zIndexTable_1));\n                for (var i = 0; i <= index; i++) {\n                    if (zIndexTable_1[i] && this.diagram.nameTable[zIndexTable_1[i]].parentId === objectName_1) {\n                        if (childIndex === -1) {\n                            childIndex = i;\n                            tempIndex_1 = i;\n                            break;\n                        }\n                    }\n                }\n                for (var i = 0; i <= tabelLength; i++) {\n                    if (tempTable[i] && tempTable[i] !== objectName_1 && this.diagram.nameTable[tempTable[i]].parentId !== objectName_1) {\n                        var node = this.diagram.nameTable[tempTable[i]];\n                        var swimlaneObject = this.diagram.nameTable[objectName_1];\n                        if (node.zIndex >= swimlaneObject.zIndex) {\n                            childCount++;\n                        }\n                    }\n                }\n                var k = childIndex;\n                for (var i = 0; i <= childCount; i++) {\n                    while (!zIndexTable_1[k]) {\n                        k++;\n                    }\n                    laneIndex = this.diagram.nameTable[zIndexTable_1[k]].zIndex;\n                    k++;\n                }\n                for (var i = laneIndex; i <= tabelLength; i++) {\n                    while (!cloneTable[childIndex]) {\n                        childIndex++;\n                    }\n                    while (!zIndexTable_1[i]) {\n                        i++;\n                    }\n                    zIndexTable_1[i] = cloneTable[childIndex];\n                    this.diagram.nameTable[zIndexTable_1[i]].zIndex = i;\n                    childIndex++;\n                }\n                zIndexTable_1[tabelLength] = this.diagram.nameTable[objectName_1].id;\n                this.diagram.nameTable[objectName_1].zIndex = tabelLength;\n                k = index + 1;\n                var j = tempIndex_1;\n                for (var i = 0; i < childCount; i++) {\n                    while (!tempTable[k]) {\n                        k++;\n                    }\n                    while (this.diagram.nameTable[tempTable[k]].parentId === objectName_1) {\n                        k++;\n                    }\n                    while (!zIndexTable_1[j]) {\n                        j++;\n                    }\n                    zIndexTable_1[j] = tempTable[k];\n                    this.diagram.nameTable[zIndexTable_1[j]].zIndex = j;\n                    k++;\n                    j++;\n                }\n            }\n            if (this.diagram.mode === 'SVG') {\n                var diagramLayer = this.diagram.diagramLayer;\n                //const child: string[] = this.getChildElements(this.diagram.nameTable[objectName].wrapper.children);\n                //const targerNodes: Object = [];\n                var element = getDiagramElement(objectName_1 + '_groupElement', this.diagram.element.id);\n                var nodes = this.diagram.selectedItems.nodes;\n                if (nodes.length > 0 && (nodes[0].shape.type === 'Native' || nodes[0].shape.type === 'HTML')) {\n                    element.parentNode.removeChild(element);\n                    for (var j = 0; j < this.diagram.views.length; j++) {\n                        element = getDiagramElement(objectName_1 + (nodes[0].shape.type === 'HTML' ? '_html_element' : '_content_groupElement'), this.diagram.views[j]);\n                        var lastChildNode = element.parentNode.lastChild;\n                        lastChildNode.parentNode.insertBefore(element, lastChildNode.nextSibling);\n                    }\n                    var htmlLayer = getHTMLLayer(this.diagram.element.id);\n                    this.diagram.diagramRenderer.renderElement(this.diagram.nameTable[objectName_1].wrapper, diagramLayer, htmlLayer);\n                }\n                else {\n                    Object.keys(zIndexTable_1).forEach(function (key) {\n                        var zIndexValue = zIndexTable_1[key];\n                        if ((zIndexValue !== objectName_1) && (_this.diagram.nameTable[zIndexValue].parentId) !== objectName_1) {\n                            //EJ2-42101 - SendToBack and BringToFront not working for connector with group node\n                            //Added @Dheepshiva to restrict the objects with lower zIndex\n                            if (zIndexValue !== undefined &&\n                                (oldzIndexTable_1.indexOf(objectName_1) < oldzIndexTable_1.indexOf(zIndexValue))) {\n                                var objectNode = _this.diagram.nameTable[objectName_1];\n                                var zIndexNode = _this.diagram.nameTable[zIndexValue];\n                                if (objectNode.parentId === '' && zIndexNode.parentId === '' && zIndexNode.parentId === undefined\n                                    && objectNode.parentId !== zIndexNode.id) {\n                                    _this.moveSvgNode(zIndexValue, objectName_1);\n                                    _this.updateNativeNodeIndex(objectName_1);\n                                }\n                                else {\n                                    if (_this.checkGroupNode(objectName_1, zIndexValue, _this.diagram.nameTable)) {\n                                        _this.moveSvgNode(zIndexValue, objectName_1);\n                                        _this.updateNativeNodeIndex(objectName_1);\n                                    }\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n            else {\n                this.diagram.refreshCanvasLayers();\n            }\n            var redoObject = cloneObject(this.diagram.selectedItems);\n            var entry = { type: 'BringToFront', category: 'Internal', undoObject: undoObject, redoObject: redoObject };\n            if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                this.addHistoryEntry(entry);\n            }\n        }\n        this.diagram.protectPropertyChange(false);\n        if (isBlazor()) {\n            this.getZIndexObjects();\n        }\n    };\n    CommandHandler.prototype.checkGroupNode = function (selectedNodeName, layerObject, nameTable) {\n        return nameTable[layerObject].parentId === nameTable[selectedNodeName].parentId;\n    };\n    /**\n     * sortByZIndex method\\\n     *\n     * @returns {  Object[] }    sortByZIndex method .\\\n     *  @param { Object[] } nodeArray - Provide the nodeArray element .\n     *  @param { string } sortID - Provide the sortID element .\n     * @private\n     */\n    CommandHandler.prototype.sortByZIndex = function (nodeArray, sortID) {\n        var id = sortID ? sortID : 'zIndex';\n        nodeArray = nodeArray.sort(function (a, b) {\n            return a[id] - b[id];\n        });\n        return nodeArray;\n    };\n    /**\n     * orderCommands method\\\n     *\n     * @returns {  void }    orderCommands method .\\\n     *  @param { boolean } isRedo - Provide the previousObject element .\n     *  @param { Selector } selector - Provide the previousObject element .\n     *  @param { EntryType } action - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.orderCommands = function (isRedo, selector, action) {\n        var selectedObject = selector.nodes;\n        selectedObject = selectedObject.concat(selector.connectors);\n        if (isRedo) {\n            if (action === 'SendBackward') {\n                this.sendBackward(selectedObject[0]);\n            }\n            else if (action === 'SendForward') {\n                this.sendForward(selectedObject[0]);\n            }\n            else if (action === 'BringToFront') {\n                this.bringToFront(selectedObject[0]);\n            }\n            else if (action === 'SendToBack') {\n                this.sendToBack(selectedObject[0]);\n            }\n        }\n        else {\n            var startZIndex = selectedObject[0].zIndex;\n            var endZIndex = this.diagram.nameTable[selectedObject[0].id].zIndex;\n            var undoObject = selectedObject[0];\n            var layer = this.getObjectLayer(undoObject.id);\n            var layerIndex = layer.zIndex;\n            var zIndexTable = layer.zIndexTable;\n            if (action === 'SendBackward' || action === 'SendForward') {\n                for (var i = 0; i < selectedObject.length; i++) {\n                    var undoObject_1 = selectedObject[i];\n                    var layer_2 = this.diagram.layers.indexOf(this.getObjectLayer(undoObject_1.id));\n                    var node = this.diagram.nameTable[selectedObject[i].id];\n                    node.zIndex = undoObject_1.zIndex;\n                    this.diagram.layers[layer_2].zIndexTable[undoObject_1.zIndex] = undoObject_1.id;\n                }\n            }\n            else if (action === 'BringToFront') {\n                if (selectedObject[0].shape.type === 'SwimLane') {\n                    this.sendToBack(selectedObject[0]);\n                }\n                else {\n                    var k = 1;\n                    for (var j = endZIndex; j > startZIndex; j--) {\n                        if (zIndexTable[j]) {\n                            if (!zIndexTable[j - k]) {\n                                zIndexTable[j - k] = zIndexTable[j];\n                                this.diagram.nameTable[zIndexTable[j - k]].zIndex = j;\n                                delete zIndexTable[j];\n                            }\n                            else {\n                                zIndexTable[j] = zIndexTable[j - k];\n                                this.diagram.nameTable[zIndexTable[j]].zIndex = j;\n                            }\n                        }\n                    }\n                }\n            }\n            else if (action === 'SendToBack') {\n                if (selectedObject[0].shape.type === 'SwimLane') {\n                    this.bringToFront(selectedObject[0]);\n                }\n                else {\n                    for (var j = endZIndex; j < startZIndex; j++) {\n                        if (zIndexTable[j]) {\n                            if (!zIndexTable[j + 1]) {\n                                zIndexTable[j + 1] = zIndexTable[j];\n                                this.diagram.nameTable[zIndexTable[j + 1]].zIndex = j;\n                                delete zIndexTable[j];\n                            }\n                            else {\n                                zIndexTable[j] = zIndexTable[j + 1];\n                                this.diagram.nameTable[zIndexTable[j]].zIndex = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if (action === 'BringToFront' || action === 'SendToBack') {\n                var node = this.diagram.nameTable[selectedObject[0].id];\n                node.zIndex = undoObject.zIndex;\n                this.diagram.layers[layerIndex].zIndexTable[undoObject.zIndex] = undoObject.id;\n            }\n            if (this.diagram.mode === 'SVG') {\n                if (action === 'SendBackward') {\n                    this.moveObject(selectedObject[1].id, selectedObject[0].id);\n                }\n                else if (action === 'SendForward') {\n                    this.moveObject(selectedObject[0].id, selectedObject[1].id);\n                }\n                else if (action === 'BringToFront') {\n                    if (selectedObject[0].shape.type !== 'SwimLane') {\n                        this.moveObject(selectedObject[0].id, zIndexTable[selectedObject[0].zIndex + 1]);\n                    }\n                }\n                else if (action === 'SendToBack') {\n                    if (selectedObject[0].shape.type !== 'SwimLane') {\n                        var layer_3 = this.getObjectLayer(selectedObject[0].id);\n                        for (var i = 0; i <= selectedObject[0].zIndex; i++) {\n                            if (layer_3.objects[i] !== selectedObject[0].id) {\n                                this.moveSvgNode(layer_3.objects[i], selectedObject[0].id);\n                                this.updateNativeNodeIndex(selectedObject[0].id);\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                this.diagram.refreshCanvasLayers();\n            }\n        }\n    };\n    CommandHandler.prototype.moveObject = function (sourceId, targetId) {\n        if (targetId) {\n            this.moveSvgNode(sourceId, targetId);\n            this.updateNativeNodeIndex(sourceId, targetId);\n        }\n    };\n    /**\n     * sendForward method\\\n     *\n     * @returns {  void }    sendForward method .\\\n     *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.sendForward = function (obj) {\n        this.diagram.protectPropertyChange(true);\n        if (hasSelection(this.diagram) || obj) {\n            var nodeId = (obj && obj.id);\n            nodeId = nodeId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id\n                : this.diagram.selectedItems.connectors[0].id);\n            var layerIndex = this.diagram.layers.indexOf(this.getObjectLayer(nodeId));\n            var zIndexTable = this.diagram.layers[layerIndex].zIndexTable;\n            //const tabelLength: number = Object.keys(zIndexTable).length;\n            var index = this.diagram.nameTable[nodeId];\n            var intersectArray = [];\n            var temp = this.diagram.spatialSearch.findObjects(index.wrapper.bounds);\n            if (temp.length > 2) {\n                temp = this.sortByZIndex(temp);\n            }\n            for (var _i = 0, temp_1 = temp; _i < temp_1.length; _i++) {\n                var i = temp_1[_i];\n                if (index.id !== i.id) {\n                    var currentLayer = this.getObjectLayer(i.id).zIndex;\n                    if (layerIndex === currentLayer && (Number(this.diagram.nameTable[nodeId].zIndex) < Number(i.zIndex)) &&\n                        index.wrapper.bounds.intersects(i.wrapper.bounds)) {\n                        intersectArray.push(i);\n                        break;\n                    }\n                }\n            }\n            if (intersectArray.length > 0) {\n                var node = this.diagram.nameTable[zIndexTable[Number(intersectArray[0].zIndex)]];\n                if (node.parentId) {\n                    var parentId = '';\n                    var parent_1 = findParentInSwimlane(node, this.diagram, parentId);\n                    var obj_2 = this.diagram.nameTable[parent_1];\n                    if (obj_2.id !== nodeId) {\n                        intersectArray[0] = obj_2;\n                    }\n                }\n                var overlapObject = intersectArray[0].zIndex;\n                var currentObject = index.zIndex;\n                var temp_2 = zIndexTable[overlapObject];\n                //swap the nodes\n                var undoObject = cloneObject(this.diagram.selectedItems);\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                (this.diagram.nameTable[temp_2] instanceof Node) ? undoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_2])) :\n                    undoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_2]));\n                this.diagram.layers[0].zIndexTable[overlapObject] = index.id;\n                this.diagram.nameTable[zIndexTable[overlapObject]].zIndex = overlapObject;\n                this.diagram.layers[0].zIndexTable[currentObject] = intersectArray[0].id;\n                this.diagram.nameTable[zIndexTable[currentObject]].zIndex = currentObject;\n                if (this.diagram.mode === 'SVG') {\n                    this.moveSvgNode(zIndexTable[Number(intersectArray[0].zIndex)], nodeId);\n                    this.updateNativeNodeIndex(zIndexTable[Number(intersectArray[0].zIndex)], nodeId);\n                }\n                else {\n                    this.diagram.refreshCanvasLayers();\n                }\n                var redo = cloneObject(this.diagram.selectedItems);\n                // eslint-disable-next-line\n                (this.diagram.nameTable[temp_2] instanceof Node) ? redo.nodes.push(cloneObject(this.diagram.nameTable[temp_2])) :\n                    redo.connectors.push(cloneObject(this.diagram.nameTable[temp_2]));\n                var historyEntry = {\n                    type: 'SendForward', category: 'Internal',\n                    undoObject: undoObject, redoObject: redo\n                };\n                if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    this.addHistoryEntry(historyEntry);\n                }\n            }\n            if (isBlazor()) {\n                var elements = [];\n                elements.push(index);\n                elements.push(intersectArray[intersectArray.length - 1]);\n                this.updateBlazorZIndex(elements);\n            }\n        }\n        this.diagram.protectPropertyChange(false);\n    };\n    /**\n     * sendBackward method\\\n     *\n     * @returns {  void }    sendBackward method .\\\n     *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.sendBackward = function (obj) {\n        this.diagram.protectPropertyChange(true);\n        if (hasSelection(this.diagram) || obj) {\n            var objectId = (obj && obj.id);\n            objectId = objectId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id\n                : this.diagram.selectedItems.connectors[0].id);\n            var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n            var zIndexTable = this.diagram.layers[layerNum].zIndexTable;\n            //const tabelLength: number = Object.keys(zIndexTable).length;\n            var node = this.diagram.nameTable[objectId];\n            var intersectArray = [];\n            var temp = this.diagram.spatialSearch.findObjects(node.wrapper.bounds);\n            if (temp.length > 2) {\n                temp = this.sortByZIndex(temp);\n            }\n            for (var _i = 0, temp_3 = temp; _i < temp_3.length; _i++) {\n                var i = temp_3[_i];\n                if (node.id !== i.id) {\n                    var currentLayer = this.getObjectLayer(i.id).zIndex;\n                    if (layerNum === currentLayer && (Number(this.diagram.nameTable[objectId].zIndex) > Number(i.zIndex)) &&\n                        node.wrapper.bounds.intersects(i.wrapper.bounds)) {\n                        intersectArray.push(i);\n                    }\n                }\n            }\n            for (var i = intersectArray.length - 1; i >= 0; i--) {\n                var child = this.diagram.nameTable[intersectArray[i].id];\n                if (child.parentId === objectId) {\n                    intersectArray.splice(i, 1);\n                }\n            }\n            if (intersectArray.length > 0) {\n                var child = this.diagram.nameTable[intersectArray[intersectArray.length - 1].id];\n                if (child.parentId) {\n                    var parentId = '';\n                    var parent_2 = findParentInSwimlane(child, this.diagram, parentId);\n                    var obj_3 = this.diagram.nameTable[parent_2];\n                    if (objectId !== obj_3.id) {\n                        intersectArray[intersectArray.length - 1] = obj_3;\n                    }\n                }\n                var overlapObject = intersectArray[intersectArray.length - 1].zIndex;\n                var currentObject = node.zIndex;\n                var temp_4 = zIndexTable[overlapObject];\n                var undoObject = cloneObject(this.diagram.selectedItems);\n                // eslint-disable-next-line\n                (this.diagram.nameTable[temp_4] instanceof Node) ? undoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_4])) :\n                    undoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_4]));\n                //swap the nodes\n                zIndexTable[overlapObject] = node.id;\n                this.diagram.nameTable[zIndexTable[overlapObject]].zIndex = overlapObject;\n                zIndexTable[currentObject] = intersectArray[intersectArray.length - 1].id;\n                this.diagram.nameTable[zIndexTable[currentObject]].zIndex = currentObject;\n                if (this.diagram.mode === 'SVG') {\n                    this.moveSvgNode(objectId, zIndexTable[intersectArray[intersectArray.length - 1].zIndex]);\n                    var node_2 = this.diagram.nameTable[zIndexTable[intersectArray[intersectArray.length - 1].zIndex]];\n                    if (node_2.children && node_2.children.length > 0) {\n                        this.updateNativeNodeIndex(objectId);\n                    }\n                    else {\n                        this.updateNativeNodeIndex(objectId, zIndexTable[intersectArray[intersectArray.length - 1].zIndex]);\n                    }\n                    if (isBlazor()) {\n                        var elements = [];\n                        elements.push(node_2);\n                        elements.push(intersectArray[intersectArray.length - 1]);\n                        this.updateBlazorZIndex(elements);\n                    }\n                }\n                else {\n                    this.diagram.refreshCanvasLayers();\n                }\n                var redoObject = cloneObject(this.diagram.selectedItems);\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                (this.diagram.nameTable[temp_4] instanceof Node) ? redoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_4])) :\n                    redoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_4]));\n                var entry = { type: 'SendBackward', category: 'Internal', undoObject: undoObject, redoObject: redoObject };\n                if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    this.addHistoryEntry(entry);\n                }\n                //swap the nodes\n            }\n        }\n        this.diagram.protectPropertyChange(false);\n    };\n    /**\n     * updateNativeNodeIndex method\\\n     *\n     * @returns {  void }    updateNativeNodeIndex method .\\\n     *  @param { string } nodeId - Provide the previousObject element .\n     *  @param { string } targetID - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.updateNativeNodeIndex = function (nodeId, targetID) {\n        var node = this.diagram.selectedItems.nodes[0] || this.diagram.getObject(targetID);\n        for (var i = 0; i < this.diagram.views.length; i++) {\n            if (node && (node.shape.type === 'HTML'\n                || node.shape.type === 'Native')) {\n                var id = node.shape.type === 'HTML' ? '_html_element' : '_content_groupElement';\n                var backNode = getDiagramElement(nodeId + id, this.diagram.views[i]);\n                var diagramDiv = targetID ? getDiagramElement(targetID + id, this.diagram.views[i])\n                    : backNode.parentElement.firstChild;\n                if (backNode && diagramDiv) {\n                    if (backNode.parentNode.id === diagramDiv.parentNode.id) {\n                        diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * initSelectorWrapper method\\\n     *\n     * @returns {  void }    initSelectorWrapper method .\\\n     * @private\n     */\n    CommandHandler.prototype.initSelectorWrapper = function () {\n        var selectorModel = this.diagram.selectedItems;\n        selectorModel.init(this.diagram);\n        if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n            selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n            selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;\n            selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;\n        }\n    };\n    /**\n     * doRubberBandSelection method\\\n     *\n     * @returns {  void }    doRubberBandSelection method .\\\n     *  @param { Rect } region - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.doRubberBandSelection = function (region) {\n        this.clearSelectionRectangle();\n        var selArray = [];\n        var rubberArray = [];\n        selArray = this.diagram.getNodesConnectors(selArray);\n        if (this.diagram.selectedItems.rubberBandSelectionMode === 'CompleteIntersect') {\n            rubberArray = completeRegion(region, selArray);\n        }\n        else {\n            rubberArray = this.diagram.spatialSearch.findObjects(region);\n        }\n        if (rubberArray.length) {\n            this.selectObjects(rubberArray, true);\n        }\n    };\n    CommandHandler.prototype.clearSelectionRectangle = function () {\n        var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);\n        var element = adornerSvg.getElementById(this.diagram.element.id + '_diagramAdorner_selected_region');\n        if (element) {\n            remove(element);\n        }\n    };\n    /**\n     * dragConnectorEnds method\\\n     *\n     * @returns {  void }    dragConnectorEnds method .\\\n     *  @param { string } endPoint - Provide the previousObject element .\n     *  @param { IElement } obj - Provide the previousObject element .\n     *  @param { PointModel } point - Provide the point element .\n     *  @param { BezierSegmentModel } segment - Provide the segment element .\n     *  @param { IElement } target - Provide the target element .\n     *  @param { string } targetPortId - Provide the targetPortId element .\n     * @private\n     */\n    CommandHandler.prototype.dragConnectorEnds = function (endPoint, obj, point, segment, target, targetPortId) {\n        var selectorModel;\n        var connector; //let node: Node;\n        var tx; //let segmentPoint: PointModel;\n        var ty; //let index: number;\n        var checkBezierThumb = false;\n        if (obj instanceof Selector) {\n            selectorModel = obj;\n            connector = selectorModel.connectors[0];\n        }\n        else if (obj instanceof Connector && this.diagram.currentDrawingObject) {\n            this.clearSelection();\n            connector = this.diagram.currentDrawingObject;\n        }\n        if (endPoint === 'BezierSourceThumb' || endPoint === 'BezierTargetThumb') {\n            checkBezierThumb = true;\n        }\n        if (endPoint === 'ConnectorSourceEnd' || endPoint === 'BezierSourceThumb') {\n            tx = point.x - (checkBezierThumb ? segment.bezierPoint1.x : connector.sourcePoint.x);\n            ty = point.y - (checkBezierThumb ? segment.bezierPoint1.y : connector.sourcePoint.y);\n            return this.dragSourceEnd(connector, tx, ty, null, point, endPoint, undefined, target, targetPortId, undefined, segment);\n        }\n        else {\n            tx = point.x - (checkBezierThumb ? segment.bezierPoint2.x : connector.targetPoint.x);\n            ty = point.y - (checkBezierThumb ? segment.bezierPoint2.y : connector.targetPoint.y);\n            return this.dragTargetEnd(connector, tx, ty, null, point, endPoint, undefined, segment);\n        }\n    };\n    /**\n     * getSelectedObject method\\\n     *\n     * @returns {  void }    getSelectedObject method .\\\n     * @private\n     */\n    CommandHandler.prototype.getSelectedObject = function () {\n        var selectormodel = this.diagram.selectedItems;\n        return (selectormodel.nodes).concat(selectormodel.connectors);\n    };\n    /**\n     * updateBlazorProperties method\\\n     *\n     * @returns {  void }    updateBlazorProperties method .\\\n     *  @param { boolean } isObjectInteraction - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.updateBlazorProperties = function (isObjectInteraction) {\n        var blazorInterop = 'sfBlazor';\n        var blazor = 'Blazor';\n        if (!isObjectInteraction) {\n            if (window && window[blazor]) {\n                var obj = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': this.diagramObject };\n                window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n            }\n        }\n        else {\n            if (window && window[blazor] && JSON.stringify(this.deepDiffer.diagramObject) !== '{}') {\n                var obj = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': this.deepDiffer.diagramObject };\n                if (!this.diagram.isLoading) {\n                    window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n                }\n            }\n        }\n        //this.diagram.enableServerDataBinding(true);\n        this.deepDiffer.newNodeObject = [];\n        this.deepDiffer.newConnectorObject = [];\n        this.diagramObject = [];\n        this.diagram.oldNodeObjects = [];\n        this.diagram.oldConnectorObjects = [];\n    };\n    /**\n     * enableCloneObject method\\\n     *\n     * @returns {  void }    enableCloneObject method .\\\n     *  @param { boolean } value - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.enableCloneObject = function (value) {\n        if ((!this.diagram.lineRoutingModule || !(this.diagram.constraints & DiagramConstraints.LineRouting))) {\n            this.diagram.canEnableBlazorObject = value;\n        }\n    };\n    /**\n     * ismouseEvents method\\\n     *\n     * @returns {  void }    ismouseEvents method .\\\n     *  @param { boolean } value - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.ismouseEvents = function (value) {\n        if (value) {\n            this.diagram.blazorActions = this.diagram.addConstraints(this.diagram.blazorActions, BlazorAction.interaction);\n        }\n        else {\n            this.diagram.blazorActions = this.diagram.removeConstraints(this.diagram.blazorActions, BlazorAction.interaction);\n        }\n    };\n    /**\n     * updateLayerObject method\\\n     *\n     * @returns {  void }    updateLayerObject method .\\\n     *  @param { object } oldDiagram - Provide the previousObject element .\n     *  @param { boolean } temp - Provide the temp element .\n     * @private\n     */\n    CommandHandler.prototype.updateLayerObject = function (oldDiagram, temp) {\n        if (isBlazor()) {\n            var diffLayers = {};\n            diffLayers = this.deepDiffer.getLayerObject(oldDiagram, temp, this.diagram);\n            this.diagramObject = diffLayers;\n            this.updateBlazorProperties();\n        }\n    };\n    /* tslint:enable:no-string-literal */\n    /**\n     * getDiagramOldValues method\\\n     *\n     * @returns {  void }    getDiagramOldValues method .\\\n     *  @param { object } oldDiagram - Provide the previousObject element .\n     *  @param { string[] } attribute - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.getDiagramOldValues = function (oldDiagram, attribute) {\n        var newDiagram = {};\n        for (var i = 0; i < attribute.length; i++) {\n            newDiagram[attribute[i]] = cloneObject(this.diagram[attribute[i]]);\n        }\n        var newObject = cloneObject(newDiagram);\n        var result = this.deepDiffer.map(newObject, oldDiagram);\n        var diffValue = this.deepDiffer.frameObject({}, result);\n        var diff = this.deepDiffer.removeEmptyValues(diffValue);\n        diff = this.deepDiffer.changeSegments(diff, newObject);\n        this.diagramObject = diff;\n        if (!(this.diagram.blazorActions & BlazorAction.ClearObject)) {\n            this.updateBlazorProperties();\n        }\n    };\n    /* tslint:disable */\n    /**\n     * getBlazorOldValues method\\\n     *\n     * @returns {  void }    getBlazorOldValues method .\\\n     *  @param { MouseEventArgs } args - Provide the previousObject element .\n     *  @param { boolean } labelDrag - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.getBlazorOldValues = function (args, labelDrag) {\n        if (isBlazor()) {\n            var oldNodeObject = this.diagram.oldNodeObjects;\n            for (var i = 0; i < oldNodeObject.length; i++) {\n                if (oldNodeObject[i].id) {\n                    if (this.diagram.oldNodeObjects[i] instanceof Node) {\n                        this.diagram.oldNodeObjects[i] = cloneBlazorObject(this.diagram.oldNodeObjects[i]);\n                    }\n                    this.deepDiffer.getDifferenceValues(this.diagram.nameTable[oldNodeObject[i].id], args, labelDrag, this.diagram);\n                }\n            }\n            var oldConnectorObject = this.diagram.oldConnectorObjects;\n            for (var i = 0; i < oldConnectorObject.length; i++) {\n                if (oldConnectorObject[i].id) {\n                    if (this.diagram.oldConnectorObjects[i] instanceof Connector) {\n                        this.diagram.oldConnectorObjects[i] = cloneBlazorObject(this.diagram.oldConnectorObjects[i]);\n                    }\n                    this.deepDiffer.getDifferenceValues(this.diagram.nameTable[oldConnectorObject[i].id], args, labelDrag, this.diagram);\n                }\n            }\n            if (oldNodeObject.length > 0 || oldConnectorObject.length > 0) {\n                this.updateBlazorProperties(true);\n            }\n        }\n    };\n    /**\n     * getObjectChanges method\\\n     *\n     * @returns {  void }    getObjectChanges method .\\\n     *  @param { Object[] } previousObject - Provide the previousObject element .\n     *  @param { Object[] } currentObject - Provide the previousObject element .\n     *  @param { Object[] } previousObject - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.getObjectChanges = function (previousObject, currentObject, changedNodes) {\n        for (var i = 0; i < previousObject.length; i++) {\n            var value = this.deepDiffer.map(currentObject[i], previousObject[i]);\n            var result = this.deepDiffer.frameObject({}, value);\n            var change = this.deepDiffer.removeEmptyValues(result);\n            if (change.children) {\n                change.children = cloneObject(currentObject[i]).children;\n            }\n            change = this.deepDiffer.changeSegments(change, currentObject[i]);\n            change.sfIndex = getIndex(this.diagram, currentObject[i].id);\n            changedNodes.push(change);\n        }\n    };\n    /**\n     * clearObjectSelection method\\\n     *\n     * @returns {  void }    clearObjectSelection method .\\\n     *  @param { (NodeModel | ConnectorModel) } mouseDownElement - Provide the triggerAction element .\n     * @private\n     */\n    // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node\n    CommandHandler.prototype.clearObjectSelection = function (mouseDownElement) {\n        var selectedItems = this.diagram.selectedItems;\n        var list = [];\n        list = list.concat(selectedItems.nodes, selectedItems.connectors);\n        if (list.indexOf(mouseDownElement) === -1) {\n            this.clearSelection((list.length > 0) ? true : false);\n            this.selectObjects([mouseDownElement], true);\n        }\n    };\n    /**\n     * clearSelection method\\\n     *\n     * @returns {  void }    clearSelection method .\\\n     *  @param { boolean } triggerAction - Provide the triggerAction element .\n     *  @param { boolean } isTriggered - Provide the isTriggered element .\n     * @private\n     */\n    CommandHandler.prototype.clearSelection = function (triggerAction, isTriggered) {\n        return __awaiter(this, void 0, void 0, function () {\n            var enableServerDataBinding, selectormodel, arrayNodes, arg, blazarArgs, eventObj, selectNodes, i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        enableServerDataBinding = this.diagram.allowServerDataBinding;\n                        this.diagram.enableServerDataBinding(false);\n                        if (!hasSelection(this.diagram)) return [3 /*break*/, 5];\n                        selectormodel = this.diagram.selectedItems;\n                        arrayNodes = this.getSelectedObject();\n                        if (this.diagram.currentSymbol) {\n                            this.diagram.previousSelectedObject = arrayNodes;\n                        }\n                        arg = {\n                            oldValue: arrayNodes, newValue: [], cause: this.diagram.diagramActions,\n                            state: 'Changing', type: 'Removal', cancel: false\n                        };\n                        this.updateBlazorSelectorModel(arrayNodes, true);\n                        if (triggerAction) {\n                            if (!isBlazor()) {\n                                this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                            }\n                            else {\n                                this.oldSelectedObjects = cloneObject(selectormodel);\n                            }\n                        }\n                        if (!!arg.cancel) return [3 /*break*/, 4];\n                        selectormodel.offsetX = 0;\n                        selectormodel.offsetY = 0;\n                        selectormodel.width = 0;\n                        selectormodel.height = 0;\n                        selectormodel.rotateAngle = 0;\n                        selectormodel.nodes = [];\n                        selectormodel.connectors = [];\n                        selectormodel.wrapper = null;\n                        selectormodel.annotation = undefined;\n                        this.diagram.clearSelectorLayer();\n                        if (!triggerAction) return [3 /*break*/, 4];\n                        arg = {\n                            oldValue: cloneBlazorObject(arrayNodes), newValue: [], cause: this.diagram.diagramActions,\n                            state: 'Changed', type: 'Removal', cancel: false\n                        };\n                        if (isBlazor()) {\n                            arg = this.updateSelectionChangeEventArgs(arg, [], arrayNodes);\n                            this.updateBlazorSelector();\n                        }\n                        if (!!isBlazor()) return [3 /*break*/, 1];\n                        this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                        return [3 /*break*/, 4];\n                    case 1:\n                        blazarArgs = void 0;\n                        if (!(window && window[this.blazor] && this.diagram.selectionChange)) return [3 /*break*/, 3];\n                        eventObj = { 'EventName': 'selectionChange', args: JSON.stringify(arg) };\n                        return [4 /*yield*/, window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram)];\n                    case 2:\n                        blazarArgs = _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        // let blazarArgs: void | object = await this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                        if (blazarArgs && blazarArgs.cancel && !isTriggered) {\n                            selectNodes = [];\n                            if (blazarArgs.oldValue.nodes.length > 0) {\n                                selectNodes = blazarArgs.oldValue.nodes;\n                            }\n                            if (blazarArgs.oldValue.connectors.length > 0) {\n                                selectNodes = selectNodes.concat(blazarArgs.oldValue.connectors);\n                            }\n                            if (selectNodes) {\n                                for (i = 0; i < selectNodes.length; i++) {\n                                    this.select(this.diagram.nameTable[selectNodes[i].id], (i !== 0 && selectNodes.length > 1) ? true : false);\n                                }\n                            }\n                        }\n                        _a.label = 4;\n                    case 4:\n                        this.updateBlazorSelector();\n                        this.diagram.enableServerDataBinding(enableServerDataBinding);\n                        _a.label = 5;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * clearSelectedItems method\\\n     *\n     * @returns {  void }    clearSelectedItems method .\\\n     * @private\n     */\n    CommandHandler.prototype.clearSelectedItems = function () {\n        var selectedNodes = this.diagram.selectedItems.nodes ? this.diagram.selectedItems.nodes.length : 0;\n        var selectedConnectors = this.diagram.selectedItems.connectors ? this.diagram.selectedItems.connectors.length : 0;\n        this.clearSelection((selectedNodes + selectedConnectors) > 0 ? true : false);\n    };\n    /**\n     * removeStackHighlighter method\\\n     *\n     * @returns {  void }    removeStackHighlighter method .\\\n     * @private\n     */\n    CommandHandler.prototype.removeStackHighlighter = function () {\n        var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);\n        var highlighter = adornerSvg.getElementById(adornerSvg.id + '_stack_highlighter');\n        if (highlighter) {\n            highlighter.parentNode.removeChild(highlighter);\n        }\n    };\n    /**\n     * @param {End} args - provide the args  value.\n     * @param {IElement} target - provide the target  value.\n     * @private\n     */\n    CommandHandler.prototype.renderStackHighlighter = function (args, target) {\n        var source = this.diagram.selectedItems.nodes[0];\n        var symbolDrag;\n        var node;\n        var selectorModel;\n        if (!target) {\n            var objects = this.diagram.findObjectsUnderMouse(args.position);\n            target = this.diagram.findObjectUnderMouse(objects, 'Drag', true);\n            if (target && !(target.isLane || target.isPhase || target.isHeader)) {\n                for (var i = 0; i < objects.length; i++) {\n                    var laneNode = this.diagram.nameTable[objects[i].id];\n                    if (!laneNode.isLane || laneNode.isPhase || laneNode.isHeader) {\n                        target = laneNode;\n                        this.diagram.parentObject = target;\n                    }\n                }\n            }\n        }\n        if (source && target && target.isLane && source.shape && !source.shape.isPhase) {\n            node = this.diagram.nameTable[target.parentId];\n            if (this.diagram.currentSymbol && node.shape.type === 'SwimLane') {\n                symbolDrag = true;\n            }\n            if ((source && !source.parentId && source.shape.type !== 'SwimLane') ||\n                (source && source.parentId && this.diagram.nameTable[source.parentId] && this.diagram.nameTable[source.parentId].isLane &&\n                    (source.parentId !== target.parentId && source.parentId !== target.id))) {\n                selectorModel = this.diagram.selectedItems;\n                var canvas = gridSelection(this.diagram, selectorModel, target.id, true);\n                if (canvas) {\n                    selectorModel.wrapper.children[0] = canvas;\n                }\n                this.diagram.renderSelector(false, true);\n                selectorModel.wrapper.children[0] = selectorModel.nodes[0].wrapper;\n            }\n        }\n        if (source && target && target.parentId && source.shape && source.shape.isPhase) {\n            var node_3 = this.diagram.nameTable[target.parentId];\n            if (node_3.shape.type === 'SwimLane') {\n                this.diagram.selectedItems.wrapper.children[0] = this.diagram.nameTable[target.parentId].wrapper;\n                this.diagram.renderSelector(false, true);\n            }\n        }\n        if ((symbolDrag && this.diagram.currentSymbol.shape.isLane) || (source && target &&\n            source.parentId && target.parentId && !source.isPhase && (source.parentId === target.parentId)\n            && (source.id !== target.id) && node &&\n            (node.container && (node.container.type === 'Stack' || node.container.type === 'Grid')))) {\n            var canvas = void 0;\n            var value = node.container.orientation === 'Vertical';\n            var isVertical = node.container === 'Stack' ? value : !value;\n            if (node.container.type === 'Grid' && target.isLane &&\n                ((!this.diagram.currentSymbol &&\n                    (node.shape.orientation === 'Horizontal' && target.rowIndex !== source.rowIndex) ||\n                    (node.shape.orientation === 'Vertical' && target.columnIndex !== source.columnIndex))\n                    || (this.diagram.currentSymbol &&\n                        this.diagram.currentSymbol.shape.orientation === node.container.orientation))) {\n                selectorModel = this.diagram.selectedItems;\n                if ((source.isLane && canLaneInterchange(source, this.diagram)) || !source.isLane) {\n                    canvas = gridSelection(this.diagram, selectorModel, target.id, symbolDrag);\n                }\n            }\n            var wrapper = node.container.type === 'Stack' ? target.wrapper : canvas;\n            if (wrapper) {\n                renderStackHighlighter(wrapper, isVertical, args.position, this.diagram, false, true);\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.insertBlazorConnector = function (obj) {\n        if (obj instanceof Selector) {\n            for (var i = 0; i < obj.connectors.length; i++) {\n                this.diagram.insertBlazorConnector(obj.connectors[i]);\n            }\n        }\n        else {\n            this.diagram.insertBlazorConnector(obj);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.drag = function (obj, tx, ty) {\n        var tempNode;\n        var elements = [];\n        if (canMove(obj) && this.checkBoundaryConstraints(tx, ty, obj.wrapper.bounds) && canPageEditable(this.diagram)) {\n            if (obj instanceof Node) {\n                var oldValues = { offsetX: obj.offsetX, offsetY: obj.offsetY };\n                obj.offsetX += tx;\n                obj.offsetY += ty;\n                if (obj.children && !(obj.container)) {\n                    if (!(checkParentAsContainer(this.diagram, obj, true))) {\n                        this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.isGroupDragging;\n                    }\n                    var nodes = this.getAllDescendants(obj, elements);\n                    for (var i = 0; i < nodes.length; i++) {\n                        tempNode = (this.diagram.nameTable[nodes[i].id]);\n                        this.drag(tempNode, tx, ty);\n                    }\n                    this.updateInnerParentProperties(obj);\n                    this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.isGroupDragging;\n                }\n                if (checkParentAsContainer(this.diagram, obj, true)) {\n                    checkChildNodeInContainer(this.diagram, obj);\n                }\n                else {\n                    if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {\n                        obj.wrapper.measureChildren = true;\n                    }\n                    this.diagram.nodePropertyChange(obj, oldValues, { offsetX: obj.offsetX, offsetY: obj.offsetY }, undefined, undefined, false);\n                    obj.wrapper.measureChildren = false;\n                }\n                if (obj.shape.type === 'SwimLane' && !this.diagram.currentSymbol) {\n                    var grid = obj.wrapper.children[0];\n                    var connectors = getConnectors(this.diagram, grid, 0, true);\n                    updateConnectorsProperties(connectors, this.diagram);\n                }\n            }\n            else {\n                var connector = obj;\n                var oldValues = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n                var update = connector.type === 'Bezier' ? true : false;\n                var hasEnds = false;\n                if (!connector.sourceWrapper) {\n                    this.dragSourceEnd(connector, tx, ty, true, null, '', update);\n                }\n                else {\n                    hasEnds = true;\n                }\n                if (!connector.targetWrapper) {\n                    this.dragTargetEnd(connector, tx, ty, true, null, '', update);\n                }\n                else {\n                    hasEnds = true;\n                }\n                var canDragPoints = false;\n                if (obj instanceof Connector) {\n                    canDragPoints = true;\n                }\n                if (!hasEnds || canDragPoints) {\n                    this.dragControlPoint(connector, tx, ty, true);\n                    var conn = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n                    this.diagram.connectorPropertyChange(connector, oldValues, conn);\n                }\n            }\n        }\n    };\n    /**   @private  */\n    CommandHandler.prototype.connectorSegmentChange = function (actualObject, existingInnerBounds, isRotate) {\n        var tx;\n        var ty;\n        var segmentChange = true;\n        if (existingInnerBounds.equals(existingInnerBounds, actualObject.wrapper.bounds) === false) {\n            if (actualObject.outEdges.length > 0) {\n                for (var k = 0; k < actualObject.outEdges.length; k++) {\n                    var connector = this.diagram.nameTable[actualObject.outEdges[k]];\n                    if (connector.targetID !== '') {\n                        segmentChange = this.isSelected(this.diagram.nameTable[connector.targetID]) ? false : true;\n                    }\n                    else {\n                        segmentChange = this.isSelected(this.diagram.nameTable[connector.id]) ? false : true;\n                    }\n                    if (connector.type === 'Orthogonal' && connector.segments && connector.segments.length > 1) {\n                        if (!isRotate) {\n                            if (segmentChange) {\n                                switch (connector.segments[0].direction) {\n                                    case 'Bottom':\n                                        tx = actualObject.wrapper.bounds.bottomCenter.x - existingInnerBounds.bottomCenter.x;\n                                        ty = actualObject.wrapper.bounds.bottomCenter.y - existingInnerBounds.bottomCenter.y;\n                                        break;\n                                    case 'Top':\n                                        tx = actualObject.wrapper.bounds.topCenter.x - existingInnerBounds.topCenter.x;\n                                        ty = actualObject.wrapper.bounds.topCenter.y - existingInnerBounds.topCenter.y;\n                                        break;\n                                    case 'Left':\n                                        tx = actualObject.wrapper.bounds.middleLeft.x - existingInnerBounds.middleLeft.x;\n                                        ty = actualObject.wrapper.bounds.middleLeft.y - existingInnerBounds.middleLeft.y;\n                                        break;\n                                    case 'Right':\n                                        tx = actualObject.wrapper.bounds.middleRight.x - existingInnerBounds.middleRight.x;\n                                        ty = actualObject.wrapper.bounds.middleRight.y - existingInnerBounds.middleRight.y;\n                                        break;\n                                }\n                                this.dragSourceEnd(connector, tx, ty, true, null, 'ConnectorSourceEnd', undefined, undefined, undefined, (actualObject.parentId &&\n                                    (this.diagram.diagramActions & DiagramAction.isGroupDragging)) ? false : true);\n                            }\n                        }\n                        else {\n                            var firstSegment = connector.segments[0];\n                            var secondSegment = connector.segments[1];\n                            var cornerPoints = swapBounds(actualObject.wrapper, actualObject.wrapper.corners, actualObject.wrapper.bounds);\n                            var sourcePoint = findPoint(cornerPoints, firstSegment.direction);\n                            sourcePoint = getIntersection(connector, connector.sourceWrapper, sourcePoint, { x: connector.sourceWrapper.offsetX, y: connector.sourceWrapper.offsetY }, false);\n                            var source = {\n                                corners: undefined, point: sourcePoint, margin: undefined, direction: firstSegment.direction\n                            };\n                            var target = {\n                                corners: undefined, point: secondSegment.points[1], margin: undefined, direction: undefined\n                            };\n                            var intermediatePoints = orthoConnection2Segment(source, target);\n                            firstSegment.length = Point.distancePoints(intermediatePoints[0], intermediatePoints[1]);\n                            if (secondSegment.direction && secondSegment.length) {\n                                secondSegment.length = Point.distancePoints(intermediatePoints[1], intermediatePoints[2]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.updateEndPoint = function (connector, oldChanges) {\n        var conn = {\n            sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint,\n            sourceID: connector.sourceID ? connector.sourceID : undefined,\n            targetID: connector.targetID ? connector.targetID : undefined,\n            sourcePortID: connector.sourcePortID ? connector.sourcePortID : undefined,\n            targetPortID: connector.targetPortID ? connector.targetPortID : undefined,\n            segments: connector.segments ? connector.segments : undefined\n        };\n        var newValue = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n        if (connector.sourceID) {\n            newValue.sourceID = connector.sourceID;\n        }\n        if (connector.targetID) {\n            newValue.targetID = connector.targetID;\n        }\n        if (connector.sourcePortID) {\n            newValue.sourcePortID = connector.sourcePortID;\n        }\n        if (connector.targetPortID) {\n            newValue.targetPortID = connector.targetPortID;\n        }\n        if (connector.segments) {\n            newValue.segments = connector.segments;\n        }\n        this.diagram.connectorPropertyChange(connector, oldChanges ? oldChanges : {}, newValue);\n        // this.diagram.refreshDiagramLayer();\n        this.diagram.updateSelector();\n    };\n    /**\n     * @param obj\n     * @param tx\n     * @param ty\n     * @param preventUpdate\n     * @param point\n     * @param endPoint\n     * @param update\n     * @param target\n     * @param targetPortId\n     * @param isDragSource\n     * @param segment\n     * @private\n     */\n    CommandHandler.prototype.dragSourceEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, target, targetPortId, isDragSource, segment) {\n        var connector = this.diagram.nameTable[obj.id];\n        var oldChanges = {};\n        var checkBoundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);\n        if (canDragSourceEnd(connector) && checkBoundaryConstraints\n            && (endPoint !== 'BezierSourceThumb') && canPageEditable(this.diagram)) {\n            oldChanges = { sourcePoint: connector.sourcePoint };\n            connector.sourcePoint.x += tx;\n            connector.sourcePoint.y += ty;\n            if (endPoint === 'ConnectorSourceEnd' && connector.type === 'Orthogonal') {\n                this.changeSegmentLength(connector, target, targetPortId, isDragSource);\n            }\n            if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n                this.updatePathElementOffset(connector);\n            }\n        }\n        if (connector.type === 'Bezier') {\n            oldChanges = { sourcePoint: connector.sourcePoint };\n            if (segment) {\n                this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorSourceEnd' : endPoint, tx, ty, segment, point, !update);\n            }\n            else {\n                for (var i = 0; i < obj.segments.length; i++) {\n                    this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorSourceEnd' : endPoint, tx, ty, obj.segments[i], point, !update);\n                }\n            }\n        }\n        if (!preventUpdate) {\n            this.updateEndPoint(connector, oldChanges);\n        }\n        if (!(this.diagram.realActions & RealAction.AnimationClick)) {\n            this.diagram.refreshCanvasLayers();\n        }\n        return checkBoundaryConstraints;\n    };\n    /**\n     * Update Path Element offset\n     */\n    CommandHandler.prototype.updatePathElementOffset = function (connector) {\n        connector.wrapper.children.splice(3, 1);\n        var pathElement = new PathElement();\n        var anglePoints = connector.intermediatePoints;\n        pathElement = updatePathElement(anglePoints, connector);\n        connector.wrapper.children.splice(3, 0, pathElement);\n    };\n    /**\n     * Upadte the connector segments when change the source node\n     */\n    CommandHandler.prototype.changeSegmentLength = function (connector, target, targetPortId, isDragSource) {\n        if (connector.segments && connector.segments[0].direction !== null\n            && ((!target && connector.sourceID === '') || isDragSource)) {\n            var first = connector.segments[0];\n            var second = connector.segments[1];\n            var node = this.diagram.nameTable[connector.sourceID];\n            var secPoint = void 0;\n            first.points[0] = connector.sourcePoint;\n            if (first.direction === 'Top' || first.direction === 'Bottom') {\n                first.points[first.points.length - 1].x = connector.sourcePoint.x;\n                second.points[0].y = first.points[first.points.length - 1].y;\n            }\n            else {\n                first.points[first.points.length - 1].y = connector.sourcePoint.y;\n                second.points[0].x = first.points[first.points.length - 1].x;\n            }\n            if (first.direction && (first.length || first.length === 0)) {\n                first.length = Point.distancePoints(first.points[0], first.points[first.points.length - 1]);\n            }\n            if (second.direction && (second.length || second.length === 0)) {\n                second.length = Point.distancePoints(first.points[first.points.length - 1], second.points[second.points.length - 1]);\n                second.direction = Point.direction(first.points[first.points.length - 1], second.points[second.points.length - 1]);\n            }\n            if (connector.sourcePortID !== '' && first.length < 10) {\n                if (connector.segments.length > 2) {\n                    var next = connector.segments[2];\n                    var nextDirection = Point.direction(next.points[0], next.points[1]);\n                    if (first.direction === getOppositeDirection(nextDirection)) {\n                        if (first.direction === 'Right') {\n                            next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleRight.x + 20;\n                        }\n                        else if (first.direction === 'Left') {\n                            next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleLeft.x - 20;\n                        }\n                        else if (first.direction === 'Top') {\n                            next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.topCenter.y - 20;\n                        }\n                        else {\n                            next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.bottomCenter.y + 20;\n                        }\n                        if (next.direction && next.length) {\n                            next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n                        }\n                        first.length = Point.distancePoints(first.points[0], first.points[first.points.length - 1]);\n                    }\n                    else if (first.direction === nextDirection && next.direction && next.length) {\n                        if (first.direction === 'Top' || first.direction === 'Bottom') {\n                            next.points[0] = first.points[0];\n                            next.points[next.points.length - 1].x = next.points[0].x;\n                        }\n                        else {\n                            next.points[0] = first.points[0];\n                            next.points[next.points.length - 1].y = next.points[0].y;\n                        }\n                        next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n                        connector.segments.splice(0, 2);\n                    }\n                    else {\n                        first.length = 20;\n                    }\n                }\n                else {\n                    first.length = 20;\n                }\n            }\n            else if (first.length < 1) {\n                if (connector.sourceID !== '') {\n                    if (second.direction === 'Right') {\n                        secPoint = node.wrapper.corners.middleRight;\n                        second.points[second.points.length - 1].y = secPoint.y;\n                    }\n                    else if (second.direction === 'Left') {\n                        secPoint = node.wrapper.corners.middleLeft;\n                        second.points[second.points.length - 1].y = secPoint.y;\n                    }\n                    else if (second.direction === 'Top') {\n                        secPoint = node.wrapper.corners.topCenter;\n                        second.points[second.points.length - 1].x = secPoint.x;\n                    }\n                    else {\n                        secPoint = node.wrapper.corners.bottomCenter;\n                        second.points[second.points.length - 1].x = secPoint.x;\n                    }\n                    second.length = Point.distancePoints(secPoint, second.points[second.points.length - 1]);\n                    if (connector.segments.length > 2) {\n                        var next = connector.segments[2];\n                        if (next.direction && next.length) {\n                            next.length = Point.distancePoints(second.points[second.points.length - 1], next.points[next.points.length - 1]);\n                        }\n                    }\n                    connector.segments.splice(0, 1);\n                }\n                else {\n                    connector.segments.splice(0, 1);\n                }\n            }\n        }\n        else {\n            if (target && !targetPortId && connector.sourceID !== target.id &&\n                connector.segments && connector.segments[0].direction !== null && target && target instanceof Node) {\n                this.changeSourceEndToNode(connector, target);\n            }\n            if (target && targetPortId && connector.sourcePortID !== targetPortId &&\n                connector.segments && connector.segments[0].direction !== null && target && target instanceof Node) {\n                this.changeSourceEndToPort(connector, target, targetPortId);\n            }\n        }\n    };\n    /**\n     * Change the connector endPoint to port\n     */\n    CommandHandler.prototype.changeSourceEndToPort = function (connector, target, targetPortId) {\n        var port = this.diagram.getWrapper(target.wrapper, targetPortId);\n        var point = { x: port.offsetX, y: port.offsetY };\n        var direction = getPortDirection(point, cornersPointsBeforeRotation(target.wrapper), target.wrapper.bounds, false);\n        var firstSegment = connector.segments[0];\n        var secondSegment = connector.segments[1];\n        if (firstSegment.direction !== direction) {\n            var segments = [];\n            var segValues = {};\n            if (firstSegment.direction === getOppositeDirection(direction)) {\n                segValues = {};\n                var segValues1 = void 0;\n                if (direction === 'Top' || direction === 'Bottom') {\n                    segValues1 = (direction === 'Top') ? {\n                        type: 'Orthogonal', isTerminal: true, direction: direction,\n                        length: Math.abs(firstSegment.points[0].y - point.y)\n                    } :\n                        {\n                            type: 'Orthogonal', isTerminal: true, direction: direction,\n                            length: Math.abs(point.y - firstSegment.points[0].y)\n                        };\n                    segValues = (firstSegment.points[0].x > point.x) ?\n                        { type: 'Orthogonal', isTerminal: true, direction: 'Right', length: (firstSegment.points[0].x - point.x) } :\n                        { type: 'Orthogonal', isTerminal: true, direction: 'Left', length: (point.x - firstSegment.points[0].x) };\n                }\n                else {\n                    segValues1 = (direction === 'Right') ? {\n                        type: 'Orthogonal', isTerminal: true, direction: direction,\n                        length: Math.abs(firstSegment.points[0].x - point.x)\n                    } :\n                        {\n                            type: 'Orthogonal', isTerminal: true, direction: direction,\n                            length: Math.abs(point.x - firstSegment.points[0].x)\n                        };\n                    segValues = (firstSegment.points[0].y > point.y) ?\n                        { type: 'Orthogonal', direction: 'Top', isTerminal: true, length: (firstSegment.points[0].y - point.y) } :\n                        { type: 'Orthogonal', direction: 'Bottom', isTerminal: true, length: (point.y - firstSegment.points[0].y) };\n                }\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues1, true));\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n            }\n            else {\n                segValues = { type: 'Orthogonal', direction: direction, length: 20, isTerminal: true };\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n            }\n            if (firstSegment.direction !== getOppositeDirection(direction)) {\n                if (direction === 'Top' || direction === 'Bottom') {\n                    firstSegment.points[0].x = point.x;\n                    firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = (direction === 'Top') ?\n                        point.y - 20 : point.y + 20;\n                }\n                else {\n                    firstSegment.points[0].y = point.y;\n                    firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = (direction === 'Right') ?\n                        point.x + 20 : point.x - 20;\n                }\n                firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n                secondSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);\n            }\n            connector.segments = segments.concat(connector.segments);\n        }\n        else {\n            firstSegment.points[0] = point;\n            if (direction === 'Top' || direction === 'Bottom') {\n                firstSegment.points[firstSegment.points.length - 1].x = point.x;\n            }\n            else {\n                firstSegment.points[firstSegment.points.length - 1].y = point.y;\n            }\n            firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n            secondSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);\n        }\n    };\n    /**\n     * @param connector\n     * @param changeTerminal\n     * @private\nRemove terinal segment in initial\n     */\n    CommandHandler.prototype.removeTerminalSegment = function (connector, changeTerminal) {\n        for (var i = 0; i < connector.segments.length - 2; i++) {\n            var segment = connector.segments[0];\n            if (segment.isTerminal) {\n                if (changeTerminal) {\n                    segment.isTerminal = false;\n                }\n                else {\n                    connector.segments.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    };\n    /**\n     * Change the connector endPoint from point to node\n     */\n    CommandHandler.prototype.changeSourceEndToNode = function (connector, target) {\n        this.removeTerminalSegment(connector);\n        var sourceWrapper = target.wrapper.children[0].corners;\n        var sourcePoint;\n        var sourcePoint2;\n        var firstSegment = connector.segments[0];\n        var nextSegment = connector.segments[1];\n        var segments = [];\n        if (firstSegment.direction === 'Right' || firstSegment.direction === 'Left') {\n            sourcePoint = (firstSegment.direction === 'Left') ? sourceWrapper.middleLeft : sourceWrapper.middleRight;\n            if (firstSegment.length > sourceWrapper.width || ((firstSegment.direction === 'Left' &&\n                sourcePoint.x >= firstSegment.points[0].x) || (firstSegment.direction === 'Right' &&\n                sourcePoint.x <= firstSegment.points[0].x))) {\n                firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = sourcePoint.y;\n                firstSegment.points[0].x = sourcePoint.x;\n                firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n                nextSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);\n            }\n            else {\n                var direction = void 0;\n                if (nextSegment.direction) {\n                    direction = nextSegment.direction;\n                }\n                else {\n                    direction = Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);\n                }\n                sourcePoint2 = (direction === 'Bottom') ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;\n                if (nextSegment.length && nextSegment.direction) {\n                    nextSegment.length =\n                        (direction === 'Top') ? firstSegment.points[firstSegment.points.length - 1].y - (sourcePoint2.y + 20) :\n                            (sourcePoint2.y + 20) - firstSegment.points[firstSegment.points.length - 1].y;\n                }\n                firstSegment.length = firstSegment.points[firstSegment.points.length - 1].x - sourcePoint2.x;\n                firstSegment.direction = (firstSegment.length > 0) ? 'Right' : 'Left';\n                var segValues = { type: 'Orthogonal', direction: direction, length: 20 };\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n                connector.segments = segments.concat(connector.segments);\n            }\n        }\n        else {\n            sourcePoint = (firstSegment.direction === 'Bottom') ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;\n            if (firstSegment.length > sourceWrapper.height || ((firstSegment.direction === 'Top' &&\n                sourcePoint.y >= firstSegment.points[0].y) ||\n                (firstSegment.direction === 'Bottom' && sourcePoint.y <= firstSegment.points[0].y))) {\n                firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = sourcePoint.x;\n                firstSegment.points[0].y = sourcePoint.y;\n                firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n                nextSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);\n            }\n            else {\n                sourcePoint2 = (nextSegment.direction === 'Left') ? sourceWrapper.middleLeft : sourceWrapper.middleRight;\n                var direction = void 0;\n                if (nextSegment.direction) {\n                    direction = nextSegment.direction;\n                }\n                else {\n                    direction = Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);\n                }\n                if (nextSegment.length && nextSegment.direction) {\n                    nextSegment.length =\n                        (direction === 'Left') ? firstSegment.points[firstSegment.points.length - 1].x - (sourcePoint2.x + 20) :\n                            (sourcePoint2.x + 20) - firstSegment.points[firstSegment.points.length - 1].x;\n                }\n                firstSegment.length = firstSegment.points[firstSegment.points.length - 1].y - sourcePoint2.y;\n                firstSegment.direction = (firstSegment.length > 0) ? 'Bottom' : 'Top';\n                var segValues = { type: 'Orthogonal', direction: direction, length: 20 };\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n                connector.segments = segments.concat(connector.segments);\n            }\n        }\n    };\n    //Translate the bezier points during the interaction\n    CommandHandler.prototype.translateBezierPoints = function (connector, value, tx, ty, seg, point, update) {\n        var index = (connector.segments.indexOf(seg));\n        var segment = connector.segments[index];\n        if (segment) {\n            if (value === 'BezierSourceThumb' && (segment.vector1.angle || segment.vector1.distance)) {\n                segment.vector1 = {\n                    distance: connector.distance(connector.sourcePoint, point),\n                    angle: Point.findAngle(connector.sourcePoint, point)\n                };\n            }\n            else if (value === 'BezierTargetThumb' && (segment.vector2.angle || segment.vector2.distance)) {\n                segment.vector2 = {\n                    distance: connector.distance(connector.targetPoint, point),\n                    angle: Point.findAngle(connector.targetPoint, point)\n                };\n            }\n            else if ((value === 'ConnectorSourceEnd' && !connector.sourceID || value === 'ConnectorTargetEnd' && !connector.targetID)\n                && update && isEmptyVector(segment.vector1) && isEmptyVector(segment.vector2)) {\n                if (Point.isEmptyPoint(segment.point1)) {\n                    segment.bezierPoint1 = getBezierPoints(connector.sourcePoint, connector.targetPoint);\n                }\n                if (Point.isEmptyPoint(segment.point2)) {\n                    segment.bezierPoint2 = getBezierPoints(connector.targetPoint, connector.sourcePoint);\n                }\n            }\n            else if (value === 'BezierSourceThumb' || (value === 'ConnectorSourceEnd' && !update && isEmptyVector(segment.vector1))) {\n                segment.bezierPoint1.x += tx;\n                segment.bezierPoint1.y += ty;\n                if ((!Point.isEmptyPoint(segment.point1)) || (update)) {\n                    segment.point1 = { x: segment.bezierPoint1.x, y: segment.bezierPoint1.y };\n                }\n            }\n            else if (value === 'BezierTargetThumb' || (value === 'ConnectorTargetEnd' && !update && isEmptyVector(segment.vector2))) {\n                segment.bezierPoint2.x += tx;\n                segment.bezierPoint2.y += ty;\n                if ((!Point.isEmptyPoint(segment.point2)) || (update)) {\n                    segment.point2 = { x: segment.bezierPoint2.x, y: segment.bezierPoint2.y };\n                }\n            }\n        }\n    };\n    /**\n     * dragTargetEnd method \\\n     *\n     * @returns { void }     dragTargetEnd method .\\\n     * @param {ConnectorModel} obj - provide the obj value.\n     * @param {number} tx - provide the tx value.\n     * @param {number} ty - provide the ty value.\n     * @param {boolean} preventUpdate - provide the preventUpdate value.\n     * @param {PointModel} point - provide the point value.\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {boolean} update - provide the update value.\n     * @param {OrthogonalSegmentModel | BezierSegmentModel | StraightSegmentModel} segment - provide the segment value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.dragTargetEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, segment) {\n        var connector = this.diagram.nameTable[obj.id];\n        var oldChanges;\n        var boundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);\n        if (canDragTargetEnd(connector) && endPoint !== 'BezierTargetThumb'\n            && boundaryConstraints && canPageEditable(this.diagram)) {\n            oldChanges = { targetPoint: connector.targetPoint };\n            connector.targetPoint.x += tx;\n            connector.targetPoint.y += ty;\n            if (endPoint === 'ConnectorTargetEnd' && connector.type === 'Orthogonal' &&\n                connector.segments && connector.segments.length > 0) {\n                var prev = connector.segments[connector.segments.length - 2];\n                if (prev && connector.segments[connector.segments.length - 1].points.length === 2) {\n                    if (prev.direction === 'Left' || prev.direction === 'Right') {\n                        prev.points[prev.points.length - 1].x = connector.targetPoint.x;\n                    }\n                    else {\n                        prev.points[prev.points.length - 1].y = connector.targetPoint.y;\n                    }\n                    prev.length = Point.distancePoints(prev.points[0], prev.points[prev.points.length - 1]);\n                    prev.direction = Point.direction(prev.points[0], prev.points[prev.points.length - 1]);\n                }\n            }\n            if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n                this.updatePathElementOffset(connector);\n            }\n        }\n        if (connector.type === 'Bezier') {\n            oldChanges = { targetPoint: connector.targetPoint };\n            if (segment) {\n                this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorTargetEnd' : endPoint, tx, ty, segment, point, !update);\n            }\n            else {\n                for (var i = 0; i < obj.segments.length; i++) {\n                    this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorTargetEnd' : endPoint, tx, ty, obj.segments[i], point, !update);\n                }\n            }\n        }\n        if (!preventUpdate) {\n            this.updateEndPoint(connector, oldChanges);\n        }\n        if (!(this.diagram.realActions & RealAction.AnimationClick)) {\n            this.diagram.refreshCanvasLayers();\n        }\n        return boundaryConstraints;\n    };\n    /**\n     * dragControlPoint method \\\n     *\n     * @returns { void }     dragControlPoint method .\\\n     * @param {ConnectorModel} obj - provide the obj value.\n     * @param {number} tx - provide the tx value.\n     * @param {number} ty - provide the ty value.\n     * @param {boolean} preventUpdate - provide the preventUpdate value.\n     * @param {number} segmentNumber - provide the segmentNumber value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.dragControlPoint = function (obj, tx, ty, preventUpdate, segmentNumber) {\n        var connector = this.diagram.nameTable[obj.id];\n        if ((connector.type === 'Straight' || connector.type === 'Bezier') && connector.segments.length > 0) {\n            if (segmentNumber !== undefined && connector.segments[segmentNumber]) {\n                connector.segments[segmentNumber].point.x += tx;\n                connector.segments[segmentNumber].point.y += ty;\n            }\n            else {\n                for (var i = 0; i < connector.segments.length - 1; i++) {\n                    connector.segments[i].point.x += tx;\n                    connector.segments[i].point.y += ty;\n                }\n            }\n            if (!preventUpdate) {\n                this.updateEndPoint(connector);\n            }\n        }\n        return true;\n    };\n    /**\n     * rotatePropertyChnage method \\\n     *\n     * @returns { void }     rotatePropertyChnage method .\\\n     * @param {number} angle - provide the obj value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.rotatePropertyChnage = function (angle) {\n        var selectedItems = this.diagram.selectedItems;\n        var objects = [];\n        objects = objects.concat(selectedItems.nodes);\n        objects = objects.concat(selectedItems.connectors);\n        var pivotValue = { x: selectedItems.offsetX, y: selectedItems.offsetY };\n        this.rotateObjects(selectedItems, objects, angle - selectedItems.rotateAngle, pivotValue);\n        selectedItems.wrapper.rotateAngle = selectedItems.rotateAngle = angle;\n        this.diagram.updateSelector();\n    };\n    /**\n     * rotateObjects method \\\n     *\n     * @returns { void }     rotateObjects method .\\\n     * @param {NodeModel | SelectorModel} parent - provide the parent value.\n     * @param {(NodeModel | ConnectorModel)[]} objects - provide the objects value.\n     * @param {number} angle - provide the angle value.\n     * @param {PointModel} pivot - provide the pivot value.\n     * @param {boolean} includeParent - provide the includeParent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.rotateObjects = function (parent, objects, angle, pivot, includeParent) {\n        pivot = pivot || {};\n        var matrix = identityMatrix();\n        rotateMatrix(matrix, angle, pivot.x, pivot.y);\n        var oldValues;\n        for (var _i = 0, objects_2 = objects; _i < objects_2.length; _i++) {\n            var obj = objects_2[_i];\n            if (obj instanceof Node) {\n                if (canRotate(obj) && canPageEditable(this.diagram)) {\n                    if (includeParent !== false || parent !== obj) {\n                        oldValues = { rotateAngle: obj.rotateAngle };\n                        obj.rotateAngle += angle;\n                        obj.rotateAngle = (obj.rotateAngle + 360) % 360;\n                        var newOffset = transformPointByMatrix(matrix, { x: obj.offsetX, y: obj.offsetY });\n                        obj.offsetX = newOffset.x;\n                        obj.offsetY = newOffset.y;\n                        this.diagram.nodePropertyChange(obj, {}, { offsetX: obj.offsetX, offsetY: obj.offsetY, rotateAngle: obj.rotateAngle });\n                    }\n                    if (obj.processId) {\n                        var parent_3 = this.diagram.nameTable[obj.processId];\n                        var bound = this.diagram.bpmnModule.getChildrenBound(parent_3, obj.id, this.diagram);\n                        this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);\n                    }\n                    if (obj.children && obj.children.length && !obj.container) {\n                        this.getChildren(obj, objects);\n                    }\n                }\n            }\n            else {\n                this.rotatePoints(obj, angle, pivot || { x: obj.wrapper.offsetX, y: obj.wrapper.offsetY });\n            }\n            this.diagram.updateDiagramObject(obj);\n        }\n        this.diagram.refreshCanvasLayers();\n        this.diagram.updateSelector();\n    };\n    /**\n     * snapConnectorEnd method \\\n     *\n     * @returns { PointModel }     snapConnectorEnd method .\\\n     * @param {PointModel} currentPosition - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.snapConnectorEnd = function (currentPosition) {\n        if ((this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines)\n            && this.snappingModule) {\n            this.diagram.snappingModule.snapConnectorEnd(currentPosition);\n        }\n        return currentPosition;\n    };\n    /**\n     * snapAngle method \\\n     *\n     * @returns { number }     snapAngle method .\\\n     * @param {number} angle - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.snapAngle = function (angle) {\n        if ((this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines)\n            && this.snappingModule) {\n            return this.snappingModule.snapAngle(this.diagram, angle);\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * rotatePoints method \\\n     *\n     * @returns { number }     rotatePoints method .\\\n     * @param {Connector} conn - provide the parent value.\n     * @param {number} angle - provide the parent value.\n     * @param {PointModel} pivot - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.rotatePoints = function (conn, angle, pivot) {\n        if (!conn.sourceWrapper || !conn.targetWrapper) {\n            var matrix = identityMatrix();\n            rotateMatrix(matrix, angle, pivot.x, pivot.y);\n            conn.sourcePoint = transformPointByMatrix(matrix, conn.sourcePoint);\n            conn.targetPoint = transformPointByMatrix(matrix, conn.targetPoint);\n            if (conn.shape.type === 'Bpmn' && conn.shape.sequence === 'Default') {\n                this.updatePathElementOffset(conn);\n            }\n            var newProp = { sourcePoint: conn.sourcePoint, targetPoint: conn.targetPoint };\n            this.diagram.connectorPropertyChange(conn, {}, newProp);\n            if (conn.segments && conn.segments.length > 0) {\n                this.diagram.protectPropertyChange(true);\n                var connector = conn;\n                connector.segments = [];\n                this.diagram.connectorPropertyChange(connector, {}, { segments: connector.segments });\n                this.diagram.protectPropertyChange(false);\n            }\n        }\n    };\n    CommandHandler.prototype.updateInnerParentProperties = function (tempNode) {\n        var elements = [];\n        var protect = 'isProtectedOnChange';\n        var protectChange = this.diagram[protect];\n        this.diagram.protectPropertyChange(true);\n        var innerParents = this.getAllDescendants(tempNode, elements, false, true);\n        for (var i = 0; i < innerParents.length; i++) {\n            var obj = this.diagram.nameTable[innerParents[i].id];\n            obj.offsetX = obj.wrapper.offsetX;\n            obj.offsetY = obj.wrapper.offsetY;\n            obj.width = obj.wrapper.width;\n            obj.height = obj.wrapper.height;\n        }\n        this.diagram.protectPropertyChange(protectChange);\n    };\n    /**\n     * scale method \\\n     *\n     * @returns { boolean }     scale method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the parent value.\n     * @param {number} sw - provide the parent value.\n     * @param {number} sh - provide the parent value.\n     * @param {number} pivot - provide the parent value.\n     * @param {number} refObject - provide the parent value.\n     * @param {boolean} isOutsideBoundary - provide the parent value.\n     *\n     * @private\n     */\n    // eslint-disable-next-line max-len\n    CommandHandler.prototype.scale = function (obj, sw, sh, pivot, refObject, isOutsideBoundary) {\n        var node = this.diagram.nameTable[obj.id];\n        var tempNode = node;\n        var elements = [];\n        var element = node.wrapper;\n        if (!refObject) {\n            refObject = obj;\n        }\n        var refWrapper = refObject.wrapper;\n        var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;\n        var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;\n        var refPoint = getPoint(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);\n        if (element.actualSize.width !== undefined && element.actualSize.height !== undefined && canPageEditable(this.diagram)) {\n            if (tempNode.children && !(tempNode.container)) {\n                var nodes = this.getAllDescendants(tempNode, elements);\n                for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                    var temp = nodes_1[_i];\n                    this.scaleObject(sw, sh, refPoint, temp, element, refObject);\n                }\n                obj.wrapper.measure(new Size());\n                obj.wrapper.arrange(obj.wrapper.desiredSize);\n                this.diagram.updateGroupOffset(node);\n                this.updateInnerParentProperties(tempNode);\n            }\n            else {\n                this.scaleObject(sw, sh, refPoint, node, element, refObject);\n            }\n            var bounds = getBounds(obj.wrapper);\n            var checkBoundaryConstraints = this.checkBoundaryConstraints(undefined, undefined, bounds);\n            if (!checkBoundaryConstraints && isOutsideBoundary) {\n                this.scale(obj, 1 / sw, 1 / sh, pivot, undefined, true);\n                return false;\n            }\n            this.diagram.updateDiagramObject(obj);\n        }\n        return true;\n    };\n    /** @private */\n    CommandHandler.prototype.getAllDescendants = function (node, nodes, includeParent, innerParent) {\n        var temp = node;\n        var parentNodes = [];\n        for (var i = 0; i < temp.children.length; i++) {\n            node = (this.diagram.nameTable[temp.children[i]]);\n            if (node) {\n                if (!node.children) {\n                    nodes.push(node);\n                }\n                else {\n                    if (includeParent) {\n                        nodes.push(node);\n                    }\n                    if (innerParent) {\n                        parentNodes.push(node);\n                    }\n                    nodes = this.getAllDescendants(node, nodes);\n                }\n            }\n        }\n        return (innerParent) ? parentNodes : nodes;\n    };\n    /**\n     * getChildren method \\\n     *\n     * @returns { (NodeModel | ConnectorModel)[]): (NodeModel | ConnectorModel)[] }     getChildren method .\\\n     * @param {NodeModel} node - provide the sw value.\n     * @param {(NodeModel | ConnectorModel)[]} nodes - provide the sw value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.getChildren = function (node, nodes) {\n        var temp = node;\n        if (node.children) {\n            for (var i = 0; i < temp.children.length; i++) {\n                node = (this.diagram.nameTable[temp.children[i]]);\n                nodes.push(node);\n            }\n        }\n        return nodes;\n    };\n    /**\n     * scaleObject method \\\n     *\n     * @returns { NodeModel }     scaleObject method .\\\n     * @param {string} id - provide the sw value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.cloneChild = function (id) {\n        var node = this.diagram.nameTable[id];\n        return node;\n    };\n    /**\n     * scaleObject method \\\n     *\n     * @returns { void }     scaleObject method .\\\n     * @param {End} sw - provide the sw value.\n     * @param {End} sh - provide the sh value.\n     * @param {PointModel} pivot - provide the pivot value.\n     * @param {IElement} obj - provide the pivot value.\n     * @param {DiagramElement} element - provide the element value.\n     * @param {IElement} refObject - provide the refObject value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.scaleObject = function (sw, sh, pivot, obj, element, refObject, canUpdate) {\n        sw = sw < 0 ? 1 : sw;\n        sh = sh < 0 ? 1 : sh;\n        var oldValues = {};\n        if (sw !== 1 || sh !== 1) {\n            var width = void 0;\n            var height = void 0;\n            if (obj instanceof Node) {\n                var node = obj;\n                var isResize = void 0;\n                var bound = void 0;\n                oldValues = {\n                    width: obj.wrapper.actualSize.width, height: obj.wrapper.actualSize.height,\n                    offsetX: obj.wrapper.offsetX, offsetY: obj.wrapper.offsetY,\n                    margin: { top: node.margin.top, left: node.margin.left }\n                };\n                if (node.shape.type === 'Bpmn' && node.shape.activity.subProcess.processes\n                    && node.shape.activity.subProcess.processes.length > 0) {\n                    bound = this.diagram.bpmnModule.getChildrenBound(node, node.id, this.diagram);\n                    isResize = node.wrapper.bounds.containsRect(bound);\n                }\n                width = node.wrapper.actualSize.width * sw;\n                height = node.wrapper.actualSize.height * sh;\n                if (node.maxWidth !== undefined && node.maxWidth !== 0) {\n                    width = Math.min(node.maxWidth, width);\n                }\n                if (node.minWidth !== undefined && node.minWidth !== 0) {\n                    width = Math.max(node.minWidth, width);\n                }\n                if (node.maxHeight !== undefined && node.maxHeight !== 0) {\n                    height = Math.min(node.maxHeight, height);\n                }\n                if (node.minHeight !== undefined && node.minHeight !== 0) {\n                    height = Math.max(node.minHeight, height);\n                }\n                if (isResize) {\n                    width = Math.max(width, (bound.right - node.wrapper.bounds.x));\n                    height = Math.max(height, (bound.bottom - node.wrapper.bounds.y));\n                }\n                sw = width / node.actualSize.width;\n                sh = height / node.actualSize.height;\n            }\n            var matrix = identityMatrix(); // let refWrapper: DiagramElement;\n            if (!refObject) {\n                refObject = obj;\n            }\n            var refWrapper = refObject.wrapper;\n            rotateMatrix(matrix, -refWrapper.rotateAngle, pivot.x, pivot.y);\n            scaleMatrix(matrix, sw, sh, pivot.x, pivot.y);\n            rotateMatrix(matrix, refWrapper.rotateAngle, pivot.x, pivot.y);\n            if (obj instanceof Node) {\n                var node = obj; //let left: number; let top: number;\n                var newPosition = transformPointByMatrix(matrix, { x: node.wrapper.offsetX, y: node.wrapper.offsetY });\n                var oldleft = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;\n                var oldtop = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;\n                if (width > 0) {\n                    if (node.processId) {\n                        var parent_4 = this.diagram.nameTable[node.processId];\n                        if (!parent_4.maxWidth || ((node.margin.left + width) < parent_4.maxWidth)) {\n                            node.width = width;\n                            node.offsetX = newPosition.x;\n                        }\n                    }\n                    else {\n                        node.width = width;\n                        node.offsetX = newPosition.x;\n                    }\n                }\n                if (height > 0) {\n                    if (node.processId) {\n                        var parent_5 = this.diagram.nameTable[node.processId];\n                        if (!parent_5.maxHeight || ((node.margin.top + height) < parent_5.maxHeight)) {\n                            node.height = height;\n                            node.offsetY = newPosition.y;\n                        }\n                    }\n                    else {\n                        node.height = height;\n                        node.offsetY = newPosition.y;\n                    }\n                }\n                var left = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;\n                var top_1 = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;\n                var parent_6 = this.diagram.nameTable[node.processId];\n                if (parent_6 && ((node.margin.top + (top_1 - oldtop)) <= 0 ||\n                    (node.margin.left + (left - oldleft) <= 0))) {\n                    this.diagram.nodePropertyChange(obj, {}, {\n                        margin: { top: node.margin.top, left: node.margin.left }\n                    });\n                }\n                else {\n                    if (checkParentAsContainer(this.diagram, obj, true)) {\n                        checkChildNodeInContainer(this.diagram, obj);\n                    }\n                    else {\n                        if (!canUpdate) {\n                            this.diagram.nodePropertyChange(obj, oldValues, {\n                                width: node.width, height: node.height, offsetX: node.offsetX, offsetY: node.offsetY,\n                                margin: { top: node.margin.top + (top_1 - oldtop), left: node.margin.left + (left - oldleft) }\n                            });\n                        }\n                    }\n                }\n            }\n            else {\n                var connector = obj;\n                var oldValues_1 = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n                if (!connector.sourceWrapper || !connector.targetWrapper) {\n                    this.scaleConnector(connector, matrix, oldValues_1, sw, sh, pivot);\n                }\n            }\n            var parentNode = this.diagram.nameTable[obj.processId];\n            if (parentNode) {\n                var parent_7 = parentNode.wrapper.bounds;\n                var child = obj.wrapper.bounds;\n                var bound = this.diagram.bpmnModule.getChildrenBound(parentNode, obj.id, this.diagram);\n                this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);\n            }\n        }\n    };\n    CommandHandler.prototype.scaleConnector = function (connector, matrix, oldValues, sw, sh, pivot) {\n        connector.sourcePoint = transformPointByMatrix(matrix, connector.sourcePoint);\n        connector.targetPoint = transformPointByMatrix(matrix, connector.targetPoint);\n        if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n            this.updatePathElementOffset(connector);\n        }\n        var newProp = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n        this.diagram.connectorPropertyChange(connector, oldValues, newProp);\n        var selector = this.diagram.selectedItems;\n        if (selectionHasConnector(this.diagram, selector)) {\n            var clonedSelectedItems = cloneObject(this.diagram.selectedItems);\n            var nodeModel = {\n                offsetX: clonedSelectedItems.offsetX, offsetY: clonedSelectedItems.offsetY,\n                height: clonedSelectedItems.height, width: clonedSelectedItems.width, rotateAngle: clonedSelectedItems.rotateAngle\n            };\n            var obj = new Node(this.diagram, 'nodes', nodeModel, true);\n            obj.wrapper = clonedSelectedItems.wrapper;\n            obj.wrapper.rotateAngle = selector.rotateAngle;\n            this.scaleObject(sw, sh, pivot, obj, obj.wrapper, obj, true);\n            selector.wrapper.actualSize.width = obj.width;\n            selector.wrapper.actualSize.height = obj.height;\n            selector.wrapper.offsetX = obj.offsetX;\n            selector.wrapper.offsetY = obj.offsetY;\n            var child = this.diagram.selectedItems.connectors[0];\n            if (child.id !== connector.id) {\n                this.measureSelector(selector);\n            }\n        }\n    };\n    CommandHandler.prototype.measureSelector = function (selector) {\n        var desiredBounds = undefined;\n        //Measuring the children\n        var clonedSelectedItems = cloneObject(this.diagram.selectedItems);\n        var objects = [];\n        var bounds;\n        objects = clonedSelectedItems.connectors;\n        var pivot = { x: this.diagram.selectedItems.offsetX, y: this.diagram.selectedItems.offsetY };\n        for (var i = 0; i < objects.length; i++) {\n            var matrix_1 = identityMatrix();\n            rotateMatrix(matrix_1, -selector.rotateAngle, pivot.x, pivot.y);\n            objects[i].sourcePoint = transformPointByMatrix(matrix_1, objects[i].sourcePoint);\n            objects[i].targetPoint = transformPointByMatrix(matrix_1, objects[i].targetPoint);\n            var p1 = { x: objects[i].sourcePoint.x, y: objects[i].sourcePoint.y };\n            var p2 = { x: objects[i].targetPoint.x, y: objects[i].targetPoint.y };\n            bounds = (this.calculateBounds(p1, p2));\n            if (desiredBounds === undefined) {\n                desiredBounds = bounds;\n            }\n            else {\n                desiredBounds.uniteRect(bounds);\n            }\n        }\n        var offsetPt = {};\n        if (desiredBounds !== undefined) {\n            offsetPt = {\n                x: desiredBounds.x + desiredBounds.width * selector.wrapper.pivot.x,\n                y: desiredBounds.y + desiredBounds.height * selector.wrapper.pivot.y\n            };\n        }\n        var nodeModel = {\n            offsetX: offsetPt.x, offsetY: offsetPt.y,\n            height: desiredBounds.height, width: desiredBounds.width, rotateAngle: 0\n        };\n        var obj = new Node(this.diagram, 'nodes', nodeModel, true);\n        var matrix = identityMatrix();\n        rotateMatrix(matrix, selector.rotateAngle, pivot.x, pivot.y);\n        obj.rotateAngle += selector.rotateAngle;\n        obj.rotateAngle = (obj.rotateAngle + 360) % 360;\n        var newOffset = transformPointByMatrix(matrix, { x: obj.offsetX, y: obj.offsetY });\n        obj.offsetX = newOffset.x;\n        obj.offsetY = newOffset.y;\n        selector.wrapper.actualSize.width = desiredBounds.width;\n        selector.wrapper.actualSize.height = desiredBounds.height;\n        selector.wrapper.offsetX = obj.offsetX;\n        selector.wrapper.offsetY = obj.offsetY;\n        var selectorEle = getSelectorElement(this.diagram.element.id);\n        this.diagram.diagramRenderer.renderResizeHandle(selector.wrapper, selectorEle, selector.thumbsConstraints, this.diagram.scroller.currentZoom, selector.constraints, this.diagram.scroller.transform, false, canMove(selector));\n    };\n    CommandHandler.prototype.calculateBounds = function (p1, p2) {\n        var left = Math.min(p1.x, p2.x);\n        var right = Math.max(p1.x, p2.x);\n        var top = Math.min(p1.y, p2.y);\n        var bottom = Math.max(p1.y, p2.y);\n        var width = right - left;\n        var height = bottom - top;\n        var rect = new Rect(left, top, width, height);\n        return rect;\n    };\n    /**\n     * portDrag method \\\n     *\n     * @returns { void }     portDrag method .\\\n     * @param { NodeModel | ConnectorModel} obj - provide the obj value.\n     * @param {DiagramElement} portElement - provide the portElement value.\n     * @param {number} tx - provide the tx value.\n     * @param {number} ty - provide the tx value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.portDrag = function (obj, portElement, tx, ty) {\n        var oldValues;\n        var changedvalues;\n        var port = this.findTarget(portElement, obj);\n        var bounds = getBounds(obj.wrapper);\n        if (port && canDrag(port, this.diagram)) {\n            oldValues = this.getPortChanges(obj, port);\n            port.offset.x += (tx / bounds.width);\n            port.offset.y += (ty / bounds.height);\n            changedvalues = this.getPortChanges(obj, port);\n            this.diagram.nodePropertyChange(obj, oldValues, changedvalues);\n            this.diagram.updateDiagramObject(obj);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.labelDrag = function (obj, textElement, tx, ty) {\n        //let changedvalues: Object;\n        //let label: ShapeAnnotationModel | PathAnnotationModel;\n        // eslint-disable-next-line max-len\n        var label = this.findTarget(textElement, obj);\n        var bounds = cornersPointsBeforeRotation(obj.wrapper);\n        var oldValues = this.getAnnotationChanges(obj, label);\n        if (label instanceof ShapeAnnotation) {\n            label.offset.x += (tx / bounds.width);\n            label.offset.y += (ty / bounds.height);\n        }\n        else {\n            this.updatePathAnnotationOffset(obj, label, tx, ty);\n            if (label instanceof PathAnnotation) {\n                label.alignment = 'Center';\n            }\n        }\n        var changedvalues = this.getAnnotationChanges(obj, label);\n        if (obj instanceof Node) {\n            this.diagram.nodePropertyChange(obj, oldValues, changedvalues);\n        }\n        else {\n            this.diagram.connectorPropertyChange(obj, oldValues, changedvalues);\n        }\n        this.diagram.updateDiagramObject(obj);\n        if (!isSelected(this.diagram, label, false, textElement)) {\n            this.labelSelect(obj, textElement);\n        }\n    };\n    CommandHandler.prototype.updatePathAnnotationOffset = function (object, label, tx, ty, newPosition, size) {\n        var textWrapper = this.diagram.getWrapper(object.wrapper, label.id);\n        var offsetX = textWrapper.offsetX;\n        var offsetY = textWrapper.offsetY;\n        var offset;\n        var intermediatePoints = object.intermediatePoints;\n        var prev;\n        var pointLength = 0;\n        var totalLength = 0;\n        var intersectingOffset;\n        var currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY + ty };\n        var intersetingPts = this.getInterceptWithSegment(currentPosition, intermediatePoints);\n        var newOffset = intermediatePoints[intermediatePoints.length - 1];\n        totalLength = Point.getLengthFromListOfPoints(intermediatePoints);\n        if (intersetingPts.length > 0) {\n            if (label.dragLimit.top || label.dragLimit.bottom || label.dragLimit.left || label.dragLimit.right) {\n                var minDistance = { minDistance: null };\n                newOffset = this.getRelativeOffset(currentPosition, intermediatePoints, minDistance);\n                var distance = { minDistance: null };\n                intersectingOffset = this.getRelativeOffset(currentPosition, intersetingPts, distance);\n                if (minDistance != null && distance.minDistance < minDistance.minDistance) {\n                    newOffset = intersectingOffset;\n                }\n                else {\n                    var connectorOffset = getOffsetOfConnector(object.intermediatePoints, label);\n                    newOffset = connectorOffset.point;\n                }\n            }\n            else {\n                intersectingOffset = intersetingPts[intersetingPts.length - 1];\n                newOffset = intersectingOffset;\n            }\n            if (newOffset) {\n                var p = void 0;\n                var bounds = void 0;\n                for (p = 0; p < intermediatePoints.length; p++) {\n                    if (prev != null) {\n                        bounds = Rect.toBounds([prev, intermediatePoints[p]]);\n                        if (bounds.containsPoint(newOffset)) {\n                            pointLength += Point.findLength(prev, newOffset);\n                            break;\n                        }\n                        else {\n                            pointLength += Point.findLength(prev, intermediatePoints[p]);\n                        }\n                    }\n                    prev = intermediatePoints[p];\n                }\n                offset = { x: pointLength / totalLength, y: 0 };\n            }\n            this.updateLabelMargin(object, label, offset, currentPosition, size, tx, ty);\n        }\n        else {\n            this.updateLabelMargin(object, label, null, currentPosition, size, tx, ty);\n        }\n    };\n    CommandHandler.prototype.getRelativeOffset = function (currentPosition, points, minDistance) {\n        var newOffset;\n        var distance;\n        var pt;\n        var i;\n        for (i = 0; i < points.length; i++) {\n            pt = points[i];\n            distance = Math.round(Math.sqrt(Math.pow((currentPosition.x - pt.x), 2) +\n                Math.pow((currentPosition.y - pt.y), 2)));\n            if (minDistance.minDistance === null ||\n                Math.min(Math.abs(minDistance.minDistance), Math.abs(distance)) === Math.abs(distance)) {\n                newOffset = pt;\n                minDistance.minDistance = distance;\n            }\n        }\n        return newOffset;\n    };\n    CommandHandler.prototype.dragLimitValue = function (label, point, tempPt, contentDimension) {\n        var x = false;\n        var y = false;\n        if ((tempPt.x >= (point.x - label.dragLimit.left - (contentDimension.width / 2))) &&\n            (tempPt.x <= point.x + label.dragLimit.right + (contentDimension.width / 2))) {\n            x = true;\n        }\n        if ((tempPt.y >= (point.y - label.dragLimit.top - (contentDimension.height / 2))) &&\n            (tempPt.y <= point.y + label.dragLimit.bottom + (contentDimension.height / 2))) {\n            y = true;\n        }\n        return { x: x, y: y };\n    };\n    /* eslint-disable */\n    CommandHandler.prototype.updateLabelMargin = function (node, label, offset, tempPt, size, tx, ty) {\n        offset = offset ? offset : { x: label.offset, y: 0 };\n        if (label && offset && offset.x > 0 && offset.x < 1) {\n            //let point: PointModel;\n            var length_2 = Point.getLengthFromListOfPoints(node.intermediatePoints);\n            var point = this.getPointAtLength(length_2 * offset.x, node.intermediatePoints, 0);\n            var curZoomfactor = this.diagram.scrollSettings.currentZoom;\n            var dragLimit = label.dragLimit;\n            if (dragLimit.top || dragLimit.bottom || dragLimit.left || dragLimit.right) {\n                var labelBounds = this.diagram.getWrapper(node.wrapper, label.id);\n                var contentDimension = new Rect(0, 0, 0, 0);\n                var annotationWrtapper = this.diagram.getWrapper(node.wrapper, label.id);\n                contentDimension.x = ((annotationWrtapper).offsetX / curZoomfactor) + tx;\n                contentDimension.y = (annotationWrtapper.offsetY / curZoomfactor) + ty;\n                contentDimension.width = annotationWrtapper.bounds.width / curZoomfactor;\n                contentDimension.height = annotationWrtapper.bounds.height / curZoomfactor;\n                var draggableBounds = new Rect(point.x - (dragLimit.left || 0) - contentDimension.width / 2, point.y - (dragLimit.top || 0) - contentDimension.height / 2, (dragLimit.left || 0) + (dragLimit.right || 0) + contentDimension.width, (dragLimit.top || 0) + (dragLimit.bottom || 0) + contentDimension.height);\n                if (draggableBounds.containsPoint(tempPt)) {\n                    tempPt = tempPt;\n                }\n                else {\n                    var lineIntersects = void 0;\n                    var line1 = [point, tempPt];\n                    lineIntersects = this.boundsInterSects(line1, draggableBounds, false);\n                    for (var _i = 0, lineIntersects_1 = lineIntersects; _i < lineIntersects_1.length; _i++) {\n                        var i = lineIntersects_1[_i];\n                        var ptt = i;\n                        tempPt = ptt;\n                    }\n                }\n                var cursorLimit = this.dragLimitValue(label, point, tempPt, contentDimension);\n                label.margin = {\n                    left: cursorLimit.x ? tempPt.x - point.x : label.margin.left,\n                    top: cursorLimit.y ? tempPt.y - point.y : label.margin.top, right: 0, bottom: 0\n                };\n            }\n            else {\n                label.margin = { left: tempPt.x - point.x, top: tempPt.y - point.y, right: 0, bottom: 0 };\n            }\n            label.offset = offset.x;\n            if (size) {\n                label.width = size.width;\n                label.height = size.height;\n            }\n        }\n    };\n    CommandHandler.prototype.boundsInterSects = function (polyLine, bounds, self) {\n        var intersects;\n        if (bounds) {\n            var polyLine2 = [\n                { x: bounds.x, y: bounds.y },\n                { x: bounds.x + bounds.width, y: bounds.y },\n                { x: bounds.x + bounds.width, y: bounds.y + bounds.height },\n                { x: bounds.x, y: bounds.y + bounds.height },\n                { x: bounds.x, y: bounds.y }\n            ];\n            intersects = this.intersect(polyLine, polyLine2, self);\n        }\n        return intersects;\n    };\n    CommandHandler.prototype.intersect = function (polyLine1, polyLine2, self) {\n        var intersect = [];\n        for (var i = 0; i < polyLine1.length - 1; i++) {\n            for (var j = 0; j < polyLine2.length - 1; j++) {\n                var p = intersect2(polyLine1[i], polyLine1[i + 1], polyLine2[j], polyLine2[j + 1]);\n                if (p.x !== 0 && p.y !== 0) {\n                    intersect.push(p);\n                }\n            }\n        }\n        return intersect;\n    };\n    CommandHandler.prototype.getPointAtLength = function (length, points, angle) {\n        angle = 0;\n        var run = 0;\n        var pre;\n        var found = { x: 0, y: 0 };\n        var pt;\n        for (var i = 0; i < points.length; i++) {\n            pt = points[i];\n            if (!pre) {\n                pre = pt;\n                continue;\n            }\n            else {\n                var l = Point.findLength(pre, pt);\n                var r = void 0;\n                var deg = void 0;\n                var x = void 0;\n                var y = void 0;\n                if (run + l >= length) {\n                    r = length - run;\n                    deg = Point.findAngle(pre, pt);\n                    x = r * Math.cos(deg * Math.PI / 180);\n                    y = r * Math.sin(deg * Math.PI / 180);\n                    found = { x: pre.x + x, y: pre.y + y };\n                    angle = deg;\n                    break;\n                }\n                else {\n                    run += l;\n                }\n            }\n            pre = pt;\n        }\n        return found;\n    };\n    CommandHandler.prototype.getInterceptWithSegment = function (currentPosition, conPoints) {\n        var intercepts = [];\n        var imgLine = [];\n        var segemnt = [];\n        var tarAngle;\n        var srcAngle; //let maxLength: number;\n        var maxLength = Point.findLength({ x: 0, y: 0 }, { x: this.diagram.scroller.viewPortWidth, y: this.diagram.scroller.viewPortHeight });\n        for (var i = 1; i < conPoints.length; i++) {\n            segemnt = [conPoints[i - 1], conPoints[i]];\n            imgLine = [];\n            srcAngle = Math.round(Point.findAngle(segemnt[0], segemnt[1]) % 360);\n            tarAngle = Math.round(Point.findAngle(segemnt[1], segemnt[0]) % 360);\n            var angleAdd = (srcAngle > 0 && srcAngle <= 90) || (srcAngle > 180 && srcAngle <= 270) ? 90 : -90;\n            imgLine.push(Point.transform(currentPosition, srcAngle + angleAdd, maxLength));\n            imgLine.push(Point.transform(currentPosition, tarAngle + angleAdd, maxLength));\n            var lineUtil1 = { x1: segemnt[0].x, y1: segemnt[0].y, x2: segemnt[1].x, y2: segemnt[1].y };\n            var lineUtil2 = { x1: imgLine[0].x, y1: imgLine[0].y, x2: imgLine[1].x, y2: imgLine[1].y };\n            var line3 = intersect3(lineUtil1, lineUtil2);\n            if (line3.enabled) {\n                intercepts.push(line3.intersectPt);\n            }\n        }\n        return intercepts;\n    };\n    /** @private */\n    CommandHandler.prototype.getAnnotationChanges = function (object, label) {\n        var index = findObjectIndex(object, label.id, true);\n        var annotations = {};\n        annotations[index] = {\n            width: label.width, height: label.height, offset: (object instanceof Node) ? ({\n                x: label.offset.x,\n                y: label.offset.y\n            }) : label.offset,\n            rotateAngle: label.rotateAngle,\n            margin: { left: label.margin.left, right: label.margin.right, top: label.margin.top, bottom: label.margin.bottom },\n            horizontalAlignment: label.horizontalAlignment, verticalAlignment: label.verticalAlignment,\n            alignment: ((object instanceof Connector) ? label.alignment : undefined)\n        };\n        return { annotations: annotations };\n    };\n    /** @private */\n    CommandHandler.prototype.getPortChanges = function (object, port) {\n        var index = findObjectIndex(object, port.id, false);\n        var ports = {};\n        ports[index] = { offset: port.offset };\n        return { ports: ports };\n    };\n    /** @private */\n    CommandHandler.prototype.labelRotate = function (object, label, currentPosition, selector) {\n        var oldValues;\n        var changedvalues;\n        oldValues = this.getAnnotationChanges(object, label);\n        var matrix = identityMatrix();\n        var rotateAngle = label.rotateAngle;\n        var labelWrapper = this.diagram.getWrapper(object.wrapper, label.id);\n        var angle = findAngle({ x: labelWrapper.offsetX, y: labelWrapper.offsetY }, currentPosition) + 90;\n        var snapAngle = this.snapAngle(angle);\n        angle = snapAngle !== 0 ? snapAngle : angle;\n        if (label instanceof PathAnnotation && label.segmentAngle) {\n            var getPointloop = getAnnotationPosition(object.intermediatePoints, label, object.wrapper.bounds);\n            angle -= getPointloop.angle;\n        }\n        angle = (angle + 360) % 360;\n        label.rotateAngle += angle - (label.rotateAngle + labelWrapper.parentTransform);\n        label.margin.bottom += (labelWrapper.verticalAlignment === 'Top') ? (-label.height / 2) : ((labelWrapper.verticalAlignment === 'Bottom') ? (label.height / 2) : 0);\n        label.margin.right += (labelWrapper.horizontalAlignment === 'Left') ? (-label.width / 2) : ((labelWrapper.horizontalAlignment === 'Right') ? (label.width / 2) : 0);\n        if (label instanceof PathAnnotation) {\n            label.alignment = 'Center';\n        }\n        else {\n            label.horizontalAlignment = label.verticalAlignment = 'Center';\n        }\n        selector.wrapper.rotateAngle = selector.rotateAngle = label.rotateAngle;\n        changedvalues = this.getAnnotationChanges(object, label);\n        if (object instanceof Node) {\n            this.diagram.nodePropertyChange(object, oldValues, changedvalues);\n        }\n        else {\n            this.diagram.connectorPropertyChange(object, oldValues, changedvalues);\n        }\n        this.diagram.updateDiagramObject(object);\n    };\n    /** @private */\n    CommandHandler.prototype.labelResize = function (node, label, deltaWidth, deltaHeight, pivot, selector) {\n        var oldValues;\n        var changedvalues;\n        var rotateAngle;\n        oldValues = this.getAnnotationChanges(node, label);\n        var textElement = selector.wrapper.children[0];\n        if ((deltaWidth && deltaWidth !== 1) || (deltaHeight && deltaHeight !== 1)) {\n            var newMat = identityMatrix();\n            var matrix = identityMatrix();\n            rotateMatrix(newMat, -node.rotateAngle, node.offsetX, node.offsetY);\n            rotateAngle = ((textElement.rotateAngle + ((node instanceof Node) ? node.rotateAngle : 0)) + 360) % 360;\n            rotateMatrix(matrix, -rotateAngle, pivot.x, pivot.y);\n            scaleMatrix(matrix, deltaWidth, deltaHeight, pivot.x, pivot.y);\n            rotateMatrix(matrix, rotateAngle, pivot.x, pivot.y);\n            var newPosition = transformPointByMatrix(matrix, { x: textElement.offsetX, y: textElement.offsetY });\n            var height = textElement.actualSize.height * deltaHeight;\n            var width = textElement.actualSize.width * deltaWidth;\n            var shape = this.findTarget(textElement, node);\n            if (shape instanceof PathAnnotation) {\n                this.updatePathAnnotationOffset(node, label, 0, 0, newPosition, new Size(width, height));\n            }\n            else {\n                var bounds = cornersPointsBeforeRotation(node.wrapper);\n                newPosition = transformPointByMatrix(newMat, newPosition);\n                newPosition.x = newPosition.x - textElement.margin.left + textElement.margin.right;\n                newPosition.y = newPosition.y - textElement.margin.top + textElement.margin.bottom;\n                newPosition.y += (shape.verticalAlignment === 'Top') ? (-height / 2) : ((shape.verticalAlignment === 'Bottom') ? (height / 2) : 0);\n                newPosition.x += (shape.horizontalAlignment === 'Left') ? (-width / 2) : ((shape.horizontalAlignment === 'Right') ? (width / 2) : 0);\n                var offsetx = bounds.width / (newPosition.x - bounds.x);\n                var offsety = bounds.height / (newPosition.y - bounds.y);\n                if (width > 1) {\n                    shape.width = width;\n                    shape.offset.x = 1 / offsetx;\n                }\n                if (height > 1) {\n                    shape.height = height;\n                    shape.offset.y = 1 / offsety;\n                }\n            }\n        }\n        if (label instanceof PathAnnotation) {\n            label.alignment = 'Center';\n        }\n        changedvalues = this.getAnnotationChanges(node, label);\n        if (node instanceof Node) {\n            this.diagram.nodePropertyChange(node, oldValues, changedvalues);\n        }\n        else {\n            this.diagram.connectorPropertyChange(node, oldValues, changedvalues);\n        }\n        this.diagram.updateDiagramObject(node);\n    };\n    /** @private */\n    CommandHandler.prototype.getSubProcess = function (source) {\n        var selector = { nodes: [], connectors: [] };\n        var process;\n        if (source instanceof Node) {\n            process = source.processId;\n        }\n        else if (source && source.nodes && (source.nodes.length)\n            && source.nodes[0].processId) {\n            process = source.nodes[0].processId;\n        }\n        if (process) {\n            selector.nodes.push(clone(this.diagram.nameTable[process]));\n            return selector;\n        }\n        return selector;\n    };\n    /**   @private  */\n    CommandHandler.prototype.checkBoundaryConstraints = function (tx, ty, nodeBounds) {\n        var pageSettings = this.diagram.pageSettings;\n        var boundaryConstraints = this.diagram.pageSettings.boundaryConstraints;\n        var scroller = this.diagram.scroller;\n        if (boundaryConstraints === 'Page' || boundaryConstraints === 'Diagram') {\n            var selectorBounds = !nodeBounds ? this.diagram.selectedItems.wrapper.bounds : undefined;\n            var width = boundaryConstraints === 'Page' ? pageSettings.width : scroller.viewPortWidth;\n            var height = boundaryConstraints === 'Page' ? pageSettings.height : scroller.viewPortHeight;\n            var bounds = nodeBounds;\n            var right = (nodeBounds ? bounds.right : selectorBounds.right) + (tx || 0);\n            var left = (nodeBounds ? bounds.left : selectorBounds.left) + (tx || 0);\n            var top_2 = (nodeBounds ? bounds.top : selectorBounds.top) + (ty || 0);\n            var bottom = (nodeBounds ? bounds.bottom : selectorBounds.bottom) + (ty || 0);\n            if (right <= width && left >= 0\n                && bottom <= height && top_2 >= 0) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    };\n    //interfaces\n    /** @private */\n    CommandHandler.prototype.dragSelectedObjects = function (tx, ty) {\n        var obj = this.diagram.selectedItems;\n        if (this.state && !this.state.backup) {\n            this.state.backup = {};\n            this.state.backup.offsetX = obj.offsetX;\n            this.state.backup.offsetY = obj.offsetY;\n        }\n        obj = renderContainerHelper(this.diagram, obj) || obj;\n        if (this.checkBoundaryConstraints(tx, ty)) {\n            this.diagram.diagramActions = this.diagram.diagramActions | (DiagramAction.PreventZIndexOnDragging | DiagramAction.DragUsingMouse);\n            var actualObject = this.diagram.selectedObject.actualObject;\n            if ((actualObject && actualObject instanceof Node && actualObject.isLane &&\n                canLaneInterchange(actualObject, this.diagram)) || (!actualObject || !actualObject.isLane)) {\n                this.diagram.drag(obj, tx, ty);\n            }\n            this.diagram.diagramActions = this.diagram.diagramActions & ~(DiagramAction.PreventZIndexOnDragging | DiagramAction.DragUsingMouse);\n            this.diagram.refreshCanvasLayers();\n            return true;\n        }\n        return false;\n    };\n    /** @private */\n    CommandHandler.prototype.scaleSelectedItems = function (sx, sy, pivot) {\n        var obj = this.diagram.selectedItems;\n        if (this.state && !this.state.backup) {\n            this.state.backup = {};\n            this.state.backup.offsetX = obj.offsetX;\n            this.state.backup.offsetY = obj.offsetY;\n            this.state.backup.width = obj.width;\n            this.state.backup.height = obj.height;\n            this.state.backup.pivot = pivot;\n        }\n        obj = renderContainerHelper(this.diagram, obj) || obj;\n        return this.diagram.scale(obj, sx, sy, pivot);\n    };\n    /** @private */\n    CommandHandler.prototype.rotateSelectedItems = function (angle) {\n        var obj = this.diagram.selectedItems;\n        if (this.state && !this.state.backup) {\n            this.state.backup = {};\n            this.state.backup.angle = obj.rotateAngle;\n        }\n        obj = renderContainerHelper(this.diagram, obj) || obj;\n        return this.diagram.rotate(obj, angle);\n    };\n    /** @private */\n    CommandHandler.prototype.hasSelection = function () {\n        return hasSelection(this.diagram);\n    };\n    /** @private */\n    CommandHandler.prototype.isSelected = function (element) {\n        return isSelected(this.diagram, element);\n    };\n    /**\n     * initExpand is used for layout expand and collapse interaction\n     */\n    CommandHandler.prototype.initExpand = function (args) {\n        var propName = 'isProtectedOnChange';\n        var protectedChange = this.diagram[propName];\n        this.diagram.protectPropertyChange(true);\n        var node = (args.target || args.source);\n        var oldValues = { isExpanded: node.isExpanded };\n        node.isExpanded = !node.isExpanded;\n        this.diagram.preventNodesUpdate = true;\n        this.diagram.diagramActions |= DiagramAction.PreventIconsUpdate;\n        this.diagram.nodePropertyChange(node, oldValues, { isExpanded: node.isExpanded });\n        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.PreventIconsUpdate;\n        this.diagram.preventNodesUpdate = false;\n        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            var view = this.diagram.views[temp];\n            if (!(view instanceof Diagram)) {\n                this.diagram.refreshCanvasDiagramLayer(view);\n            }\n        }\n        this.diagram.protectPropertyChange(protectedChange);\n    };\n    /** @private */\n    CommandHandler.prototype.expandNode = function (node, diagram, canLayout) {\n        var animation;\n        //let objects: ILayout;\n        var preventNodesUpdate = this.diagram.preventNodesUpdate;\n        var expand = node.isExpanded;\n        this.diagram.preventNodesUpdate = true;\n        this.diagram.preventConnectorsUpdate = true;\n        this.expandCollapse(node, expand, this.diagram);\n        node.isExpanded = expand;\n        var fixedNode = this.diagram.layout.fixedNode;\n        this.diagram.layout.fixedNode = node.id;\n        if ((this.diagram.diagramActions != DiagramAction.Render) && this.diagram.layoutAnimateModule && this.diagram.layout.enableAnimation && this.diagram.organizationalChartModule) {\n            this.diagram.organizationalChartModule.isAnimation = true;\n        }\n        this.diagram.blazorActions |= BlazorAction.expandNode;\n        var objects = {};\n        if (!canLayout) {\n            objects = this.diagram.doLayout();\n        }\n        this.diagram.blazorActions &= ~BlazorAction.expandNode;\n        this.diagram.preventNodesUpdate = preventNodesUpdate;\n        this.diagram.preventConnectorsUpdate = false;\n        if (this.diagram.layoutAnimateModule && this.diagram.organizationalChartModule && !canLayout) {\n            this.diagram.allowServerDataBinding = false;\n            this.layoutAnimateModule.expand(this.diagram.layout.enableAnimation, objects, node, this.diagram);\n        }\n        else {\n            var arg = {\n                element: cloneBlazorObject(clone(node)), state: (node.isExpanded) ? true : false\n            };\n            this.triggerEvent(DiagramEvent.expandStateChange, arg);\n            if (this.diagram.lineRoutingModule && this.diagram.constraints & DiagramConstraints.LineRouting) {\n                this.diagram.resetSegments();\n            }\n        }\n        this.diagram.layout.fixedNode = fixedNode === '' ? '' : this.diagram.layout.fixedNode;\n        return objects;\n    };\n    CommandHandler.prototype.getparentexpand = function (target, diagram, visibility, connector) {\n        var boolean;\n        for (var i = 0; i < target.inEdges.length; i++) {\n            var newConnector = diagram.nameTable[target.inEdges[i]];\n            var previousNode = diagram.nameTable[newConnector.sourceID];\n            if (previousNode.isExpanded && !visibility && previousNode.id !== connector.sourceID && newConnector.visible) {\n                return false;\n            }\n            else {\n                boolean = true;\n            }\n        }\n        return boolean;\n    };\n    /**\n     * Setinterval and Clear interval for layout animation\n     */\n    /** @private */\n    CommandHandler.prototype.expandCollapse = function (source, visibility, diagram) {\n        for (var i = 0; i < source.outEdges.length; i++) {\n            var connector = diagram.nameTable[source.outEdges[i]];\n            var target = diagram.nameTable[connector.targetID];\n            var value = this.getparentexpand(target, diagram, visibility, connector);\n            connector.visible = visibility;\n            var oldValues = {\n                visible: target.visible,\n                style: { opacity: target.wrapper.style.opacity }\n            };\n            var newValues = {\n                visible: target.visible,\n                style: { opacity: target.wrapper.style.opacity }\n            };\n            if (value) {\n                if (target.isExpanded) {\n                    this.expandCollapse(target, visibility, diagram);\n                }\n                target.visible = visibility;\n                target.style.opacity = (this.diagram.layoutAnimateModule &&\n                    this.diagram.layout.enableAnimation && visibility) ? 0.1 : target.style.opacity;\n                diagram.nodePropertyChange(target, oldValues, newValues);\n            }\n            diagram.connectorPropertyChange(connector, oldValues, newValues);\n        }\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.updateNodeDimension = function (obj, rect) {\n        if (obj instanceof Node) {\n            obj.offsetX = rect.x + rect.width / 2;\n            obj.offsetY = rect.y + rect.height / 2;\n            obj.width = rect.width;\n            obj.height = rect.height;\n            obj.wrapper.children[0].canMeasurePath = true;\n            this.diagram.nodePropertyChange(obj, {}, {\n                width: rect.width, height: rect.height, offsetX: obj.offsetX,\n                offsetY: obj.offsetY\n            });\n            if (this.diagram.mode !== 'SVG') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.updateConnectorPoints = function (obj, rect) {\n        if (obj instanceof Connector) {\n            this.diagram.connectorPropertyChange(obj, {}, {\n                targetPoint: obj.targetPoint\n            });\n            this.diagram.updateDiagramObject(obj);\n        }\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.updateSelectedNodeProperties = function (object) {\n        if (this.diagram.lineRoutingModule && (this.diagram.constraints & DiagramConstraints.LineRouting)) {\n            var previousNodeObject = [];\n            var previousConnectorObject = [];\n            var updateNodeObject = [];\n            var updateConnectorObject = [];\n            var changeNodes = [];\n            var changeConnectors = [];\n            this.diagram.protectPropertyChange(true);\n            var objects = [];\n            var connectors = [];\n            var actualObject = this.diagram.selectedObject.actualObject;\n            var helperObject = this.diagram.selectedObject.helperObject;\n            if (helperObject && actualObject) {\n                var offsetX = (helperObject.offsetX - actualObject.offsetX);\n                var offsetY = (helperObject.offsetY - actualObject.offsetY);\n                var width = (helperObject.width - actualObject.width);\n                var height = (helperObject.height - actualObject.height);\n                var rotateAngle = (helperObject.rotateAngle - actualObject.rotateAngle);\n                if (this.diagram.selectedItems.nodes.length + this.diagram.selectedItems.connectors.length > 0) {\n                    this.diagram.selectedItems.wrapper.rotateAngle = this.diagram.selectedItems.rotateAngle = helperObject.rotateAngle;\n                }\n                if (actualObject instanceof Node &&\n                    actualObject.shape.type !== 'SwimLane' && !actualObject.isLane && !actualObject.isPhase && !actualObject.isHeader) {\n                    if (actualObject.offsetX !== actualObject.wrapper.offsetX || actualObject.offsetY !== actualObject.wrapper.offsetY ||\n                        actualObject.width !== actualObject.wrapper.width || actualObject.height !== actualObject.wrapper.height ||\n                        actualObject.rotateAngle !== actualObject.wrapper.rotateAngle) {\n                        if (isBlazor()) {\n                            previousNodeObject.push(cloneObject(actualObject, undefined, undefined, true));\n                        }\n                        actualObject.offsetX += offsetX;\n                        actualObject.offsetY += offsetY;\n                        actualObject.width += width;\n                        actualObject.height += height;\n                        actualObject.rotateAngle += rotateAngle;\n                        this.diagram.nodePropertyChange(actualObject, {}, {\n                            offsetX: actualObject.offsetX, offsetY: actualObject.offsetY,\n                            width: actualObject.width, height: actualObject.height, rotateAngle: actualObject.rotateAngle\n                        });\n                        if (isBlazor()) {\n                            updateNodeObject.push(cloneObject(actualObject, undefined, undefined, true));\n                        }\n                    }\n                    objects = this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds);\n                }\n                else if (actualObject instanceof Selector) {\n                    for (var i = 0; i < actualObject.nodes.length; i++) {\n                        var node = actualObject.nodes[i];\n                        if (node instanceof Node && node.shape.type !== 'SwimLane' && !node.isLane\n                            && !node.isPhase && !node.isHeader) {\n                            node.offsetX += offsetX;\n                            node.offsetY += offsetY;\n                            node.width += width;\n                            node.height += height;\n                            node.rotateAngle += rotateAngle;\n                            this.diagram.nodePropertyChange(node, {}, {\n                                offsetX: node.offsetX, offsetY: node.offsetY,\n                                width: node.width, height: node.height, rotateAngle: node.rotateAngle\n                            });\n                            objects = objects.concat(this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds));\n                        }\n                    }\n                }\n            }\n            else {\n                if (object instanceof Connector) {\n                    objects.push(object);\n                }\n                else if (object instanceof Selector && object.connectors.length) {\n                    objects = objects.concat(object.connectors);\n                }\n            }\n            for (var i = 0; i < objects.length; i++) {\n                if (objects[i] instanceof Connector && connectors.indexOf(objects[i].id) === -1) {\n                    connectors.push(objects[i].id);\n                }\n            }\n            this.diagram.lineRoutingModule.renderVirtualRegion(this.diagram, true);\n            for (var i = 0; i < connectors.length; i++) {\n                var connector = this.diagram.nameTable[connectors[i]];\n                if (connector instanceof Connector && connector.type === 'Orthogonal') {\n                    if (isBlazor()) {\n                        previousConnectorObject.push(cloneObject(connector, undefined, undefined, true));\n                    }\n                    this.diagram.lineRoutingModule.refreshConnectorSegments(this.diagram, connector, true);\n                    if (isBlazor()) {\n                        updateConnectorObject.push(cloneObject(connector, undefined, undefined, true));\n                    }\n                }\n            }\n            this.updateSelector();\n            if (isBlazor()) {\n                this.getObjectChanges(previousNodeObject, updateNodeObject, changeNodes);\n                this.getObjectChanges(previousConnectorObject, updateConnectorObject, changeConnectors);\n                var blazorInterop = 'sfBlazor';\n                var blazor = 'Blazor';\n                var diagramObject = { nodes: changeNodes, connectors: changeConnectors };\n                if (window && window[blazor] && (changeConnectors.length + changeNodes.length)) {\n                    var obj = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': diagramObject };\n                    window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n                }\n            }\n            this.diagram.protectPropertyChange(false);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.drawSelectionRectangle = function (x, y, width, height) {\n        this.diagram.drawSelectionRectangle(x, y, width, height);\n    };\n    /** @private */\n    CommandHandler.prototype.startGroupAction = function () {\n        this.diagram.startGroupAction();\n    };\n    /** @private */\n    CommandHandler.prototype.endGroupAction = function () {\n        this.diagram.endGroupAction();\n    };\n    /** @private */\n    CommandHandler.prototype.removeChildFromBPmn = function (child, newTarget, oldTarget) {\n        var obj = this.diagram.nameTable[child.id] || child.nodes[0];\n        if (oldTarget) {\n            if ((obj) && obj.processId && obj.processId === oldTarget.wrapper.id) {\n                var node = clone(obj);\n                node.processId = obj.processId;\n                this.diagram.startGroupAction();\n                var edges = [];\n                edges = edges.concat(obj.outEdges, obj.inEdges);\n                for (var i = edges.length - 1; i >= 0; i--) {\n                    var connector = this.diagram.nameTable[edges[i]];\n                    if (connector) {\n                        this.diagram.remove(connector);\n                    }\n                }\n                //let nodeCollection: string[];\n                var nodeCollection = (this.diagram.nameTable[obj.processId].shape.activity.subProcess.processes) || [];\n                nodeCollection.splice(nodeCollection.indexOf((obj).id), 1);\n                this.diagram.bpmnModule.removeChildFromBPMN(this.diagram.nameTable[obj.processId].wrapper, (obj).id);\n                this.diagram.nameTable[(obj).id].processId = '';\n                obj.offsetX = obj.wrapper.offsetX;\n                obj.offsetY = obj.wrapper.offsetY;\n                var undoElement = clone(obj);\n                var entry = {\n                    type: 'PositionChanged', redoObject: { nodes: [undoElement] }, undoObject: { nodes: [node] }, category: 'Internal'\n                };\n                this.addHistoryEntry(entry);\n                this.diagram.endGroupAction();\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.isDroppable = function (source, targetNodes) {\n        var node = this.diagram.nameTable[source.id] || source.nodes[0];\n        if (node) {\n            if ((!isBlazor() && node.shape.shape === 'TextAnnotation') ||\n                (isBlazor() && node.shape.bpmnShape === 'TextAnnotation')) {\n                return true;\n            }\n            if (node && node.shape.type === 'Bpmn') {\n                if ((node.processId === targetNodes.id) || (node.id === targetNodes.processId) ||\n                    targetNodes.shape.type === 'Bpmn'\n                        && targetNodes.shape.activity.subProcess.collapsed) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.renderHighlighter = function (args, connectHighlighter, source) {\n        var bounds = new Rect();\n        if (args.target instanceof Node || (connectHighlighter && args.source instanceof Node)) {\n            var tgt = connectHighlighter ? args.source : args.target;\n            var tgtWrap = connectHighlighter ? args.sourceWrapper : args.targetWrapper;\n            var target = this.findTarget(tgtWrap, tgt, source, true);\n            var element = void 0;\n            if (target instanceof BpmnSubEvent) {\n                var portId = target.id;\n                var node = args.target;\n                var parent_8 = node.wrapper.children[0].children[0].children[2];\n                for (var _i = 0, _a = parent_8.children; _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    if (child.id === node.id + '_' + portId) {\n                        element = child.children[0];\n                        break;\n                    }\n                }\n            }\n            else {\n                element = target instanceof Node ?\n                    target.wrapper : connectHighlighter ? args.sourceWrapper : args.targetWrapper;\n            }\n            this.diagram.renderHighlighter(element);\n        }\n    };\n    //additional events\n    /** @private */\n    CommandHandler.prototype.mouseOver = function (source, target, position) {\n        //mouse over\n        //returns whether the source can move over the target or not\n        return true;\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.snapPoint = function (startPoint, endPoint, tx, ty) {\n        var obj = this.diagram.selectedItems;\n        var point;\n        var towardsLeft = endPoint.x < startPoint.x;\n        var towardsTop = endPoint.y < startPoint.y;\n        point = { x: tx, y: ty };\n        var snappedPoint = point;\n        if (this.snappingModule) {\n            snappedPoint = this.diagram.snappingModule.snapPoint(this.diagram, obj, towardsLeft, towardsTop, point, startPoint, endPoint);\n        }\n        return snappedPoint;\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.removeSnap = function () {\n        if ((this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) && this.snappingModule) {\n            this.snappingModule.removeGuidelines(this.diagram);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.dropAnnotation = function (source, target) {\n        var node = (source instanceof Node) ? source : source.nodes[0];\n        if (this.diagram.bpmnModule && target.shape.type === 'Bpmn'\n            && ((!isBlazor() && node.shape.shape === 'TextAnnotation') ||\n                (isBlazor() && node.shape.bpmnShape === 'TextAnnotation'))) {\n            var hasTarget = 'hasTarget';\n            node[hasTarget] = target.id;\n            node.shape.annotation.nodeId = target.id;\n            if (!this.diagram.currentSymbol) {\n                this.diagram.addTextAnnotation(node.shape.annotation, target);\n                node.shape.annotation.nodeId = '';\n                this.diagram.remove(node);\n            }\n            this.diagram.refreshDiagramLayer();\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.drop = function (source, target, position) {\n        //drop\n        if (this.diagram.bpmnModule) {\n            var sourcenode = (source instanceof Node) ? source : source.nodes[0];\n            if (sourcenode && sourcenode.shape.type === 'Bpmn' && target.shape.type === 'Bpmn') {\n                this.diagram.bpmnModule.dropBPMNchild(target, (source instanceof Node) ? source : source.nodes[0], this.diagram);\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.addHistoryEntry = function (entry) {\n        this.diagram.addHistoryEntry(entry);\n    };\n    /** @private */\n    CommandHandler.prototype.align = function (objects, option, type) {\n        if (objects.length > 0) {\n            var i = 0;\n            objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];\n            var bounds = (type === 'Object') ? getBounds(objects[0].wrapper) : this.diagram.selectedItems.wrapper.bounds;\n            var undoObj = { nodes: [], connectors: [] };\n            var redoObj = { nodes: [], connectors: [] };\n            for (i = ((type === 'Object') ? (i + 1) : i); i < objects.length; i++) {\n                var tx = 0;\n                var ty = 0;\n                objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];\n                var objectBounds = getBounds(objects[i].wrapper);\n                if (option === 'Left') {\n                    tx = bounds.left + objectBounds.width / 2 - objectBounds.center.x;\n                }\n                else if (option === 'Right') {\n                    tx = bounds.right - objectBounds.width / 2 - objectBounds.center.x;\n                }\n                else if (option === 'Top') {\n                    ty = bounds.top + objectBounds.height / 2 - objectBounds.center.y;\n                }\n                else if (option === 'Bottom') {\n                    ty = bounds.bottom - objectBounds.height / 2 - objectBounds.center.y;\n                }\n                else if (option === 'Center') {\n                    tx = bounds.center.x - objectBounds.center.x;\n                }\n                else if (option === 'Middle') {\n                    ty = bounds.center.y - objectBounds.center.y;\n                }\n                undoObj = this.storeObject(undoObj, objects[i]);\n                this.drag(objects[i], tx, ty);\n                this.diagram.updateSelector();\n                redoObj = this.storeObject(redoObj, objects[i]);\n            }\n            undoObj = clone(undoObj);\n            redoObj = clone(redoObj);\n            var entry = {\n                type: 'Align', category: 'Internal',\n                undoObject: cloneObject(undoObj), redoObject: cloneObject(redoObj)\n            };\n            this.addHistoryEntry(entry);\n        }\n    };\n    /**\n     * distribute method \\\n     *\n     * @returns { void }     distribute method .\\\n     * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.\n     * @param {SizingOptions} option - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.distribute = function (objects, option) {\n        if (objects.length > 0) {\n            var i = 0;\n            //const j: number = 0;\n            //const rect: Rect = new Rect();\n            //const b: Rect[] = [];\n            //let temp: NodeModel | ConnectorModel;\n            var right = 0;\n            var left = 0;\n            var top_3 = 0;\n            var bottom = 0;\n            var center = 0;\n            var middle = 0;\n            var btt = 0;\n            //const sum: number = 0;\n            var undoSelectorObj = { nodes: [], connectors: [] };\n            var redoSelectorObj = { nodes: [], connectors: [] };\n            for (i = 0; i < objects.length; i++) {\n                objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];\n            }\n            objects = sort(objects, option);\n            for (i = 1; i < objects.length; i++) {\n                right = right + objects[i].wrapper.bounds.topRight.x - objects[i - 1].wrapper.bounds.topRight.x;\n                left = left + objects[i].wrapper.bounds.topLeft.x - objects[i - 1].wrapper.bounds.topLeft.x;\n                top_3 = top_3 + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.topRight.y;\n                bottom = bottom + objects[i].wrapper.bounds.bottomRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;\n                center = center + objects[i].wrapper.bounds.center.x - objects[i - 1].wrapper.bounds.center.x;\n                middle = middle + objects[i].wrapper.bounds.center.y - objects[i - 1].wrapper.bounds.center.y;\n                btt = btt + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;\n            }\n            for (i = 1; i < objects.length - 1; i++) {\n                var tx = 0;\n                var ty = 0;\n                var prev = getBounds(objects[i - 1].wrapper);\n                var current = getBounds(objects[i].wrapper);\n                if (option === 'RightToLeft' || option === 'Center') {\n                    tx = prev.center.x - current.center.x + (center / (objects.length - 1));\n                }\n                else if (option === 'Right') {\n                    tx = prev.topRight.x - current.topRight.x + (right / (objects.length - 1));\n                }\n                else if (option === 'Left') {\n                    tx = prev.topLeft.x - current.topLeft.x + (left / (objects.length - 1));\n                }\n                else if (option === 'Middle') {\n                    ty = prev.center.y - current.center.y + (middle / (objects.length - 1));\n                }\n                else if (option === 'Top') {\n                    ty = prev.topRight.y - current.topRight.y + (top_3 / (objects.length - 1));\n                }\n                else if (option === 'Bottom') {\n                    ty = prev.bottomRight.y - current.bottomRight.y + (bottom / (objects.length - 1));\n                }\n                else if (option === 'BottomToTop') {\n                    ty = prev.bottomRight.y - current.topRight.y + (btt / (objects.length - 1));\n                }\n                undoSelectorObj = this.storeObject(undoSelectorObj, objects[i]);\n                this.drag(objects[i], tx, ty);\n                this.diagram.updateSelector();\n                redoSelectorObj = this.storeObject(redoSelectorObj, objects[i]);\n            }\n            undoSelectorObj = clone(undoSelectorObj);\n            redoSelectorObj = clone(redoSelectorObj);\n            var entry = {\n                type: 'Distribute', category: 'Internal',\n                undoObject: cloneObject(undoSelectorObj), redoObject: cloneObject(redoSelectorObj)\n            };\n            this.addHistoryEntry(entry);\n        }\n    };\n    /* eslint-enable */\n    /**\n     * sameSize method \\\n     *\n     * @returns { void }     sameSize method .\\\n     * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.\n     * @param {SizingOptions} option - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.sameSize = function (objects, option) {\n        if (objects.length > 0) {\n            var i = 0;\n            //let pivot: PointModel;\n            var pivot = { x: 0.5, y: 0.5 };\n            objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];\n            var bounds = getBounds(objects[0].wrapper);\n            var undoObject = { nodes: [], connectors: [] };\n            var redoObject = { nodes: [], connectors: [] };\n            for (i = 1; i < objects.length; i++) {\n                objects[i] = this.diagram.nameTable[objects[i].id] || objects[0];\n                var rect = getBounds(objects[i].wrapper);\n                var sw = 1;\n                var sh = 1;\n                if (option === 'Width') {\n                    sw = bounds.width / rect.width;\n                }\n                else if (option === 'Height') {\n                    sh = bounds.height / rect.height;\n                }\n                else if (option === 'Size') {\n                    sw = bounds.width / rect.width;\n                    sh = bounds.height / rect.height;\n                }\n                undoObject = this.storeObject(undoObject, objects[i]);\n                this.scale(objects[i], sw, sh, pivot);\n                redoObject = this.storeObject(redoObject, objects[i]);\n            }\n            this.diagram.updateSelector();\n            undoObject = clone(undoObject);\n            redoObject = clone(redoObject);\n            var entry = {\n                type: 'Sizing', category: 'Internal',\n                undoObject: cloneObject(undoObject), redoObject: cloneObject(redoObject)\n            };\n            this.addHistoryEntry(entry);\n        }\n    };\n    CommandHandler.prototype.storeObject = function (selectorObject, obj) {\n        if (obj instanceof Node) {\n            selectorObject.nodes.push(clone(obj));\n        }\n        else {\n            selectorObject.connectors.push(clone(obj));\n        }\n        return selectorObject;\n    };\n    /**\n     * updatePanState method \\\n     *\n     * @returns { any }     updatePanState method .\\\n     * @param {number} eventCheck - provide the eventCheck value.\n     *\n     * @private\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    CommandHandler.prototype.updatePanState = function (eventCheck) {\n        if (eventCheck) {\n            this.diagram.realActions = this.diagram.realActions | RealAction.PanInProgress;\n        }\n        else {\n            this.diagram.dataBind();\n            var diagramScrollSettings = this.diagram.scrollSettings;\n            this.diagram.realActions = this.diagram.realActions & ~RealAction.PanInProgress;\n            var Values = {\n                VerticalOffset: diagramScrollSettings.verticalOffset, HorizontalOffset: diagramScrollSettings.horizontalOffset,\n                ViewportHeight: diagramScrollSettings.viewPortHeight, ViewportWidth: diagramScrollSettings.viewPortWidth,\n                CurrentZoom: diagramScrollSettings.currentZoom\n            };\n            var arg = {\n                oldValue: Values,\n                newValue: Values, source: this.diagram, panState: 'Completed'\n            };\n            this.triggerEvent(DiagramEvent.scrollChange, arg);\n        }\n    };\n    /**\n     * dataBinding method \\\n     *\n     * @returns { void }     dataBinding method .\\\n     *\n     * @private\n     */\n    CommandHandler.prototype.dataBinding = function () {\n        this.diagram.dataBind();\n    };\n    CommandHandler.prototype.setBlazorDiagramProps = function (arg) {\n        this.diagram.setBlazorDiagramProps(arg);\n    };\n    /**\n     * scroll method \\\n     *\n     * @returns { void }     scroll method .\\\n     * @param {number} scrollX - provide the source value.\n     * @param {number} scrollY - provide the target value.\n     * @param {PointModel} focusPoint - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.scroll = function (scrollX, scrollY, focusPoint) {\n        var panx = canPanX(this.diagram);\n        var pany = canPanY(this.diagram);\n        if (isBlazor()) {\n            this.diagram.setCursor('grabbing');\n            this.diagram.scroller.zoom(1, (scrollX = panx ? scrollX : 0) * this.diagram.scroller.currentZoom, (scrollY = pany ? scrollY : 0) * this.diagram.scroller.currentZoom, focusPoint);\n        }\n        else {\n            this.diagram.pan((scrollX = panx ? scrollX : 0) * this.diagram.scroller.currentZoom, (scrollY = pany ? scrollY : 0) * this.diagram.scroller.currentZoom, focusPoint);\n        }\n    };\n    /**\n     * drawHighlighter method \\\n     *\n     * @returns { NodeModel | ConnectorModel }     drawHighlighter method .\\\n     * @param {IElement} element - provide the element value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.drawHighlighter = function (element) {\n        this.diagram.renderHighlighter(element.wrapper);\n    };\n    /**\n     * removeHighlighter method \\\n     *\n     * @returns { void }     removeHighlighter method .\\\n     *\n     * @private\n     */\n    CommandHandler.prototype.removeHighlighter = function () {\n        this.diagram.clearHighlighter();\n    };\n    /**\n     * renderContainerHelper method \\\n     *\n     * @returns { NodeModel | ConnectorModel }     renderContainerHelper method .\\\n     * @param {NodeModel | SelectorModel | ConnectorModel} node - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.renderContainerHelper = function (node) {\n        return renderContainerHelper(this.diagram, node);\n    };\n    /**\n     * isParentAsContainer method \\\n     *\n     * @returns { boolean }     isParentAsContainer method .\\\n     * @param {NodeModel} node - provide the parent value.\n     * @param {boolean} isChild - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.isParentAsContainer = function (node, isChild) {\n        return checkParentAsContainer(this.diagram, node, isChild);\n    };\n    /**\n     * dropChildToContainer method \\\n     *\n     * @returns { void }     dropChildToContainer method .\\\n     * @param {NodeModel} parent - provide the parent value.\n     * @param {NodeModel} node - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.dropChildToContainer = function (parent, node) {\n        if (!(this.diagram.diagramActions & DiagramAction.PreventLaneContainerUpdate)) {\n            addChildToContainer(this.diagram, parent, node);\n        }\n    };\n    /**\n    *\n    * @private\n    */\n    CommandHandler.prototype.updateLaneChildrenZindex = function (node, target) {\n        var lowerIndexobject = this.findLeastIndexObject(node, target);\n        var swimlane = this.diagram.nameTable[target.parentId];\n        if (swimlane && swimlane.zIndex > lowerIndexobject.zIndex) {\n            var layerIndex = this.diagram.layers.indexOf(this.diagram.getActiveLayer());\n            var layerZIndexTable = this.diagram.layers[layerIndex].zIndexTable;\n            var tempTable = JSON.parse(JSON.stringify(layerZIndexTable));\n            var startIndex = lowerIndexobject.zIndex;\n            var endIndex = swimlane.zIndex;\n            for (var i = endIndex; i >= startIndex; i--) {\n                if (startIndex !== i) {\n                    if (!layerZIndexTable[i - 1]) {\n                        layerZIndexTable[i - 1] = layerZIndexTable[i];\n                        this.diagram.nameTable[layerZIndexTable[i - 1]].zIndex = i;\n                        delete layerZIndexTable[i];\n                    }\n                    else {\n                        //bringing the objects forward\n                        layerZIndexTable[i] = layerZIndexTable[i - 1];\n                        this.diagram.nameTable[layerZIndexTable[i]].zIndex = i;\n                    }\n                }\n                else {\n                    var tempIndex = this.swapZIndexObjects(endIndex, layerZIndexTable, swimlane.id, tempTable);\n                }\n            }\n            if (this.diagram.mode === 'SVG') {\n                this.moveSvgNode(target.parentId, lowerIndexobject.id);\n                this.updateNativeNodeIndex(target.parentId, lowerIndexobject.id);\n            }\n            else {\n                this.diagram.refreshCanvasLayers();\n            }\n        }\n    };\n    CommandHandler.prototype.findLeastIndexConnector = function (edges, target, index) {\n        for (var i = 0; i < edges.length; i++) {\n            var connector = this.diagram.nameTable[edges[i]];\n            if (index.zIndex > connector.zIndex) {\n                index = connector;\n            }\n        }\n        return index;\n    };\n    CommandHandler.prototype.findLeastIndexObject = function (node, target) {\n        var lowerIndexobject = node;\n        if (node instanceof Node) {\n            lowerIndexobject = this.findLeastIndexConnector(node.inEdges, target, lowerIndexobject);\n            lowerIndexobject = this.findLeastIndexConnector(node.outEdges, target, lowerIndexobject);\n        }\n        return lowerIndexobject;\n    };\n    /**\n     * checkSelection method \\\n     *\n     * @returns { void }     checkSelection method .\\\n     * @param {SelectorModel} selector - provide the source value.\n     * @param {string} corner - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.checkSelection = function (selector, corner) {\n        var node; // let wrapper: GridPanel; let child: Container; let index: number; let shape: SwimLaneModel;\n        if (selector.nodes.length === 1 && selector.connectors.length === 0) {\n            if (checkParentAsContainer(this.diagram, selector.nodes[0], true)) {\n                node = (selector.nodes[0].shape === 'SwimLane') ? selector.nodes[0] :\n                    this.diagram.nameTable[selector.nodes[0].parentId];\n                var child = selector.nodes[0];\n                if (node.shape.type === 'SwimLane') {\n                    var orientation_1 = (node.shape.orientation === 'Horizontal') ? true : false;\n                    if ((child.isPhase && ((orientation_1 && corner === 'ResizeSouth') || (!orientation_1 && corner === 'ResizeEast'))) ||\n                        (child.isLane && ((orientation_1 && corner === 'ResizeEast') || (!orientation_1 && corner === 'ResizeSouth')))) {\n                        swimLaneSelection(this.diagram, node, corner);\n                    }\n                }\n                else if (node.container.type === 'Grid') {\n                    if (((node.container.orientation === 'Horizontal' && child.rowIndex === 1) ||\n                        (node.container.orientation === 'Vertical' && child.rowIndex > 0 && child.columnIndex > 0))) {\n                        if (corner === 'ResizeSouth') {\n                            for (var i = 0; i < this.diagram.nodes.length; i++) {\n                                var obj = this.diagram.nodes[i];\n                                if (obj.rowIndex === node.rows.length - 1 && obj.columnIndex === 0) {\n                                    this.select(obj);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        if (corner === 'ResizeEast') {\n                            for (var i = 0; i < this.diagram.nodes.length; i++) {\n                                var obj = this.diagram.nodes[i];\n                                if (obj.rowIndex === 1 && obj.columnIndex === node.columns.length - 1) {\n                                    this.select(obj);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                swimLaneSelection(this.diagram, selector.nodes[0], corner);\n            }\n        }\n    };\n    /**\n     * zoom method \\\n     *\n     * @returns { void }     zoom method .\\\n     * @param {number} scale - provide the source value.\n     * @param {number} scrollX - provide the target value.\n     * @param {number} scrollY - provide the layoutOrientation value.\n     * @param {PointModel} focusPoint - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.zoom = function (scale, scrollX, scrollY, focusPoint) {\n        this.diagram.scroller.zoom(scale, scrollX * this.diagram.scroller.currentZoom, scrollY * this.diagram.scroller.currentZoom, focusPoint);\n    };\n    return CommandHandler;\n}());\nexport { CommandHandler };\n"]},"metadata":{},"sourceType":"module"}