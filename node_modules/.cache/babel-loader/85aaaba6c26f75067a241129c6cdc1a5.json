{"ast":null,"code":"/* eslint-disable jsdoc/require-returns-check */\nimport { Point } from './../primitives/point';\nimport { Rect } from './../primitives/rect';\nimport { getPoints, intersect3 } from './diagram-util';\nimport { NoOfSegments } from '../enum/enum';\nimport { StraightSegment, BezierSegment, OrthogonalSegment } from './../objects/connector';\nimport { PathElement } from './../core/elements/path-element';\nimport { cornersPointsBeforeRotation, rotatePoint } from './base-util';\n/**\n * Connector modules are used to dock and update the connectors\n */\n\n/**\n * intermeditatePoints method\\\n *\n * @returns {  Function }    getFunction method .\\\n * @param {PointModel} element - provide the angle value.\n * @param {PointModel} layoutOrientation - provide the angle value.\n * @param {PointModel} lineDistribution - provide the angle value.\n * @private\n */\n\nexport function findConnectorPoints(element, layoutOrientation, lineDistribution) {\n  //const intermeditatePoints: PointModel[];\n  var sourcePoint;\n\n  if (element.type === 'Straight' || !element.sourceWrapper) {\n    sourcePoint = getSourcePoint(element);\n  } else {\n    sourcePoint = element.sourceWrapper.corners.center;\n  } // eslint-disable-next-line\n\n\n  var intermeditatePoints = terminateConnection(element, sourcePoint, element.targetPoint, layoutOrientation, lineDistribution);\n  setLineEndPoint(element, intermeditatePoints[0], false);\n  setLineEndPoint(element, intermeditatePoints[intermeditatePoints.length - 1], true);\n  return intermeditatePoints;\n}\n/**\n * getSourcePoint method\\\n *\n * @returns {  PointModel }    getFunction method .\\\n * @param {PointModel} element - provide the angle value.\n * @private\n */\n\nfunction getSourcePoint(element) {\n  var srcPoint;\n\n  if (element.sourcePortWrapper) {\n    var srcPort = element.sourcePortWrapper; //const srcNode: DiagramElement = element.sourceWrapper;\n\n    var pt = {\n      x: srcPort.offsetX,\n      y: srcPort.offsetY\n    }; //const direction: string = getPortDirection(pt, cornersPointsBeforeRotation(srcNode), srcNode.bounds, false);\n\n    srcPoint = pt;\n  } else if (element.sourceID && element.sourceWrapper) {\n    if (element.targetWrapper) {\n      var sPoint = element.sourceWrapper.corners.center;\n      var tPoint = element.targetWrapper.corners.center;\n      srcPoint = getIntersection(element, element.sourceWrapper, sPoint, tPoint, false);\n    } else {\n      srcPoint = element.sourcePoint;\n    }\n  } else {\n    srcPoint = element.sourcePoint;\n  }\n\n  return srcPoint;\n}\n/**\n * getDirection method \\\n *\n * @returns { void }     getDirection method .\\\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n * @param {LayoutOrientation} layoutOrientation - provide the layoutOrientation value.\n *\n * @private\n */\n\n\nfunction getDirection(source, target, layoutOrientation) {\n  if (layoutOrientation === 'LeftToRight') {\n    source.direction = source.direction ? source.direction : 'Right';\n    target.direction = target.direction ? target.direction : 'Left';\n  } else if (layoutOrientation === 'RightToLeft') {\n    source.direction = source.direction ? source.direction : 'Left';\n    target.direction = target.direction ? target.direction : 'Right';\n  } else if (layoutOrientation === 'TopToBottom') {\n    source.direction = source.direction ? source.direction : 'Bottom';\n    target.direction = target.direction ? target.direction : 'Top';\n  } else if (layoutOrientation === 'BottomToTop') {\n    source.direction = source.direction ? source.direction : 'Top';\n    target.direction = target.direction ? target.direction : 'Bottom';\n  }\n}\n/**\n * terminateConnection method \\\n *\n * @returns { PointModel[] }     terminateConnection method .\\\n * @param {Connector} element - provide the element value.\n * @param {PointModel} srcPoint - provide the srcPoint value.\n * @param {PointModel} tarPoint - provide the tarPoint value.\n * @param {LayoutOrientation} layoutOrientation - provide the layoutOrientation value.\n * @param {boolean} lineDistribution - provide the lineDistribution value.\n *\n * @private\n */\n\n\nfunction terminateConnection(element, srcPoint, tarPoint, layoutOrientation, lineDistribution) {\n  var sourceNode = element.sourceWrapper;\n  var targetNode = element.targetWrapper;\n  var sourcePort = element.sourcePortWrapper;\n  var targetPort = element.targetPortWrapper;\n  var srcCorner;\n  var tarCorner; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  var intermeditatePoints = [];\n  var segPoint;\n  var srcDir;\n  var tarDir;\n  var minSpace = 13;\n  var sourceMargin = {\n    left: 5,\n    right: 5,\n    bottom: 5,\n    top: 5\n  };\n  var targetMargin = {\n    left: 5,\n    right: 5,\n    bottom: 5,\n    top: 5\n  };\n  var source = {\n    corners: srcCorner,\n    point: srcPoint,\n    direction: srcDir,\n    margin: sourceMargin\n  };\n  var target = {\n    corners: tarCorner,\n    point: tarPoint,\n    direction: tarDir,\n    margin: targetMargin\n  };\n  var sourceCorners;\n  var targetCorners;\n\n  if (sourceNode !== undefined && targetNode !== undefined) {\n    sourceCorners = cornersPointsBeforeRotation(sourceNode);\n    targetCorners = cornersPointsBeforeRotation(targetNode);\n    source.corners = sourceNode.corners;\n    target.corners = targetNode.corners;\n  }\n\n  if (sourcePort !== undefined) {\n    var port = {\n      x: sourcePort.offsetX,\n      y: sourcePort.offsetY\n    };\n    source.direction = getPortDirection(port, sourceCorners, sourceNode.bounds, false);\n  }\n\n  if (targetPort !== undefined) {\n    var tarPortPt = {\n      x: targetPort.offsetX,\n      y: targetPort.offsetY\n    };\n    target.direction = getPortDirection(tarPortPt, targetCorners, targetNode.bounds, false);\n  }\n\n  if (sourceNode !== undefined && targetNode !== undefined) {\n    if (source.direction === undefined || target.direction === undefined) {\n      if (layoutOrientation) {\n        getDirection(source, target, layoutOrientation);\n      } else {\n        if (source.corners.top > target.corners.bottom && Math.abs(source.corners.top - target.corners.bottom) > source.margin.top + source.margin.bottom) {\n          source.direction = source.direction ? source.direction : 'Top';\n          target.direction = target.direction ? target.direction : 'Bottom';\n        } else if (source.corners.bottom < target.corners.top && Math.abs(source.corners.bottom - target.corners.top) > source.margin.bottom + source.margin.top) {\n          source.direction = source.direction ? source.direction : 'Bottom';\n          target.direction = target.direction ? target.direction : 'Top';\n        } else if (source.corners.right < target.corners.left && Math.abs(source.corners.right - target.corners.left) > source.margin.right + source.margin.left || source.corners.right + minSpace < target.corners.left || target.corners.right >= source.corners.left - minSpace && source.corners.left > target.corners.left) {\n          source.direction = source.direction ? source.direction : 'Right';\n          target.direction = target.direction ? target.direction : 'Left';\n        } else if (source.corners.left > target.corners.right && Math.abs(source.corners.left - target.corners.right) > source.margin.left + source.margin.right || target.corners.right + minSpace < source.corners.left || source.corners.right >= target.corners.left - minSpace && source.corners.left < target.corners.left) {\n          source.direction = source.direction ? source.direction : 'Left';\n          target.direction = target.direction ? target.direction : 'Right';\n        } else {\n          if (sourceNode.id !== targetNode.id && !sourceCorners.equals(sourceCorners, targetCorners) && targetCorners.containsPoint(sourceCorners.topCenter, source.margin.top)) {\n            source.direction = source.direction ? source.direction : 'Bottom';\n            target.direction = target.direction ? target.direction : 'Top';\n          } else {\n            source.direction = source.direction ? source.direction : 'Top';\n            target.direction = target.direction ? target.direction : 'Bottom';\n          }\n        }\n      }\n    }\n\n    return defaultOrthoConnection(element, source.direction, target.direction, source.point, target.point, lineDistribution);\n  } //It will be called only when there is only one end node\n\n\n  checkLastSegmentasTerminal(element);\n\n  if (element.sourceWrapper || element.targetWrapper) {\n    connectToOneEnd(element, source, target);\n  }\n\n  if (element.type === 'Straight' || element.type === 'Bezier') {\n    intermeditatePoints = intermeditatePointsForStraight(element, source, target);\n  } else {\n    if (element.type === 'Orthogonal' && element.segments && element.segments.length > 0 && element.segments[0].length !== null && element.segments[0].direction !== null) {\n      intermeditatePoints = findPointToPointOrtho(element, source, target, sourceNode, targetNode, sourcePort, targetPort);\n    } else {\n      var extra = void 0;\n\n      if (!source.direction) {\n        source.direction = target.direction ? element.targetPortWrapper !== undefined ? target.direction : getOppositeDirection(target.direction) : Point.direction(source.point, target.point);\n      } else {\n        extra = adjustSegmentLength(sourceNode.bounds, source, 20);\n      }\n\n      element.segments[0].points = intermeditatePoints = orthoConnection3Segment(element, source, target, extra);\n    }\n  }\n\n  return intermeditatePoints;\n}\n/**\n * updateSegmentPoints method \\\n *\n * @returns { PointModel[] }     updateSegmentPoints method .\\\n * @param {End} source - provide the source value.\n * @param {OrthogonalSegment} segment - provide the segment value.\n *\n * @private\n */\n\n\nfunction updateSegmentPoints(source, segment) {\n  //let segPoint: PointModel; //let angle: number; //let extra: number;\n  source.direction = segment.direction;\n  segment.points = [];\n  segment.points.push(source.point);\n  var extra = segment.direction === 'Left' || segment.direction === 'Top' ? -segment.length : segment.length;\n  var angle = segment.direction === 'Left' || segment.direction === 'Right' ? 0 : 90;\n  var segPoint = addLineSegment(source.point, extra, angle);\n  segment.points.push(segPoint);\n  return segPoint;\n}\n/**\n * pointToPoint method \\\n *\n * @returns { void }     pointToPoint method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\n\n\nfunction pointToPoint(element, source, target) {\n  var point;\n  var direction;\n  var portdirection;\n  source.corners = element.sourceWrapper ? element.sourceWrapper.corners : undefined;\n\n  if (element.sourcePortWrapper) {\n    var port = {\n      x: element.sourcePortWrapper.offsetX,\n      y: element.sourcePortWrapper.offsetY\n    };\n    portdirection = getPortDirection(port, cornersPointsBeforeRotation(element.sourceWrapper), element.sourceWrapper.bounds, false);\n\n    if (source.corners && (source.direction === 'Bottom' || source.direction === 'Top')) {\n      if (target.point.x > source.corners.left && target.point.x < source.corners.right) {\n        direction = source.point.y > target.point.y ? 'Top' : 'Bottom';\n      }\n    } else if (source.corners && (source.direction === 'Left' || source.direction === 'Right')) {\n      if (target.point.y > source.corners.top && target.point.y < source.corners.bottom) {\n        direction = source.point.x > target.point.x ? 'Left' : 'Right';\n      }\n    }\n  }\n\n  if (element.sourcePortWrapper && portdirection === getOppositeDirection(direction)) {\n    var length_1;\n\n    if ((portdirection === 'Left' || portdirection === 'Right') && source.point.y >= source.corners.top && source.point.y <= source.corners.center.y && target.point.y >= source.corners.top && target.point.y <= source.corners.center.y) {\n      source.direction = 'Top';\n      length_1 = source.point.y - source.corners.top + 20;\n    } else if ((portdirection === 'Left' || portdirection === 'Right') && source.point.y > source.corners.center.y && source.point.y <= source.corners.bottom && target.point.y > source.corners.center.y && target.point.y <= source.corners.bottom) {\n      source.direction = 'Bottom';\n      length_1 = source.corners.bottom - source.point.y + 20;\n    } else if ((portdirection === 'Top' || portdirection === 'Bottom') && source.point.x >= source.corners.left && source.point.x <= source.corners.center.x && target.point.x >= source.corners.left && target.point.x <= source.corners.center.x) {\n      source.direction = 'Left';\n      length_1 = source.point.x - source.corners.left + 20;\n    } else if ((portdirection === 'Top' || portdirection === 'Bottom') && source.point.x <= source.corners.right && source.point.x > source.corners.center.x && target.point.x <= source.corners.right && target.point.x < source.corners.center.x) {\n      source.direction = 'Right';\n      length_1 = source.corners.right - source.point.x + 20;\n    }\n\n    if (source.direction && length_1) {\n      point = orthoConnection3Segment(element, source, target, length_1, true);\n    }\n  } else {\n    source.direction = direction ? direction : findSourceDirection(source.direction, source.point, target.point);\n    point = orthoConnection2Segment(source, target);\n  }\n\n  return point;\n}\n/**\n * pointToNode method \\\n *\n * @returns { void }     pointToNode method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\n\n\nfunction pointToNode(element, source, target) {\n  var point;\n  target.corners = element.targetWrapper.corners;\n  findDirection(element.targetWrapper, source, target, element);\n  var direction = findSourceDirection(target.direction, source.point, target.point);\n\n  if (source.direction === target.direction && (source.direction === 'Left' || source.direction === 'Right')) {\n    source.direction = direction;\n    point = orthoConnection3Segment(element, source, target, element.targetWrapper.width / 2 + 20);\n    var source1 = source;\n    source1.point = point[1];\n    findDirection(element.targetWrapper, source, target, element);\n    point = orthoConnection3Segment(element, source, target);\n  } else {\n    source.direction = direction;\n    point = orthoConnection2Segment(source, target);\n  }\n\n  return point;\n}\n/**\n * addPoints method \\\n *\n * @returns { void }     addPoints method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\n\n\nfunction addPoints(element, source, target) {\n  target.corners = element.targetWrapper.corners;\n  var direction;\n  var length;\n\n  if (source.direction !== 'Left' && source.direction !== 'Right') {\n    if (target.corners.center.y === source.point.y && !(target.corners.left <= source.point.x && source.point.x <= target.corners.right)) {\n      direction = 'Top';\n      length = target.corners.height / 2 + 20;\n    } else if (target.corners.center.y === source.point.y && element.segments[element.segments.length - 2].direction === 'Bottom' || target.corners.center.y > source.point.y && source.point.y >= target.corners.top) {\n      direction = 'Top';\n      length = source.point.y - target.corners.top + 20;\n    } else if (target.corners.center.y === source.point.y && element.segments[element.segments.length - 2].direction === 'Top' || target.corners.center.y < source.point.y && source.point.y <= target.corners.bottom) {\n      direction = 'Bottom';\n      length = target.corners.bottom - source.point.y + 20;\n    } else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && source.corners.top <= source.point.y && source.point.y <= source.corners.bottom) {\n      direction = source.direction;\n      length = source.point.y > target.point.y ? source.point.y - source.corners.top + 20 : source.corners.bottom - source.point.y + 20;\n    }\n  } else {\n    if (target.corners.center.x === source.point.x && !(target.corners.top < source.point.y && source.point.y <= target.corners.bottom)) {\n      direction = 'Left';\n      length = target.corners.width / 2 + 20;\n    } else if (target.corners.center.x === source.point.x && element.segments[element.segments.length - 2].direction === 'Right' || target.corners.center.x > source.point.x && source.point.x >= target.corners.left) {\n      direction = 'Left';\n      length = source.point.x - target.corners.left + 20;\n    } else if (target.corners.center.x === source.point.x && element.segments[element.segments.length - 2].direction === 'Left' || target.corners.center.x <= source.point.x && source.point.x <= target.corners.right) {\n      direction = 'Right';\n      length = target.corners.right - source.point.x + 20;\n    } else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && source.corners.left <= source.point.x && source.point.x <= source.corners.right) {\n      direction = source.direction;\n      length = source.point.x > target.point.x ? source.point.x - source.corners.left + 20 : source.corners.right - source.point.x + 20;\n    }\n  }\n\n  var extra = direction === 'Left' || direction === 'Top' ? -length : length;\n  var angle = direction === 'Left' || direction === 'Right' ? 0 : 90;\n  var refPoint = source.point;\n  source.point = addLineSegment(source.point, extra, angle);\n  source.direction = Point.direction(source.point, target.point);\n\n  if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && (source.corners.center.x === target.corners.center.x || source.corners.center.y === target.corners.center.y)) {\n    source.direction = target.direction;\n  }\n\n  var point = orthoConnection3Segment(element, source, target);\n  point.splice(0, 0, refPoint);\n  return point;\n}\n/**\n * findSegmentDirection method \\\n *\n * @returns { void }     findSegmentDirection method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n * @param {Direction} portDir - provide the target value.\n *\n * @private\n */\n\n\nfunction findSegmentDirection(element, source, target, portDir) {\n  var update = false;\n\n  switch (target.direction) {\n    case 'Left':\n      if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && portDir === 'Right' && source.point.x > target.point.x && source.point.y >= source.corners.top && source.point.y <= source.corners.bottom || (portDir === 'Bottom' && source.point.y > target.point.y || portDir === 'Top' && source.point.y < target.point.y) && source.point.x >= source.corners.left && source.point.x <= source.corners.right) {\n        source.direction = portDir === 'Right' ? source.point.y > target.point.y ? 'Top' : 'Bottom' : source.point.x < target.point.x ? 'Right' : 'Left';\n        update = true;\n      } else if (source.point.x > target.point.x && (source.point.y > target.point.y || source.point.y < target.point.y) && !(target.corners.top > source.point.y && target.corners.bottom < source.point.y)) {\n        source.direction = 'Left';\n      } else if (source.point.x < target.point.x && source.point.y > target.point.y || source.point.x > target.point.x && source.point.y <= target.point.y && target.corners.top < source.point.y && target.corners.center.y >= source.point.y) {\n        source.direction = 'Top';\n      } else if (source.point.x < target.point.x && source.point.y < target.point.y || source.point.x > target.point.x && source.point.y > target.point.y && target.corners.bottom < source.point.y && target.corners.center.y > source.point.y) {\n        source.direction = 'Bottom';\n      } else if (source.point.y === target.point.y && source.point.x < target.point.x) {\n        source.direction = 'Right';\n      }\n\n      break;\n\n    case 'Right':\n      if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && (portDir === 'Bottom' && source.point.y > target.point.y || portDir === 'Top' && source.point.y < target.point.y) && source.point.x > target.point.x && source.point.x >= source.corners.left && source.point.x <= source.corners.right) {\n        source.direction = source.point.x > target.point.x ? 'Left' : 'Right';\n        update = true;\n      } else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && portDir === 'Left' && source.point.x < target.point.x && source.point.y >= source.corners.top && source.point.y <= source.corners.bottom) {\n        source.direction = source.point.y > target.point.y ? 'Top' : 'Bottom';\n        update = true;\n      } else if (source.point.x < target.point.x && target.corners.top <= source.point.y && target.corners.bottom >= source.point.y && source.point.y === target.point.y) {\n        source.direction = 'Top';\n      } else if (source.point.y > target.point.y && source.point.x > target.point.x) {\n        source.direction = 'Top';\n      } else if (source.point.y < target.point.y && source.point.x > target.point.x) {\n        source.direction = 'Bottom';\n      } else if (source.point.x < target.point.x && (source.point.y > target.point.y || source.point.y < target.point.y)) {\n        source.direction = 'Right';\n      } else if (source.point.y === target.point.y && source.point.x > target.point.x) {\n        source.direction = 'Left';\n      }\n\n      break;\n\n    case 'Top':\n      if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && portDir === 'Bottom' && source.point.y > target.point.y && source.point.x >= source.corners.left && source.point.x <= source.corners.right || (portDir === 'Right' && source.point.x > target.point.x || portDir === 'Left' && target.point.y > source.point.y && target.point.x > source.point.x) && source.point.y >= source.corners.top && source.point.y <= source.corners.bottom) {\n        source.direction = portDir === 'Bottom' ? source.point.x > target.point.x ? 'Left' : 'Right' : source.point.y < target.point.y ? 'Bottom' : 'Top';\n        update = true;\n      } else if (source.point.x === target.point.x && source.point.y < target.point.y) {\n        source.direction = 'Bottom';\n      } else if (source.point.y > target.point.y && source.point.x > target.corners.left && source.point.x < target.corners.right) {\n        source.direction = 'Left';\n      } else if (source.point.y >= target.point.y) {\n        source.direction = 'Top';\n      } else if (source.point.y < target.point.y && source.point.x > target.point.x) {\n        source.direction = 'Left';\n      } else if (source.point.y < target.point.y && source.point.x < target.point.x) {\n        source.direction = 'Right';\n      }\n\n      break;\n\n    case 'Bottom':\n      if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && ((portDir === 'Right' || portDir === 'Left' && target.point.x > source.point.x) && source.point.y > target.point.y && source.point.y >= source.corners.top && source.point.y <= source.corners.bottom || portDir === 'Top' && source.point.y < target.point.y && source.point.x >= source.corners.left && source.point.x <= source.corners.right)) {\n        if (portDir === 'Right' || portDir === 'Left') {\n          source.direction = source.point.y > target.point.y ? 'Top' : 'Bottom';\n        } else {\n          source.direction = source.point.x > target.point.x ? 'Left' : 'Right';\n        }\n\n        update = true;\n      } else if (source.point.y < target.point.y && source.point.x > target.corners.left && target.corners.right > source.point.x) {\n        if (source.point.y < target.point.y && source.point.x > target.corners.left && target.corners.center.x >= source.point.x) {\n          source.direction = 'Left';\n        } else if (source.point.y < target.point.y && source.point.x < target.corners.right && target.corners.center.x < source.point.x) {\n          source.direction = 'Right';\n        }\n      } else if (source.point.y > target.point.y && source.point.x > target.point.x) {\n        source.direction = 'Left';\n      } else if (source.point.y > target.point.y && source.point.x < target.point.x) {\n        source.direction = 'Right';\n      } else if (source.point.y <= target.point.y && (source.point.x > target.point.x || target.point.x > source.point.x)) {\n        source.direction = 'Bottom';\n      }\n\n      break;\n  }\n\n  return update;\n}\n/**\n * pointToPort method \\\n *\n * @returns { void }     pointToPort method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\n\n\nfunction pointToPort(element, source, target) {\n  var point;\n  target.corners = element.targetWrapper.corners;\n  var portdirection;\n  var length;\n\n  if (element.sourcePortWrapper !== undefined) {\n    var port = {\n      x: element.sourcePortWrapper.offsetX,\n      y: element.sourcePortWrapper.offsetY\n    };\n    portdirection = getPortDirection(port, cornersPointsBeforeRotation(element.sourceWrapper), element.sourceWrapper.bounds, false);\n  }\n\n  var update = findSegmentDirection(element, source, target, portdirection);\n\n  if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && target.direction === getOppositeDirection(portdirection) && ((target.direction === 'Left' && source.point.x > target.point.x || target.direction === 'Right' && source.point.x < target.point.x) && source.point.y >= source.corners.top && source.point.y <= source.corners.bottom || target.direction === 'Bottom' && source.point.y < target.point.y && source.point.x >= source.corners.left && source.point.x <= source.corners.right)) {\n    point = addPoints(element, source, target);\n  } else if (source.direction === target.direction) {\n    point = orthoConnection3Segment(element, source, target);\n  } else if ((target.direction === 'Left' && source.point.x > target.point.x || target.direction === 'Right' && source.point.x < target.point.x) && (source.direction === 'Top' || source.direction === 'Bottom') && source.point.y <= target.point.y && target.corners.top <= source.point.y && target.corners.bottom >= source.point.y || target.direction === 'Top' && source.point.y > target.point.y || target.direction === 'Bottom' && source.point.y < target.point.y && target.corners.left <= source.point.x && target.corners.right >= source.point.x) {\n    point = addPoints(element, source, target);\n  } else {\n    if (element.sourceWrapper !== undefined && element.targetWrapper !== undefined && element.targetPortWrapper !== undefined && (source.direction === 'Left' || source.direction === 'Right') && source.point.y >= source.corners.top && source.point.y <= source.corners.bottom && (target.direction === 'Top' || target.direction === 'Bottom') && target.corners.center.x === source.corners.center.x) {\n      source.direction = target.direction === 'Top' ? 'Bottom' : 'Top';\n      length = target.direction === 'Top' ? source.corners.bottom - source.point.y + 20 : source.point.y - source.corners.top + 20;\n      point = orthoConnection3Segment(element, source, target, length);\n    } else if (element.sourceWrapper !== undefined && element.targetWrapper !== undefined && element.targetPortWrapper !== undefined && (source.direction === 'Top' || source.direction === 'Bottom') && source.point.x >= source.corners.left && source.point.x <= source.corners.right && (target.direction === 'Left' || target.direction === 'Right') && target.corners.center.y === source.corners.center.y) {\n      source.direction = target.direction === 'Left' ? 'Right' : 'Left';\n      length = target.direction === 'Left' ? source.corners.right - source.point.x + 20 : source.point.x - source.corners.left + 20;\n      point = orthoConnection3Segment(element, source, target, length);\n    } else if (update) {\n      if (source.direction === 'Left' || source.direction === 'Right') {\n        length = source.direction === 'Left' ? source.point.x - source.corners.left + 20 : source.corners.right - source.point.x + 20;\n      } else {\n        length = source.direction === 'Top' ? source.point.y - source.corners.top + 20 : source.corners.bottom - source.point.y + 20;\n      }\n\n      point = orthoConnection3Segment(element, source, target, length);\n    } else {\n      point = orthoConnection2Segment(source, target);\n    }\n  }\n\n  return point;\n}\n/**\n * findPointToPointOrtho method \\\n *\n * @returns { void }     findPointToPointOrtho method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} source - provide the source value.\n * @param {DiagramElement} target - provide the target value.\n * @param {DiagramElement} sourceNode - provide the target value.\n * @param {DiagramElement} targetNode - provide the target value.\n * @param {DiagramElement} sourcePort - provide the sourcePort value.\n * @param {DiagramElement} targetPort - provide the targetPort value.\n *\n * @private\n */\n\n\nfunction findPointToPointOrtho(element, source, target, sourceNode, targetNode, sourcePort, targetPort) {\n  var j;\n  var point;\n  var intermeditatePoints = [];\n  var direction;\n  var port; //let seg: OrthogonalSegment;\n\n  checkLastSegmentasTerminal(element);\n  var removeSegment;\n\n  if (element.segments.length > 0) {\n    for (var i = 0; i < element.segments.length; i++) {\n      var seg = element.segments[i];\n\n      if (i === 0 && element.sourcePortWrapper !== undefined) {\n        port = {\n          x: sourcePort.offsetX,\n          y: sourcePort.offsetY\n        };\n        direction = getPortDirection(port, cornersPointsBeforeRotation(sourceNode), sourceNode.bounds, false);\n\n        if (seg.direction === getOppositeDirection(direction)) {\n          seg.direction = direction;\n        }\n      }\n\n      if (i > 0 && element.segments[i - 1].direction === seg.direction) {\n        i = checkConsectiveSegmentAsSame(element, i, source);\n      } else {\n        var lastSegment = element.segments[i - 1];\n        source.point = seg.direction ? updateSegmentPoints(source, seg) : lastSegment.points[lastSegment.points.length - 1];\n      }\n\n      if (i === element.segments.length - 1) {\n        if (!targetPort && !targetNode) {\n          point = pointToPoint(element, source, target);\n        } else if (element.targetWrapper && element.targetPortWrapper === undefined) {\n          checkSourcePointInTarget(element, source);\n          point = pointToNode(element, source, target);\n        } else {\n          point = pointToPort(element, source, target);\n        }\n\n        if (point) {\n          checkPreviousSegment(point, element, source);\n          seg.points = [];\n\n          if (point.length >= 2) {\n            for (j = 0; j < point.length; j++) {\n              seg.points.push(point[j]);\n            }\n          } else {\n            removeSegment = i;\n          }\n        }\n      }\n\n      if (sourcePort && i === 0) {\n        var sourcePoint = checkPortdirection(element, sourcePort, sourceNode);\n\n        if (sourcePoint) {\n          source.point = sourcePoint;\n        }\n      }\n    }\n\n    if (removeSegment !== undefined) {\n      if (removeSegment === element.segments.length - 1) {\n        element.segments[removeSegment - 1].direction = null;\n        element.segments[removeSegment - 1].length = null;\n      }\n\n      element.segments.splice(removeSegment, 1);\n    }\n\n    intermeditatePoints = returnIntermeditatePoints(element, intermeditatePoints);\n  }\n\n  return intermeditatePoints;\n}\n/**\n * checkPortdirection method \\\n *\n * @returns { PointModel }     checkPortdirection method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} sourcePort - provide the target value.\n * @param {DiagramElement} sourceNode - provide the target value.\n *\n * @private\n */\n\n\nfunction checkPortdirection(element, sourcePort, sourceNode) {\n  var port = {\n    x: sourcePort.offsetX,\n    y: sourcePort.offsetY\n  };\n  var point;\n  var bounds = cornersPointsBeforeRotation(sourceNode);\n  var direction = getPortDirection(port, bounds, sourceNode.bounds, false);\n  var seg = element.segments[0];\n\n  if (seg.direction !== direction) {\n    pointsFromNodeToPoint(seg, direction, bounds, seg.points[0], seg.points[seg.points.length - 1], false);\n    point = seg.points[seg.points.length - 1];\n    seg.direction = Point.direction(seg.points[seg.points.length - 2], seg.points[seg.points.length - 1]);\n  }\n\n  return point;\n}\n/**\n * checkPreviousSegment method \\\n *\n * @returns { PointModel }     checkPreviousSegment method .\\\n * @param {Connector} tPoints - provide the element value.\n * @param {DiagramElement} connector - provide the target value.\n * @param {DiagramElement} source - provide the target value.\n *\n * @private\n */\n\n\nfunction checkPreviousSegment(tPoints, connector, source) {\n  var actualSegment = connector.segments[connector.segments.length - 2];\n  var actualLastPoint = actualSegment.points[actualSegment.points.length - 1];\n  var direction;\n\n  if ((actualSegment.direction === 'Top' || actualSegment.direction === 'Bottom') && actualLastPoint.x === tPoints[1].x || (actualSegment.direction === 'Left' || actualSegment.direction === 'Right') && actualLastPoint.y === tPoints[1].y) {\n    actualSegment.points[actualSegment.points.length - 1] = tPoints[1];\n    direction = Point.direction(actualSegment.points[0], actualSegment.points[actualSegment.points.length - 1]);\n\n    if (connector.sourceWrapper !== undefined && connector.sourcePortWrapper === undefined && direction === getOppositeDirection(actualSegment.direction)) {\n      if (actualSegment.direction === 'Left' || actualSegment.direction === 'Right') {\n        actualSegment.points[0].x = actualSegment.direction === 'Right' ? actualSegment.points[0].x - connector.sourceWrapper.corners.width : actualSegment.points[0].x + connector.sourceWrapper.corners.width;\n      } else {\n        actualSegment.points[0].y = actualSegment.direction === 'Bottom' ? actualSegment.points[0].y - connector.sourceWrapper.corners.height : actualSegment.points[0].y + connector.sourceWrapper.corners.height;\n      }\n    }\n\n    actualSegment.direction = direction;\n    actualSegment.length = Point.distancePoints(actualSegment.points[0], actualSegment.points[actualSegment.points.length - 1]);\n    tPoints.splice(0, 1);\n  }\n}\n/**\n * connectToOneEnd method \\\n *\n * @returns { void }     connectToOneEnd method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} source - provide the target value.\n * @param {DiagramElement} target - provide the target value.\n *\n * @private\n */\n\n\nfunction connectToOneEnd(element, source, target) {\n  var sourcePort = element.sourcePortWrapper;\n  var targetPort = element.targetPortWrapper;\n  var node = element.sourceWrapper;\n  var fixedPoint = source.point;\n  var nodeMargin = {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n  var nodeConnectingPoint = {\n    x: 0,\n    y: 0\n  };\n  var refPoint;\n  var nodeDirection = 'Top';\n\n  if (!node) {\n    node = element.targetWrapper;\n    nodeMargin = target.margin;\n  } else {\n    fixedPoint = target.point;\n    nodeMargin = source.margin;\n  }\n\n  if (element.type === 'Orthogonal') {\n    if (element.segments && element.segments.length > 0 && element.sourceWrapper && element.segments[0].direction) {\n      source.direction = element.segments[0].direction;\n      nodeConnectingPoint = findPoint(node.corners, source.direction);\n      refPoint = findPoint(node.corners, getOppositeDirection(source.direction));\n      nodeConnectingPoint = getIntersection(element, node, nodeConnectingPoint, refPoint, false);\n    } else {\n      var source_1 = {\n        corners: null,\n        direction: null,\n        point: fixedPoint,\n        margin: nodeMargin\n      };\n      var target_1 = {\n        corners: null,\n        direction: null,\n        point: null,\n        margin: null\n      };\n      findDirection(node, source_1, target_1, element);\n      nodeConnectingPoint = target_1.point;\n      nodeDirection = target_1.direction;\n    }\n  } else {\n    var segmentPoint = void 0;\n\n    if (element.segments && element.segments.length > 1) {\n      if (node === element.sourceWrapper) {\n        segmentPoint = element.segments[0].point;\n      } else {\n        segmentPoint = element.segments[element.segments.length - 2].point;\n      }\n    }\n\n    nodeConnectingPoint = getIntersection(element, node, node.bounds.center, element.segments && element.segments.length > 1 ? segmentPoint : fixedPoint, node === element.targetWrapper);\n  }\n\n  if (node === element.sourceWrapper) {\n    source.direction = source.direction || nodeDirection;\n    source.point = nodeConnectingPoint;\n\n    if (element.sourcePortWrapper) {\n      source.point = {\n        x: sourcePort.offsetX,\n        y: sourcePort.offsetY\n      };\n\n      if (element.sourcePadding) {\n        source.point = addPaddingToConnector(element, source, target, false);\n      }\n    }\n  } else {\n    target.direction = target.direction || nodeDirection;\n    target.point = nodeConnectingPoint;\n\n    if (element.targetPortWrapper) {\n      target.point = {\n        x: targetPort.offsetX,\n        y: targetPort.offsetY\n      };\n\n      if (element.targetPadding) {\n        target.point = addPaddingToConnector(element, source, target, true);\n      }\n    }\n  }\n}\n/**\n * addPaddingToConnector method \\\n *\n * @returns { void }     addPaddingToConnector method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} source - provide the target value.\n * @param {DiagramElement} target - provide the target value.\n * @param {DiagramElement} isTarget - provide the target value.\n *\n * @private\n */\n\n\nfunction addPaddingToConnector(element, source, target, isTarget) {\n  var sourcePort = element.sourcePortWrapper;\n  var targetPort = element.targetPortWrapper;\n  var padding = isTarget ? element.targetPadding : element.sourcePadding;\n  var paddingPort = isTarget ? targetPort : sourcePort;\n  var rect = new Rect(paddingPort.bounds.x - padding, paddingPort.bounds.y - padding, paddingPort.actualSize.width + 2 * padding, paddingPort.actualSize.height + 2 * padding);\n  var segmentPoints = [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft];\n  segmentPoints[segmentPoints.length] = segmentPoints[0]; //const length: number = segmentPoints.length;\n\n  var thisSegment = {\n    x1: source.point.x,\n    y1: source.point.y,\n    x2: target.point.x,\n    y2: target.point.y\n  };\n  var point = isTarget ? target.point : source.point;\n  return getIntersectionPoints(thisSegment, segmentPoints, true, point) || point;\n}\n/**\n * checkSourceAndTargetIntersect method \\\n *\n * @returns { void }     checkSourceAndTargetIntersect method .\\\n * @param {DiagramElement} sourceWrapper - provide the sourceWrapper value.\n * @param {DiagramElement} targetWrapper - provide the targetWrapper value.\n * @param {Connector} connector - provide the Connector value.\n *\n * @private\n */\n\n\nfunction checkSourceAndTargetIntersect(sourceWrapper, targetWrapper, connector) {\n  var sourceSegment = createSegmentsCollection(sourceWrapper, connector.sourcePadding);\n  var targetSegment = createSegmentsCollection(targetWrapper, connector.targetPadding);\n\n  for (var i = 0; i < sourceSegment.length - 1; i++) {\n    var srcSegment = sourceSegment[i];\n\n    for (var j = 0; j < targetSegment.length - 1; j++) {\n      var tarSegmet = targetSegment[j];\n\n      if (intersect3(srcSegment, tarSegmet).enabled) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * createSegmentsCollection method \\\n *\n * @returns { Segment[] }     createSegmentsCollection method .\\\n * @param {DiagramElement} sourceWrapper - provide the sourceWrapper value.\n * @param {number} padding - provide the padding value.\n *\n * @private\n */\n\n\nfunction createSegmentsCollection(sourceWrapper, padding) {\n  var segments = [];\n  var points = getPoints(sourceWrapper, sourceWrapper.corners, padding);\n  points.push(points[0]);\n\n  for (var i = 0; i < points.length - 1; i++) {\n    segments.push(createLineSegment(points[i], points[i + 1]));\n  }\n\n  return segments;\n}\n/**\n * createLineSegment method \\\n *\n * @returns { Segment }     createLineSegment method .\\\n * @param {PointModel} sPt - provide the sourceWrapper value.\n * @param {PointModel} tPt - provide the padding value.\n *\n * @private\n */\n\n\nfunction createLineSegment(sPt, tPt) {\n  var line = {\n    x1: sPt.x,\n    y1: sPt.y,\n    x2: tPt.x,\n    y2: tPt.y\n  };\n  return line;\n}\n/**\n * swapBounds method \\\n *\n * @returns { Corners }     swapBounds method .\\\n * @param {PointModel} object - provide the sourceWrapper value.\n * @param {PointModel} bounds - provide the padding value.\n * @param {Rect} outerBounds - provide the padding value.\n *\n * @private\n */\n\n\nexport function swapBounds(object, bounds, outerBounds) {\n  var rectBounds;\n  var rotateAngle = object.rotateAngle + object.parentTransform;\n\n  if (rotateAngle) {\n    if (rotateAngle < 45) {\n      return bounds;\n    } else if (rotateAngle <= 135) {\n      rectBounds = {\n        width: bounds.width,\n        height: bounds.height,\n        topLeft: bounds.bottomLeft,\n        topCenter: bounds.middleLeft,\n        topRight: bounds.topLeft,\n        middleLeft: bounds.bottomCenter,\n        center: outerBounds.center,\n        middleRight: bounds.topCenter,\n        bottomLeft: bounds.bottomRight,\n        bottomCenter: bounds.middleRight,\n        bottomRight: bounds.topRight,\n        left: outerBounds.left,\n        right: outerBounds.right,\n        top: outerBounds.top,\n        bottom: outerBounds.bottom\n      };\n    } else if (rotateAngle <= 225) {\n      rectBounds = {\n        width: bounds.width,\n        height: bounds.height,\n        topLeft: bounds.bottomLeft,\n        topCenter: bounds.bottomCenter,\n        topRight: bounds.bottomRight,\n        middleLeft: bounds.middleRight,\n        center: outerBounds.center,\n        middleRight: bounds.middleLeft,\n        bottomLeft: bounds.topLeft,\n        bottomCenter: bounds.topCenter,\n        bottomRight: bounds.topRight,\n        left: outerBounds.left,\n        right: outerBounds.right,\n        top: outerBounds.top,\n        bottom: outerBounds.bottom\n      };\n    } else if (rotateAngle <= 315) {\n      rectBounds = {\n        width: bounds.width,\n        height: bounds.height,\n        topLeft: bounds.topRight,\n        topCenter: bounds.middleRight,\n        topRight: bounds.bottomRight,\n        middleLeft: bounds.topCenter,\n        center: outerBounds.center,\n        middleRight: bounds.bottomCenter,\n        bottomLeft: bounds.topLeft,\n        bottomCenter: bounds.middleLeft,\n        bottomRight: bounds.bottomLeft,\n        left: outerBounds.left,\n        right: outerBounds.right,\n        top: outerBounds.top,\n        bottom: outerBounds.bottom\n      };\n    } else {\n      return bounds;\n    }\n\n    return rectBounds;\n  }\n\n  return bounds;\n}\n/**\n * defaultOrthoConnection method \\\n *\n * @returns { PointModel[] }     defaultOrthoConnection method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {Direction} srcDir - provide the srcDir value.\n * @param {Direction} tarDir - provide the srcDir value.\n * @param {PointModel} sPt - provide the sPt value.\n * @param {PointModel} tPt - provide the tPt value.\n * @param {Rect} lineDistribution - provide the padding value.\n *\n * @private\n */\n\n/* tslint:disable */\n// eslint-disable-next-line\n\nfunction defaultOrthoConnection(ele, srcDir, tarDir, sPt, tPt, lineDistribution) {\n  var sourceEle = ele.sourceWrapper;\n  var targetEle = ele.targetWrapper;\n  var srcPort = ele.sourcePortWrapper;\n  var tarPort = ele.targetPortWrapper;\n  var intermeditatePoints = [];\n  var refPoint;\n  var srcCor = sourceEle.corners; // eslint-disable-next-line\n\n  var tarCor = targetEle.corners;\n  var point = tarCor.center; //const i: number;\n\n  var sourceMargin = {\n    left: 5,\n    right: 5,\n    bottom: 5,\n    top: 5\n  };\n  var targetMargin = {\n    left: 5,\n    right: 5,\n    bottom: 5,\n    top: 5\n  };\n  var source = {\n    corners: srcCor,\n    point: sPt,\n    direction: srcDir,\n    margin: sourceMargin\n  }; // eslint-disable-next-line\n\n  var target = {\n    corners: tarCor,\n    point: tPt,\n    direction: tarDir,\n    margin: targetMargin\n  };\n  var srcBounds = swapBounds(sourceEle, srcCor, ele.sourceWrapper.bounds);\n  var tarBounds = swapBounds(targetEle, tarCor, ele.targetWrapper.bounds);\n  var isInterSect = false;\n\n  if (ele.sourceWrapper && ele.targetWrapper) {\n    isInterSect = checkSourceAndTargetIntersect(ele.sourceWrapper, ele.targetWrapper, ele);\n  }\n\n  if (srcPort !== undefined) {\n    source.point = {\n      x: srcPort.offsetX,\n      y: srcPort.offsetY\n    };\n\n    switch (source.direction) {\n      case 'Bottom':\n      case 'Top':\n        // eslint-disable-next-line\n        source.point.y = source.point.y;\n        break;\n\n      case 'Left':\n      case 'Right':\n        // eslint-disable-next-line\n        source.point.x = source.point.x;\n        break;\n    }\n\n    if (ele.sourcePadding && !isInterSect) {\n      if (tarPort) {\n        target.point = {\n          x: tarPort.offsetX,\n          y: tarPort.offsetY\n        };\n      }\n\n      source.point = addPaddingToConnector(ele, source, target, false);\n    }\n  } else {\n    if (ele.type === 'Orthogonal') {\n      if (ele.segments && ele.segments.length > 0 && ele.segments[0].direction) {\n        source.direction = ele.segments[0].direction;\n      }\n\n      source.point = findPoint(srcBounds, source.direction);\n      refPoint = findPoint(srcBounds, getOppositeDirection(source.direction));\n      source.point = getIntersection(ele, sourceEle, source.point, refPoint, false);\n    } else {\n      source.point = sourceEle.corners.center;\n    }\n  }\n\n  if (tarPort !== undefined) {\n    target.point = {\n      x: tarPort.offsetX,\n      y: tarPort.offsetY\n    };\n\n    switch (target.direction) {\n      case 'Bottom':\n      case 'Top':\n        // eslint-disable-next-line\n        target.point.y = target.point.y;\n        break;\n\n      case 'Left':\n      case 'Right':\n        // eslint-disable-next-line\n        target.point.x = target.point.x;\n        break;\n    }\n\n    if (ele.targetPadding && !isInterSect) {\n      target.point = addPaddingToConnector(ele, source, target, true);\n    }\n  } else {\n    if (ele.type === 'Orthogonal') {\n      target.point = findPoint(tarBounds, target.direction);\n      refPoint = findPoint(tarBounds, getOppositeDirection(target.direction));\n      target.point = getIntersection(ele, targetEle, target.point, refPoint, true);\n    } else {\n      target.point = targetEle.corners.center;\n    }\n  }\n\n  if (ele.type !== 'Orthogonal') {\n    var segment = void 0;\n    var first = void 0;\n    checkLastSegmentasTerminal(ele);\n\n    if (ele.sourcePortWrapper === undefined) {\n      source.point = source.corners.center;\n\n      if (ele.segments && ele.segments.length > 0) {\n        first = ele.segments[0];\n        segment = !Point.isEmptyPoint(first.point) ? first : undefined;\n      }\n\n      var tarPoint = segment !== undefined ? segment.point : target.point;\n\n      if (ele.type === 'Bezier' && ele.segments.length > 0 && ele.segments[0].vector1.angle && ele.segments[0].vector1.distance) {\n        var value = Math.max(source.corners.width, source.corners.height);\n        tarPoint = Point.transform(source.point, ele.segments[0].vector1.angle, value / 2);\n      }\n\n      source.point = isInterSect ? ele.sourceWrapper.bounds.center : getIntersection(ele, sourceEle, source.point, tarPoint, false);\n    }\n\n    if (ele.targetPortWrapper === undefined) {\n      target.point = target.corners.center;\n\n      if (ele.segments && ele.segments.length > 1) {\n        first = ele.segments[ele.segments.length - 2];\n        segment = !Point.isEmptyPoint(first.point) ? first : undefined;\n      }\n\n      var srcPoint = segment ? segment.point : source.point;\n\n      if (ele.type === 'Bezier' && ele.segments.length > 0 && ele.segments[ele.segments.length - 1].vector2.angle && ele.segments[ele.segments.length - 1].vector2.distance) {\n        var value = Math.max(source.corners.width, source.corners.height);\n        srcPoint = Point.transform(target.point, ele.segments[0].vector2.angle, value / 2);\n      }\n\n      target.point = isInterSect ? ele.targetWrapper.bounds.center : getIntersection(ele, targetEle, srcPoint, target.point, true);\n    }\n\n    intermeditatePoints = intermeditatePointsForStraight(ele, source, target);\n  } else {\n    if (ele.type === 'Orthogonal' && ele.segments && ele.segments.length > 0 && ele.segments[0].direction !== null) {\n      intermeditatePoints = findIntermeditatePoints(ele, source, target, srcPort, tarPort, sourceEle, targetEle);\n    } else {\n      if (!ele.segments[0]) {\n        var segment = new OrthogonalSegment(ele, 'segments', {\n          type: 'Orthogonal'\n        }, true);\n        ele.segments.push(segment);\n      } // eslint-disable-next-line\n\n\n      ele.segments[0].points = intermeditatePoints = findOrthoSegments(ele, source, target, undefined, lineDistribution);\n    }\n  }\n\n  return intermeditatePoints;\n}\n/**\n * intermeditatePointsForStraight method \\\n *\n * @returns { PointModel[] }     intermeditatePointsForStraight method .\\\n * @param {Connector} element - provide the Connector value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\n\n\nfunction intermeditatePointsForStraight(element, source, target) {\n  var intermeditatePoints = [];\n\n  if (element.segments && element.segments.length > 0) {\n    var i = void 0;\n    var segPoint = [];\n    var srcPoint = source.point;\n\n    for (i = 0; i < element.segments.length; i++) {\n      var seg = element.segments[i];\n      segPoint = [];\n      segPoint.push(srcPoint);\n\n      if (i !== element.segments.length - 1) {\n        segPoint.push(seg.point);\n        srcPoint = seg.point;\n      } else {\n        segPoint.push(target.point);\n      }\n\n      element.segments[i].points = segPoint;\n\n      if (element.segments.length > 1 && Point.equals(seg.points[0], seg.points[1])) {\n        element.segments.splice(i, 1);\n      }\n\n      if (seg) {\n        for (var j = 0; j < seg.points.length; j++) {\n          if (j > 0 || i === 0) {\n            intermeditatePoints.push(seg.points[j]);\n          }\n        }\n      }\n    }\n  }\n\n  return intermeditatePoints;\n}\n/**\n * findSourceDirection method \\\n *\n * @returns { PointModel[] }     findSourceDirection method .\\\n * @param {Direction} dir - provide the dir value.\n * @param {PointModel} srcPoint - provide the srcPoint value.\n * @param {PointModel} tarPoint - provide the tarPoint value.\n *\n * @private\n */\n\n\nfunction findSourceDirection(dir, srcPoint, tarPoint) {\n  var direction = dir === 'Top' || dir === 'Bottom' ? tarPoint.x > srcPoint.x ? 'Right' : 'Left' : tarPoint.y > srcPoint.y ? 'Bottom' : 'Top';\n  return direction;\n}\n/**\n * checkLastSegmentasTerminal method \\\n *\n * @returns { void }     checkLastSegmentasTerminal method .\\\n * @param {Connector} ele - provide the Connector value.\n *\n * @private\n */\n\n\nfunction checkLastSegmentasTerminal(ele) {\n  if (ele.type === 'Straight' || ele.type === 'Bezier') {\n    if (ele.segments.length === 0 || ele.segments.length > 0 && !Point.isEmptyPoint(ele.segments[ele.segments.length - 1].point)) {\n      //let segment: BezierSegmentModel | StraightSegmentModel;\n      var segment = ele.type === 'Bezier' ? new BezierSegment(ele, 'segments', {\n        type: 'Bezier'\n      }, true) : new StraightSegment(ele, 'segments', {\n        type: 'Straight'\n      }, true);\n      ele.segments.push(segment);\n    }\n  } else {\n    if (ele.segments.length === 0 || ele.segments[ele.segments.length - 1].direction) {\n      var segment = new OrthogonalSegment(ele, 'segments', {\n        type: 'Orthogonal'\n      }, true);\n      ele.segments.push(segment);\n    }\n  }\n}\n/**\n * checkConsectiveSegmentAsSame method \\\n *\n * @returns { number }     checkConsectiveSegmentAsSame method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {Connector} i - provide the Connector value.\n * @param {Connector} source - provide the Connector value.\n *\n * @private\n */\n\n\nfunction checkConsectiveSegmentAsSame(ele, i, source) {\n  var seg = ele.segments[i];\n  var extra = seg.direction === 'Left' || seg.direction === 'Top' ? -seg.length : seg.length;\n  var angle = seg.direction === 'Left' || seg.direction === 'Right' ? 0 : 90;\n  var segPoint = addLineSegment(source.point, extra, angle);\n  ele.segments[i - 1].length += seg.length;\n  ele.segments[i - 1].points[1] = source.point = segPoint;\n  ele.segments.splice(i, 1);\n  i--;\n  return i;\n}\n/**\n * nodeOrPortToNode method \\\n *\n * @returns { PointModel[] }     nodeOrPortToNode method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {End} source - provide the Connector value.\n * @param {End} target - provide the Connector value.\n *\n * @private\n */\n\n\nfunction nodeOrPortToNode(ele, source, target) {\n  var point;\n  var portdirection;\n\n  if (ele.sourcePortWrapper) {\n    var port = {\n      x: ele.sourcePortWrapper.offsetX,\n      y: ele.sourcePortWrapper.offsetY\n    };\n    portdirection = getPortDirection(port, cornersPointsBeforeRotation(ele.sourceWrapper), ele.sourceWrapper.bounds, false);\n  }\n\n  findDirection(ele.targetWrapper, source, target, ele);\n  var direction = findSourceDirection(target.direction, source.point, target.point);\n\n  if (ele.sourcePortWrapper !== undefined && source.direction === target.direction && ((source.direction === 'Top' || source.direction === 'Bottom') && source.corners.center.x === target.corners.center.x || (source.direction === 'Left' || source.direction === 'Right') && source.corners.center.y === target.corners.center.y)) {\n    source.direction = direction;\n    point = direction === 'Top' || direction === 'Bottom' ? orthoConnection3Segment(ele, source, target, ele.sourceWrapper.height / 2 + 20) : orthoConnection3Segment(ele, source, target, ele.sourceWrapper.width / 2 + 20);\n    var source1 = source;\n    source1.point = point[1];\n\n    if (direction === 'Left' || direction === 'Right') {\n      target.direction = direction;\n      target.point = direction === 'Left' ? target.corners.middleLeft : target.corners.middleRight;\n    } else {\n      findDirection(ele.targetWrapper, source, target, ele);\n    }\n\n    point = orthoConnection3Segment(ele, source, target);\n  } else if (target.point.x >= source.corners.left && target.point.x <= source.corners.right && source.point.y >= source.corners.top && source.point.y <= source.corners.bottom) {\n    source.direction = target.point.y > source.point.y ? 'Bottom' : 'Top';\n    var length_2 = source.direction === 'Top' ? source.point.y - source.corners.top + 20 : source.corners.bottom - source.point.y + 20;\n    point = orthoConnection3Segment(ele, source, target, length_2);\n  } else if (ele.sourcePortWrapper && portdirection === getOppositeDirection(direction)) {\n    var length_3;\n\n    if ((portdirection === 'Left' || portdirection === 'Right') && source.point.y >= source.corners.top && source.point.y <= source.corners.bottom) {\n      source.direction = target.point.y > source.point.y ? 'Bottom' : 'Top';\n      length_3 = source.corners.height / 2 + 20;\n    } else if ((portdirection === 'Top' || portdirection === 'Bottom') && source.point.x >= source.corners.left && source.point.x <= source.corners.right) {\n      source.direction = target.point.x > source.point.x ? 'Right' : 'Left';\n      length_3 = source.corners.width / 2 + 20;\n    }\n\n    if (source.direction && length_3) {\n      point = orthoConnection3Segment(ele, source, target, length_3, true);\n    } else {\n      source.direction = direction;\n      point = orthoConnection2Segment(source, target);\n    }\n  } else if (ele.sourcePortWrapper && portdirection === target.direction && (portdirection === 'Top' || portdirection === 'Bottom') && source.corners.center.x === target.corners.center.x) {\n    source.direction = target.point.y > source.point.y ? 'Bottom' : 'Top';\n    var len = source.direction === 'Bottom' ? source.corners.bottom - source.point.y + 20 : source.point.y - source.corners.top + 20;\n    point = orthoConnection3Segment(ele, source, target, len);\n  } else {\n    source.direction = direction;\n    point = orthoConnection2Segment(source, target);\n  }\n\n  return point;\n}\n/**\n * checkSourcePointInTarget method \\\n *\n * @returns { void } checkSourcePointInTarget method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {End} source - provide the Connector value.\n *\n * @private\n */\n\n\nfunction checkSourcePointInTarget(ele, source) {\n  if (ele.targetWrapper !== undefined && ele.targetPortWrapper === undefined) {\n    var padding = 1;\n\n    if (cornersPointsBeforeRotation(ele.targetWrapper).containsPoint(source.point, padding)) {\n      var target = ele.targetWrapper;\n      var segment = ele.segments[ele.segments.length - 2];\n      var lastPoint = segment.points[segment.points.length - 1];\n      var direction = getOppositeDirection(segment.direction);\n\n      if (direction === 'Bottom') {\n        if (lastPoint.y < target.corners.bottom + padding) {\n          segment.points[segment.points.length - 1].y = target.corners.bottom + 20;\n          segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n        }\n      } else if (direction === 'Top') {\n        if (lastPoint.y > target.corners.top - padding) {\n          segment.points[segment.points.length - 1].y = target.corners.top - 20;\n          segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n        }\n      } else if (direction === 'Left') {\n        if (lastPoint.x > target.corners.left - padding) {\n          segment.points[segment.points.length - 1].x = target.corners.left - 20;\n          segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n        }\n      } else if (direction === 'Right') {\n        if (lastPoint.x < target.corners.right + padding) {\n          segment.points[segment.points.length - 1].x = target.corners.right + 20;\n          segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n        }\n      }\n\n      source.point = segment.points[segment.points.length - 1];\n    }\n  }\n}\n/**\n * findIntermeditatePoints method \\\n *\n * @returns { void } findIntermeditatePoints method .\\\n * @param {Connector} ele - provide the ele value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the source value.\n * @param {DiagramElement} srcPort - provide the srcPort value.\n * @param {DiagramElement} tarPort - provide the tarPort value.\n * @param {DiagramElement} sourceEle - provide the sourceEle value.\n * @param {DiagramElement} targetEle - provide the targetEle value.\n * @private\n */\n\n\nfunction findIntermeditatePoints(ele, source, target, srcPort, tarPort, sourceEle, targetEle) {\n  var point;\n  var intermeditatePoints = [];\n  var seg;\n  var j;\n  var removeSegment;\n  checkLastSegmentasTerminal(ele);\n\n  for (var i = 0; i < ele.segments.length; i++) {\n    seg = ele.segments[i];\n\n    if (srcPort && source.direction === getOppositeDirection(seg.direction)) {\n      seg.direction = source.direction;\n    }\n\n    if (i > 0 && ele.segments[i - 1].direction === seg.direction) {\n      i = checkConsectiveSegmentAsSame(ele, i, source);\n    } else {\n      if (seg.direction) {\n        source.point = updateSegmentPoints(source, ele.segments[i]);\n      } else {\n        var segment = ele.segments[i - 1];\n        source.point = segment.points[segment.points.length - 1];\n      }\n    }\n\n    if (i === ele.segments.length - 1) {\n      checkSourcePointInTarget(ele, source);\n\n      if (tarPort === undefined) {\n        point = nodeOrPortToNode(ele, source, target);\n      } else {\n        point = pointToPort(ele, source, target);\n      }\n\n      checkPreviousSegment(point, ele, source);\n      seg.points = [];\n\n      if (point.length >= 2) {\n        for (j = 0; j < point.length; j++) {\n          seg.points.push(point[j]);\n        }\n      } else {\n        removeSegment = i;\n      }\n    }\n\n    if (removeSegment !== undefined) {\n      if (removeSegment === ele.segments.length - 1) {\n        ele.segments[removeSegment - 1].direction = null;\n        ele.segments[removeSegment - 1].length = null;\n      }\n\n      ele.segments.splice(removeSegment, 1);\n    }\n\n    if (srcPort && i === 0) {\n      var sourcePoint = checkPortdirection(ele, srcPort, sourceEle);\n\n      if (sourcePoint) {\n        source.point = sourcePoint;\n      }\n    }\n  }\n\n  return returnIntermeditatePoints(ele, intermeditatePoints);\n}\n/**\n * returnIntermeditatePoints method \\\n *\n * @returns { PointModel[] } returnIntermeditatePoints method .\\\n * @param {Connector} element - provide the ele value.\n * @param {PointModel[]} intermeditatePoints - provide the source value.\n * @private\n */\n\n\nfunction returnIntermeditatePoints(element, intermeditatePoints) {\n  for (var i = 0; i < element.segments.length; i++) {\n    var seg = element.segments[i];\n\n    for (var j = 0; j < seg.points.length; j++) {\n      if (j > 0 || i === 0) {\n        intermeditatePoints.push(seg.points[j]);\n      }\n    }\n  }\n\n  return intermeditatePoints;\n}\n/**\n * findDirection method \\\n *\n * @returns { void } findDirection method .\\\n * @param {DiagramElement} node - provide the ele value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the source value.\n * @param {Connector} ele - provide the source value.\n * @private\n */\n\n\nfunction findDirection(node, source, target, ele) {\n  var nodeDirection;\n  var nodeConnectingPoint = {\n    x: 0,\n    y: 0\n  };\n  var nodeCorners = swapBounds(node, node.corners, node.bounds);\n  var nodeMargin = source.margin;\n  var fixedPoint = source.point;\n\n  if (nodeCorners.bottomCenter.y + nodeMargin.bottom < fixedPoint.y) {\n    nodeDirection = 'Bottom';\n    nodeConnectingPoint = nodeCorners.bottomCenter;\n  } else if (nodeCorners.topCenter.y - nodeMargin.top > fixedPoint.y) {\n    nodeDirection = 'Top';\n    nodeConnectingPoint = nodeCorners.topCenter;\n  } else if (nodeCorners.middleLeft.x - nodeMargin.left > fixedPoint.x) {\n    nodeDirection = 'Left';\n    nodeConnectingPoint = nodeCorners.middleLeft;\n  } else if (nodeCorners.middleRight.x + nodeMargin.right < fixedPoint.x) {\n    nodeDirection = 'Right';\n    nodeConnectingPoint = nodeCorners.middleRight;\n  } else {\n    var top_1 = Math.abs(fixedPoint.y - nodeCorners.topCenter.y);\n    var right = Math.abs(fixedPoint.x - nodeCorners.middleRight.x);\n    var bottom = Math.abs(fixedPoint.y - nodeCorners.bottomCenter.y);\n    var left = Math.abs(fixedPoint.x - nodeCorners.middleLeft.x);\n    var shortes = Number.MAX_VALUE;\n    shortes = top_1;\n    nodeDirection = 'Top';\n    nodeConnectingPoint = nodeCorners.topCenter;\n\n    if (shortes > right) {\n      shortes = right;\n      nodeDirection = 'Right';\n      nodeConnectingPoint = nodeCorners.middleRight;\n    }\n\n    if (shortes > bottom) {\n      shortes = bottom;\n      nodeDirection = 'Bottom';\n      nodeConnectingPoint = nodeCorners.bottomCenter;\n    }\n\n    if (shortes > left) {\n      //shortes = left;\n      nodeDirection = 'Left';\n      nodeConnectingPoint = nodeCorners.middleLeft;\n    }\n  }\n\n  target.point = nodeConnectingPoint;\n  target.direction = nodeDirection;\n  var refPoint = findPoint(nodeCorners, getOppositeDirection(target.direction));\n  target.point = getIntersection(ele, node, target.point, refPoint, node === ele.targetWrapper);\n}\n/**\n * findOrthoSegments method \\\n *\n * @returns { PointModel[] } findOrthoSegments method .\\\n * @param {DiagramElement} ele - provide the ele value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n * @param {Connector} extra - provide the extra value.\n * @param {boolean} lineDistribution - provide the lineDistribution value.\n * @private\n */\n\n\nfunction findOrthoSegments(ele, source, target, extra, lineDistribution) {\n  var swap = false;\n  var intermeditatePoints = [];\n  var seg;\n  swap = getSwapping(source.direction, target.direction);\n\n  if (swap) {\n    swapPoints(source, target);\n  }\n\n  if (source.direction === 'Right' && target.direction === 'Left') {\n    seg = getRightToLeftSegmentCount(ele, source, target, swap);\n  } else if (source.direction === 'Right' && target.direction === 'Right') {\n    seg = getRightToRightSegmentCount(ele, source, target);\n  } else if (source.direction === 'Right' && target.direction === 'Top') {\n    seg = getRightToTopSegmentCount(ele, source, target, swap);\n  } else if (source.direction === 'Right' && target.direction === 'Bottom') {\n    seg = getRightToBottomSegmentCount(ele, source, target, swap);\n  } else if (source.direction === 'Bottom' && target.direction === 'Top') {\n    seg = getBottomToTopSegmentCount(source, target);\n  } else if (source.direction === 'Bottom' && target.direction === 'Bottom') {\n    source.margin = {\n      left: 10,\n      right: 10,\n      top: 10,\n      bottom: 10\n    };\n    target.margin = {\n      left: 10,\n      right: 10,\n      top: 10,\n      bottom: 10\n    };\n    seg = getBottomToBottomSegmentCount(ele, source, target);\n  } else if (source.direction === 'Bottom' && target.direction === 'Left') {\n    seg = getBottomToLeftSegmentCount(ele, source, target, swap);\n  } else if (source.direction === 'Left' && target.direction === 'Left') {\n    seg = getLeftToLeftSegmentCount(ele, source, target);\n  } else if (source.direction === 'Left' && target.direction === 'Top') {\n    seg = getLeftToTopSegmentCount(ele, source, target, swap);\n  } else if (source.direction === 'Top' && target.direction === 'Top') {\n    seg = getTopToTopSegmentCount(ele, source, target);\n  }\n\n  if (swap) {\n    swapPoints(source, target);\n  }\n\n  intermeditatePoints = addOrthoSegments(ele, seg, source, target, extra, lineDistribution);\n  return intermeditatePoints;\n}\n/**\n * findAngle method \\\n *\n * @returns { number } findAngle method .\\\n * @param {DiagramElement} s - provide the s value.\n * @param {End} e - provide the e value.\n * @private\n */\n\n\nexport function findAngle(s, e) {\n  var r = {\n    x: e.x,\n    y: s.y\n  }; //const sr: number = Point.findLength(s, r);\n\n  var re = Point.findLength(r, e);\n  var es = Point.findLength(e, s);\n  var ang = Math.asin(re / es);\n  ang = ang * 180 / Math.PI;\n\n  if (s.x < e.x) {\n    if (s.y > e.y) {\n      ang = 360 - ang;\n    }\n  } else {\n    if (s.y < e.y) {\n      ang = 180 - ang;\n    } else {\n      ang = 180 + ang;\n    }\n  }\n\n  return ang;\n}\n/**\n * findPoint method \\\n *\n * @returns { number } findPoint method .\\\n * @param {Corners} cor - provide the cor value.\n * @param {string} direction - provide the direction value.\n * @private\n */\n\nexport function findPoint(cor, direction) {\n  var point;\n\n  switch (direction) {\n    case 'Left':\n      point = cor.middleLeft;\n      break;\n\n    case 'Top':\n      point = cor.topCenter;\n      break;\n\n    case 'Right':\n      point = cor.middleRight;\n      break;\n\n    case 'Bottom':\n      point = cor.bottomCenter;\n      break;\n  }\n\n  return point;\n}\n/**\n * pointsFromNodeToPoint method \\\n *\n * @returns { number } pointsFromNodeToPoint method .\\\n * @param {OrthogonalSegment} seg - provide the seg value.\n * @param {string} direction - provide the direction value.\n * @param {Rect} bounds - provide the bounds value.\n * @param {PointModel} point - provide the point value.\n * @param {PointModel} endPoint - provide the endPoint value.\n * @param {boolean} isTarget - provide the isTarget value.\n * @private\n */\n\nfunction pointsFromNodeToPoint(seg, direction, bounds, point, endPoint, isTarget) {\n  var minSpace = 13;\n  var x;\n  var points = [];\n  var y;\n  points.push(point); //let straight: boolean;\n\n  var straight = point.y === endPoint.y && (direction === 'Left' && endPoint.x < point.x || direction === 'Right' && endPoint.x > point.x) || point.x === endPoint.x && (direction === 'Top' && endPoint.y < point.y || direction === 'Bottom' && endPoint.y > point.y);\n\n  if (!straight) {\n    if (direction === 'Top' || direction === 'Bottom') {\n      if (direction === 'Top' && endPoint.y < point.y && endPoint.y > point.y - minSpace || direction === 'Bottom' && endPoint.y > point.y && endPoint.y < point.y + minSpace) {\n        y = direction === 'Top' ? bounds.top - minSpace : bounds.bottom + minSpace;\n        points.push({\n          x: point.x,\n          y: y\n        });\n        points.push({\n          x: point.x + (endPoint.x - point.x) / 2,\n          y: y\n        });\n        points.push({\n          x: point.x + (endPoint.x - point.x) / 2,\n          y: endPoint.y\n        });\n      } else if (Math.abs(point.x - endPoint.x) > minSpace && (direction === 'Top' && endPoint.y < point.y || direction === 'Bottom' && endPoint.y > point.y)) {\n        //twosegments\n        points.push({\n          x: point.x,\n          y: endPoint.y\n        });\n      } else {\n        y = direction === 'Top' ? bounds.top - minSpace : bounds.bottom + minSpace;\n        x = endPoint.x < point.x ? bounds.left - minSpace : bounds.right + minSpace;\n        points.push({\n          x: point.x,\n          y: y\n        });\n        points.push({\n          x: endPoint.x,\n          y: y\n        });\n      }\n    } else {\n      if (direction === 'Left' && endPoint.x < point.x && endPoint.x > point.x - minSpace || direction === 'right' && endPoint.x > point.x && endPoint.x < point.x + minSpace) {\n        x = direction === 'Left' ? bounds.left - minSpace : bounds.right + minSpace;\n        points.push({\n          x: x,\n          y: point.y\n        });\n        points.push({\n          x: x,\n          y: point.y + (endPoint.y - point.y) / 2\n        });\n        points.push({\n          x: endPoint.x,\n          y: point.y + (endPoint.y - point.y) / 2\n        });\n      } else if (Math.abs(point.y - endPoint.y) > minSpace && (direction === 'Left' && endPoint.x < point.x || direction === 'Right' && endPoint.x > point.x)) {\n        points.push({\n          x: endPoint.x,\n          y: point.y\n        }); //twosegments\n      } else {\n        x = direction === 'Left' ? bounds.left - minSpace : bounds.right + minSpace;\n        points.push({\n          x: x,\n          y: point.y\n        });\n        points.push({\n          x: x,\n          y: endPoint.y\n        });\n      }\n    }\n\n    if (isTarget) {\n      points.push(seg.points[0]);\n      points.reverse();\n    }\n\n    seg.points = points;\n  }\n}\n/**\n * addLineSegment method \\\n *\n * @returns { PointModel } addLineSegment method .\\\n * @param {PointModel} point - provide the seg value.\n * @param {number} extra - provide the direction value.\n * @param {number} angle - provide the bounds value.\n * @private\n */\n\n\nfunction addLineSegment(point, extra, angle) {\n  var segEnd = Point.transform(point, angle, extra);\n  return segEnd;\n}\n/**\n * getIntersection method \\\n *\n * @returns { PointModel } getIntersection method .\\\n * @param {PointModel} ele - provide the ele value.\n * @param {number} bounds - provide the bounds value.\n * @param {number} sPt - provide the sPt value.\n * @param {number} tPt - provide the tPt value.\n * @param {number} isTar - provide the isTar value.\n * @private\n */\n\n\nexport function getIntersection(ele, bounds, sPt, tPt, isTar) {\n  sPt = {\n    x: sPt.x,\n    y: sPt.y\n  };\n  tPt = {\n    x: tPt.x,\n    y: tPt.y\n  }; //const angle: number = Point.findAngle(tPt, sPt); ///let child: PathElement;// let intersection: PointModel;\n\n  var wrapper = isTar ? ele.targetWrapper : ele.sourceWrapper;\n  var padding = isTar ? ele.targetPadding : ele.sourcePadding;\n  var rect;\n  var segmentPoints;\n  var point = isTar || ele.type === 'Orthogonal' ? sPt : tPt; //const sourcePoint: PointModel = Point.transform(sPt, angle, Math.max(wrapper.actualSize.height / 2, wrapper.actualSize.width / 2));\n\n  var child = wrapper;\n  var sPt1 = rotatePoint(-wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, sPt);\n  var tPt1 = rotatePoint(-wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, tPt);\n\n  if (ele.type === 'Orthogonal') {\n    var constValue = 5;\n\n    if (sPt1.x === tPt1.x) {\n      if (sPt1.y < tPt1.y) {\n        sPt1.y -= constValue;\n      } else {\n        sPt1.y += constValue;\n      }\n    }\n\n    if (sPt1.y === tPt1.y) {\n      if (sPt1.x < tPt1.x) {\n        sPt1.x -= constValue;\n      } else {\n        sPt1.x += constValue;\n      }\n    }\n\n    sPt = rotatePoint(wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, sPt1);\n  } else {\n    //const angle: number = isTar ? Point.findAngle(sPt, tPt) : Point.findAngle(tPt, sPt);\n    if (isTar) {\n      var angle = Point.findAngle(sPt, tPt);\n      tPt = Point.transform({\n        x: tPt.x,\n        y: tPt.y\n      }, angle, Math.max(wrapper.actualSize.width, wrapper.actualSize.height));\n    } else {\n      var angle = Point.findAngle(tPt, sPt);\n      sPt = Point.transform({\n        x: sPt.x,\n        y: sPt.y\n      }, angle, Math.max(wrapper.actualSize.width, wrapper.actualSize.height));\n    }\n  }\n\n  if (ele.sourcePadding || ele.targetPadding) {\n    rect = new Rect(wrapper.bounds.x - padding, wrapper.bounds.y - padding, wrapper.actualSize.width + 2 * padding, wrapper.actualSize.height + 2 * padding);\n  }\n\n  if (wrapper instanceof PathElement && wrapper.data) {\n    segmentPoints = rect ? [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft] : child.getPoints();\n\n    if (child.data.split('m').length - 1 + (child.data.split('M').length - 1) === 1) {\n      segmentPoints[segmentPoints.length] = segmentPoints[0];\n    }\n  } else {\n    segmentPoints = rect ? [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft] : getPoints(wrapper, wrapper.corners);\n    segmentPoints[segmentPoints.length] = segmentPoints[0];\n  } //const length: number = segmentPoints.length;\n\n\n  var thisSegment = {\n    x1: sPt.x,\n    y1: sPt.y,\n    x2: tPt.x,\n    y2: tPt.y\n  };\n  return getIntersectionPoints(thisSegment, segmentPoints, true, point) || sPt;\n}\n/**\n * setLineEndPoint method \\\n *\n * @returns { PointModel } setLineEndPoint method .\\\n * @param {PointModel} element - provide the ele value.\n * @param {number} point - provide the bounds value.\n * @param {number} isTarget - provide the sPt value.\n * @private\n */\n\nfunction setLineEndPoint(element, point, isTarget) {\n  point.x = Math.round(point.x * 100) / 100;\n  point.y = Math.round(point.y * 100) / 100;\n\n  if (isTarget) {\n    element.targetPoint = point;\n  } else {\n    element.sourcePoint = point;\n  }\n\n  return point;\n}\n/**\n * getIntersectionPoints method \\\n *\n * @returns { PointModel } getIntersectionPoints method .\\\n * @param {Segment} thisSegment - provide the ele value.\n * @param {Object[]} pts - provide the bounds value.\n * @param {boolean} minimal - provide the sPt value.\n * @param {PointModel} point - provide the sPt value.\n * @private\n */\n\n\nexport function getIntersectionPoints(thisSegment, pts, minimal, point) {\n  var length = pts.length;\n  var min;\n  var segment = {\n    x1: pts[0].x,\n    y1: pts[0].y,\n    x2: pts[1].x,\n    y2: pts[1].y\n  };\n  var intersection = intersectSegment(thisSegment, segment);\n\n  if (intersection) {\n    // if (!minimal) { return intersection; } //commented because minimal is always true\n    min = Point.distancePoints(intersection, point);\n  }\n\n  if (isNaN(min) || min > 0) {\n    for (var i = 1; i < length - 1; i++) {\n      segment = {\n        x1: pts[i].x,\n        y1: pts[i].y,\n        x2: pts[i + 1].x,\n        y2: pts[i + 1].y\n      };\n      var intersect = intersectSegment(thisSegment, segment);\n\n      if (intersect) {\n        // if (!minimal) { return intersect; }//commented because minimal is always true\n        var dist = Point.distancePoints(intersect, point);\n\n        if (isNaN(min) || min > dist) {\n          min = dist;\n          intersection = intersect;\n        }\n\n        if (min >= 0 && min <= 1) {\n          break;\n        }\n      }\n    }\n  }\n\n  return intersection;\n}\n/**\n * intersectSegment method \\\n *\n * @returns { PointModel } intersectSegment method .\\\n * @param {Segment} segment1 - provide the ele value.\n * @param {Segment} segment2 - provide the bounds value.\n * @private\n */\n\nfunction intersectSegment(segment1, segment2) {\n  var x1 = segment1.x1;\n  var y1 = segment1.y1;\n  var x2 = segment1.x2;\n  var y2 = segment1.y2;\n  var x3 = segment2.x1;\n  var y3 = segment2.y1;\n  var x4 = segment2.x2;\n  var y4 = segment2.y2;\n  var a1;\n  var a2;\n  var b1;\n  var b2;\n  var c1;\n  var c2;\n  var x;\n  var y;\n  var r1;\n  var r2;\n  var r3;\n  var r4;\n  var offset;\n  var num; // eslint-disable-next-line\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // eslint-disable-next-line\n\n  r3 = a1 * x3 + b1 * y3 + c1;\n  r4 = a1 * x4 + b1 * y4 + c1;\n\n  if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {\n    return null;\n  } // eslint-disable-next-line\n\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // eslint-disable-next-line\n\n  r1 = a2 * x1 + b2 * y1 + c2;\n  r2 = a2 * x2 + b2 * y2 + c2;\n\n  if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {\n    return null;\n  }\n\n  var denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  if (denom < 0) {\n    offset = -denom / 2;\n  } else {\n    offset = denom / 2;\n  }\n\n  offset = 0;\n  num = b1 * c2 - b2 * c1;\n\n  if (num < 0) {\n    x = (num - offset) / denom;\n  } else {\n    x = (num + offset) / denom;\n  }\n\n  num = a2 * c1 - a1 * c2;\n\n  if (num < 0) {\n    y = (num - offset) / denom;\n  } else {\n    y = (num + offset) / denom;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\n * sameSign method \\\n *\n * @returns { boolean } sameSign method .\\\n * @param {Connector} a - provide the Connector value.\n * @param {End} b - provide the source End value.\n * @private\n */\n\n\nfunction sameSign(a, b) {\n  return a * b >= 0;\n}\n/**\n * getRightToLeftSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToLeftSegmentCount method .\\\n * @param {Connector} element - provide the Connector value.\n * @param {End} source - provide the source End value.\n * @param {End} target - provide the target  End value.\n * @param {boolean} swap - provide the swap value.\n * @private\n */\n\n\nfunction getRightToLeftSegmentCount(element, source, target, swap) {\n  var srcPort = element.sourcePortWrapper; //let targetPort: DiagramElement = element.targetPortWrapper;\n\n  var pts;\n  var diffY = Math.round(Math.abs(source.point.y - target.point.y)); //let diffX: number = Math.round(Math.abs(source.point.x - target.point.x));\n\n  var right = {\n    x: Math.max(source.point.x, source.corners.right),\n    y: source.point.y\n  };\n  var left = {\n    x: Math.min(target.point.x, target.corners.left),\n    y: target.point.y\n  };\n  var margin = 10;\n\n  if (swap) {\n    //let point: PointModel;\n    var point = left;\n    left = right;\n    right = point;\n  }\n\n  if (!(source.corners.bottom + margin < target.corners.top - margin || source.corners.top - margin > target.corners.bottom + margin)) {\n    margin = 0;\n  }\n\n  source.margin = {\n    left: margin,\n    right: margin,\n    top: margin,\n    bottom: margin\n  };\n  target.margin = {\n    left: margin,\n    right: margin,\n    top: margin,\n    bottom: margin\n  };\n\n  if (diffY === 0 && (source.corners.right < target.corners.left || swap && source.corners.right < target.corners.left)) {\n    pts = NoOfSegments.One;\n  } else if (source.point.x + source.margin.right < target.point.x - target.margin.left) {\n    pts = NoOfSegments.Three;\n  } else if (element.sourceWrapper !== element.targetWrapper && (cornersPointsBeforeRotation(element.sourceWrapper).containsPoint(left) || cornersPointsBeforeRotation(element.targetWrapper).containsPoint(right))) {\n    pts = NoOfSegments.Three;\n  } else if (source.corners.bottom <= target.corners.top) {\n    pts = NoOfSegments.Five;\n  } else if (source.corners.top >= target.corners.top) {\n    pts = NoOfSegments.Five;\n  } else if (srcPort !== undefined && srcPort.offsetY <= target.corners.top || srcPort === undefined && source.corners.right <= target.corners.top) {\n    pts = NoOfSegments.Five;\n  } else if (srcPort !== undefined && srcPort.offsetY >= target.corners.bottom || srcPort === undefined && source.corners.right >= target.corners.bottom) {\n    pts = NoOfSegments.Five;\n  } else {\n    pts = NoOfSegments.Five;\n  }\n\n  return pts;\n}\n/**\n * getRightToRightSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToRightSegmentCount method .\\\n * @param {Connector} element - provide the Connector value.\n * @param {End} sourceObj - provide the source End value.\n * @param {End} targetObj - provide the target  End value.\n * @private\n */\n\n\nfunction getRightToRightSegmentCount(element, sourceObj, targetObj) {\n  var sourcePort = element.sourcePortWrapper;\n  var tarPort = element.targetPortWrapper;\n  var pts;\n  var diffX = sourceObj.point.x - targetObj.point.x;\n  var diffY = sourceObj.point.y - targetObj.point.y;\n  targetObj.margin = {\n    left: 10,\n    right: 10,\n    top: 10,\n    bottom: 10\n  };\n  sourceObj.margin = {\n    left: 10,\n    right: 10,\n    top: 10,\n    bottom: 10\n  };\n\n  if (sourceObj.corners.right >= targetObj.corners.right) {\n    if (sourcePort !== undefined && (sourcePort.offsetY < targetObj.corners.top || sourcePort.offsetY > targetObj.corners.bottom) || sourcePort === undefined && sourceObj.corners.middleRight.y < targetObj.corners.top) {\n      pts = NoOfSegments.Three;\n    } else if (sourcePort !== undefined && sourcePort.offsetY > targetObj.corners.bottom + targetObj.margin.bottom && sourceObj.corners.top > targetObj.corners.bottom || sourcePort === undefined && sourceObj.corners.middleRight.y > targetObj.corners.bottom) {\n      pts = NoOfSegments.Three;\n    } else if (sourcePort !== undefined && sourcePort.offsetY < targetObj.corners.top && sourceObj.corners.bottom > targetObj.corners.top || sourcePort === undefined && sourceObj.corners.middleRight.y > targetObj.corners.bottom) {\n      pts = NoOfSegments.Three;\n    } else if (sourceObj.corners.right < targetObj.corners.left || targetObj.corners.right < sourceObj.corners.left) {\n      pts = NoOfSegments.Five;\n    } else if (diffX === 0 || diffY === 0) {\n      pts = NoOfSegments.One;\n    } else {\n      pts = NoOfSegments.Three;\n    }\n  } else if (tarPort !== undefined && sourceObj.corners.bottom < tarPort.offsetY || tarPort === undefined && sourceObj.corners.bottom < targetObj.corners.middleRight.y) {\n    pts = NoOfSegments.Three;\n  } else if (tarPort !== undefined && sourceObj.corners.top > tarPort.offsetY || tarPort === undefined && sourceObj.corners.top > targetObj.corners.middleRight.y) {\n    pts = NoOfSegments.Three;\n  } else if (tarPort !== undefined && (sourcePort !== undefined && sourcePort.offsetX < targetObj.corners.left && sourcePort.offsetX !== tarPort.offsetX && sourcePort.offsetY !== tarPort.offsetY && Math.abs(sourceObj.corners.right - targetObj.corners.left) <= 20 || sourcePort === undefined && sourceObj.corners.right < targetObj.corners.left && sourceObj.corners.center.x !== targetObj.corners.center.x && sourceObj.corners.center.y !== targetObj.corners.center.y)) {\n    pts = NoOfSegments.Three;\n  } else if (sourceObj.corners.right < targetObj.corners.left) {\n    pts = NoOfSegments.Five;\n  } else if (diffX === 0 || diffY === 0) {\n    pts = NoOfSegments.One;\n  } else {\n    pts = NoOfSegments.Three;\n  }\n\n  return pts;\n}\n/**\n * getRightToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToTopSegmentCount method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap value.\n * @private\n */\n\n\nfunction getRightToTopSegmentCount(element, source, target, swap) {\n  var tarPort = element.targetPortWrapper;\n  var srcPort = element.sourcePortWrapper;\n  var right = {\n    x: Math.max(source.point.x, source.corners.right),\n    y: source.point.y\n  };\n  var top = {\n    x: target.point.x,\n    y: Math.min(target.point.y, target.corners.top)\n  };\n  var pts;\n  target.margin = {\n    left: 5,\n    right: 5,\n    top: 5,\n    bottom: 5\n  };\n  source.margin = {\n    top: 5,\n    bottom: 5,\n    left: 5,\n    right: 5\n  };\n\n  if (swap) {\n    //let port: DiagramElement;\n    var port = srcPort;\n    srcPort = tarPort;\n    tarPort = port;\n  }\n\n  if (srcPort !== undefined && srcPort.offsetY < target.corners.top - target.margin.top || srcPort === undefined && source.corners.bottom < target.corners.top - target.margin.top) {\n    if (source.corners.bottom < target.corners.top) {\n      if (tarPort !== undefined && source.corners.right + source.margin.right < tarPort.offsetX || tarPort === undefined && source.corners.right + source.margin.right < target.corners.topCenter.x) {\n        pts = NoOfSegments.Two;\n      } else {\n        pts = NoOfSegments.Four;\n      }\n    } else if (tarPort !== undefined && source.corners.left > tarPort.offsetX || tarPort === undefined && source.corners.left > target.corners.topCenter.x) {\n      pts = NoOfSegments.Four;\n    } else {\n      pts = NoOfSegments.Two;\n    }\n  } else if (srcPort !== undefined && Math.abs(source.corners.right - target.corners.left) <= 25 && Math.abs(srcPort.offsetY - target.corners.top) <= 25) {\n    pts = NoOfSegments.Two;\n  } else if (tarPort !== undefined && Math.abs(tarPort.offsetX - source.corners.topCenter.x) >= 25 && source.corners.middleRight.y < tarPort.offsetY) {\n    pts = NoOfSegments.Two;\n  } else if (source.corners.right < target.corners.left) {\n    pts = NoOfSegments.Four;\n  } else if (element.sourceWrapper !== element.targetWrapper && (cornersPointsBeforeRotation(element.sourceWrapper).containsPoint(top) || cornersPointsBeforeRotation(element.targetWrapper).containsPoint(right))) {\n    pts = NoOfSegments.Two;\n  } else {\n    pts = NoOfSegments.Four;\n  }\n\n  return pts;\n}\n/**\n * getRightToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToTopSegmentCount method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap value.\n * @private\n */\n\n\nfunction getRightToBottomSegmentCount(element, source, target, swap) {\n  source.margin = {\n    left: 10,\n    right: 10,\n    top: 10,\n    bottom: 10\n  };\n  target.margin = {\n    left: 10,\n    right: 10,\n    top: 10,\n    bottom: 10\n  };\n  var pts;\n  var srcPort = element.sourcePortWrapper;\n  var tarPort = element.targetPortWrapper; //let right: PointModel = { x: Math.max(source.point.x, source.corners.right), y: source.point.y };\n  //let bottom: PointModel = { x: target.point.x, y: Math.max(target.point.y, target.corners.bottom) };\n\n  if (swap) {\n    //let port: DiagramElement;\n    var port = srcPort;\n    srcPort = tarPort;\n    tarPort = port;\n  }\n\n  if (srcPort !== undefined && srcPort.offsetY > target.corners.bottom + target.margin.bottom || srcPort === undefined && source.corners.middleRight.y > target.corners.bottom + target.margin.bottom) {\n    if (source.corners.top > target.corners.bottom) {\n      if (tarPort !== undefined && source.corners.right + source.margin.right < tarPort.offsetX || tarPort === undefined && source.corners.right + source.margin.right < target.corners.bottomCenter.x) {\n        pts = NoOfSegments.Two;\n      } else {\n        pts = NoOfSegments.Four;\n      }\n    } else if (tarPort !== undefined && source.corners.left > tarPort.offsetX || tarPort === undefined && source.corners.left > target.corners.bottomCenter.x) {\n      pts = NoOfSegments.Four;\n    } else {\n      pts = NoOfSegments.Two;\n    }\n  } else if (srcPort !== undefined && Math.abs(source.corners.right - target.corners.left) <= 25 && Math.abs(srcPort.offsetY - target.corners.bottom) <= 25) {\n    pts = NoOfSegments.Two;\n  } else if (source.corners.right < target.corners.left) {\n    pts = NoOfSegments.Four;\n  } else {\n    pts = NoOfSegments.Four;\n  }\n\n  return pts;\n}\n/**\n * getBottomToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getBottomToTopSegmentCount method .\\\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target  value.\n * @private\n */\n\n\nfunction getBottomToTopSegmentCount(source, target) {\n  var pts;\n  var diffX = source.point.x - target.point.x; //const diffY: number = source.point.y - target.point.y;\n  //let bottom: PointModel = { x: source.point.x, y: Math.max(source.point.y, source.corners.bottom) };\n  //let top: PointModel = { x: target.point.x, y: Math.min(target.point.y, target.corners.top) };\n\n  var margin = 10;\n\n  if (!(source.corners.right + margin < target.corners.left - margin || source.corners.left - margin > target.corners.right + margin)) {\n    margin = 0;\n  }\n\n  source.margin = {\n    left: margin,\n    right: margin,\n    top: margin,\n    bottom: margin\n  };\n  target.margin = {\n    left: margin,\n    right: margin,\n    top: margin,\n    bottom: margin\n  };\n\n  if (diffX === 0 && source.corners.bottom < target.corners.top) {\n    pts = NoOfSegments.One;\n  } else if (source.corners.bottom + source.margin.bottom < target.corners.top - target.margin.top) {\n    pts = NoOfSegments.Three;\n  } else if (source.corners.right + source.margin.right < target.corners.left - target.margin.left) {\n    pts = NoOfSegments.Five;\n  } else if (source.corners.left - source.margin.left > target.corners.right + target.margin.right) {\n    pts = NoOfSegments.Five;\n  } else {\n    pts = NoOfSegments.Five;\n  }\n\n  return pts;\n}\n/**\n * getBottomToLeftSegmentCount method \\\n *\n * @returns { NoOfSegments } getBottomToLeftSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap  value.\n * @private\n */\n\n\nfunction getBottomToLeftSegmentCount(element, source, target, swap) {\n  var srcPort = element.sourcePortWrapper;\n  var tarPort = element.targetPortWrapper; //let bottom: PointModel = { x: source.point.x, y: Math.max(source.point.y, source.corners.bottom) };\n  //let left: PointModel = { x: Math.min(target.point.x, target.corners.left), y: target.point.y };\n\n  var pts;\n\n  if (swap) {\n    //let port: DiagramElement;\n    var port = srcPort;\n    srcPort = tarPort;\n    tarPort = port;\n  }\n\n  if (srcPort !== undefined && srcPort.offsetX < target.corners.left - target.margin.left || srcPort === undefined && source.corners.bottomCenter.x < target.corners.bottomLeft.x - target.margin.left) {\n    if (source.corners.right < target.corners.left) {\n      if (tarPort !== undefined && source.corners.bottom + source.margin.bottom < tarPort.offsetY || tarPort === undefined && source.corners.bottom + source.margin.bottom < target.corners.middleLeft.y) {\n        pts = NoOfSegments.Two;\n      } else {\n        pts = NoOfSegments.Four;\n      }\n    } else if (tarPort !== undefined && source.corners.top > tarPort.offsetY || tarPort === undefined && source.corners.top > target.corners.middleLeft.y) {\n      pts = NoOfSegments.Four;\n    } else {\n      pts = NoOfSegments.Two;\n    }\n  } else if (tarPort !== undefined && Math.abs(source.corners.right - target.corners.left) <= 25 && Math.abs(tarPort.offsetY - source.corners.bottom) <= 25) {\n    pts = NoOfSegments.Two;\n  } else {\n    pts = NoOfSegments.Four;\n  }\n\n  return pts;\n}\n/**\n * getBottomToBottomSegmentCount method \\\n *\n * @returns { NoOfSegments } getBottomToBottomSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\n\n\nfunction getBottomToBottomSegmentCount(element, source, target) {\n  var srcPort = element.sourcePortWrapper;\n  var tarPort = element.targetPortWrapper;\n  var difX = Math.round(Math.abs(source.point.x - target.point.x));\n  var diffY = Math.round(Math.abs(target.point.y - target.point.y));\n  var pts;\n\n  if (source.corners.bottom < target.corners.bottom) {\n    if (srcPort !== undefined && srcPort.offsetX < target.corners.left - target.margin.left || srcPort === undefined && source.corners.bottomCenter.x < target.corners.left - target.margin.left) {\n      pts = NoOfSegments.Three;\n    } else if (srcPort !== undefined && srcPort.offsetX > target.corners.right + target.margin.right || srcPort === undefined && source.corners.bottomCenter.x > target.corners.right + target.margin.right) {\n      pts = NoOfSegments.Three;\n    } else if (source.corners.bottom < target.corners.top) {\n      pts = NoOfSegments.Five;\n    } else if (difX === 0 || diffY === 0) {\n      pts = NoOfSegments.One;\n    } else {\n      pts = NoOfSegments.Three;\n    }\n  } else if (tarPort !== undefined && source.corners.left > tarPort.offsetX || tarPort === undefined && source.corners.left > target.corners.left) {\n    pts = NoOfSegments.Three;\n  } else if (tarPort !== undefined && source.corners.right < tarPort.offsetX || tarPort === undefined && source.corners.right < target.corners.right) {\n    pts = NoOfSegments.Three;\n  } else if (source.corners.top > target.corners.bottom) {\n    pts = NoOfSegments.Five;\n  } else if (difX === 0 || diffY === 0) {\n    pts = NoOfSegments.One;\n  } else {\n    pts = NoOfSegments.Three;\n  }\n\n  return pts;\n}\n/**\n * getLeftToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getLeftToTopSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap  value.\n * @private\n */\n\n\nfunction getLeftToTopSegmentCount(element, source, target, swap) {\n  var pts;\n  var sourcePort = element.sourcePortWrapper;\n  var tarPort = element.targetPortWrapper;\n  var left = {\n    x: Math.min(source.point.x, source.corners.left),\n    y: source.point.y\n  };\n  var top = {\n    x: target.point.x,\n    y: Math.min(target.point.y, target.corners.top)\n  };\n\n  if (swap) {\n    //let port: DiagramElement;\n    var port = sourcePort;\n    sourcePort = tarPort;\n    tarPort = port;\n  }\n\n  if (sourcePort !== undefined && sourcePort.offsetY < target.corners.top - target.margin.top || sourcePort === undefined && (source.corners.bottom < target.corners.top - target.margin.top || source.corners.middleLeft.y < target.corners.top - target.margin.top)) {\n    if (source.corners.bottom < target.corners.top) {\n      if (tarPort !== undefined && source.corners.left - source.margin.left > tarPort.offsetX || tarPort === undefined && source.corners.left - source.margin.left > target.corners.topCenter.x) {\n        pts = NoOfSegments.Two;\n      } else {\n        pts = NoOfSegments.Four;\n      }\n    } else if (tarPort !== undefined && source.corners.right < tarPort.offsetX || tarPort === undefined && source.corners.right < target.corners.topCenter.x) {\n      pts = NoOfSegments.Four;\n    } else {\n      pts = NoOfSegments.Two;\n    }\n  } else if (sourcePort !== undefined && Math.abs(source.corners.left - target.corners.right) <= 25 && Math.abs(sourcePort.offsetY - target.corners.top) <= 25) {\n    pts = NoOfSegments.Two;\n  } else if (element.sourceWrapper !== element.targetWrapper && (cornersPointsBeforeRotation(element.sourceWrapper).containsPoint(top) || cornersPointsBeforeRotation(element.targetWrapper).containsPoint(left))) {\n    pts = NoOfSegments.Two;\n  } else if (source.corners.left > target.corners.right) {\n    pts = NoOfSegments.Four;\n  } else {\n    pts = NoOfSegments.Four;\n  }\n\n  return pts;\n}\n/**\n * getLeftToLeftSegmentCount method \\\n *\n * @returns { NoOfSegments } getLeftToLeftSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\n\n\nfunction getLeftToLeftSegmentCount(element, source, target) {\n  var srcPort = element.sourcePortWrapper;\n  var targetPort = element.targetPortWrapper;\n  source.margin = {\n    left: 10,\n    right: 10,\n    top: 10,\n    bottom: 10\n  };\n  target.margin = {\n    left: 10,\n    right: 10,\n    top: 10,\n    bottom: 10\n  };\n  var diffX = Math.round(Math.abs(source.point.x - target.point.x));\n  var diffY = Math.round(Math.abs(source.point.y - target.point.y));\n  var pts;\n\n  if (source.corners.left < target.corners.left) {\n    if (targetPort !== undefined && source.corners.bottom + source.margin.bottom < targetPort.offsetY || targetPort === undefined && source.corners.bottom + source.margin.bottom < target.corners.middleLeft.y) {\n      pts = NoOfSegments.Three;\n    } else if (targetPort !== undefined && source.corners.top - source.margin.top > targetPort.offsetY || targetPort === undefined && source.corners.top - source.margin.top > target.corners.middleLeft.y) {\n      pts = NoOfSegments.Three;\n    } else if (source.corners.right < target.corners.left || target.corners.right < source.corners.left) {\n      pts = NoOfSegments.Five;\n    } else if (diffX === 0 || diffY === 0) {\n      pts = NoOfSegments.One;\n    } else {\n      pts = NoOfSegments.Three;\n    }\n  } else if (srcPort !== undefined && srcPort.offsetY < target.corners.top - target.margin.top || srcPort === undefined && source.corners.middleLeft.y < target.corners.top) {\n    pts = NoOfSegments.Three;\n  } else if (srcPort !== undefined && srcPort.offsetY > target.corners.bottom + target.margin.bottom || srcPort === undefined && source.corners.middleLeft.y > target.corners.bottom + target.margin.bottom) {\n    pts = NoOfSegments.Three;\n  } else if (source.corners.left > target.corners.right) {\n    pts = NoOfSegments.Five;\n  } else if (diffX === 0 || diffY === 0) {\n    pts = NoOfSegments.One;\n  } else {\n    pts = NoOfSegments.Three;\n  }\n\n  return pts;\n}\n/**\n * getTopToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getTopToTopSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\n\n\nfunction getTopToTopSegmentCount(element, source, target) {\n  var srcPort = element.sourcePortWrapper;\n  var targetPort = element.targetPortWrapper;\n  var diffX = Math.round(Math.abs(source.point.x - target.point.x));\n  var diffY = Math.round(Math.abs(source.point.y - target.point.y));\n  source.margin = {\n    left: 10,\n    right: 10,\n    top: 10,\n    bottom: 10\n  };\n  var pts;\n  target.margin = {\n    left: 10,\n    right: 10,\n    top: 10,\n    bottom: 10\n  };\n\n  if (source.corners.top < target.corners.top) {\n    if (targetPort !== undefined && source.corners.left > targetPort.offsetX || targetPort === undefined && source.corners.left > target.corners.left) {\n      pts = NoOfSegments.Three;\n    } else if (targetPort !== undefined && source.corners.right < targetPort.offsetX || targetPort === undefined && source.corners.right < target.corners.right) {\n      pts = NoOfSegments.Three;\n    } else if (source.corners.bottom < target.corners.top) {\n      pts = NoOfSegments.Five;\n    } else if (diffX === 0 || diffY === 0) {\n      pts = NoOfSegments.One;\n    } else {\n      pts = NoOfSegments.Three;\n    }\n  } else if (srcPort !== undefined && srcPort.offsetX > target.corners.right || srcPort === undefined && source.corners.left > target.corners.right) {\n    pts = NoOfSegments.Three;\n  } else if (srcPort !== undefined && srcPort.offsetX < target.corners.left || srcPort === undefined && source.corners.bottomRight.x < target.corners.left) {\n    pts = NoOfSegments.Three;\n  } else if (source.corners.top > target.corners.bottom) {\n    pts = NoOfSegments.Five;\n  } else if (diffX === 0 || diffY === 0) {\n    pts = NoOfSegments.One;\n  } else {\n    pts = NoOfSegments.Three;\n  }\n\n  return pts;\n}\n/**\n * addOrthoSegments method \\\n *\n * @returns {  PointModel[] } addOrthoSegments method .\\\n * @param {Connector} element - provide the element value.\n * @param {NoOfSegments} seg - provide the seg  value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {number} segLength - provide the segLength  value.\n * @param {boolean} lineDistribution - provide the lineDistribution  value.\n * @private\n */\n\n\nfunction addOrthoSegments(element, seg, source, target, segLength, lineDistribution) {\n  var src = element.sourceWrapper;\n  var tar = element.targetWrapper; //let tarPort: DiagramElement = element.targetPortWrapper;\n\n  var intermeditatePoints;\n  var srcCorner = src.corners;\n  var tarCorner = tar.corners;\n  var value;\n  var extra = 20;\n\n  if (source.direction !== target.direction || seg === NoOfSegments.Five) {\n    if (source.direction === getOppositeDirection(target.direction) || seg === NoOfSegments.Three) {\n      switch (source.direction) {\n        case 'Left':\n          if (srcCorner.middleLeft.x > tarCorner.middleRight.x) {\n            value = (srcCorner.middleLeft.x - tarCorner.middleRight.x) / 2;\n            extra = !lineDistribution ? Math.min(extra, value) : value;\n          }\n\n          break;\n\n        case 'Right':\n          if (srcCorner.middleRight.x < tarCorner.middleLeft.x) {\n            value = (tarCorner.middleLeft.x - srcCorner.middleRight.x) / 2;\n            extra = !lineDistribution ? Math.min(extra, value) : value;\n          }\n\n          break;\n\n        case 'Top':\n          if (srcCorner.topCenter.y > tarCorner.bottomCenter.y) {\n            value = (srcCorner.topCenter.y - tarCorner.bottomCenter.y) / 2;\n            extra = !lineDistribution ? Math.min(extra, value) : value;\n          }\n\n          break;\n\n        case 'Bottom':\n          if (srcCorner.bottomCenter.y < tarCorner.topCenter.y) {\n            value = (tarCorner.topCenter.y - srcCorner.bottomCenter.y) / 2;\n            extra = !lineDistribution ? Math.min(extra, value) : value;\n          }\n\n          break;\n      }\n    }\n  }\n\n  extra = adjustSegmentLength(srcCorner, source, extra);\n\n  if (segLength) {\n    extra = Math.max(extra, segLength);\n  }\n\n  if (seg === NoOfSegments.One) {\n    intermeditatePoints = [source.point, target.point];\n  }\n\n  if (seg === NoOfSegments.Two) {\n    intermeditatePoints = orthoConnection2Segment(source, target);\n  }\n\n  if (seg === NoOfSegments.Three) {\n    intermeditatePoints = orthoConnection3Segment(element, source, target, extra);\n  }\n\n  if (seg === NoOfSegments.Four) {\n    var prevDir = undefined;\n    intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints, extra);\n  }\n\n  if (seg === NoOfSegments.Five) {\n    intermeditatePoints = orthoConnection5Segment(source, target, extra);\n  }\n\n  return intermeditatePoints;\n}\n/**\n * adjustSegmentLength method \\\n *\n * @returns {  PointModel[] } adjustSegmentLength method .\\\n * @param {Rect | Corners} bounds - provide the element value.\n * @param {End} source - provide the seg  value.\n * @param {number} extra - provide the source  value.\n * @private\n */\n\n\nfunction adjustSegmentLength(bounds, source, extra) {\n  switch (source.direction) {\n    case 'Left':\n      if (source.point.x > bounds.left) {\n        extra = source.point.x - bounds.left > extra ? source.point.x - bounds.left + extra : extra;\n      }\n\n      break;\n\n    case 'Right':\n      if (source.point.x < bounds.right) {\n        extra = bounds.right - source.point.x > extra ? bounds.right - source.point.x + extra : extra;\n      }\n\n      break;\n\n    case 'Top':\n      if (source.point.y > bounds.top) {\n        extra = source.point.y - bounds.top > extra ? source.point.y - bounds.top + extra : extra;\n      }\n\n      break;\n\n    case 'Bottom':\n      if (source.point.y < bounds.bottom) {\n        extra = bounds.bottom - source.point.y > extra ? bounds.bottom - source.point.y + extra : extra;\n      }\n\n      break;\n  }\n\n  return extra;\n}\n/**\n * orthoConnection2Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection2Segment method .\\\n * @param {Rect | Corners} source - provide the source value.\n * @param {End} target - provide the target  value.\n * @private\n */\n\n\nexport function orthoConnection2Segment(source, target) {\n  var intermeditatePoints;\n\n  switch (source.direction) {\n    case 'Left':\n    case 'Right':\n      // eslint-disable-next-line\n      var point1 = {\n        x: target.point.x,\n        y: source.point.y\n      };\n      intermeditatePoints = Point.equals(source.point, point1) || Point.equals(target.point, point1) ? [source.point, target.point] : [source.point, point1, target.point];\n      break;\n\n    case 'Top':\n    case 'Bottom':\n      // eslint-disable-next-line no-case-declarations\n      var point2 = {\n        x: source.point.x,\n        y: target.point.y\n      };\n      intermeditatePoints = Point.equals(source.point, point2) || Point.equals(target.point, point2) ? [source.point, target.point] : [source.point, point2, target.point];\n      break;\n  }\n\n  return intermeditatePoints;\n}\n/**\n * orthoConnection3Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection2Segment method .\\\n * @param {Connector} element - provide the source value.\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {number} extra - provide the target  value.\n * @param {boolean} allow - provide the target  value.\n * @private\n */\n\nfunction orthoConnection3Segment(element, source, target, extra, allow) {\n  if (!extra) {\n    extra = 20;\n  }\n\n  var srcPort = element.sourcePortWrapper;\n  var intermeditatePoints;\n  var segmentValue;\n  var next;\n  var diffx = target.point.x - source.point.x;\n  var diffy = target.point.y - source.point.y;\n  var temp;\n\n  if (!allow && (Math.abs(diffx) < 0.001 || Math.abs(diffy) < 0.001)) {\n    if (target.direction === undefined) {\n      intermeditatePoints = [source.point, target.point];\n      return intermeditatePoints;\n    }\n  }\n\n  if (element.targetWrapper === undefined && Math.abs(diffx) <= 31 && Math.abs(diffy) <= 31) {\n    if (source.direction === 'Left' || source.direction === 'Right') {\n      if (Math.abs(diffy) < 12) {\n        source.direction = source.point.y > target.point.y ? 'Top' : 'Bottom';\n      }\n    } else {\n      if (Math.abs(diffx) < 12) {\n        source.direction = source.point.x > target.point.x ? 'Left' : 'Right';\n      }\n    }\n\n    if (Math.abs(diffx) > 12 || Math.abs(diffy) > 12) {\n      return orthoConnection2Segment(source, target);\n    } else {\n      extra += 5;\n    }\n  }\n\n  if (source.direction === 'Left' || source.direction === 'Right') {\n    if (source.direction === 'Right') {\n      if (target.direction !== undefined && target.direction === 'Right') {\n        extra = Math.max(source.point.x, target.point.x) - source.point.x + extra;\n      }\n\n      if (source.point.x > target.point.x && srcPort === undefined) {\n        extra = -extra;\n      }\n    } else {\n      if (target.direction !== undefined && target.direction === 'Left') {\n        extra = source.point.x - Math.min(source.point.x, target.point.x) + extra;\n      }\n\n      if (source.point.x > target.point.x || srcPort !== undefined || source.direction === 'Left') {\n        extra = -extra;\n      }\n    }\n\n    temp = target.point.y - source.point.y;\n    segmentValue = addLineSegment(source.point, extra, 0);\n    temp = target.point.y - segmentValue.y;\n\n    if (temp !== 0) {\n      next = addLineSegment(segmentValue, target.point.y - segmentValue.y, 90);\n    }\n  } else if (source.direction === 'Top' || source.direction === 'Bottom') {\n    if (source.direction === 'Bottom') {\n      if (target.direction !== undefined && target.direction === 'Bottom') {\n        extra = Math.max(source.point.y, target.point.y) - source.point.y + extra;\n      }\n    } else {\n      if (target.direction !== undefined && target.direction === 'Top') {\n        extra = source.point.y - Math.min(source.point.y, target.point.y) + extra;\n      }\n\n      if (source.point.y > target.point.y || srcPort !== undefined || source.direction === 'Top') {\n        extra = -extra;\n      }\n    }\n\n    temp = target.point.x - source.point.x;\n\n    if (source.direction === 'Top') {\n      segmentValue = addLineSegment(source.point, extra, 90);\n    } else {\n      segmentValue = addLineSegment(source.point, extra, 90);\n    }\n\n    temp = target.point.x - segmentValue.x;\n\n    if (temp !== 0) {\n      next = addLineSegment(segmentValue, target.point.x - segmentValue.x, 0);\n    }\n  }\n\n  if (temp === 0) {\n    return intermeditatePoints = [source.point, target.point];\n  }\n\n  intermeditatePoints = [source.point, segmentValue, next, target.point];\n  return intermeditatePoints;\n}\n/**\n * orthoConnection5Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection5Segment method .\\\n * @param {Connector} source - provide the source value.\n * @param {End} target - provide the target  value.\n * @param {End} extra - provide the extra  value.\n * @private\n */\n\n\nfunction orthoConnection5Segment(source, target, extra) {\n  if (extra === void 0) {\n    extra = 20;\n  }\n\n  var intermeditatePoints;\n  var length = extra;\n  var sLeft = source.corners.left - source.margin.left;\n  var sRight = source.corners.right + source.margin.right;\n  var sBottom = source.corners.bottom + source.margin.bottom;\n  var sTop = source.corners.top - source.margin.top;\n  var tLeft = target.corners.left - target.margin.left;\n  var tRight = target.corners.right + target.margin.right;\n  var tBottom = target.corners.bottom + target.margin.bottom;\n  var tTop = target.corners.top - target.margin.top;\n  var segmentValue;\n\n  switch (source.direction) {\n    case 'Left':\n      if ((sTop > tTop && sTop < tBottom || sBottom < tBottom && sBottom > tTop) && sLeft > tLeft && sLeft <= tRight && extra >= 20) {\n        length = source.point.x - target.corners.left + length;\n      }\n\n      segmentValue = addLineSegment(source.point, length, 180);\n      break;\n\n    case 'Top':\n      if ((sLeft > tLeft && sLeft < tRight || sRight < tRight && sRight > tLeft) && sTop > tTop && sTop <= tBottom && extra >= 20) {\n        length = source.point.y - target.corners.top + length;\n      }\n\n      segmentValue = addLineSegment(source.point, length, 270);\n      break;\n\n    case 'Right':\n      if ((sTop > tTop && sTop < tBottom || sBottom < tBottom && sBottom > tTop) && sRight < tRight && sRight >= tLeft && extra >= 20) {\n        length = target.corners.right - source.point.x + length;\n      }\n\n      segmentValue = addLineSegment(source.point, length, 0);\n      break;\n\n    case 'Bottom':\n      if ((sLeft > tLeft && sLeft < tRight || sRight < tRight && sRight > tLeft) && sBottom < tBottom && sBottom >= tTop && extra >= 20) {\n        length = target.corners.bottom - source.point.y + length;\n      }\n\n      segmentValue = addLineSegment(source.point, length, 90);\n      break;\n  }\n\n  intermeditatePoints = [source.point, segmentValue];\n\n  if (source.direction === 'Top' || source.direction === 'Bottom') {\n    var prevDir = source.direction;\n    source.direction = segmentValue.x > target.point.x ? 'Left' : 'Right';\n    source.point = segmentValue;\n    intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints);\n  } else {\n    var prevDir = source.direction;\n    source.direction = segmentValue.y > target.point.y ? 'Top' : 'Bottom';\n    source.point = segmentValue;\n    intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints);\n  }\n\n  return intermeditatePoints;\n}\n/**\n * orthoConnection4Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection4Segment method .\\\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {string} prevDir - provide the target  value.\n * @param {PointModel[]} interPt - provide the target  value.\n * @param {number} e - provide the target  value.\n * @private\n */\n\n\nfunction orthoConnection4Segment(source, target, prevDir, interPt, e) {\n  if (e === void 0) {\n    e = 20;\n  }\n\n  var segmentValue;\n\n  if (prevDir === undefined) {\n    source.margin = {\n      left: 2,\n      right: 2,\n      top: 2,\n      bottom: 2\n    };\n    target.margin = {\n      left: 0,\n      right: 5,\n      top: 0,\n      bottom: 5\n    };\n  } else {\n    if (source.direction === 'Bottom') {\n      if (target.corners.top > source.corners.bottom && target.corners.top - source.corners.bottom < 20) {\n        e = (target.corners.top - source.corners.bottom) / 2;\n      }\n    } else if (source.direction === 'Top') {\n      if (target.corners.bottom < source.corners.top && source.corners.top - target.corners.bottom < 20) {\n        e = (source.corners.top - target.corners.bottom) / 2;\n      }\n    } else if (source.direction === 'Right') {\n      if (target.corners.left > source.corners.right && target.corners.left - source.corners.right < 20) {\n        e = (target.corners.left - source.corners.right) / 2;\n      }\n    } else if (source.direction === 'Left') {\n      if (target.corners.right < source.corners.left && source.corners.left - target.corners.right < 20) {\n        e = (source.corners.left - target.corners.right) / 2;\n      }\n    }\n  }\n\n  switch (source.direction) {\n    case 'Left':\n      e = getLeftLength(source, target, prevDir, e);\n      segmentValue = addLineSegment(source.point, e, 180);\n      break;\n\n    case 'Right':\n      e = getRightLength(source, target, e, prevDir);\n      segmentValue = addLineSegment(source.point, e, 0);\n      break;\n\n    case 'Top':\n      e = getTopLength(source, target, prevDir, e);\n      segmentValue = addLineSegment(source.point, e, 270);\n      break;\n\n    case 'Bottom':\n      e = getBottomLength(source, target, e, prevDir);\n      segmentValue = addLineSegment(source.point, e, 90);\n  }\n\n  if (interPt !== undefined) {\n    interPt.push(segmentValue);\n  } else {\n    interPt = [source.point, segmentValue];\n  }\n\n  if (source.direction === 'Top' || source.direction === 'Bottom') {\n    getOrtho3Seg(segmentValue, 'horizontal', source, target, interPt);\n  } else if (source.direction === 'Right' || source.direction === 'Left') {\n    getOrtho3Seg(segmentValue, 'vertical', source, target, interPt);\n  }\n\n  return interPt;\n}\n/**\n * getOrtho3Seg method \\\n *\n * @returns {  void } getOrtho3Seg method .\\\n * @param {PointModel} sPt - provide the sPt  value.\n * @param {string} orientation - provide the orientation  value.\n * @param {End} src - provide the src  value.\n * @param {End} tar - provide the tar  value.\n * @param {PointModel[]} points - provide the points  value.\n * @private\n */\n\n\nfunction getOrtho3Seg(sPt, orientation, src, tar, points) {\n  var point1;\n  var point2;\n  var point3;\n\n  if (orientation === 'horizontal') {\n    src.margin = {\n      left: 0,\n      right: 10,\n      top: 0,\n      bottom: 10\n    };\n    tar.margin = {\n      left: 0,\n      right: 10,\n      top: 0,\n      bottom: 10\n    };\n  } else if (orientation === 'vertical') {\n    src.margin = {\n      left: 10,\n      right: 0,\n      top: 10,\n      bottom: 0\n    };\n    tar.margin = {\n      left: 10,\n      right: 0,\n      top: 10,\n      bottom: 0\n    };\n  }\n\n  var extra = 20;\n\n  if (orientation === 'horizontal') {\n    switch (tar.direction) {\n      case 'Left':\n        if (src.corners.right + src.margin.right < tar.corners.left - tar.margin.left && (tar.corners.left - src.corners.right > extra || src.corners.top - src.margin.top <= tar.point.y && src.corners.bottom + src.margin.bottom >= tar.point.y)) {\n          var gap = Math.min(Math.abs(tar.corners.left - src.corners.right) / 2, 20);\n          extra = src.corners.right - sPt.x + gap;\n        } else {\n          if (src.direction === 'Top' && sPt.y > tar.point.y || src.direction === 'Bottom' && sPt.y < tar.point.y) {\n            extra = Math.min(tar.corners.left, sPt.x) - sPt.x - 20;\n          } else if (sPt.x >= src.corners.left - src.margin.left && sPt.x <= src.corners.right + src.margin.right) {\n            extra = Math.min(tar.corners.left, src.corners.left) - sPt.x - 20;\n          } else {\n            extra = tar.corners.left - sPt.x - 20;\n          }\n        }\n\n        break;\n\n      case 'Right':\n        if (src.corners.left - src.margin.left > tar.corners.right + tar.margin.right && (src.corners.left - tar.corners.right > extra || src.corners.top - src.margin.top <= tar.point.y && src.corners.bottom + src.margin.bottom >= tar.point.y)) {\n          var gap = Math.min(Math.abs(src.corners.left - tar.corners.right) / 2, 20);\n          extra = src.corners.left - sPt.x - gap;\n        } else {\n          if (src.direction === 'Top' && sPt.y > tar.point.y || src.direction === 'Bottom' && sPt.y < tar.point.y) {\n            extra = Math.max(tar.corners.right, sPt.x) - sPt.x + 20;\n          } else if (sPt.x >= src.corners.left - src.margin.left && sPt.x <= src.corners.right + src.margin.right) {\n            extra = Math.max(tar.corners.right, src.corners.right) - sPt.x + 20;\n          } else {\n            extra = tar.corners.right - sPt.x + 20;\n          }\n        }\n\n        break;\n    }\n\n    point1 = addLineSegment(sPt, extra, 0);\n    point2 = addLineSegment(point1, tar.point.y - sPt.y, 90);\n    point3 = tar.point;\n  } else if (orientation === 'vertical') {\n    switch (tar.direction) {\n      case 'Top':\n        if (src.corners.bottom + src.margin.bottom < tar.corners.top - tar.margin.top && (tar.corners.top - src.corners.bottom > extra || src.corners.left - src.margin.left <= tar.point.x && src.corners.right + src.margin.right >= tar.point.x)) {\n          var gap = Math.min(Math.abs(tar.corners.top - src.corners.bottom) / 2, 20);\n          extra = src.corners.bottom - sPt.y + gap;\n        } else {\n          if (src.direction === 'Left' && sPt.x > tar.point.x || src.direction === 'Right' && sPt.x < tar.point.x) {\n            extra = Math.min(tar.corners.top, sPt.y) - sPt.y - 20;\n          } else if (sPt.y >= src.corners.top - src.margin.top && sPt.y <= src.corners.bottom + src.margin.bottom) {\n            extra = Math.min(tar.corners.top, src.corners.top) - sPt.y - 20;\n          } else {\n            extra = tar.corners.top - sPt.y - 20;\n          }\n        }\n\n        break;\n\n      case 'Bottom':\n        if (src.corners.top - src.margin.top > tar.corners.bottom + tar.margin.bottom && (src.corners.top - tar.corners.bottom > extra || src.corners.left - src.margin.left <= tar.point.x && src.corners.right + src.margin.right >= tar.point.x)) {\n          var gap = Math.min(Math.abs(src.corners.top - tar.corners.bottom) / 2, 20);\n          extra = src.corners.top - sPt.y - gap;\n        } else {\n          if (src.direction === 'Left' && sPt.x > tar.point.x || src.direction === 'Right' && sPt.x < tar.point.x) {\n            extra = Math.max(tar.corners.bottom, sPt.y) - sPt.y + 20;\n          } else if (sPt.y >= src.corners.top - src.margin.top && sPt.y <= src.corners.bottom + src.margin.bottom) {\n            extra = Math.max(tar.corners.bottom, src.corners.bottom) - sPt.y + 20;\n          } else {\n            extra = tar.corners.bottom - sPt.y + 20;\n          }\n        }\n\n        break;\n    }\n\n    point1 = addLineSegment(sPt, extra, 90);\n    point2 = addLineSegment(point1, tar.point.x - sPt.x, 0);\n    point3 = tar.point;\n  }\n\n  points.push(point1);\n  points.push(point2);\n  points.push(point3);\n}\n/**\n * getTopLength method \\\n *\n * @returns {  number } getTopLength method .\\\n * @param {End} source - provide the sPt  value.\n * @param {End} target - provide the sPt  value.\n * @param {string} preDir - provide the orientation  value.\n * @param {number} length - provide the src  value.\n * @private\n */\n\n\nfunction getTopLength(source, target, preDir, length) {\n  if (source.corners.top - source.margin.top > target.corners.top + target.margin.top && source.corners.top - source.margin.top <= target.corners.bottom + target.margin.bottom) {\n    if (target.direction === 'Right' && source.point.x < target.point.x) {\n      length += source.corners.top - target.corners.top;\n    } else if (target.direction === 'Left' && source.point.x > target.point.x) {\n      length += source.corners.top - target.corners.top;\n    }\n\n    length += source.point.y - source.corners.top;\n  } else {\n    if (preDir !== undefined && preDir !== 'Left' && target.direction === 'Right' && source.point.x < target.point.x) {\n      length += Math.abs(source.point.y - target.corners.bottom);\n    } else if (preDir !== undefined && preDir !== 'Right' && target.direction === 'Left' && target.point.x < source.point.x) {\n      length += Math.abs(source.point.y - target.corners.bottom);\n    } else {\n      length += source.point.y - source.corners.top;\n    }\n  }\n\n  return length;\n}\n/**\n * getLeftLength method \\\n *\n * @returns {  number } getLeftLength method .\\\n * @param {End} source - provide the sPt  value.\n * @param {End} target - provide the sPt  value.\n * @param {string} prevDir - provide the orientation  value.\n * @param {number} segLength - provide the src  value.\n * @private\n */\n\n\nfunction getLeftLength(source, target, prevDir, segLength) {\n  if (source.corners.left - source.margin.left > target.corners.left - target.margin.left && source.corners.left - source.margin.left <= target.corners.right + target.margin.right) {\n    if (target.direction === 'Bottom' && source.point.y < target.point.y) {\n      segLength += source.corners.left - target.corners.left;\n    } else if (target.direction === 'Top' && source.point.y > target.point.y) {\n      segLength += source.corners.left - target.corners.left;\n    }\n\n    segLength += source.point.x - source.corners.left;\n  } else {\n    if (prevDir !== undefined && prevDir !== 'Top' && target.direction === 'Bottom' && source.point.y < target.point.y) {\n      segLength += Math.abs(source.point.x - target.corners.right);\n    } else if (prevDir !== undefined && prevDir !== 'Bottom' && target.direction === 'Top' && target.point.y < source.point.y) {\n      segLength += Math.abs(source.point.x - target.corners.right);\n    } else {\n      segLength += source.point.x - source.corners.left;\n    }\n  }\n\n  return segLength;\n}\n/**\n * getRightLength method \\\n *\n * @returns {  number } getRightLength method .\\\n * @param {End} source - provide the sPt  value.\n * @param {End} target - provide the orientation  value.\n * @param {number} length - provide the src  value.\n * @param {string} prevDir - provide the src  value.\n * @private\n */\n\n\nfunction getRightLength(source, target, length, prevDir) {\n  if (source.corners.right + source.margin.right < target.corners.right + target.margin.right && source.corners.right + source.margin.right >= target.corners.left - target.margin.left) {\n    if (target.direction === 'Bottom' && source.point.y < target.point.y) {\n      length += target.corners.right - source.corners.right;\n    } else if (target.direction === 'Top' && source.point.y > target.point.y) {\n      length += target.corners.right - source.corners.right;\n    }\n\n    length += source.corners.right - source.point.x;\n  } else {\n    if (prevDir !== undefined && prevDir !== 'Top' && target.direction === 'Bottom' && source.point.y < target.point.y) {\n      length += Math.abs(source.point.x - target.corners.right);\n    } else if (prevDir !== undefined && prevDir !== 'Bottom' && target.direction === 'Top' && target.point.y < source.point.y) {\n      length += Math.abs(source.point.x - target.corners.right);\n    } else {\n      length += source.corners.right - source.point.x;\n    }\n  }\n\n  return length;\n}\n/**\n * getBottomLength method \\\n *\n * @returns {  number } getBottomLength method .\\\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {number} segLength - provide the segLength  value.\n * @param {string} prevDir - provide the src  value.\n * @private\n */\n\n\nfunction getBottomLength(source, target, segLength, prevDir) {\n  if (source.corners.bottom + source.margin.bottom < target.corners.bottom + target.margin.bottom && source.corners.bottom + source.margin.bottom >= target.corners.top - target.margin.top) {\n    if (target.direction === 'Right' && source.point.x < target.point.x) {\n      segLength += target.corners.bottom - source.corners.bottom;\n    } else if (target.direction === 'Left' && source.point.x > target.point.x) {\n      segLength += target.corners.bottom - source.corners.bottom;\n    }\n\n    segLength += source.corners.bottom - source.point.y;\n  } else {\n    if (prevDir !== undefined && prevDir !== 'Left' && target.direction === 'Right' && source.point.x < target.point.x) {\n      segLength += Math.abs(source.point.y - target.corners.bottom);\n    } else if (prevDir !== undefined && prevDir !== 'Right' && target.direction === 'Left' && target.point.x < source.point.x) {\n      segLength += Math.abs(source.point.y - target.corners.bottom);\n    } else {\n      segLength += source.corners.bottom - source.point.y;\n    }\n  }\n\n  return segLength;\n}\n/**\n * getSwapping method \\\n *\n * @returns {  boolean } getSwapping method .\\\n * @param {string} srcDir - provide the source  value.\n * @param {string} tarDir - provide the target  value.\n * @private\n */\n\n\nfunction getSwapping(srcDir, tarDir) {\n  var swap = false;\n\n  switch (srcDir) {\n    case 'Left':\n      switch (tarDir) {\n        case 'Right':\n        case 'Bottom':\n          swap = true;\n          break;\n      }\n\n      break;\n\n    case 'Top':\n      switch (tarDir) {\n        case 'Left':\n        case 'Right':\n        case 'Bottom':\n          swap = true;\n          break;\n      }\n\n      break;\n\n    case 'Bottom':\n      switch (tarDir) {\n        case 'Right':\n          swap = true;\n          break;\n      }\n\n      break;\n  }\n\n  return swap;\n}\n/**\n * swapPoints method \\\n *\n * @returns {  void } swapPoints method .\\\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\n\n\nfunction swapPoints(source, target) {\n  var direction = source.direction;\n  source.direction = target.direction;\n  target.direction = direction;\n  var point = source.point;\n  source.point = target.point;\n  target.point = point;\n  var corner = source.corners;\n  source.corners = target.corners;\n  target.corners = corner;\n}\n/**\n * getPortDirection method \\\n *\n * @returns {  boolean } getPortDirection method .\\\n * @param {PointModel} point - provide the point  value.\n * @param {Corners} corner - provide the corner  value.\n * @param {Rect} bounds - provide the bounds  value.\n * @param {boolean} closeEdge - provide the closeEdge  value.\n * @private\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nexport function getPortDirection(point, corner, bounds, closeEdge) {\n  var direction;\n  var boundsValue = corner === undefined ? bounds : corner;\n  var one = boundsValue.topLeft;\n  var two = boundsValue.topRight;\n  var three = boundsValue.bottomRight;\n  var four = boundsValue.bottomLeft;\n  var center = boundsValue.center;\n  var angle = findAngle(center, point);\n  var fourty5 = findAngle(center, three);\n  var one35 = findAngle(center, four);\n  var two25 = findAngle(center, one);\n  var three15 = findAngle(center, two);\n\n  if (angle > two25 && angle < three15) {\n    direction = 'Top'; // if (bounds.width < bounds.height && closeEdge) {\n    //     let height: number = (bounds.height - bounds.width) / 2;\n    //     let width: number = bounds.width;\n    //     if (Math.abs(point.x - one.x) < Math.abs(point.x - two.x)) {\n    //         direction = checkCloseEdge(direction, new Rect(one.x, one.y, width, height), point, 'Left');\n    //     } else {\n    //         direction = checkCloseEdge(direction, new Rect(two.x - bounds.width, two.y, width, height), point, 'Right');\n    //     }\n    // }\n  } else if (angle >= fourty5 && angle < one35) {\n    direction = 'Bottom'; // if (bounds.width < bounds.height && closeEdge) {\n    //     let height: number = (bounds.height - bounds.width) / 2;\n    //     let width: number = bounds.width;\n    //     if (Math.abs(point.x - four.x) < Math.abs(point.x - three.x)) {\n    //         direction = checkCloseEdge(direction, new Rect(four.x, four.y - height, width, height), point, 'Left');\n    //     } else {\n    //         let value: Rect = new Rect(three.x - bounds.width, three.y - bounds.height / 4, bounds.width, bounds.height / 4);\n    //         direction = checkCloseEdge(direction, value, point, 'Right');\n    //     }\n    // }\n  } else if (angle >= one35 && angle <= two25) {\n    direction = 'Left'; // if (bounds.width > bounds.height && closeEdge) {\n    //     let width: number = (bounds.width - bounds.height) / 2;\n    //     let height: number = bounds.height;\n    //     if (Math.abs(point.y - one.y) < Math.abs(point.y - four.y)) {\n    //         direction = checkCloseEdge(direction, new Rect(one.x, one.y, width, height), point, 'Top');\n    //     } else {\n    //         direction = checkCloseEdge(direction, new Rect(four.x, four.y - height, width, height), point, 'Bottom');\n    //     }\n    // }\n  } else if (angle >= three15 || angle < fourty5) {\n    direction = 'Right'; // if (bounds.width > bounds.height && closeEdge) {\n    //     let width: number = (bounds.width - bounds.height) / 2;\n    //     let height: number = bounds.height;\n    //     if (Math.abs(point.y - two.y) < Math.abs(point.y - three.y)) {\n    //         direction = checkCloseEdge(direction, new Rect(two.x - width, two.y, width, height), point, 'Top');\n    //     } else {\n    //         direction = checkCloseEdge(direction,\n    //new Rect(three.x - width, three.y - height, width, height), point, 'Bottom');\n    //     }\n    // }\n  } else {\n    direction = 'Right';\n  }\n\n  return direction;\n} // function checkCloseEdge(direction: string, threshold: Rect, port: PointModel, nearest: string): string {\n// if (threshold) {\n//     switch (direction) {\n//         case 'Bottom':\n//         case 'Top':\n//             let left: number = Math.abs(threshold.left - port.x);\n//             let right: number = Math.abs(threshold.right - port.x);\n//             let ver: number = direction === 'Top' ? Math.abs(threshold.top - port.y) : Math.abs(threshold.bottom - port.y);\n//             if (left < right) {\n//                 if (left < ver) {\n//                     return 'Left';\n//                 }\n//             } else {\n//                 if (right < ver) {\n//                     return 'Right';\n//                 }\n//             }\n//             break;\n//         case 'Left':\n//         case 'Right':\n//             let top: number = Math.abs(threshold.top - port.y);\n//             let bottom: number = Math.abs(threshold.bottom - port.y);\n//             let hor: number = direction === 'Left' ? Math.abs(threshold.left - port.x) : Math.abs(threshold.right - port.x);\n//             if (top < bottom) {\n//                 if (top < hor) {\n//                     return 'Top';\n//                 }\n//             } else {\n//                 if (bottom < hor) {\n//                     return 'Bottom';\n//                 }\n//             }\n//             break;\n//     }\n// }\n//Meant for dock port\n//    return direction;\n//  }\n\n/**\n * getOuterBounds method \\\n *\n * @returns {  Rect } getOuterBounds method .\\\n * @param {Connector} obj - provide the point  value.\n * @private\n */\n\nexport function getOuterBounds(obj) {\n  //let outerBounds: Rect;\n  var outerBounds = obj.wrapper.children[0].bounds;\n\n  if (obj.sourceDecorator.shape !== 'None') {\n    outerBounds.uniteRect(obj.wrapper.children[1].bounds);\n  }\n\n  if (obj.targetDecorator.shape !== 'None') {\n    outerBounds.uniteRect(obj.wrapper.children[2].bounds);\n  }\n\n  return outerBounds;\n}\n/**\n * getOppositeDirection method \\\n *\n * @returns {  string } getOppositeDirection method .\\\n * @param {string} direction - provide the direction  value.\n * @private\n */\n\nexport function getOppositeDirection(direction) {\n  switch (direction) {\n    case 'Top':\n      return 'Bottom';\n\n    case 'Bottom':\n      return 'Top';\n\n    case 'Left':\n      return 'Right';\n\n    case 'Right':\n      return 'Left';\n  }\n\n  return 'auto';\n}","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/connector.js"],"names":["Point","Rect","getPoints","intersect3","NoOfSegments","StraightSegment","BezierSegment","OrthogonalSegment","PathElement","cornersPointsBeforeRotation","rotatePoint","findConnectorPoints","element","layoutOrientation","lineDistribution","sourcePoint","type","sourceWrapper","getSourcePoint","corners","center","intermeditatePoints","terminateConnection","targetPoint","setLineEndPoint","length","srcPoint","sourcePortWrapper","srcPort","pt","x","offsetX","y","offsetY","sourceID","targetWrapper","sPoint","tPoint","getIntersection","getDirection","source","target","direction","tarPoint","sourceNode","targetNode","sourcePort","targetPort","targetPortWrapper","srcCorner","tarCorner","segPoint","srcDir","tarDir","minSpace","sourceMargin","left","right","bottom","top","targetMargin","point","margin","sourceCorners","targetCorners","undefined","port","getPortDirection","bounds","tarPortPt","Math","abs","id","equals","containsPoint","topCenter","defaultOrthoConnection","checkLastSegmentasTerminal","connectToOneEnd","intermeditatePointsForStraight","segments","findPointToPointOrtho","extra","getOppositeDirection","adjustSegmentLength","points","orthoConnection3Segment","updateSegmentPoints","segment","push","angle","addLineSegment","pointToPoint","portdirection","length_1","findSourceDirection","orthoConnection2Segment","pointToNode","findDirection","width","source1","addPoints","height","refPoint","splice","findSegmentDirection","portDir","update","pointToPort","j","removeSegment","i","seg","checkConsectiveSegmentAsSame","lastSegment","checkSourcePointInTarget","checkPreviousSegment","checkPortdirection","returnIntermeditatePoints","pointsFromNodeToPoint","tPoints","connector","actualSegment","actualLastPoint","distancePoints","node","fixedPoint","nodeMargin","nodeConnectingPoint","nodeDirection","findPoint","source_1","target_1","segmentPoint","sourcePadding","addPaddingToConnector","targetPadding","isTarget","padding","paddingPort","rect","actualSize","segmentPoints","topLeft","topRight","bottomRight","bottomLeft","thisSegment","x1","y1","x2","y2","getIntersectionPoints","checkSourceAndTargetIntersect","sourceSegment","createSegmentsCollection","targetSegment","srcSegment","tarSegmet","enabled","createLineSegment","sPt","tPt","line","swapBounds","object","outerBounds","rectBounds","rotateAngle","parentTransform","middleLeft","bottomCenter","middleRight","ele","sourceEle","targetEle","tarPort","srcCor","tarCor","srcBounds","tarBounds","isInterSect","first","isEmptyPoint","vector1","distance","value","max","transform","vector2","findIntermeditatePoints","findOrthoSegments","dir","nodeOrPortToNode","length_2","length_3","len","lastPoint","nodeCorners","top_1","shortes","Number","MAX_VALUE","swap","getSwapping","swapPoints","getRightToLeftSegmentCount","getRightToRightSegmentCount","getRightToTopSegmentCount","getRightToBottomSegmentCount","getBottomToTopSegmentCount","getBottomToBottomSegmentCount","getBottomToLeftSegmentCount","getLeftToLeftSegmentCount","getLeftToTopSegmentCount","getTopToTopSegmentCount","addOrthoSegments","findAngle","s","e","r","re","findLength","es","ang","asin","PI","cor","endPoint","straight","reverse","segEnd","isTar","wrapper","child","sPt1","tPt1","constValue","data","split","round","pts","minimal","min","intersection","intersectSegment","isNaN","intersect","dist","segment1","segment2","x3","y3","x4","y4","a1","a2","b1","b2","c1","c2","r1","r2","r3","r4","offset","num","sameSign","denom","a","b","diffY","One","Three","Five","sourceObj","targetObj","diffX","Two","Four","difX","segLength","src","tar","prevDir","orthoConnection4Segment","orthoConnection5Segment","point1","point2","allow","segmentValue","next","diffx","diffy","temp","sLeft","sRight","sBottom","sTop","tLeft","tRight","tBottom","tTop","interPt","getLeftLength","getRightLength","getTopLength","getBottomLength","getOrtho3Seg","orientation","point3","gap","preDir","corner","closeEdge","boundsValue","one","two","three","four","fourty5","one35","two25","three15","getOuterBounds","obj","children","sourceDecorator","shape","uniteRect","targetDecorator"],"mappings":"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","sourcesContent":["/* eslint-disable jsdoc/require-returns-check */\nimport { Point } from './../primitives/point';\nimport { Rect } from './../primitives/rect';\nimport { getPoints, intersect3 } from './diagram-util';\nimport { NoOfSegments } from '../enum/enum';\nimport { StraightSegment, BezierSegment, OrthogonalSegment } from './../objects/connector';\nimport { PathElement } from './../core/elements/path-element';\nimport { cornersPointsBeforeRotation, rotatePoint } from './base-util';\n/**\n * Connector modules are used to dock and update the connectors\n */\n/**\n * intermeditatePoints method\\\n *\n * @returns {  Function }    getFunction method .\\\n * @param {PointModel} element - provide the angle value.\n * @param {PointModel} layoutOrientation - provide the angle value.\n * @param {PointModel} lineDistribution - provide the angle value.\n * @private\n */\nexport function findConnectorPoints(element, layoutOrientation, lineDistribution) {\n    //const intermeditatePoints: PointModel[];\n    var sourcePoint;\n    if (element.type === 'Straight' || !element.sourceWrapper) {\n        sourcePoint = getSourcePoint(element);\n    }\n    else {\n        sourcePoint = element.sourceWrapper.corners.center;\n    }\n    // eslint-disable-next-line\n    var intermeditatePoints = terminateConnection(element, sourcePoint, element.targetPoint, layoutOrientation, lineDistribution);\n    setLineEndPoint(element, intermeditatePoints[0], false);\n    setLineEndPoint(element, intermeditatePoints[intermeditatePoints.length - 1], true);\n    return intermeditatePoints;\n}\n/**\n * getSourcePoint method\\\n *\n * @returns {  PointModel }    getFunction method .\\\n * @param {PointModel} element - provide the angle value.\n * @private\n */\nfunction getSourcePoint(element) {\n    var srcPoint;\n    if (element.sourcePortWrapper) {\n        var srcPort = element.sourcePortWrapper;\n        //const srcNode: DiagramElement = element.sourceWrapper;\n        var pt = { x: srcPort.offsetX, y: srcPort.offsetY };\n        //const direction: string = getPortDirection(pt, cornersPointsBeforeRotation(srcNode), srcNode.bounds, false);\n        srcPoint = pt;\n    }\n    else if (element.sourceID && element.sourceWrapper) {\n        if (element.targetWrapper) {\n            var sPoint = element.sourceWrapper.corners.center;\n            var tPoint = element.targetWrapper.corners.center;\n            srcPoint = getIntersection(element, element.sourceWrapper, sPoint, tPoint, false);\n        }\n        else {\n            srcPoint = element.sourcePoint;\n        }\n    }\n    else {\n        srcPoint = element.sourcePoint;\n    }\n    return srcPoint;\n}\n/**\n * getDirection method \\\n *\n * @returns { void }     getDirection method .\\\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n * @param {LayoutOrientation} layoutOrientation - provide the layoutOrientation value.\n *\n * @private\n */\nfunction getDirection(source, target, layoutOrientation) {\n    if (layoutOrientation === 'LeftToRight') {\n        source.direction = source.direction ? source.direction : 'Right';\n        target.direction = target.direction ? target.direction : 'Left';\n    }\n    else if (layoutOrientation === 'RightToLeft') {\n        source.direction = source.direction ? source.direction : 'Left';\n        target.direction = target.direction ? target.direction : 'Right';\n    }\n    else if (layoutOrientation === 'TopToBottom') {\n        source.direction = source.direction ? source.direction : 'Bottom';\n        target.direction = target.direction ? target.direction : 'Top';\n    }\n    else if (layoutOrientation === 'BottomToTop') {\n        source.direction = source.direction ? source.direction : 'Top';\n        target.direction = target.direction ? target.direction : 'Bottom';\n    }\n}\n/**\n * terminateConnection method \\\n *\n * @returns { PointModel[] }     terminateConnection method .\\\n * @param {Connector} element - provide the element value.\n * @param {PointModel} srcPoint - provide the srcPoint value.\n * @param {PointModel} tarPoint - provide the tarPoint value.\n * @param {LayoutOrientation} layoutOrientation - provide the layoutOrientation value.\n * @param {boolean} lineDistribution - provide the lineDistribution value.\n *\n * @private\n */\nfunction terminateConnection(element, srcPoint, tarPoint, layoutOrientation, lineDistribution) {\n    var sourceNode = element.sourceWrapper;\n    var targetNode = element.targetWrapper;\n    var sourcePort = element.sourcePortWrapper;\n    var targetPort = element.targetPortWrapper;\n    var srcCorner;\n    var tarCorner;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    var intermeditatePoints = [];\n    var segPoint;\n    var srcDir;\n    var tarDir;\n    var minSpace = 13;\n    var sourceMargin = { left: 5, right: 5, bottom: 5, top: 5 };\n    var targetMargin = { left: 5, right: 5, bottom: 5, top: 5 };\n    var source = { corners: srcCorner, point: srcPoint, direction: srcDir, margin: sourceMargin };\n    var target = { corners: tarCorner, point: tarPoint, direction: tarDir, margin: targetMargin };\n    var sourceCorners;\n    var targetCorners;\n    if (sourceNode !== undefined && targetNode !== undefined) {\n        sourceCorners = cornersPointsBeforeRotation(sourceNode);\n        targetCorners = cornersPointsBeforeRotation(targetNode);\n        source.corners = sourceNode.corners;\n        target.corners = targetNode.corners;\n    }\n    if (sourcePort !== undefined) {\n        var port = { x: sourcePort.offsetX, y: sourcePort.offsetY };\n        source.direction = getPortDirection(port, sourceCorners, sourceNode.bounds, false);\n    }\n    if (targetPort !== undefined) {\n        var tarPortPt = { x: targetPort.offsetX, y: targetPort.offsetY };\n        target.direction = getPortDirection(tarPortPt, targetCorners, targetNode.bounds, false);\n    }\n    if (sourceNode !== undefined && targetNode !== undefined) {\n        if (source.direction === undefined || target.direction === undefined) {\n            if (layoutOrientation) {\n                getDirection(source, target, layoutOrientation);\n            }\n            else {\n                if (source.corners.top > target.corners.bottom &&\n                    Math.abs(source.corners.top - target.corners.bottom) >\n                        (source.margin.top + source.margin.bottom)) {\n                    source.direction = source.direction ? source.direction : 'Top';\n                    target.direction = target.direction ? target.direction : 'Bottom';\n                }\n                else if (source.corners.bottom < target.corners.top &&\n                    Math.abs(source.corners.bottom - target.corners.top) >\n                        (source.margin.bottom + source.margin.top)) {\n                    source.direction = source.direction ? source.direction : 'Bottom';\n                    target.direction = target.direction ? target.direction : 'Top';\n                }\n                else if ((source.corners.right < target.corners.left &&\n                    Math.abs(source.corners.right - target.corners.left) >\n                        (source.margin.right + source.margin.left)) ||\n                    ((source.corners.right + minSpace < target.corners.left) ||\n                        (target.corners.right >= source.corners.left - minSpace && source.corners.left > target.corners.left))) {\n                    source.direction = source.direction ? source.direction : 'Right';\n                    target.direction = target.direction ? target.direction : 'Left';\n                }\n                else if ((source.corners.left > target.corners.right &&\n                    Math.abs(source.corners.left - target.corners.right) > (source.margin.left + source.margin.right)) ||\n                    ((target.corners.right + minSpace < source.corners.left ||\n                        (source.corners.right >= target.corners.left - minSpace\n                            && source.corners.left < target.corners.left)))) {\n                    source.direction = source.direction ? source.direction : 'Left';\n                    target.direction = target.direction ? target.direction : 'Right';\n                }\n                else {\n                    if (sourceNode.id !== targetNode.id && (!sourceCorners.equals(sourceCorners, targetCorners)) &&\n                        targetCorners.containsPoint(sourceCorners.topCenter, source.margin.top)) {\n                        source.direction = source.direction ? source.direction : 'Bottom';\n                        target.direction = target.direction ? target.direction : 'Top';\n                    }\n                    else {\n                        source.direction = source.direction ? source.direction : 'Top';\n                        target.direction = target.direction ? target.direction : 'Bottom';\n                    }\n                }\n            }\n        }\n        return defaultOrthoConnection(element, source.direction, target.direction, source.point, target.point, lineDistribution);\n    }\n    //It will be called only when there is only one end node\n    checkLastSegmentasTerminal(element);\n    if (element.sourceWrapper || element.targetWrapper) {\n        connectToOneEnd(element, source, target);\n    }\n    if (element.type === 'Straight' || element.type === 'Bezier') {\n        intermeditatePoints = intermeditatePointsForStraight(element, source, target);\n    }\n    else {\n        if (element.type === 'Orthogonal' && element.segments && element.segments.length > 0 &&\n            element.segments[0].length !== null &&\n            element.segments[0].direction !== null) {\n            intermeditatePoints = findPointToPointOrtho(element, source, target, sourceNode, targetNode, sourcePort, targetPort);\n        }\n        else {\n            var extra = void 0;\n            if (!source.direction) {\n                source.direction = (target.direction) ? ((element.targetPortWrapper !== undefined) ? target.direction : getOppositeDirection(target.direction)) :\n                    Point.direction(source.point, target.point);\n            }\n            else {\n                extra = adjustSegmentLength(sourceNode.bounds, source, 20);\n            }\n            element.segments[0].points = intermeditatePoints = orthoConnection3Segment(element, source, target, extra);\n        }\n    }\n    return intermeditatePoints;\n}\n/**\n * updateSegmentPoints method \\\n *\n * @returns { PointModel[] }     updateSegmentPoints method .\\\n * @param {End} source - provide the source value.\n * @param {OrthogonalSegment} segment - provide the segment value.\n *\n * @private\n */\nfunction updateSegmentPoints(source, segment) {\n    //let segPoint: PointModel; //let angle: number; //let extra: number;\n    source.direction = segment.direction;\n    segment.points = [];\n    segment.points.push(source.point);\n    var extra = (segment.direction === 'Left' || segment.direction === 'Top') ? -(segment.length) : segment.length;\n    var angle = (segment.direction === 'Left' || segment.direction === 'Right') ? 0 : 90;\n    var segPoint = addLineSegment(source.point, extra, angle);\n    segment.points.push(segPoint);\n    return segPoint;\n}\n/**\n * pointToPoint method \\\n *\n * @returns { void }     pointToPoint method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\nfunction pointToPoint(element, source, target) {\n    var point;\n    var direction;\n    var portdirection;\n    source.corners = (element.sourceWrapper) ? element.sourceWrapper.corners : undefined;\n    if (element.sourcePortWrapper) {\n        var port = { x: element.sourcePortWrapper.offsetX, y: element.sourcePortWrapper.offsetY };\n        portdirection = getPortDirection(port, cornersPointsBeforeRotation(element.sourceWrapper), element.sourceWrapper.bounds, false);\n        if (source.corners && (source.direction === 'Bottom' || source.direction === 'Top')) {\n            if (target.point.x > source.corners.left && target.point.x < source.corners.right) {\n                direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';\n            }\n        }\n        else if (source.corners && (source.direction === 'Left' || source.direction === 'Right')) {\n            if (target.point.y > source.corners.top && target.point.y < source.corners.bottom) {\n                direction = (source.point.x > target.point.x) ? 'Left' : 'Right';\n            }\n        }\n    }\n    if (element.sourcePortWrapper && portdirection === getOppositeDirection(direction)) {\n        var length_1;\n        if ((portdirection === 'Left' || portdirection === 'Right') && (source.point.y >= source.corners.top\n            && source.point.y <= source.corners.center.y) &&\n            (target.point.y >= source.corners.top && target.point.y <= source.corners.center.y)) {\n            source.direction = 'Top';\n            length_1 = source.point.y - source.corners.top + 20;\n        }\n        else if ((portdirection === 'Left' || portdirection === 'Right') && (source.point.y > source.corners.center.y\n            && source.point.y <= source.corners.bottom) &&\n            (target.point.y > source.corners.center.y && target.point.y <= source.corners.bottom)) {\n            source.direction = 'Bottom';\n            length_1 = source.corners.bottom - source.point.y + 20;\n        }\n        else if ((portdirection === 'Top' || portdirection === 'Bottom') && (source.point.x >= source.corners.left\n            && source.point.x <= source.corners.center.x) &&\n            (target.point.x >= source.corners.left && target.point.x <= source.corners.center.x)) {\n            source.direction = 'Left';\n            length_1 = source.point.x - source.corners.left + 20;\n        }\n        else if ((portdirection === 'Top' || portdirection === 'Bottom') && (source.point.x <= source.corners.right\n            && source.point.x > source.corners.center.x) &&\n            (target.point.x <= source.corners.right && target.point.x < source.corners.center.x)) {\n            source.direction = 'Right';\n            length_1 = source.corners.right - source.point.x + 20;\n        }\n        if (source.direction && length_1) {\n            point = orthoConnection3Segment(element, source, target, length_1, true);\n        }\n    }\n    else {\n        source.direction = (direction) ? direction : findSourceDirection(source.direction, source.point, target.point);\n        point = orthoConnection2Segment(source, target);\n    }\n    return point;\n}\n/**\n * pointToNode method \\\n *\n * @returns { void }     pointToNode method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\nfunction pointToNode(element, source, target) {\n    var point;\n    target.corners = element.targetWrapper.corners;\n    findDirection(element.targetWrapper, source, target, element);\n    var direction = findSourceDirection(target.direction, source.point, target.point);\n    if (source.direction === target.direction && (source.direction === 'Left' || source.direction === 'Right')) {\n        source.direction = direction;\n        point = orthoConnection3Segment(element, source, target, element.targetWrapper.width / 2 + 20);\n        var source1 = source;\n        source1.point = point[1];\n        findDirection(element.targetWrapper, source, target, element);\n        point = orthoConnection3Segment(element, source, target);\n    }\n    else {\n        source.direction = direction;\n        point = orthoConnection2Segment(source, target);\n    }\n    return point;\n}\n/**\n * addPoints method \\\n *\n * @returns { void }     addPoints method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\nfunction addPoints(element, source, target) {\n    target.corners = element.targetWrapper.corners;\n    var direction;\n    var length;\n    if (source.direction !== 'Left' && source.direction !== 'Right') {\n        if (target.corners.center.y === source.point.y &&\n            (!(target.corners.left <= source.point.x && source.point.x <= target.corners.right))) {\n            direction = 'Top';\n            length = target.corners.height / 2 + 20;\n        }\n        else if ((target.corners.center.y === source.point.y &&\n            element.segments[element.segments.length - 2].direction === 'Bottom') ||\n            (target.corners.center.y > source.point.y && source.point.y >= target.corners.top)) {\n            direction = 'Top';\n            length = (source.point.y - target.corners.top) + 20;\n        }\n        else if ((target.corners.center.y === source.point.y &&\n            element.segments[element.segments.length - 2].direction === 'Top') ||\n            (target.corners.center.y < source.point.y && source.point.y <= target.corners.bottom)) {\n            direction = 'Bottom';\n            length = (target.corners.bottom - source.point.y) + 20;\n        }\n        else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n            source.corners.top <= source.point.y && source.point.y <= source.corners.bottom) {\n            direction = source.direction;\n            length = (source.point.y > target.point.y) ? (source.point.y - source.corners.top + 20) :\n                (source.corners.bottom - source.point.y + 20);\n        }\n    }\n    else {\n        if (target.corners.center.x === source.point.x &&\n            (!(target.corners.top < source.point.y && source.point.y <= target.corners.bottom))) {\n            direction = 'Left';\n            length = target.corners.width / 2 + 20;\n        }\n        else if ((target.corners.center.x === source.point.x &&\n            element.segments[element.segments.length - 2].direction === 'Right')\n            || (target.corners.center.x > source.point.x && source.point.x >= target.corners.left)) {\n            direction = 'Left';\n            length = (source.point.x - target.corners.left) + 20;\n        }\n        else if ((target.corners.center.x === source.point.x &&\n            element.segments[element.segments.length - 2].direction === 'Left') ||\n            (target.corners.center.x <= source.point.x && source.point.x <= target.corners.right)) {\n            direction = 'Right';\n            length = (target.corners.right - source.point.x) + 20;\n        }\n        else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n            source.corners.left <= source.point.x && source.point.x <= source.corners.right) {\n            direction = source.direction;\n            length = (source.point.x > target.point.x) ? (source.point.x - source.corners.left + 20) :\n                (source.corners.right - source.point.x + 20);\n        }\n    }\n    var extra = (direction === 'Left' || direction === 'Top') ? -(length) : length;\n    var angle = (direction === 'Left' || direction === 'Right') ? 0 : 90;\n    var refPoint = source.point;\n    source.point = addLineSegment(source.point, extra, angle);\n    source.direction = Point.direction(source.point, target.point);\n    if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n        (source.corners.center.x === target.corners.center.x || source.corners.center.y === target.corners.center.y)) {\n        source.direction = target.direction;\n    }\n    var point = orthoConnection3Segment(element, source, target);\n    point.splice(0, 0, refPoint);\n    return point;\n}\n/**\n * findSegmentDirection method \\\n *\n * @returns { void }     findSegmentDirection method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n * @param {Direction} portDir - provide the target value.\n *\n * @private\n */\nfunction findSegmentDirection(element, source, target, portDir) {\n    var update = false;\n    switch (target.direction) {\n        case 'Left':\n            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && (portDir === 'Right' &&\n                source.point.x > target.point.x && source.point.y >= source.corners.top &&\n                source.point.y <= source.corners.bottom)\n                || (((portDir === 'Bottom' && source.point.y > target.point.y) ||\n                    (portDir === 'Top' && source.point.y < target.point.y)) &&\n                    source.point.x >= source.corners.left && source.point.x <= source.corners.right)) {\n                source.direction = (portDir === 'Right') ? ((source.point.y > target.point.y) ? 'Top' : 'Bottom') :\n                    (source.point.x < target.point.x ? 'Right' : 'Left');\n                update = true;\n            }\n            else if (source.point.x > target.point.x && (source.point.y > target.point.y || source.point.y < target.point.y)\n                && (!(target.corners.top > source.point.y && target.corners.bottom < source.point.y))) {\n                source.direction = 'Left';\n            }\n            else if ((source.point.x < target.point.x && source.point.y > target.point.y) ||\n                (source.point.x > target.point.x && (source.point.y <= target.point.y)\n                    && ((target.corners.top < source.point.y && target.corners.center.y >= source.point.y)))) {\n                source.direction = 'Top';\n            }\n            else if ((source.point.x < target.point.x && source.point.y < target.point.y) ||\n                (source.point.x > target.point.x && (source.point.y > target.point.y)\n                    && ((target.corners.bottom < source.point.y && target.corners.center.y > source.point.y)))) {\n                source.direction = 'Bottom';\n            }\n            else if (source.point.y === target.point.y && source.point.x < target.point.x) {\n                source.direction = 'Right';\n            }\n            break;\n        case 'Right':\n            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n                ((portDir === 'Bottom' && source.point.y > target.point.y) ||\n                    (portDir === 'Top' && source.point.y < target.point.y)) && source.point.x > target.point.x &&\n                (source.point.x >= source.corners.left && source.point.x <= source.corners.right)) {\n                source.direction = (source.point.x > target.point.x) ? 'Left' : 'Right';\n                update = true;\n            }\n            else if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n                portDir === 'Left' && source.point.x < target.point.x && (source.point.y >= source.corners.top &&\n                source.point.y <= source.corners.bottom)) {\n                source.direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';\n                update = true;\n            }\n            else if (source.point.x < target.point.x && target.corners.top <= source.point.y\n                && target.corners.bottom >= source.point.y && source.point.y === target.point.y) {\n                source.direction = 'Top';\n            }\n            else if (source.point.y > target.point.y && source.point.x > target.point.x) {\n                source.direction = 'Top';\n            }\n            else if (source.point.y < target.point.y && source.point.x > target.point.x) {\n                source.direction = 'Bottom';\n            }\n            else if (source.point.x < target.point.x && (source.point.y > target.point.y ||\n                source.point.y < target.point.y)) {\n                source.direction = 'Right';\n            }\n            else if (source.point.y === target.point.y && source.point.x > target.point.x) {\n                source.direction = 'Left';\n            }\n            break;\n        case 'Top':\n            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && (portDir === 'Bottom' &&\n                source.point.y > target.point.y && source.point.x >= source.corners.left &&\n                source.point.x <= source.corners.right) || (((portDir === 'Right' && source.point.x > target.point.x) ||\n                (portDir === 'Left' && target.point.y > source.point.y && target.point.x > source.point.x)) &&\n                (source.point.y >= source.corners.top && source.point.y <= source.corners.bottom))) {\n                source.direction = (portDir === 'Bottom') ? ((source.point.x > target.point.x) ? 'Left' : 'Right') :\n                    (source.point.y < target.point.y) ? 'Bottom' : 'Top';\n                update = true;\n            }\n            else if (source.point.x === target.point.x && source.point.y < target.point.y) {\n                source.direction = 'Bottom';\n            }\n            else if (source.point.y > target.point.y && source.point.x > target.corners.left &&\n                source.point.x < target.corners.right) {\n                source.direction = 'Left';\n            }\n            else if (source.point.y >= target.point.y) {\n                source.direction = 'Top';\n            }\n            else if (source.point.y < target.point.y && source.point.x > target.point.x) {\n                source.direction = 'Left';\n            }\n            else if (source.point.y < target.point.y && source.point.x < target.point.x) {\n                source.direction = 'Right';\n            }\n            break;\n        case 'Bottom':\n            if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined && ((((portDir === 'Right') ||\n                (portDir === 'Left' && target.point.x > source.point.x)) && (source.point.y > target.point.y) &&\n                source.point.y >= source.corners.top && source.point.y <= source.corners.bottom) ||\n                (((portDir === 'Top' && source.point.y < target.point.y)) &&\n                    (source.point.x >= source.corners.left && source.point.x <= source.corners.right)))) {\n                if (portDir === 'Right' || portDir === 'Left') {\n                    source.direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';\n                }\n                else {\n                    source.direction = (source.point.x > target.point.x) ? 'Left' : 'Right';\n                }\n                update = true;\n            }\n            else if (source.point.y < target.point.y && source.point.x > target.corners.left &&\n                target.corners.right > source.point.x) {\n                if (source.point.y < target.point.y && source.point.x > target.corners.left &&\n                    target.corners.center.x >= source.point.x) {\n                    source.direction = 'Left';\n                }\n                else if (source.point.y < target.point.y && source.point.x < target.corners.right &&\n                    target.corners.center.x < source.point.x) {\n                    source.direction = 'Right';\n                }\n            }\n            else if (source.point.y > target.point.y && source.point.x > target.point.x) {\n                source.direction = 'Left';\n            }\n            else if (source.point.y > target.point.y && source.point.x < target.point.x) {\n                source.direction = 'Right';\n            }\n            else if (source.point.y <= target.point.y && (source.point.x > target.point.x || target.point.x > source.point.x)) {\n                source.direction = 'Bottom';\n            }\n            break;\n    }\n    return update;\n}\n/**\n * pointToPort method \\\n *\n * @returns { void }     pointToPort method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\nfunction pointToPort(element, source, target) {\n    var point;\n    target.corners = element.targetWrapper.corners;\n    var portdirection;\n    var length;\n    if (element.sourcePortWrapper !== undefined) {\n        var port = { x: element.sourcePortWrapper.offsetX, y: element.sourcePortWrapper.offsetY };\n        portdirection = getPortDirection(port, cornersPointsBeforeRotation(element.sourceWrapper), element.sourceWrapper.bounds, false);\n    }\n    var update = findSegmentDirection(element, source, target, portdirection);\n    if (element.sourcePortWrapper !== undefined && element.targetPortWrapper !== undefined &&\n        target.direction === getOppositeDirection(portdirection) &&\n        ((((target.direction === 'Left' && source.point.x > target.point.x) || (target.direction === 'Right' &&\n            source.point.x < target.point.x)) && source.point.y >= source.corners.top &&\n            source.point.y <= source.corners.bottom) || (target.direction === 'Bottom' && source.point.y < target.point.y &&\n            (source.point.x >= source.corners.left && source.point.x <= source.corners.right)))) {\n        point = addPoints(element, source, target);\n    }\n    else if (source.direction === target.direction) {\n        point = orthoConnection3Segment(element, source, target);\n    }\n    else if ((((target.direction === 'Left' && source.point.x > target.point.x) ||\n        (target.direction === 'Right' && source.point.x < target.point.x)) && (source.direction === 'Top' || source.direction === 'Bottom')\n        && ((source.point.y <= target.point.y) &&\n            ((target.corners.top <= source.point.y && target.corners.bottom >= source.point.y)))) ||\n        ((target.direction === 'Top' && source.point.y > target.point.y) ||\n            (target.direction === 'Bottom' && source.point.y < target.point.y) &&\n                ((target.corners.left <= source.point.x && target.corners.right >= source.point.x)))) {\n        point = addPoints(element, source, target);\n    }\n    else {\n        if (element.sourceWrapper !== undefined && element.targetWrapper !== undefined && element.targetPortWrapper !== undefined &&\n            ((source.direction === 'Left' || source.direction === 'Right') &&\n                (source.point.y >= source.corners.top && source.point.y <= source.corners.bottom)\n                && (target.direction === 'Top' || target.direction === 'Bottom') &&\n                (target.corners.center.x === source.corners.center.x))) {\n            source.direction = (target.direction === 'Top') ? 'Bottom' : 'Top';\n            length = (target.direction === 'Top') ? (source.corners.bottom - source.point.y + 20) :\n                (source.point.y - source.corners.top + 20);\n            point = orthoConnection3Segment(element, source, target, length);\n        }\n        else if (element.sourceWrapper !== undefined && element.targetWrapper !== undefined && element.targetPortWrapper !== undefined &&\n            ((source.direction === 'Top' || source.direction === 'Bottom') &&\n                (source.point.x >= source.corners.left && source.point.x <= source.corners.right) &&\n                (target.direction === 'Left' || target.direction === 'Right') && (target.corners.center.y === source.corners.center.y))) {\n            source.direction = (target.direction === 'Left') ? 'Right' : 'Left';\n            length = (target.direction === 'Left') ? (source.corners.right - source.point.x + 20) :\n                (source.point.x - source.corners.left + 20);\n            point = orthoConnection3Segment(element, source, target, length);\n        }\n        else if (update) {\n            if (source.direction === 'Left' || source.direction === 'Right') {\n                length = (source.direction === 'Left') ? (source.point.x - source.corners.left + 20) :\n                    (source.corners.right - source.point.x + 20);\n            }\n            else {\n                length = (source.direction === 'Top') ? (source.point.y - source.corners.top + 20) :\n                    (source.corners.bottom - source.point.y + 20);\n            }\n            point = orthoConnection3Segment(element, source, target, length);\n        }\n        else {\n            point = orthoConnection2Segment(source, target);\n        }\n    }\n    return point;\n}\n/**\n * findPointToPointOrtho method \\\n *\n * @returns { void }     findPointToPointOrtho method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} source - provide the source value.\n * @param {DiagramElement} target - provide the target value.\n * @param {DiagramElement} sourceNode - provide the target value.\n * @param {DiagramElement} targetNode - provide the target value.\n * @param {DiagramElement} sourcePort - provide the sourcePort value.\n * @param {DiagramElement} targetPort - provide the targetPort value.\n *\n * @private\n */\nfunction findPointToPointOrtho(element, source, target, sourceNode, targetNode, sourcePort, targetPort) {\n    var j;\n    var point;\n    var intermeditatePoints = [];\n    var direction;\n    var port; //let seg: OrthogonalSegment;\n    checkLastSegmentasTerminal(element);\n    var removeSegment;\n    if (element.segments.length > 0) {\n        for (var i = 0; i < element.segments.length; i++) {\n            var seg = element.segments[i];\n            if (i === 0 && element.sourcePortWrapper !== undefined) {\n                port = { x: sourcePort.offsetX, y: sourcePort.offsetY };\n                direction = getPortDirection(port, cornersPointsBeforeRotation(sourceNode), sourceNode.bounds, false);\n                if (seg.direction === getOppositeDirection(direction)) {\n                    seg.direction = direction;\n                }\n            }\n            if (i > 0 && element.segments[i - 1].direction === seg.direction) {\n                i = checkConsectiveSegmentAsSame(element, i, source);\n            }\n            else {\n                var lastSegment = element.segments[i - 1];\n                source.point = (seg.direction) ? updateSegmentPoints(source, seg) :\n                    lastSegment.points[lastSegment.points.length - 1];\n            }\n            if (i === element.segments.length - 1) {\n                if (!targetPort && !targetNode) {\n                    point = pointToPoint(element, source, target);\n                }\n                else if (element.targetWrapper && element.targetPortWrapper === undefined) {\n                    checkSourcePointInTarget(element, source);\n                    point = pointToNode(element, source, target);\n                }\n                else {\n                    point = pointToPort(element, source, target);\n                }\n                if (point) {\n                    checkPreviousSegment(point, element, source);\n                    seg.points = [];\n                    if (point.length >= 2) {\n                        for (j = 0; j < point.length; j++) {\n                            seg.points.push(point[j]);\n                        }\n                    }\n                    else {\n                        removeSegment = i;\n                    }\n                }\n            }\n            if (sourcePort && i === 0) {\n                var sourcePoint = checkPortdirection(element, sourcePort, sourceNode);\n                if (sourcePoint) {\n                    source.point = sourcePoint;\n                }\n            }\n        }\n        if (removeSegment !== undefined) {\n            if (removeSegment === element.segments.length - 1) {\n                element.segments[removeSegment - 1].direction = null;\n                element.segments[removeSegment - 1].length = null;\n            }\n            element.segments.splice(removeSegment, 1);\n        }\n        intermeditatePoints = returnIntermeditatePoints(element, intermeditatePoints);\n    }\n    return intermeditatePoints;\n}\n/**\n * checkPortdirection method \\\n *\n * @returns { PointModel }     checkPortdirection method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} sourcePort - provide the target value.\n * @param {DiagramElement} sourceNode - provide the target value.\n *\n * @private\n */\nfunction checkPortdirection(element, sourcePort, sourceNode) {\n    var port = { x: sourcePort.offsetX, y: sourcePort.offsetY };\n    var point;\n    var bounds = cornersPointsBeforeRotation(sourceNode);\n    var direction = getPortDirection(port, bounds, sourceNode.bounds, false);\n    var seg = element.segments[0];\n    if (seg.direction !== direction) {\n        pointsFromNodeToPoint(seg, direction, bounds, seg.points[0], seg.points[seg.points.length - 1], false);\n        point = seg.points[seg.points.length - 1];\n        seg.direction = Point.direction(seg.points[seg.points.length - 2], seg.points[seg.points.length - 1]);\n    }\n    return point;\n}\n/**\n * checkPreviousSegment method \\\n *\n * @returns { PointModel }     checkPreviousSegment method .\\\n * @param {Connector} tPoints - provide the element value.\n * @param {DiagramElement} connector - provide the target value.\n * @param {DiagramElement} source - provide the target value.\n *\n * @private\n */\nfunction checkPreviousSegment(tPoints, connector, source) {\n    var actualSegment = connector.segments[connector.segments.length - 2];\n    var actualLastPoint = actualSegment.points[actualSegment.points.length - 1];\n    var direction;\n    if (((actualSegment.direction === 'Top' || actualSegment.direction === 'Bottom') && (actualLastPoint.x === tPoints[1].x)) ||\n        ((actualSegment.direction === 'Left' || actualSegment.direction === 'Right') && (actualLastPoint.y === tPoints[1].y))) {\n        actualSegment.points[actualSegment.points.length - 1] = tPoints[1];\n        direction = Point.direction(actualSegment.points[0], actualSegment.points[actualSegment.points.length - 1]);\n        if (connector.sourceWrapper !== undefined && connector.sourcePortWrapper === undefined &&\n            direction === getOppositeDirection(actualSegment.direction)) {\n            if (actualSegment.direction === 'Left' || actualSegment.direction === 'Right') {\n                actualSegment.points[0].x = (actualSegment.direction === 'Right') ?\n                    actualSegment.points[0].x - connector.sourceWrapper.corners.width :\n                    actualSegment.points[0].x + connector.sourceWrapper.corners.width;\n            }\n            else {\n                actualSegment.points[0].y = (actualSegment.direction === 'Bottom') ?\n                    actualSegment.points[0].y - connector.sourceWrapper.corners.height :\n                    actualSegment.points[0].y + connector.sourceWrapper.corners.height;\n            }\n        }\n        actualSegment.direction = direction;\n        actualSegment.length = Point.distancePoints(actualSegment.points[0], actualSegment.points[actualSegment.points.length - 1]);\n        tPoints.splice(0, 1);\n    }\n}\n/**\n * connectToOneEnd method \\\n *\n * @returns { void }     connectToOneEnd method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} source - provide the target value.\n * @param {DiagramElement} target - provide the target value.\n *\n * @private\n */\nfunction connectToOneEnd(element, source, target) {\n    var sourcePort = element.sourcePortWrapper;\n    var targetPort = element.targetPortWrapper;\n    var node = element.sourceWrapper;\n    var fixedPoint = source.point;\n    var nodeMargin = { left: 0, right: 0, top: 0, bottom: 0 };\n    var nodeConnectingPoint = { x: 0, y: 0 };\n    var refPoint;\n    var nodeDirection = 'Top';\n    if (!node) {\n        node = element.targetWrapper;\n        nodeMargin = target.margin;\n    }\n    else {\n        fixedPoint = target.point;\n        nodeMargin = source.margin;\n    }\n    if (element.type === 'Orthogonal') {\n        if ((element.segments && element.segments.length > 0) && element.sourceWrapper &&\n            element.segments[0].direction) {\n            source.direction = element.segments[0].direction;\n            nodeConnectingPoint = findPoint(node.corners, source.direction);\n            refPoint = findPoint(node.corners, getOppositeDirection(source.direction));\n            nodeConnectingPoint = getIntersection(element, node, nodeConnectingPoint, refPoint, false);\n        }\n        else {\n            var source_1 = { corners: null, direction: null, point: fixedPoint, margin: nodeMargin };\n            var target_1 = { corners: null, direction: null, point: null, margin: null };\n            findDirection(node, source_1, target_1, element);\n            nodeConnectingPoint = target_1.point;\n            nodeDirection = target_1.direction;\n        }\n    }\n    else {\n        var segmentPoint = void 0;\n        if (element.segments && element.segments.length > 1) {\n            if (node === element.sourceWrapper) {\n                segmentPoint = element.segments[0].point;\n            }\n            else {\n                segmentPoint = element.segments[element.segments.length - 2].point;\n            }\n        }\n        nodeConnectingPoint = getIntersection(element, node, node.bounds.center, (element.segments && element.segments.length > 1) ? segmentPoint : fixedPoint, node === element.targetWrapper);\n    }\n    if (node === element.sourceWrapper) {\n        source.direction = source.direction || nodeDirection;\n        source.point = nodeConnectingPoint;\n        if (element.sourcePortWrapper) {\n            source.point = { x: sourcePort.offsetX, y: sourcePort.offsetY };\n            if (element.sourcePadding) {\n                source.point = addPaddingToConnector(element, source, target, false);\n            }\n        }\n    }\n    else {\n        target.direction = target.direction || nodeDirection;\n        target.point = nodeConnectingPoint;\n        if (element.targetPortWrapper) {\n            target.point = { x: targetPort.offsetX, y: targetPort.offsetY };\n            if (element.targetPadding) {\n                target.point = addPaddingToConnector(element, source, target, true);\n            }\n        }\n    }\n}\n/**\n * addPaddingToConnector method \\\n *\n * @returns { void }     addPaddingToConnector method .\\\n * @param {Connector} element - provide the element value.\n * @param {DiagramElement} source - provide the target value.\n * @param {DiagramElement} target - provide the target value.\n * @param {DiagramElement} isTarget - provide the target value.\n *\n * @private\n */\nfunction addPaddingToConnector(element, source, target, isTarget) {\n    var sourcePort = element.sourcePortWrapper;\n    var targetPort = element.targetPortWrapper;\n    var padding = (isTarget) ? element.targetPadding : element.sourcePadding;\n    var paddingPort = (isTarget) ? targetPort : sourcePort;\n    var rect = new Rect(paddingPort.bounds.x - padding, paddingPort.bounds.y - padding, paddingPort.actualSize.width + 2 * padding, paddingPort.actualSize.height + 2 * padding);\n    var segmentPoints = [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft];\n    segmentPoints[segmentPoints.length] = segmentPoints[0];\n    //const length: number = segmentPoints.length;\n    var thisSegment = { x1: source.point.x, y1: source.point.y, x2: target.point.x, y2: target.point.y };\n    var point = (isTarget) ? target.point : source.point;\n    return getIntersectionPoints(thisSegment, segmentPoints, true, point) || point;\n}\n/**\n * checkSourceAndTargetIntersect method \\\n *\n * @returns { void }     checkSourceAndTargetIntersect method .\\\n * @param {DiagramElement} sourceWrapper - provide the sourceWrapper value.\n * @param {DiagramElement} targetWrapper - provide the targetWrapper value.\n * @param {Connector} connector - provide the Connector value.\n *\n * @private\n */\nfunction checkSourceAndTargetIntersect(sourceWrapper, targetWrapper, connector) {\n    var sourceSegment = createSegmentsCollection(sourceWrapper, connector.sourcePadding);\n    var targetSegment = createSegmentsCollection(targetWrapper, connector.targetPadding);\n    for (var i = 0; i < sourceSegment.length - 1; i++) {\n        var srcSegment = sourceSegment[i];\n        for (var j = 0; j < targetSegment.length - 1; j++) {\n            var tarSegmet = targetSegment[j];\n            if (intersect3(srcSegment, tarSegmet).enabled) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n * createSegmentsCollection method \\\n *\n * @returns { Segment[] }     createSegmentsCollection method .\\\n * @param {DiagramElement} sourceWrapper - provide the sourceWrapper value.\n * @param {number} padding - provide the padding value.\n *\n * @private\n */\nfunction createSegmentsCollection(sourceWrapper, padding) {\n    var segments = [];\n    var points = getPoints(sourceWrapper, sourceWrapper.corners, padding);\n    points.push(points[0]);\n    for (var i = 0; i < points.length - 1; i++) {\n        segments.push(createLineSegment(points[i], points[i + 1]));\n    }\n    return segments;\n}\n/**\n * createLineSegment method \\\n *\n * @returns { Segment }     createLineSegment method .\\\n * @param {PointModel} sPt - provide the sourceWrapper value.\n * @param {PointModel} tPt - provide the padding value.\n *\n * @private\n */\nfunction createLineSegment(sPt, tPt) {\n    var line = { x1: sPt.x, y1: sPt.y, x2: tPt.x, y2: tPt.y };\n    return line;\n}\n/**\n * swapBounds method \\\n *\n * @returns { Corners }     swapBounds method .\\\n * @param {PointModel} object - provide the sourceWrapper value.\n * @param {PointModel} bounds - provide the padding value.\n * @param {Rect} outerBounds - provide the padding value.\n *\n * @private\n */\nexport function swapBounds(object, bounds, outerBounds) {\n    var rectBounds;\n    var rotateAngle = object.rotateAngle + object.parentTransform;\n    if (rotateAngle) {\n        if (rotateAngle < 45) {\n            return bounds;\n        }\n        else if (rotateAngle <= 135) {\n            rectBounds = {\n                width: bounds.width, height: bounds.height,\n                topLeft: bounds.bottomLeft, topCenter: bounds.middleLeft, topRight: bounds.topLeft,\n                middleLeft: bounds.bottomCenter, center: outerBounds.center, middleRight: bounds.topCenter,\n                bottomLeft: bounds.bottomRight, bottomCenter: bounds.middleRight, bottomRight: bounds.topRight,\n                left: outerBounds.left, right: outerBounds.right, top: outerBounds.top, bottom: outerBounds.bottom\n            };\n        }\n        else if (rotateAngle <= 225) {\n            rectBounds = {\n                width: bounds.width, height: bounds.height,\n                topLeft: bounds.bottomLeft, topCenter: bounds.bottomCenter, topRight: bounds.bottomRight,\n                middleLeft: bounds.middleRight, center: outerBounds.center, middleRight: bounds.middleLeft,\n                bottomLeft: bounds.topLeft, bottomCenter: bounds.topCenter, bottomRight: bounds.topRight,\n                left: outerBounds.left, right: outerBounds.right, top: outerBounds.top,\n                bottom: outerBounds.bottom\n            };\n        }\n        else if (rotateAngle <= 315) {\n            rectBounds = {\n                width: bounds.width, height: bounds.height,\n                topLeft: bounds.topRight, topCenter: bounds.middleRight, topRight: bounds.bottomRight,\n                middleLeft: bounds.topCenter, center: outerBounds.center, middleRight: bounds.bottomCenter,\n                bottomLeft: bounds.topLeft, bottomCenter: bounds.middleLeft, bottomRight: bounds.bottomLeft,\n                left: outerBounds.left, right: outerBounds.right, top: outerBounds.top, bottom: outerBounds.bottom\n            };\n        }\n        else {\n            return bounds;\n        }\n        return rectBounds;\n    }\n    return bounds;\n}\n/**\n * defaultOrthoConnection method \\\n *\n * @returns { PointModel[] }     defaultOrthoConnection method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {Direction} srcDir - provide the srcDir value.\n * @param {Direction} tarDir - provide the srcDir value.\n * @param {PointModel} sPt - provide the sPt value.\n * @param {PointModel} tPt - provide the tPt value.\n * @param {Rect} lineDistribution - provide the padding value.\n *\n * @private\n */\n/* tslint:disable */\n// eslint-disable-next-line\nfunction defaultOrthoConnection(ele, srcDir, tarDir, sPt, tPt, lineDistribution) {\n    var sourceEle = ele.sourceWrapper;\n    var targetEle = ele.targetWrapper;\n    var srcPort = ele.sourcePortWrapper;\n    var tarPort = ele.targetPortWrapper;\n    var intermeditatePoints = [];\n    var refPoint;\n    var srcCor = sourceEle.corners;\n    // eslint-disable-next-line\n    var tarCor = targetEle.corners;\n    var point = tarCor.center; //const i: number;\n    var sourceMargin = { left: 5, right: 5, bottom: 5, top: 5 };\n    var targetMargin = { left: 5, right: 5, bottom: 5, top: 5 };\n    var source = { corners: srcCor, point: sPt, direction: srcDir, margin: sourceMargin };\n    // eslint-disable-next-line\n    var target = { corners: tarCor, point: tPt, direction: tarDir, margin: targetMargin };\n    var srcBounds = swapBounds(sourceEle, srcCor, ele.sourceWrapper.bounds);\n    var tarBounds = swapBounds(targetEle, tarCor, ele.targetWrapper.bounds);\n    var isInterSect = false;\n    if (ele.sourceWrapper && ele.targetWrapper) {\n        isInterSect = checkSourceAndTargetIntersect(ele.sourceWrapper, ele.targetWrapper, ele);\n    }\n    if (srcPort !== undefined) {\n        source.point = { x: srcPort.offsetX, y: srcPort.offsetY };\n        switch (source.direction) {\n            case 'Bottom':\n            case 'Top':\n                // eslint-disable-next-line\n                source.point.y = source.point.y;\n                break;\n            case 'Left':\n            case 'Right':\n                // eslint-disable-next-line\n                source.point.x = source.point.x;\n                break;\n        }\n        if (ele.sourcePadding && !isInterSect) {\n            if (tarPort) {\n                target.point = {\n                    x: tarPort.offsetX,\n                    y: tarPort.offsetY\n                };\n            }\n            source.point = addPaddingToConnector(ele, source, target, false);\n        }\n    }\n    else {\n        if (ele.type === 'Orthogonal') {\n            if (ele.segments && ele.segments.length > 0 && ele.segments[0].direction) {\n                source.direction = ele.segments[0].direction;\n            }\n            source.point = findPoint(srcBounds, source.direction);\n            refPoint = findPoint(srcBounds, getOppositeDirection(source.direction));\n            source.point = getIntersection(ele, sourceEle, source.point, refPoint, false);\n        }\n        else {\n            source.point = sourceEle.corners.center;\n        }\n    }\n    if (tarPort !== undefined) {\n        target.point = {\n            x: tarPort.offsetX,\n            y: tarPort.offsetY\n        };\n        switch (target.direction) {\n            case 'Bottom':\n            case 'Top':\n                // eslint-disable-next-line\n                target.point.y = target.point.y;\n                break;\n            case 'Left':\n            case 'Right':\n                // eslint-disable-next-line\n                target.point.x = target.point.x;\n                break;\n        }\n        if (ele.targetPadding && !isInterSect) {\n            target.point = addPaddingToConnector(ele, source, target, true);\n        }\n    }\n    else {\n        if (ele.type === 'Orthogonal') {\n            target.point = findPoint(tarBounds, target.direction);\n            refPoint = findPoint(tarBounds, getOppositeDirection(target.direction));\n            target.point = getIntersection(ele, targetEle, target.point, refPoint, true);\n        }\n        else {\n            target.point = targetEle.corners.center;\n        }\n    }\n    if (ele.type !== 'Orthogonal') {\n        var segment = void 0;\n        var first = void 0;\n        checkLastSegmentasTerminal(ele);\n        if (ele.sourcePortWrapper === undefined) {\n            source.point = source.corners.center;\n            if (ele.segments && ele.segments.length > 0) {\n                first = ele.segments[0];\n                segment = (!Point.isEmptyPoint(first.point)) ? first : undefined;\n            }\n            var tarPoint = (segment !== undefined) ? segment.point : target.point;\n            if (ele.type === 'Bezier' && ele.segments.length > 0 &&\n                ele.segments[0].vector1.angle && ele.segments[0].vector1.distance) {\n                var value = Math.max(source.corners.width, source.corners.height);\n                tarPoint = Point.transform(source.point, ele.segments[0].vector1.angle, value / 2);\n            }\n            source.point = isInterSect ? ele.sourceWrapper.bounds.center : getIntersection(ele, sourceEle, source.point, tarPoint, false);\n        }\n        if (ele.targetPortWrapper === undefined) {\n            target.point = target.corners.center;\n            if (ele.segments && ele.segments.length > 1) {\n                first = ele.segments[ele.segments.length - 2];\n                segment = (!Point.isEmptyPoint(first.point)) ? first : undefined;\n            }\n            var srcPoint = (segment) ? segment.point : source.point;\n            if (ele.type === 'Bezier' && ele.segments.length > 0 &&\n                ele.segments[ele.segments.length - 1].vector2.angle &&\n                ele.segments[ele.segments.length - 1].vector2.distance) {\n                var value = Math.max(source.corners.width, source.corners.height);\n                srcPoint = Point.transform(target.point, ele.segments[0].vector2.angle, value / 2);\n            }\n            target.point = isInterSect ? ele.targetWrapper.bounds.center : getIntersection(ele, targetEle, srcPoint, target.point, true);\n        }\n        intermeditatePoints = intermeditatePointsForStraight(ele, source, target);\n    }\n    else {\n        if (ele.type === 'Orthogonal' && (ele.segments && ele.segments.length > 0) &&\n            ele.segments[0].direction !== null) {\n            intermeditatePoints = findIntermeditatePoints(ele, source, target, srcPort, tarPort, sourceEle, targetEle);\n        }\n        else {\n            if (!ele.segments[0]) {\n                var segment = new OrthogonalSegment(ele, 'segments', { type: 'Orthogonal' }, true);\n                ele.segments.push(segment);\n            }\n            // eslint-disable-next-line\n            ele.segments[0].points = intermeditatePoints = findOrthoSegments(ele, source, target, undefined, lineDistribution);\n        }\n    }\n    return intermeditatePoints;\n}\n/**\n * intermeditatePointsForStraight method \\\n *\n * @returns { PointModel[] }     intermeditatePointsForStraight method .\\\n * @param {Connector} element - provide the Connector value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n *\n * @private\n */\nfunction intermeditatePointsForStraight(element, source, target) {\n    var intermeditatePoints = [];\n    if (element.segments && element.segments.length > 0) {\n        var i = void 0;\n        var segPoint = [];\n        var srcPoint = source.point;\n        for (i = 0; i < element.segments.length; i++) {\n            var seg = element.segments[i];\n            segPoint = [];\n            segPoint.push(srcPoint);\n            if (i !== element.segments.length - 1) {\n                segPoint.push(seg.point);\n                srcPoint = seg.point;\n            }\n            else {\n                segPoint.push(target.point);\n            }\n            element.segments[i].points = segPoint;\n            if (element.segments.length > 1 && Point.equals(seg.points[0], seg.points[1])) {\n                (element.segments).splice(i, 1);\n            }\n            if (seg) {\n                for (var j = 0; j < seg.points.length; j++) {\n                    if (j > 0 || i === 0) {\n                        intermeditatePoints.push(seg.points[j]);\n                    }\n                }\n            }\n        }\n    }\n    return intermeditatePoints;\n}\n/**\n * findSourceDirection method \\\n *\n * @returns { PointModel[] }     findSourceDirection method .\\\n * @param {Direction} dir - provide the dir value.\n * @param {PointModel} srcPoint - provide the srcPoint value.\n * @param {PointModel} tarPoint - provide the tarPoint value.\n *\n * @private\n */\nfunction findSourceDirection(dir, srcPoint, tarPoint) {\n    var direction = (dir === 'Top' || dir === 'Bottom') ?\n        ((tarPoint.x > srcPoint.x) ? 'Right' : 'Left') :\n        ((tarPoint.y > srcPoint.y) ? 'Bottom' : 'Top');\n    return direction;\n}\n/**\n * checkLastSegmentasTerminal method \\\n *\n * @returns { void }     checkLastSegmentasTerminal method .\\\n * @param {Connector} ele - provide the Connector value.\n *\n * @private\n */\nfunction checkLastSegmentasTerminal(ele) {\n    if (ele.type === 'Straight' || ele.type === 'Bezier') {\n        if ((ele.segments.length === 0 || (ele.segments.length > 0 &&\n            (!Point.isEmptyPoint(ele.segments[ele.segments.length - 1].point))))) {\n            //let segment: BezierSegmentModel | StraightSegmentModel;\n            var segment = (ele.type === 'Bezier') ? new BezierSegment(ele, 'segments', { type: 'Bezier' }, true) :\n                new StraightSegment(ele, 'segments', { type: 'Straight' }, true);\n            (ele.segments).push(segment);\n        }\n    }\n    else {\n        if (ele.segments.length === 0 || ele.segments[ele.segments.length - 1].direction) {\n            var segment = new OrthogonalSegment(ele, 'segments', { type: 'Orthogonal' }, true);\n            ele.segments.push(segment);\n        }\n    }\n}\n/**\n * checkConsectiveSegmentAsSame method \\\n *\n * @returns { number }     checkConsectiveSegmentAsSame method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {Connector} i - provide the Connector value.\n * @param {Connector} source - provide the Connector value.\n *\n * @private\n */\nfunction checkConsectiveSegmentAsSame(ele, i, source) {\n    var seg = ele.segments[i];\n    var extra = (seg.direction === 'Left' || seg.direction === 'Top') ? -(seg.length) : seg.length;\n    var angle = (seg.direction === 'Left' || seg.direction === 'Right') ? 0 : 90;\n    var segPoint = addLineSegment(source.point, extra, angle);\n    ele.segments[i - 1].length += seg.length;\n    ele.segments[i - 1].points[1] = source.point = segPoint;\n    ele.segments.splice(i, 1);\n    i--;\n    return i;\n}\n/**\n * nodeOrPortToNode method \\\n *\n * @returns { PointModel[] }     nodeOrPortToNode method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {End} source - provide the Connector value.\n * @param {End} target - provide the Connector value.\n *\n * @private\n */\nfunction nodeOrPortToNode(ele, source, target) {\n    var point;\n    var portdirection;\n    if (ele.sourcePortWrapper) {\n        var port = { x: ele.sourcePortWrapper.offsetX, y: ele.sourcePortWrapper.offsetY };\n        portdirection = getPortDirection(port, cornersPointsBeforeRotation(ele.sourceWrapper), ele.sourceWrapper.bounds, false);\n    }\n    findDirection(ele.targetWrapper, source, target, ele);\n    var direction = findSourceDirection(target.direction, source.point, target.point);\n    if (ele.sourcePortWrapper !== undefined && source.direction === target.direction &&\n        ((source.direction === 'Top' || source.direction === 'Bottom') && (source.corners.center.x === target.corners.center.x)\n            || (source.direction === 'Left' || source.direction === 'Right') && (source.corners.center.y === target.corners.center.y))) {\n        source.direction = direction;\n        point = (direction === 'Top' || direction === 'Bottom') ?\n            orthoConnection3Segment(ele, source, target, ele.sourceWrapper.height / 2 + 20) :\n            orthoConnection3Segment(ele, source, target, ele.sourceWrapper.width / 2 + 20);\n        var source1 = source;\n        source1.point = point[1];\n        if (direction === 'Left' || direction === 'Right') {\n            target.direction = direction;\n            target.point = (direction === 'Left') ? target.corners.middleLeft : target.corners.middleRight;\n        }\n        else {\n            findDirection(ele.targetWrapper, source, target, ele);\n        }\n        point = orthoConnection3Segment(ele, source, target);\n    }\n    else if (target.point.x >= source.corners.left && target.point.x <= source.corners.right &&\n        source.point.y >= source.corners.top && source.point.y <= source.corners.bottom) {\n        source.direction = (target.point.y > source.point.y) ? 'Bottom' : 'Top';\n        var length_2 = (source.direction === 'Top') ? (source.point.y - source.corners.top + 20) :\n            (source.corners.bottom - source.point.y + 20);\n        point = orthoConnection3Segment(ele, source, target, length_2);\n    }\n    else if (ele.sourcePortWrapper && portdirection === getOppositeDirection(direction)) {\n        var length_3;\n        if ((portdirection === 'Left' || portdirection === 'Right') && (source.point.y >= source.corners.top\n            && source.point.y <= source.corners.bottom)) {\n            source.direction = (target.point.y > source.point.y) ? 'Bottom' : 'Top';\n            length_3 = source.corners.height / 2 + 20;\n        }\n        else if ((portdirection === 'Top' || portdirection === 'Bottom') && (source.point.x >= source.corners.left\n            && source.point.x <= source.corners.right)) {\n            source.direction = (target.point.x > source.point.x) ? 'Right' : 'Left';\n            length_3 = source.corners.width / 2 + 20;\n        }\n        if (source.direction && length_3) {\n            point = orthoConnection3Segment(ele, source, target, length_3, true);\n        }\n        else {\n            source.direction = direction;\n            point = orthoConnection2Segment(source, target);\n        }\n    }\n    else if (ele.sourcePortWrapper && portdirection === target.direction && (portdirection === 'Top' || portdirection === 'Bottom') &&\n        (source.corners.center.x === target.corners.center.x)) {\n        source.direction = (target.point.y > source.point.y) ? 'Bottom' : 'Top';\n        var len = (source.direction === 'Bottom') ? (source.corners.bottom - source.point.y + 20) :\n            (source.point.y - source.corners.top + 20);\n        point = orthoConnection3Segment(ele, source, target, len);\n    }\n    else {\n        source.direction = direction;\n        point = orthoConnection2Segment(source, target);\n    }\n    return point;\n}\n/**\n * checkSourcePointInTarget method \\\n *\n * @returns { void } checkSourcePointInTarget method .\\\n * @param {Connector} ele - provide the Connector value.\n * @param {End} source - provide the Connector value.\n *\n * @private\n */\nfunction checkSourcePointInTarget(ele, source) {\n    if (ele.targetWrapper !== undefined && ele.targetPortWrapper === undefined) {\n        var padding = 1;\n        if (cornersPointsBeforeRotation(ele.targetWrapper).containsPoint(source.point, padding)) {\n            var target = ele.targetWrapper;\n            var segment = ele.segments[ele.segments.length - 2];\n            var lastPoint = segment.points[segment.points.length - 1];\n            var direction = getOppositeDirection(segment.direction);\n            if (direction === 'Bottom') {\n                if (lastPoint.y < target.corners.bottom + padding) {\n                    segment.points[segment.points.length - 1].y = target.corners.bottom + 20;\n                    segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n                }\n            }\n            else if (direction === 'Top') {\n                if (lastPoint.y > target.corners.top - padding) {\n                    segment.points[segment.points.length - 1].y = target.corners.top - 20;\n                    segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n                }\n            }\n            else if (direction === 'Left') {\n                if (lastPoint.x > target.corners.left - padding) {\n                    segment.points[segment.points.length - 1].x = target.corners.left - 20;\n                    segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n                }\n            }\n            else if (direction === 'Right') {\n                if (lastPoint.x < target.corners.right + padding) {\n                    segment.points[segment.points.length - 1].x = target.corners.right + 20;\n                    segment.length = Point.distancePoints(segment.points[0], segment.points[segment.points.length - 1]);\n                }\n            }\n            source.point = segment.points[segment.points.length - 1];\n        }\n    }\n}\n/**\n * findIntermeditatePoints method \\\n *\n * @returns { void } findIntermeditatePoints method .\\\n * @param {Connector} ele - provide the ele value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the source value.\n * @param {DiagramElement} srcPort - provide the srcPort value.\n * @param {DiagramElement} tarPort - provide the tarPort value.\n * @param {DiagramElement} sourceEle - provide the sourceEle value.\n * @param {DiagramElement} targetEle - provide the targetEle value.\n * @private\n */\nfunction findIntermeditatePoints(ele, source, target, srcPort, tarPort, sourceEle, targetEle) {\n    var point;\n    var intermeditatePoints = [];\n    var seg;\n    var j;\n    var removeSegment;\n    checkLastSegmentasTerminal(ele);\n    for (var i = 0; i < ele.segments.length; i++) {\n        seg = ele.segments[i];\n        if (srcPort && source.direction === getOppositeDirection(seg.direction)) {\n            seg.direction = source.direction;\n        }\n        if (i > 0 && ele.segments[i - 1].direction === seg.direction) {\n            i = checkConsectiveSegmentAsSame(ele, i, source);\n        }\n        else {\n            if (seg.direction) {\n                source.point = updateSegmentPoints(source, ele.segments[i]);\n            }\n            else {\n                var segment = ele.segments[i - 1];\n                source.point = segment.points[segment.points.length - 1];\n            }\n        }\n        if (i === ele.segments.length - 1) {\n            checkSourcePointInTarget(ele, source);\n            if (tarPort === undefined) {\n                point = nodeOrPortToNode(ele, source, target);\n            }\n            else {\n                point = pointToPort(ele, source, target);\n            }\n            checkPreviousSegment(point, ele, source);\n            seg.points = [];\n            if (point.length >= 2) {\n                for (j = 0; j < point.length; j++) {\n                    seg.points.push(point[j]);\n                }\n            }\n            else {\n                removeSegment = i;\n            }\n        }\n        if (removeSegment !== undefined) {\n            if (removeSegment === ele.segments.length - 1) {\n                ele.segments[removeSegment - 1].direction = null;\n                ele.segments[removeSegment - 1].length = null;\n            }\n            ele.segments.splice(removeSegment, 1);\n        }\n        if (srcPort && i === 0) {\n            var sourcePoint = checkPortdirection(ele, srcPort, sourceEle);\n            if (sourcePoint) {\n                source.point = sourcePoint;\n            }\n        }\n    }\n    return returnIntermeditatePoints(ele, intermeditatePoints);\n}\n/**\n * returnIntermeditatePoints method \\\n *\n * @returns { PointModel[] } returnIntermeditatePoints method .\\\n * @param {Connector} element - provide the ele value.\n * @param {PointModel[]} intermeditatePoints - provide the source value.\n * @private\n */\nfunction returnIntermeditatePoints(element, intermeditatePoints) {\n    for (var i = 0; i < element.segments.length; i++) {\n        var seg = element.segments[i];\n        for (var j = 0; j < seg.points.length; j++) {\n            if (j > 0 || i === 0) {\n                intermeditatePoints.push(seg.points[j]);\n            }\n        }\n    }\n    return intermeditatePoints;\n}\n/**\n * findDirection method \\\n *\n * @returns { void } findDirection method .\\\n * @param {DiagramElement} node - provide the ele value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the source value.\n * @param {Connector} ele - provide the source value.\n * @private\n */\nfunction findDirection(node, source, target, ele) {\n    var nodeDirection;\n    var nodeConnectingPoint = { x: 0, y: 0 };\n    var nodeCorners = swapBounds(node, node.corners, node.bounds);\n    var nodeMargin = source.margin;\n    var fixedPoint = source.point;\n    if (nodeCorners.bottomCenter.y + nodeMargin.bottom < fixedPoint.y) {\n        nodeDirection = 'Bottom';\n        nodeConnectingPoint = nodeCorners.bottomCenter;\n    }\n    else if (nodeCorners.topCenter.y - nodeMargin.top > fixedPoint.y) {\n        nodeDirection = 'Top';\n        nodeConnectingPoint = nodeCorners.topCenter;\n    }\n    else if (nodeCorners.middleLeft.x - nodeMargin.left > fixedPoint.x) {\n        nodeDirection = 'Left';\n        nodeConnectingPoint = nodeCorners.middleLeft;\n    }\n    else if (nodeCorners.middleRight.x + nodeMargin.right < fixedPoint.x) {\n        nodeDirection = 'Right';\n        nodeConnectingPoint = nodeCorners.middleRight;\n    }\n    else {\n        var top_1 = Math.abs(fixedPoint.y - nodeCorners.topCenter.y);\n        var right = Math.abs(fixedPoint.x - nodeCorners.middleRight.x);\n        var bottom = Math.abs(fixedPoint.y - nodeCorners.bottomCenter.y);\n        var left = Math.abs(fixedPoint.x - nodeCorners.middleLeft.x);\n        var shortes = Number.MAX_VALUE;\n        shortes = top_1;\n        nodeDirection = 'Top';\n        nodeConnectingPoint = nodeCorners.topCenter;\n        if (shortes > right) {\n            shortes = right;\n            nodeDirection = 'Right';\n            nodeConnectingPoint = nodeCorners.middleRight;\n        }\n        if (shortes > bottom) {\n            shortes = bottom;\n            nodeDirection = 'Bottom';\n            nodeConnectingPoint = nodeCorners.bottomCenter;\n        }\n        if (shortes > left) {\n            //shortes = left;\n            nodeDirection = 'Left';\n            nodeConnectingPoint = nodeCorners.middleLeft;\n        }\n    }\n    target.point = nodeConnectingPoint;\n    target.direction = nodeDirection;\n    var refPoint = findPoint(nodeCorners, getOppositeDirection(target.direction));\n    target.point = getIntersection(ele, node, target.point, refPoint, node === ele.targetWrapper);\n}\n/**\n * findOrthoSegments method \\\n *\n * @returns { PointModel[] } findOrthoSegments method .\\\n * @param {DiagramElement} ele - provide the ele value.\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target value.\n * @param {Connector} extra - provide the extra value.\n * @param {boolean} lineDistribution - provide the lineDistribution value.\n * @private\n */\nfunction findOrthoSegments(ele, source, target, extra, lineDistribution) {\n    var swap = false;\n    var intermeditatePoints = [];\n    var seg;\n    swap = getSwapping(source.direction, target.direction);\n    if (swap) {\n        swapPoints(source, target);\n    }\n    if (source.direction === 'Right' && target.direction === 'Left') {\n        seg = getRightToLeftSegmentCount(ele, source, target, swap);\n    }\n    else if (source.direction === 'Right' && target.direction === 'Right') {\n        seg = getRightToRightSegmentCount(ele, source, target);\n    }\n    else if (source.direction === 'Right' && target.direction === 'Top') {\n        seg = getRightToTopSegmentCount(ele, source, target, swap);\n    }\n    else if (source.direction === 'Right' && target.direction === 'Bottom') {\n        seg = getRightToBottomSegmentCount(ele, source, target, swap);\n    }\n    else if (source.direction === 'Bottom' && target.direction === 'Top') {\n        seg = getBottomToTopSegmentCount(source, target);\n    }\n    else if (source.direction === 'Bottom' && target.direction === 'Bottom') {\n        source.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n        target.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n        seg = getBottomToBottomSegmentCount(ele, source, target);\n    }\n    else if (source.direction === 'Bottom' && target.direction === 'Left') {\n        seg = getBottomToLeftSegmentCount(ele, source, target, swap);\n    }\n    else if (source.direction === 'Left' && target.direction === 'Left') {\n        seg = getLeftToLeftSegmentCount(ele, source, target);\n    }\n    else if (source.direction === 'Left' && target.direction === 'Top') {\n        seg = getLeftToTopSegmentCount(ele, source, target, swap);\n    }\n    else if (source.direction === 'Top' && target.direction === 'Top') {\n        seg = getTopToTopSegmentCount(ele, source, target);\n    }\n    if (swap) {\n        swapPoints(source, target);\n    }\n    intermeditatePoints = addOrthoSegments(ele, seg, source, target, extra, lineDistribution);\n    return intermeditatePoints;\n}\n/**\n * findAngle method \\\n *\n * @returns { number } findAngle method .\\\n * @param {DiagramElement} s - provide the s value.\n * @param {End} e - provide the e value.\n * @private\n */\nexport function findAngle(s, e) {\n    var r = { x: e.x, y: s.y };\n    //const sr: number = Point.findLength(s, r);\n    var re = Point.findLength(r, e);\n    var es = Point.findLength(e, s);\n    var ang = Math.asin(re / es);\n    ang = ang * 180 / Math.PI;\n    if (s.x < e.x) {\n        if (s.y > e.y) {\n            ang = 360 - ang;\n        }\n    }\n    else {\n        if (s.y < e.y) {\n            ang = 180 - ang;\n        }\n        else {\n            ang = 180 + ang;\n        }\n    }\n    return ang;\n}\n/**\n * findPoint method \\\n *\n * @returns { number } findPoint method .\\\n * @param {Corners} cor - provide the cor value.\n * @param {string} direction - provide the direction value.\n * @private\n */\nexport function findPoint(cor, direction) {\n    var point;\n    switch (direction) {\n        case 'Left':\n            point = cor.middleLeft;\n            break;\n        case 'Top':\n            point = cor.topCenter;\n            break;\n        case 'Right':\n            point = cor.middleRight;\n            break;\n        case 'Bottom':\n            point = cor.bottomCenter;\n            break;\n    }\n    return point;\n}\n/**\n * pointsFromNodeToPoint method \\\n *\n * @returns { number } pointsFromNodeToPoint method .\\\n * @param {OrthogonalSegment} seg - provide the seg value.\n * @param {string} direction - provide the direction value.\n * @param {Rect} bounds - provide the bounds value.\n * @param {PointModel} point - provide the point value.\n * @param {PointModel} endPoint - provide the endPoint value.\n * @param {boolean} isTarget - provide the isTarget value.\n * @private\n */\nfunction pointsFromNodeToPoint(seg, direction, bounds, point, endPoint, isTarget) {\n    var minSpace = 13;\n    var x;\n    var points = [];\n    var y;\n    points.push(point);\n    //let straight: boolean;\n    var straight = (point.y === endPoint.y && (direction === 'Left' && endPoint.x < point.x ||\n        direction === 'Right' && endPoint.x > point.x)) ||\n        (point.x === endPoint.x && (direction === 'Top' && endPoint.y < point.y ||\n            direction === 'Bottom' && endPoint.y > point.y));\n    if (!straight) {\n        if (direction === 'Top' || direction === 'Bottom') {\n            if (direction === 'Top' && endPoint.y < point.y && endPoint.y > point.y - minSpace ||\n                direction === 'Bottom' && endPoint.y > point.y && endPoint.y < point.y + minSpace) {\n                y = direction === 'Top' ? bounds.top - minSpace : bounds.bottom + minSpace;\n                points.push({ x: point.x, y: y });\n                points.push({ x: point.x + (endPoint.x - point.x) / 2, y: y });\n                points.push({ x: point.x + (endPoint.x - point.x) / 2, y: endPoint.y });\n            }\n            else if (Math.abs(point.x - endPoint.x) > minSpace &&\n                (direction === 'Top' && endPoint.y < point.y || direction === 'Bottom' && endPoint.y > point.y)) {\n                //twosegments\n                points.push({ x: point.x, y: endPoint.y });\n            }\n            else {\n                y = direction === 'Top' ? bounds.top - minSpace : bounds.bottom + minSpace;\n                x = (endPoint.x < point.x) ? bounds.left - minSpace : bounds.right + minSpace;\n                points.push({ x: point.x, y: y });\n                points.push({ x: endPoint.x, y: y });\n            }\n        }\n        else {\n            if (direction === 'Left' && endPoint.x < point.x && endPoint.x > point.x - minSpace || direction === 'right' &&\n                endPoint.x > point.x && endPoint.x < point.x + minSpace) {\n                x = direction === 'Left' ? bounds.left - minSpace : bounds.right + minSpace;\n                points.push({ x: x, y: point.y });\n                points.push({ x: x, y: point.y + (endPoint.y - point.y) / 2 });\n                points.push({ x: endPoint.x, y: point.y + (endPoint.y - point.y) / 2 });\n            }\n            else if (Math.abs(point.y - endPoint.y) > minSpace &&\n                (direction === 'Left' && endPoint.x < point.x || direction === 'Right' && endPoint.x > point.x)) {\n                points.push({ x: endPoint.x, y: point.y });\n                //twosegments\n            }\n            else {\n                x = direction === 'Left' ? bounds.left - minSpace : bounds.right + minSpace;\n                points.push({ x: x, y: point.y });\n                points.push({ x: x, y: endPoint.y });\n            }\n        }\n        if (isTarget) {\n            points.push(seg.points[0]);\n            points.reverse();\n        }\n        seg.points = points;\n    }\n}\n/**\n * addLineSegment method \\\n *\n * @returns { PointModel } addLineSegment method .\\\n * @param {PointModel} point - provide the seg value.\n * @param {number} extra - provide the direction value.\n * @param {number} angle - provide the bounds value.\n * @private\n */\nfunction addLineSegment(point, extra, angle) {\n    var segEnd = Point.transform(point, angle, extra);\n    return segEnd;\n}\n/**\n * getIntersection method \\\n *\n * @returns { PointModel } getIntersection method .\\\n * @param {PointModel} ele - provide the ele value.\n * @param {number} bounds - provide the bounds value.\n * @param {number} sPt - provide the sPt value.\n * @param {number} tPt - provide the tPt value.\n * @param {number} isTar - provide the isTar value.\n * @private\n */\nexport function getIntersection(ele, bounds, sPt, tPt, isTar) {\n    sPt = { x: sPt.x, y: sPt.y };\n    tPt = { x: tPt.x, y: tPt.y };\n    //const angle: number = Point.findAngle(tPt, sPt); ///let child: PathElement;// let intersection: PointModel;\n    var wrapper = isTar ? ele.targetWrapper : ele.sourceWrapper;\n    var padding = (isTar ? ele.targetPadding : ele.sourcePadding);\n    var rect;\n    var segmentPoints;\n    var point = isTar || ele.type === 'Orthogonal' ? sPt : tPt;\n    //const sourcePoint: PointModel = Point.transform(sPt, angle, Math.max(wrapper.actualSize.height / 2, wrapper.actualSize.width / 2));\n    var child = wrapper;\n    var sPt1 = rotatePoint(-wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, sPt);\n    var tPt1 = rotatePoint(-wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, tPt);\n    if (ele.type === 'Orthogonal') {\n        var constValue = 5;\n        if (sPt1.x === tPt1.x) {\n            if (sPt1.y < tPt1.y) {\n                sPt1.y -= constValue;\n            }\n            else {\n                sPt1.y += constValue;\n            }\n        }\n        if (sPt1.y === tPt1.y) {\n            if (sPt1.x < tPt1.x) {\n                sPt1.x -= constValue;\n            }\n            else {\n                sPt1.x += constValue;\n            }\n        }\n        sPt = rotatePoint(wrapper.parentTransform, wrapper.offsetX, wrapper.offsetY, sPt1);\n    }\n    else {\n        //const angle: number = isTar ? Point.findAngle(sPt, tPt) : Point.findAngle(tPt, sPt);\n        if (isTar) {\n            var angle = Point.findAngle(sPt, tPt);\n            tPt = Point.transform({ x: tPt.x, y: tPt.y }, angle, Math.max(wrapper.actualSize.width, wrapper.actualSize.height));\n        }\n        else {\n            var angle = Point.findAngle(tPt, sPt);\n            sPt = Point.transform({ x: sPt.x, y: sPt.y }, angle, Math.max(wrapper.actualSize.width, wrapper.actualSize.height));\n        }\n    }\n    if ((ele.sourcePadding || ele.targetPadding)) {\n        rect = new Rect(wrapper.bounds.x - padding, wrapper.bounds.y - padding, wrapper.actualSize.width + 2 * padding, wrapper.actualSize.height + 2 * padding);\n    }\n    if (wrapper instanceof PathElement && wrapper.data) {\n        segmentPoints = rect ? [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft] : child.getPoints();\n        if (((child.data.split('m').length - 1) + (child.data.split('M').length - 1)) === 1) {\n            segmentPoints[segmentPoints.length] = segmentPoints[0];\n        }\n    }\n    else {\n        segmentPoints = rect ? [rect.topLeft, rect.topRight, rect.bottomRight, rect.bottomLeft] : getPoints(wrapper, wrapper.corners);\n        segmentPoints[segmentPoints.length] = segmentPoints[0];\n    }\n    //const length: number = segmentPoints.length;\n    var thisSegment = { x1: sPt.x, y1: sPt.y, x2: tPt.x, y2: tPt.y };\n    return getIntersectionPoints(thisSegment, segmentPoints, true, point) || sPt;\n}\n/**\n * setLineEndPoint method \\\n *\n * @returns { PointModel } setLineEndPoint method .\\\n * @param {PointModel} element - provide the ele value.\n * @param {number} point - provide the bounds value.\n * @param {number} isTarget - provide the sPt value.\n * @private\n */\nfunction setLineEndPoint(element, point, isTarget) {\n    point.x = Math.round(point.x * 100) / 100;\n    point.y = Math.round(point.y * 100) / 100;\n    if (isTarget) {\n        element.targetPoint = point;\n    }\n    else {\n        element.sourcePoint = point;\n    }\n    return point;\n}\n/**\n * getIntersectionPoints method \\\n *\n * @returns { PointModel } getIntersectionPoints method .\\\n * @param {Segment} thisSegment - provide the ele value.\n * @param {Object[]} pts - provide the bounds value.\n * @param {boolean} minimal - provide the sPt value.\n * @param {PointModel} point - provide the sPt value.\n * @private\n */\nexport function getIntersectionPoints(thisSegment, pts, minimal, point) {\n    var length = pts.length;\n    var min;\n    var segment = {\n        x1: pts[0].x, y1: pts[0].y, x2: pts[1].x,\n        y2: pts[1].y\n    };\n    var intersection = intersectSegment(thisSegment, segment);\n    if (intersection) {\n        // if (!minimal) { return intersection; } //commented because minimal is always true\n        min = Point.distancePoints(intersection, point);\n    }\n    if (isNaN(min) || min > 0) {\n        for (var i = 1; i < length - 1; i++) {\n            segment = {\n                x1: pts[i].x, y1: pts[i].y,\n                x2: pts[i + 1].x, y2: pts[i + 1].y\n            };\n            var intersect = intersectSegment(thisSegment, segment);\n            if (intersect) {\n                // if (!minimal) { return intersect; }//commented because minimal is always true\n                var dist = Point.distancePoints(intersect, point);\n                if (isNaN(min) || min > dist) {\n                    min = dist;\n                    intersection = intersect;\n                }\n                if (min >= 0 && min <= 1) {\n                    break;\n                }\n            }\n        }\n    }\n    return intersection;\n}\n/**\n * intersectSegment method \\\n *\n * @returns { PointModel } intersectSegment method .\\\n * @param {Segment} segment1 - provide the ele value.\n * @param {Segment} segment2 - provide the bounds value.\n * @private\n */\nfunction intersectSegment(segment1, segment2) {\n    var x1 = segment1.x1;\n    var y1 = segment1.y1;\n    var x2 = segment1.x2;\n    var y2 = segment1.y2;\n    var x3 = segment2.x1;\n    var y3 = segment2.y1;\n    var x4 = segment2.x2;\n    var y4 = segment2.y2;\n    var a1;\n    var a2;\n    var b1;\n    var b2;\n    var c1;\n    var c2;\n    var x;\n    var y;\n    var r1;\n    var r2;\n    var r3;\n    var r4;\n    var offset;\n    var num;\n    // eslint-disable-next-line\n    a1 = y2 - y1;\n    b1 = x1 - x2;\n    c1 = (x2 * y1) - (x1 * y2);\n    // eslint-disable-next-line\n    r3 = ((a1 * x3) + (b1 * y3) + c1);\n    r4 = ((a1 * x4) + (b1 * y4) + c1);\n    if ((r3 !== 0) && (r4 !== 0) && sameSign(r3, r4)) {\n        return null;\n    }\n    // eslint-disable-next-line\n    a2 = y4 - y3;\n    b2 = x3 - x4;\n    c2 = (x4 * y3) - (x3 * y4);\n    // eslint-disable-next-line\n    r1 = (a2 * x1) + (b2 * y1) + c2;\n    r2 = (a2 * x2) + (b2 * y2) + c2;\n    if ((r1 !== 0) && (r2 !== 0) && (sameSign(r1, r2))) {\n        return null;\n    }\n    var denom = (a1 * b2) - (a2 * b1);\n    if (denom === 0) {\n        return null;\n    }\n    if (denom < 0) {\n        offset = -denom / 2;\n    }\n    else {\n        offset = denom / 2;\n    }\n    offset = 0;\n    num = (b1 * c2) - (b2 * c1);\n    if (num < 0) {\n        x = (num - offset) / denom;\n    }\n    else {\n        x = (num + offset) / denom;\n    }\n    num = (a2 * c1) - (a1 * c2);\n    if (num < 0) {\n        y = (num - offset) / denom;\n    }\n    else {\n        y = (num + offset) / denom;\n    }\n    return { x: x, y: y };\n}\n/**\n * sameSign method \\\n *\n * @returns { boolean } sameSign method .\\\n * @param {Connector} a - provide the Connector value.\n * @param {End} b - provide the source End value.\n * @private\n */\nfunction sameSign(a, b) {\n    return ((a * b) >= 0);\n}\n/**\n * getRightToLeftSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToLeftSegmentCount method .\\\n * @param {Connector} element - provide the Connector value.\n * @param {End} source - provide the source End value.\n * @param {End} target - provide the target  End value.\n * @param {boolean} swap - provide the swap value.\n * @private\n */\nfunction getRightToLeftSegmentCount(element, source, target, swap) {\n    var srcPort = element.sourcePortWrapper;\n    //let targetPort: DiagramElement = element.targetPortWrapper;\n    var pts;\n    var diffY = Math.round(Math.abs(source.point.y - target.point.y));\n    //let diffX: number = Math.round(Math.abs(source.point.x - target.point.x));\n    var right = { x: Math.max(source.point.x, source.corners.right), y: source.point.y };\n    var left = { x: Math.min(target.point.x, target.corners.left), y: target.point.y };\n    var margin = 10;\n    if (swap) {\n        //let point: PointModel;\n        var point = left;\n        left = right;\n        right = point;\n    }\n    if (!(source.corners.bottom + margin < target.corners.top - margin ||\n        source.corners.top - margin > target.corners.bottom + margin)) {\n        margin = 0;\n    }\n    source.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    if (diffY === 0 && (source.corners.right < target.corners.left\n        || (swap && source.corners.right < target.corners.left))) {\n        pts = NoOfSegments.One;\n    }\n    else if (source.point.x + source.margin.right < target.point.x - target.margin.left) {\n        pts = NoOfSegments.Three;\n    }\n    else if (element.sourceWrapper !== element.targetWrapper &&\n        (cornersPointsBeforeRotation(element.sourceWrapper).containsPoint(left) ||\n            cornersPointsBeforeRotation(element.targetWrapper).containsPoint(right))) {\n        pts = NoOfSegments.Three;\n    }\n    else if (source.corners.bottom <= target.corners.top) {\n        pts = NoOfSegments.Five;\n    }\n    else if (source.corners.top >= target.corners.top) {\n        pts = NoOfSegments.Five;\n    }\n    else if ((srcPort !== undefined && srcPort.offsetY <= target.corners.top) ||\n        (srcPort === undefined && source.corners.right <= target.corners.top)) {\n        pts = NoOfSegments.Five;\n    }\n    else if ((srcPort !== undefined && srcPort.offsetY >= target.corners.bottom) ||\n        (srcPort === undefined && source.corners.right >= target.corners.bottom)) {\n        pts = NoOfSegments.Five;\n    }\n    else {\n        pts = NoOfSegments.Five;\n    }\n    return pts;\n}\n/**\n * getRightToRightSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToRightSegmentCount method .\\\n * @param {Connector} element - provide the Connector value.\n * @param {End} sourceObj - provide the source End value.\n * @param {End} targetObj - provide the target  End value.\n * @private\n */\nfunction getRightToRightSegmentCount(element, sourceObj, targetObj) {\n    var sourcePort = element.sourcePortWrapper;\n    var tarPort = element.targetPortWrapper;\n    var pts;\n    var diffX = sourceObj.point.x - targetObj.point.x;\n    var diffY = sourceObj.point.y - targetObj.point.y;\n    targetObj.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n    sourceObj.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n    if (sourceObj.corners.right >= targetObj.corners.right) {\n        if ((sourcePort !== undefined && (sourcePort.offsetY < targetObj.corners.top ||\n            sourcePort.offsetY > targetObj.corners.bottom)) ||\n            (sourcePort === undefined && sourceObj.corners.middleRight.y < targetObj.corners.top)) {\n            pts = NoOfSegments.Three;\n        }\n        else if ((sourcePort !== undefined && sourcePort.offsetY > targetObj.corners.bottom + targetObj.margin.bottom\n            && sourceObj.corners.top > targetObj.corners.bottom) ||\n            (sourcePort === undefined && sourceObj.corners.middleRight.y > targetObj.corners.bottom)) {\n            pts = NoOfSegments.Three;\n        }\n        else if ((sourcePort !== undefined && sourcePort.offsetY < targetObj.corners.top\n            && sourceObj.corners.bottom > targetObj.corners.top) ||\n            (sourcePort === undefined && sourceObj.corners.middleRight.y > targetObj.corners.bottom)) {\n            pts = NoOfSegments.Three;\n        }\n        else if (sourceObj.corners.right < targetObj.corners.left ||\n            targetObj.corners.right < sourceObj.corners.left) {\n            pts = NoOfSegments.Five;\n        }\n        else if (diffX === 0 || diffY === 0) {\n            pts = NoOfSegments.One;\n        }\n        else {\n            pts = NoOfSegments.Three;\n        }\n    }\n    else if ((tarPort !== undefined && sourceObj.corners.bottom < tarPort.offsetY) ||\n        (tarPort === undefined && sourceObj.corners.bottom < targetObj.corners.middleRight.y)) {\n        pts = NoOfSegments.Three;\n    }\n    else if ((tarPort !== undefined && sourceObj.corners.top > tarPort.offsetY) ||\n        (tarPort === undefined && sourceObj.corners.top > targetObj.corners.middleRight.y)) {\n        pts = NoOfSegments.Three;\n    }\n    else if ((tarPort !== undefined && ((sourcePort !== undefined && sourcePort.offsetX < targetObj.corners.left &&\n        sourcePort.offsetX !== tarPort.offsetX && sourcePort.offsetY !== tarPort.offsetY &&\n        (Math.abs(sourceObj.corners.right - targetObj.corners.left) <= 20)) ||\n        (sourcePort === undefined && sourceObj.corners.right < targetObj.corners.left &&\n            sourceObj.corners.center.x !== targetObj.corners.center.x && sourceObj.corners.center.y !== targetObj.corners.center.y)))) {\n        pts = NoOfSegments.Three;\n    }\n    else if (sourceObj.corners.right < targetObj.corners.left) {\n        pts = NoOfSegments.Five;\n    }\n    else if (diffX === 0 || diffY === 0) {\n        pts = NoOfSegments.One;\n    }\n    else {\n        pts = NoOfSegments.Three;\n    }\n    return pts;\n}\n/**\n * getRightToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToTopSegmentCount method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap value.\n * @private\n */\nfunction getRightToTopSegmentCount(element, source, target, swap) {\n    var tarPort = element.targetPortWrapper;\n    var srcPort = element.sourcePortWrapper;\n    var right = { x: Math.max(source.point.x, source.corners.right), y: source.point.y };\n    var top = { x: target.point.x, y: Math.min(target.point.y, target.corners.top) };\n    var pts;\n    target.margin = { left: 5, right: 5, top: 5, bottom: 5 };\n    source.margin = { top: 5, bottom: 5, left: 5, right: 5 };\n    if (swap) {\n        //let port: DiagramElement;\n        var port = srcPort;\n        srcPort = tarPort;\n        tarPort = port;\n    }\n    if ((srcPort !== undefined && srcPort.offsetY < target.corners.top - target.margin.top) ||\n        (srcPort === undefined && source.corners.bottom < target.corners.top - target.margin.top)) {\n        if (source.corners.bottom < target.corners.top) {\n            if ((tarPort !== undefined && source.corners.right + source.margin.right < tarPort.offsetX) ||\n                (tarPort === undefined && source.corners.right + source.margin.right < target.corners.topCenter.x)) {\n                pts = NoOfSegments.Two;\n            }\n            else {\n                pts = NoOfSegments.Four;\n            }\n        }\n        else if ((tarPort !== undefined && source.corners.left > tarPort.offsetX) ||\n            (tarPort === undefined && source.corners.left > target.corners.topCenter.x)) {\n            pts = NoOfSegments.Four;\n        }\n        else {\n            pts = NoOfSegments.Two;\n        }\n    }\n    else if (srcPort !== undefined && Math.abs(source.corners.right - target.corners.left) <= 25 &&\n        Math.abs(srcPort.offsetY - target.corners.top) <= 25) {\n        pts = NoOfSegments.Two;\n    }\n    else if (tarPort !== undefined && Math.abs(tarPort.offsetX - source.corners.topCenter.x) >= 25 &&\n        source.corners.middleRight.y < tarPort.offsetY) {\n        pts = NoOfSegments.Two;\n    }\n    else if (source.corners.right < target.corners.left) {\n        pts = NoOfSegments.Four;\n    }\n    else if (element.sourceWrapper !== element.targetWrapper &&\n        (cornersPointsBeforeRotation(element.sourceWrapper).containsPoint(top) ||\n            cornersPointsBeforeRotation(element.targetWrapper).containsPoint(right))) {\n        pts = NoOfSegments.Two;\n    }\n    else {\n        pts = NoOfSegments.Four;\n    }\n    return pts;\n}\n/**\n * getRightToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getRightToTopSegmentCount method .\\\n * @param {Connector} element - provide the element value.\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap value.\n * @private\n */\nfunction getRightToBottomSegmentCount(element, source, target, swap) {\n    source.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n    target.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n    var pts;\n    var srcPort = element.sourcePortWrapper;\n    var tarPort = element.targetPortWrapper;\n    //let right: PointModel = { x: Math.max(source.point.x, source.corners.right), y: source.point.y };\n    //let bottom: PointModel = { x: target.point.x, y: Math.max(target.point.y, target.corners.bottom) };\n    if (swap) {\n        //let port: DiagramElement;\n        var port = srcPort;\n        srcPort = tarPort;\n        tarPort = port;\n    }\n    if ((srcPort !== undefined && srcPort.offsetY > target.corners.bottom + target.margin.bottom) ||\n        (srcPort === undefined && source.corners.middleRight.y > target.corners.bottom + target.margin.bottom)) {\n        if (source.corners.top > target.corners.bottom) {\n            if ((tarPort !== undefined && source.corners.right + source.margin.right < tarPort.offsetX) ||\n                (tarPort === undefined && source.corners.right + source.margin.right < target.corners.bottomCenter.x)) {\n                pts = NoOfSegments.Two;\n            }\n            else {\n                pts = NoOfSegments.Four;\n            }\n        }\n        else if ((tarPort !== undefined && source.corners.left > tarPort.offsetX) ||\n            (tarPort === undefined && source.corners.left > target.corners.bottomCenter.x)) {\n            pts = NoOfSegments.Four;\n        }\n        else {\n            pts = NoOfSegments.Two;\n        }\n    }\n    else if (srcPort !== undefined &&\n        Math.abs(source.corners.right - target.corners.left) <= 25 &&\n        Math.abs(srcPort.offsetY - target.corners.bottom) <= 25) {\n        pts = NoOfSegments.Two;\n    }\n    else if (source.corners.right < target.corners.left) {\n        pts = NoOfSegments.Four;\n    }\n    else {\n        pts = NoOfSegments.Four;\n    }\n    return pts;\n}\n/**\n * getBottomToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getBottomToTopSegmentCount method .\\\n * @param {End} source - provide the source value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction getBottomToTopSegmentCount(source, target) {\n    var pts;\n    var diffX = source.point.x - target.point.x;\n    //const diffY: number = source.point.y - target.point.y;\n    //let bottom: PointModel = { x: source.point.x, y: Math.max(source.point.y, source.corners.bottom) };\n    //let top: PointModel = { x: target.point.x, y: Math.min(target.point.y, target.corners.top) };\n    var margin = 10;\n    if (!(source.corners.right + margin < target.corners.left - margin ||\n        source.corners.left - margin > target.corners.right + margin)) {\n        margin = 0;\n    }\n    source.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    target.margin = { left: margin, right: margin, top: margin, bottom: margin };\n    if (diffX === 0 && source.corners.bottom < target.corners.top) {\n        pts = NoOfSegments.One;\n    }\n    else if (source.corners.bottom + source.margin.bottom < target.corners.top - target.margin.top) {\n        pts = NoOfSegments.Three;\n    }\n    else if (source.corners.right + source.margin.right < target.corners.left - target.margin.left) {\n        pts = NoOfSegments.Five;\n    }\n    else if (source.corners.left - source.margin.left > target.corners.right + target.margin.right) {\n        pts = NoOfSegments.Five;\n    }\n    else {\n        pts = NoOfSegments.Five;\n    }\n    return pts;\n}\n/**\n * getBottomToLeftSegmentCount method \\\n *\n * @returns { NoOfSegments } getBottomToLeftSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap  value.\n * @private\n */\nfunction getBottomToLeftSegmentCount(element, source, target, swap) {\n    var srcPort = element.sourcePortWrapper;\n    var tarPort = element.targetPortWrapper;\n    //let bottom: PointModel = { x: source.point.x, y: Math.max(source.point.y, source.corners.bottom) };\n    //let left: PointModel = { x: Math.min(target.point.x, target.corners.left), y: target.point.y };\n    var pts;\n    if (swap) {\n        //let port: DiagramElement;\n        var port = srcPort;\n        srcPort = tarPort;\n        tarPort = port;\n    }\n    if ((srcPort !== undefined && srcPort.offsetX < target.corners.left - target.margin.left) ||\n        (srcPort === undefined && source.corners.bottomCenter.x < target.corners.bottomLeft.x - target.margin.left)) {\n        if (source.corners.right < target.corners.left) {\n            if ((tarPort !== undefined && source.corners.bottom + source.margin.bottom < tarPort.offsetY) ||\n                (tarPort === undefined && source.corners.bottom + source.margin.bottom < target.corners.middleLeft.y)) {\n                pts = NoOfSegments.Two;\n            }\n            else {\n                pts = NoOfSegments.Four;\n            }\n        }\n        else if ((tarPort !== undefined && source.corners.top > tarPort.offsetY) ||\n            (tarPort === undefined && source.corners.top > target.corners.middleLeft.y)) {\n            pts = NoOfSegments.Four;\n        }\n        else {\n            pts = NoOfSegments.Two;\n        }\n    }\n    else if (tarPort !== undefined &&\n        Math.abs(source.corners.right - target.corners.left) <= 25 &&\n        Math.abs(tarPort.offsetY - source.corners.bottom) <= 25) {\n        pts = NoOfSegments.Two;\n    }\n    else {\n        pts = NoOfSegments.Four;\n    }\n    return pts;\n}\n/**\n * getBottomToBottomSegmentCount method \\\n *\n * @returns { NoOfSegments } getBottomToBottomSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction getBottomToBottomSegmentCount(element, source, target) {\n    var srcPort = element.sourcePortWrapper;\n    var tarPort = element.targetPortWrapper;\n    var difX = Math.round(Math.abs(source.point.x - target.point.x));\n    var diffY = Math.round(Math.abs(target.point.y - target.point.y));\n    var pts;\n    if (source.corners.bottom < target.corners.bottom) {\n        if ((srcPort !== undefined && srcPort.offsetX < target.corners.left - target.margin.left) ||\n            (srcPort === undefined && source.corners.bottomCenter.x < target.corners.left - target.margin.left)) {\n            pts = NoOfSegments.Three;\n        }\n        else if ((srcPort !== undefined && srcPort.offsetX > target.corners.right + target.margin.right) ||\n            (srcPort === undefined && source.corners.bottomCenter.x > target.corners.right + target.margin.right)) {\n            pts = NoOfSegments.Three;\n        }\n        else if (source.corners.bottom < target.corners.top) {\n            pts = NoOfSegments.Five;\n        }\n        else if (difX === 0 || diffY === 0) {\n            pts = NoOfSegments.One;\n        }\n        else {\n            pts = NoOfSegments.Three;\n        }\n    }\n    else if ((tarPort !== undefined && source.corners.left > tarPort.offsetX) ||\n        (tarPort === undefined && source.corners.left > target.corners.left)) {\n        pts = NoOfSegments.Three;\n    }\n    else if ((tarPort !== undefined && source.corners.right < tarPort.offsetX) ||\n        (tarPort === undefined &&\n            source.corners.right < target.corners.right)) {\n        pts = NoOfSegments.Three;\n    }\n    else if (source.corners.top > target.corners.bottom) {\n        pts = NoOfSegments.Five;\n    }\n    else if (difX === 0 || diffY === 0) {\n        pts = NoOfSegments.One;\n    }\n    else {\n        pts = NoOfSegments.Three;\n    }\n    return pts;\n}\n/**\n * getLeftToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getLeftToTopSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {End} swap - provide the swap  value.\n * @private\n */\nfunction getLeftToTopSegmentCount(element, source, target, swap) {\n    var pts;\n    var sourcePort = element.sourcePortWrapper;\n    var tarPort = element.targetPortWrapper;\n    var left = { x: Math.min(source.point.x, source.corners.left), y: source.point.y };\n    var top = { x: target.point.x, y: Math.min(target.point.y, target.corners.top) };\n    if (swap) {\n        //let port: DiagramElement;\n        var port = sourcePort;\n        sourcePort = tarPort;\n        tarPort = port;\n    }\n    if ((sourcePort !== undefined && sourcePort.offsetY < target.corners.top - target.margin.top) ||\n        (sourcePort === undefined && (source.corners.bottom < target.corners.top - target.margin.top ||\n            source.corners.middleLeft.y < target.corners.top - target.margin.top))) {\n        if (source.corners.bottom < target.corners.top) {\n            if ((tarPort !== undefined && source.corners.left - source.margin.left > tarPort.offsetX) ||\n                (tarPort === undefined && source.corners.left - source.margin.left > target.corners.topCenter.x)) {\n                pts = NoOfSegments.Two;\n            }\n            else {\n                pts = NoOfSegments.Four;\n            }\n        }\n        else if ((tarPort !== undefined && source.corners.right < tarPort.offsetX) ||\n            (tarPort === undefined && source.corners.right < target.corners.topCenter.x)) {\n            pts = NoOfSegments.Four;\n        }\n        else {\n            pts = NoOfSegments.Two;\n        }\n    }\n    else if (sourcePort !== undefined &&\n        Math.abs(source.corners.left - target.corners.right) <= 25 &&\n        Math.abs(sourcePort.offsetY - target.corners.top) <= 25) {\n        pts = NoOfSegments.Two;\n    }\n    else if (element.sourceWrapper !== element.targetWrapper &&\n        (cornersPointsBeforeRotation(element.sourceWrapper).containsPoint(top) ||\n            cornersPointsBeforeRotation(element.targetWrapper).containsPoint(left))) {\n        pts = NoOfSegments.Two;\n    }\n    else if (source.corners.left > target.corners.right) {\n        pts = NoOfSegments.Four;\n    }\n    else {\n        pts = NoOfSegments.Four;\n    }\n    return pts;\n}\n/**\n * getLeftToLeftSegmentCount method \\\n *\n * @returns { NoOfSegments } getLeftToLeftSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction getLeftToLeftSegmentCount(element, source, target) {\n    var srcPort = element.sourcePortWrapper;\n    var targetPort = element.targetPortWrapper;\n    source.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n    target.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n    var diffX = Math.round(Math.abs(source.point.x - target.point.x));\n    var diffY = Math.round(Math.abs(source.point.y - target.point.y));\n    var pts;\n    if (source.corners.left < target.corners.left) {\n        if ((targetPort !== undefined && source.corners.bottom + source.margin.bottom < targetPort.offsetY) ||\n            (targetPort === undefined && source.corners.bottom + source.margin.bottom < target.corners.middleLeft.y)) {\n            pts = NoOfSegments.Three;\n        }\n        else if ((targetPort !== undefined && source.corners.top - source.margin.top > targetPort.offsetY) ||\n            (targetPort === undefined && source.corners.top - source.margin.top > target.corners.middleLeft.y)) {\n            pts = NoOfSegments.Three;\n        }\n        else if (source.corners.right < target.corners.left ||\n            target.corners.right < source.corners.left) {\n            pts = NoOfSegments.Five;\n        }\n        else if (diffX === 0 || diffY === 0) {\n            pts = NoOfSegments.One;\n        }\n        else {\n            pts = NoOfSegments.Three;\n        }\n    }\n    else if ((srcPort !== undefined && srcPort.offsetY < target.corners.top - target.margin.top) ||\n        (srcPort === undefined && source.corners.middleLeft.y < target.corners.top)) {\n        pts = NoOfSegments.Three;\n    }\n    else if ((srcPort !== undefined && srcPort.offsetY > target.corners.bottom + target.margin.bottom) ||\n        (srcPort === undefined && source.corners.middleLeft.y > target.corners.bottom + target.margin.bottom)) {\n        pts = NoOfSegments.Three;\n    }\n    else if (source.corners.left > target.corners.right) {\n        pts = NoOfSegments.Five;\n    }\n    else if (diffX === 0 || diffY === 0) {\n        pts = NoOfSegments.One;\n    }\n    else {\n        pts = NoOfSegments.Three;\n    }\n    return pts;\n}\n/**\n * getTopToTopSegmentCount method \\\n *\n * @returns { NoOfSegments } getTopToTopSegmentCount method .\\\n * @param {End} element - provide the element value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction getTopToTopSegmentCount(element, source, target) {\n    var srcPort = element.sourcePortWrapper;\n    var targetPort = element.targetPortWrapper;\n    var diffX = Math.round(Math.abs(source.point.x - target.point.x));\n    var diffY = Math.round(Math.abs(source.point.y - target.point.y));\n    source.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n    var pts;\n    target.margin = { left: 10, right: 10, top: 10, bottom: 10 };\n    if (source.corners.top < target.corners.top) {\n        if ((targetPort !== undefined && source.corners.left > targetPort.offsetX) ||\n            (targetPort === undefined && source.corners.left > target.corners.left)) {\n            pts = NoOfSegments.Three;\n        }\n        else if ((targetPort !== undefined && source.corners.right < targetPort.offsetX) ||\n            (targetPort === undefined && source.corners.right < target.corners.right)) {\n            pts = NoOfSegments.Three;\n        }\n        else if (source.corners.bottom < target.corners.top) {\n            pts = NoOfSegments.Five;\n        }\n        else if (diffX === 0 || diffY === 0) {\n            pts = NoOfSegments.One;\n        }\n        else {\n            pts = NoOfSegments.Three;\n        }\n    }\n    else if ((srcPort !== undefined && srcPort.offsetX > target.corners.right) ||\n        (srcPort === undefined && source.corners.left > target.corners.right)) {\n        pts = NoOfSegments.Three;\n    }\n    else if ((srcPort !== undefined && srcPort.offsetX < target.corners.left) ||\n        (srcPort === undefined && source.corners.bottomRight.x < target.corners.left)) {\n        pts = NoOfSegments.Three;\n    }\n    else if (source.corners.top > target.corners.bottom) {\n        pts = NoOfSegments.Five;\n    }\n    else if (diffX === 0 || diffY === 0) {\n        pts = NoOfSegments.One;\n    }\n    else {\n        pts = NoOfSegments.Three;\n    }\n    return pts;\n}\n/**\n * addOrthoSegments method \\\n *\n * @returns {  PointModel[] } addOrthoSegments method .\\\n * @param {Connector} element - provide the element value.\n * @param {NoOfSegments} seg - provide the seg  value.\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {number} segLength - provide the segLength  value.\n * @param {boolean} lineDistribution - provide the lineDistribution  value.\n * @private\n */\nfunction addOrthoSegments(element, seg, source, target, segLength, lineDistribution) {\n    var src = element.sourceWrapper;\n    var tar = element.targetWrapper;\n    //let tarPort: DiagramElement = element.targetPortWrapper;\n    var intermeditatePoints;\n    var srcCorner = src.corners;\n    var tarCorner = tar.corners;\n    var value;\n    var extra = 20;\n    if (source.direction !== target.direction || seg === NoOfSegments.Five) {\n        if (source.direction === getOppositeDirection(target.direction) || seg === NoOfSegments.Three) {\n            switch (source.direction) {\n                case 'Left':\n                    if (srcCorner.middleLeft.x > tarCorner.middleRight.x) {\n                        value = (srcCorner.middleLeft.x - tarCorner.middleRight.x) / 2;\n                        extra = !lineDistribution ? Math.min(extra, value) : value;\n                    }\n                    break;\n                case 'Right':\n                    if (srcCorner.middleRight.x < tarCorner.middleLeft.x) {\n                        value = (tarCorner.middleLeft.x - srcCorner.middleRight.x) / 2;\n                        extra = !lineDistribution ? Math.min(extra, value) : value;\n                    }\n                    break;\n                case 'Top':\n                    if (srcCorner.topCenter.y > tarCorner.bottomCenter.y) {\n                        value = (srcCorner.topCenter.y - tarCorner.bottomCenter.y) / 2;\n                        extra = !lineDistribution ? Math.min(extra, value) : value;\n                    }\n                    break;\n                case 'Bottom':\n                    if (srcCorner.bottomCenter.y < tarCorner.topCenter.y) {\n                        value = (tarCorner.topCenter.y - srcCorner.bottomCenter.y) / 2;\n                        extra = !lineDistribution ? Math.min(extra, value) : value;\n                    }\n                    break;\n            }\n        }\n    }\n    extra = adjustSegmentLength(srcCorner, source, extra);\n    if (segLength) {\n        extra = Math.max(extra, segLength);\n    }\n    if (seg === NoOfSegments.One) {\n        intermeditatePoints = [source.point, target.point];\n    }\n    if (seg === NoOfSegments.Two) {\n        intermeditatePoints = orthoConnection2Segment(source, target);\n    }\n    if (seg === NoOfSegments.Three) {\n        intermeditatePoints = orthoConnection3Segment(element, source, target, extra);\n    }\n    if (seg === NoOfSegments.Four) {\n        var prevDir = undefined;\n        intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints, extra);\n    }\n    if (seg === NoOfSegments.Five) {\n        intermeditatePoints = orthoConnection5Segment(source, target, extra);\n    }\n    return intermeditatePoints;\n}\n/**\n * adjustSegmentLength method \\\n *\n * @returns {  PointModel[] } adjustSegmentLength method .\\\n * @param {Rect | Corners} bounds - provide the element value.\n * @param {End} source - provide the seg  value.\n * @param {number} extra - provide the source  value.\n * @private\n */\nfunction adjustSegmentLength(bounds, source, extra) {\n    switch (source.direction) {\n        case 'Left':\n            if (source.point.x > bounds.left) {\n                extra = (source.point.x - bounds.left) > extra ? ((source.point.x - bounds.left) + extra) : extra;\n            }\n            break;\n        case 'Right':\n            if (source.point.x < bounds.right) {\n                extra = (bounds.right - source.point.x) > extra ? ((bounds.right - source.point.x) + extra) : extra;\n            }\n            break;\n        case 'Top':\n            if (source.point.y > bounds.top) {\n                extra = (source.point.y - bounds.top) > extra ? ((source.point.y - bounds.top) + extra) : extra;\n            }\n            break;\n        case 'Bottom':\n            if (source.point.y < bounds.bottom) {\n                extra = (bounds.bottom - source.point.y) > extra ? ((bounds.bottom - source.point.y) + extra) : extra;\n            }\n            break;\n    }\n    return extra;\n}\n/**\n * orthoConnection2Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection2Segment method .\\\n * @param {Rect | Corners} source - provide the source value.\n * @param {End} target - provide the target  value.\n * @private\n */\nexport function orthoConnection2Segment(source, target) {\n    var intermeditatePoints;\n    switch (source.direction) {\n        case 'Left':\n        case 'Right':\n            // eslint-disable-next-line\n            var point1 = { x: target.point.x, y: source.point.y };\n            intermeditatePoints = (Point.equals(source.point, point1) || Point.equals(target.point, point1)) ?\n                [source.point, target.point] : [source.point, point1, target.point];\n            break;\n        case 'Top':\n        case 'Bottom':\n            // eslint-disable-next-line no-case-declarations\n            var point2 = { x: source.point.x, y: target.point.y };\n            intermeditatePoints = (Point.equals(source.point, point2) || Point.equals(target.point, point2)) ?\n                [source.point, target.point] : [source.point, point2, target.point];\n            break;\n    }\n    return intermeditatePoints;\n}\n/**\n * orthoConnection3Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection2Segment method .\\\n * @param {Connector} element - provide the source value.\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {number} extra - provide the target  value.\n * @param {boolean} allow - provide the target  value.\n * @private\n */\nfunction orthoConnection3Segment(element, source, target, extra, allow) {\n    if (!extra) {\n        extra = 20;\n    }\n    var srcPort = element.sourcePortWrapper;\n    var intermeditatePoints;\n    var segmentValue;\n    var next;\n    var diffx = target.point.x - source.point.x;\n    var diffy = target.point.y - source.point.y;\n    var temp;\n    if (!allow && (Math.abs(diffx) < 0.001 || Math.abs(diffy) < 0.001)) {\n        if (target.direction === undefined) {\n            intermeditatePoints = [source.point, target.point];\n            return intermeditatePoints;\n        }\n    }\n    if (element.targetWrapper === undefined && Math.abs(diffx) <= 31 && Math.abs(diffy) <= 31) {\n        if ((source.direction === 'Left' || source.direction === 'Right')) {\n            if (Math.abs(diffy) < 12) {\n                source.direction = (source.point.y > target.point.y) ? 'Top' : 'Bottom';\n            }\n        }\n        else {\n            if (Math.abs(diffx) < 12) {\n                source.direction = (source.point.x > target.point.x) ? 'Left' : 'Right';\n            }\n        }\n        if (Math.abs(diffx) > 12 || Math.abs(diffy) > 12) {\n            return orthoConnection2Segment(source, target);\n        }\n        else {\n            extra += 5;\n        }\n    }\n    if (source.direction === 'Left' || source.direction === 'Right') {\n        if (source.direction === 'Right') {\n            if (target.direction !== undefined && target.direction === 'Right') {\n                extra = Math.max(source.point.x, target.point.x) - source.point.x + extra;\n            }\n            if (source.point.x > target.point.x && srcPort === undefined) {\n                extra = -extra;\n            }\n        }\n        else {\n            if (target.direction !== undefined && target.direction === 'Left') {\n                extra = source.point.x - Math.min(source.point.x, target.point.x) + extra;\n            }\n            if (source.point.x > target.point.x || srcPort !== undefined || source.direction === 'Left') {\n                extra = -extra;\n            }\n        }\n        temp = target.point.y - source.point.y;\n        segmentValue = addLineSegment(source.point, extra, 0);\n        temp = target.point.y - segmentValue.y;\n        if (temp !== 0) {\n            next = addLineSegment(segmentValue, target.point.y - segmentValue.y, 90);\n        }\n    }\n    else if (source.direction === 'Top' || source.direction === 'Bottom') {\n        if (source.direction === 'Bottom') {\n            if (target.direction !== undefined && target.direction === 'Bottom') {\n                extra = Math.max(source.point.y, target.point.y) - source.point.y + extra;\n            }\n        }\n        else {\n            if (target.direction !== undefined && target.direction === 'Top') {\n                extra = source.point.y - Math.min(source.point.y, target.point.y) + extra;\n            }\n            if (source.point.y > target.point.y || (srcPort !== undefined) || source.direction === 'Top') {\n                extra = -extra;\n            }\n        }\n        temp = target.point.x - source.point.x;\n        if (source.direction === 'Top') {\n            segmentValue = addLineSegment(source.point, extra, 90);\n        }\n        else {\n            segmentValue = addLineSegment(source.point, extra, 90);\n        }\n        temp = target.point.x - segmentValue.x;\n        if (temp !== 0) {\n            next = addLineSegment(segmentValue, target.point.x - segmentValue.x, 0);\n        }\n    }\n    if (temp === 0) {\n        return intermeditatePoints = [\n            source.point,\n            target.point\n        ];\n    }\n    intermeditatePoints = [\n        source.point,\n        segmentValue,\n        next,\n        target.point\n    ];\n    return intermeditatePoints;\n}\n/**\n * orthoConnection5Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection5Segment method .\\\n * @param {Connector} source - provide the source value.\n * @param {End} target - provide the target  value.\n * @param {End} extra - provide the extra  value.\n * @private\n */\nfunction orthoConnection5Segment(source, target, extra) {\n    if (extra === void 0) { extra = 20; }\n    var intermeditatePoints;\n    var length = extra;\n    var sLeft = source.corners.left - source.margin.left;\n    var sRight = source.corners.right + source.margin.right;\n    var sBottom = source.corners.bottom + source.margin.bottom;\n    var sTop = source.corners.top - source.margin.top;\n    var tLeft = target.corners.left - target.margin.left;\n    var tRight = target.corners.right + target.margin.right;\n    var tBottom = target.corners.bottom + target.margin.bottom;\n    var tTop = target.corners.top - target.margin.top;\n    var segmentValue;\n    switch (source.direction) {\n        case 'Left':\n            if ((sTop > tTop && sTop < tBottom || sBottom < tBottom && sBottom > tTop) &&\n                sLeft > tLeft && sLeft <= tRight && extra >= 20) {\n                length = source.point.x - target.corners.left + length;\n            }\n            segmentValue = addLineSegment(source.point, length, 180);\n            break;\n        case 'Top':\n            if ((sLeft > tLeft && sLeft < tRight || sRight < tRight && sRight > tLeft) &&\n                sTop > tTop && sTop <= tBottom && extra >= 20) {\n                length = source.point.y - target.corners.top + length;\n            }\n            segmentValue = addLineSegment(source.point, length, 270);\n            break;\n        case 'Right':\n            if ((sTop > tTop && sTop < tBottom || sBottom < tBottom && sBottom > tTop) &&\n                sRight < tRight && sRight >= tLeft && extra >= 20) {\n                length = target.corners.right - source.point.x + length;\n            }\n            segmentValue = addLineSegment(source.point, length, 0);\n            break;\n        case 'Bottom':\n            if ((sLeft > tLeft && sLeft < tRight || sRight < tRight && sRight > tLeft) &&\n                sBottom < tBottom && sBottom >= tTop && extra >= 20) {\n                length = target.corners.bottom - source.point.y + length;\n            }\n            segmentValue = addLineSegment(source.point, length, 90);\n            break;\n    }\n    intermeditatePoints = [\n        source.point,\n        segmentValue\n    ];\n    if (source.direction === 'Top' || source.direction === 'Bottom') {\n        var prevDir = source.direction;\n        source.direction = segmentValue.x > target.point.x ? 'Left' : 'Right';\n        source.point = segmentValue;\n        intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints);\n    }\n    else {\n        var prevDir = source.direction;\n        source.direction = segmentValue.y > target.point.y ? 'Top' : 'Bottom';\n        source.point = segmentValue;\n        intermeditatePoints = orthoConnection4Segment(source, target, prevDir, intermeditatePoints);\n    }\n    return intermeditatePoints;\n}\n/**\n * orthoConnection4Segment method \\\n *\n * @returns {  PointModel[] } orthoConnection4Segment method .\\\n * @param {End} source - provide the target  value.\n * @param {End} target - provide the target  value.\n * @param {string} prevDir - provide the target  value.\n * @param {PointModel[]} interPt - provide the target  value.\n * @param {number} e - provide the target  value.\n * @private\n */\nfunction orthoConnection4Segment(source, target, prevDir, interPt, e) {\n    if (e === void 0) { e = 20; }\n    var segmentValue;\n    if (prevDir === undefined) {\n        source.margin = { left: 2, right: 2, top: 2, bottom: 2 };\n        target.margin = { left: 0, right: 5, top: 0, bottom: 5 };\n    }\n    else {\n        if (source.direction === 'Bottom') {\n            if (target.corners.top > source.corners.bottom && target.corners.top - source.corners.bottom < 20) {\n                e = (target.corners.top - source.corners.bottom) / 2;\n            }\n        }\n        else if (source.direction === 'Top') {\n            if (target.corners.bottom < source.corners.top && source.corners.top - target.corners.bottom < 20) {\n                e = (source.corners.top - target.corners.bottom) / 2;\n            }\n        }\n        else if (source.direction === 'Right') {\n            if (target.corners.left > source.corners.right && target.corners.left - source.corners.right < 20) {\n                e = (target.corners.left - source.corners.right) / 2;\n            }\n        }\n        else if (source.direction === 'Left') {\n            if (target.corners.right < source.corners.left && source.corners.left - target.corners.right < 20) {\n                e = (source.corners.left - target.corners.right) / 2;\n            }\n        }\n    }\n    switch (source.direction) {\n        case 'Left':\n            e = getLeftLength(source, target, prevDir, e);\n            segmentValue = addLineSegment(source.point, e, 180);\n            break;\n        case 'Right':\n            e = getRightLength(source, target, e, prevDir);\n            segmentValue = addLineSegment(source.point, e, 0);\n            break;\n        case 'Top':\n            e = getTopLength(source, target, prevDir, e);\n            segmentValue = addLineSegment(source.point, e, 270);\n            break;\n        case 'Bottom':\n            e = getBottomLength(source, target, e, prevDir);\n            segmentValue = addLineSegment(source.point, e, 90);\n    }\n    if (interPt !== undefined) {\n        interPt.push(segmentValue);\n    }\n    else {\n        interPt = [\n            source.point,\n            segmentValue\n        ];\n    }\n    if (source.direction === 'Top' || source.direction === 'Bottom') {\n        getOrtho3Seg(segmentValue, 'horizontal', source, target, interPt);\n    }\n    else if (source.direction === 'Right' || source.direction === 'Left') {\n        getOrtho3Seg(segmentValue, 'vertical', source, target, interPt);\n    }\n    return interPt;\n}\n/**\n * getOrtho3Seg method \\\n *\n * @returns {  void } getOrtho3Seg method .\\\n * @param {PointModel} sPt - provide the sPt  value.\n * @param {string} orientation - provide the orientation  value.\n * @param {End} src - provide the src  value.\n * @param {End} tar - provide the tar  value.\n * @param {PointModel[]} points - provide the points  value.\n * @private\n */\nfunction getOrtho3Seg(sPt, orientation, src, tar, points) {\n    var point1;\n    var point2;\n    var point3;\n    if (orientation === 'horizontal') {\n        src.margin = { left: 0, right: 10, top: 0, bottom: 10 };\n        tar.margin = { left: 0, right: 10, top: 0, bottom: 10 };\n    }\n    else if (orientation === 'vertical') {\n        src.margin = { left: 10, right: 0, top: 10, bottom: 0 };\n        tar.margin = { left: 10, right: 0, top: 10, bottom: 0 };\n    }\n    var extra = 20;\n    if (orientation === 'horizontal') {\n        switch (tar.direction) {\n            case 'Left':\n                if (src.corners.right + src.margin.right < tar.corners.left - tar.margin.left &&\n                    (tar.corners.left - src.corners.right > extra || (src.corners.top - src.margin.top <= tar.point.y &&\n                        src.corners.bottom + src.margin.bottom >= tar.point.y))) {\n                    var gap = Math.min(Math.abs(tar.corners.left - src.corners.right) / 2, 20);\n                    extra = src.corners.right - sPt.x + gap;\n                }\n                else {\n                    if ((src.direction === 'Top' && sPt.y > tar.point.y) || (src.direction === 'Bottom' && sPt.y < tar.point.y)) {\n                        extra = Math.min(tar.corners.left, sPt.x) - sPt.x - 20;\n                    }\n                    else if (sPt.x >= src.corners.left - src.margin.left && sPt.x <= src.corners.right + src.margin.right) {\n                        extra = Math.min(tar.corners.left, src.corners.left) - sPt.x - 20;\n                    }\n                    else {\n                        extra = tar.corners.left - sPt.x - 20;\n                    }\n                }\n                break;\n            case 'Right':\n                if (src.corners.left - src.margin.left > tar.corners.right + tar.margin.right &&\n                    (src.corners.left - tar.corners.right > extra || (src.corners.top - src.margin.top <= tar.point.y &&\n                        src.corners.bottom + src.margin.bottom >= tar.point.y))) {\n                    var gap = Math.min(Math.abs(src.corners.left - tar.corners.right) / 2, 20);\n                    extra = src.corners.left - sPt.x - gap;\n                }\n                else {\n                    if ((src.direction === 'Top' && sPt.y > tar.point.y) || (src.direction === 'Bottom' && sPt.y < tar.point.y)) {\n                        extra = Math.max(tar.corners.right, sPt.x) - sPt.x + 20;\n                    }\n                    else if (sPt.x >= src.corners.left - src.margin.left && sPt.x <= src.corners.right + src.margin.right) {\n                        extra = Math.max(tar.corners.right, src.corners.right) - sPt.x + 20;\n                    }\n                    else {\n                        extra = tar.corners.right - sPt.x + 20;\n                    }\n                }\n                break;\n        }\n        point1 = addLineSegment(sPt, extra, 0);\n        point2 = addLineSegment(point1, tar.point.y - sPt.y, 90);\n        point3 = tar.point;\n    }\n    else if (orientation === 'vertical') {\n        switch (tar.direction) {\n            case 'Top':\n                if (src.corners.bottom + src.margin.bottom < tar.corners.top - tar.margin.top &&\n                    (tar.corners.top - src.corners.bottom > extra || (src.corners.left - src.margin.left <= tar.point.x &&\n                        src.corners.right + src.margin.right >= tar.point.x))) {\n                    var gap = Math.min(Math.abs(tar.corners.top - src.corners.bottom) / 2, 20);\n                    extra = src.corners.bottom - sPt.y + gap;\n                }\n                else {\n                    if ((src.direction === 'Left' && sPt.x > tar.point.x) || (src.direction === 'Right' && sPt.x < tar.point.x)) {\n                        extra = Math.min(tar.corners.top, sPt.y) - sPt.y - 20;\n                    }\n                    else if (sPt.y >= src.corners.top - src.margin.top && sPt.y <= src.corners.bottom + src.margin.bottom) {\n                        extra = Math.min(tar.corners.top, src.corners.top) - sPt.y - 20;\n                    }\n                    else {\n                        extra = tar.corners.top - sPt.y - 20;\n                    }\n                }\n                break;\n            case 'Bottom':\n                if (src.corners.top - src.margin.top > tar.corners.bottom + tar.margin.bottom &&\n                    (src.corners.top - tar.corners.bottom > extra || (src.corners.left - src.margin.left <= tar.point.x &&\n                        src.corners.right + src.margin.right >= tar.point.x))) {\n                    var gap = Math.min(Math.abs(src.corners.top - tar.corners.bottom) / 2, 20);\n                    extra = src.corners.top - sPt.y - gap;\n                }\n                else {\n                    if ((src.direction === 'Left' && sPt.x > tar.point.x) || (src.direction === 'Right' && sPt.x < tar.point.x)) {\n                        extra = Math.max(tar.corners.bottom, sPt.y) - sPt.y + 20;\n                    }\n                    else if (sPt.y >= src.corners.top - src.margin.top && sPt.y <= src.corners.bottom + src.margin.bottom) {\n                        extra = Math.max(tar.corners.bottom, src.corners.bottom) - sPt.y + 20;\n                    }\n                    else {\n                        extra = tar.corners.bottom - sPt.y + 20;\n                    }\n                }\n                break;\n        }\n        point1 = addLineSegment(sPt, extra, 90);\n        point2 = addLineSegment(point1, tar.point.x - sPt.x, 0);\n        point3 = tar.point;\n    }\n    points.push(point1);\n    points.push(point2);\n    points.push(point3);\n}\n/**\n * getTopLength method \\\n *\n * @returns {  number } getTopLength method .\\\n * @param {End} source - provide the sPt  value.\n * @param {End} target - provide the sPt  value.\n * @param {string} preDir - provide the orientation  value.\n * @param {number} length - provide the src  value.\n * @private\n */\nfunction getTopLength(source, target, preDir, length) {\n    if (source.corners.top - source.margin.top > target.corners.top + target.margin.top &&\n        source.corners.top - source.margin.top <= target.corners.bottom + target.margin.bottom) {\n        if (target.direction === 'Right' && source.point.x < target.point.x) {\n            length += source.corners.top - target.corners.top;\n        }\n        else if (target.direction === 'Left' && source.point.x > target.point.x) {\n            length += source.corners.top - target.corners.top;\n        }\n        length += source.point.y - source.corners.top;\n    }\n    else {\n        if ((preDir !== undefined && preDir !== 'Left') && target.direction === 'Right' && source.point.x < target.point.x) {\n            length += Math.abs(source.point.y - target.corners.bottom);\n        }\n        else if ((preDir !== undefined && preDir !== 'Right') && target.direction === 'Left'\n            && target.point.x < source.point.x) {\n            length += Math.abs(source.point.y - target.corners.bottom);\n        }\n        else {\n            length += source.point.y - source.corners.top;\n        }\n    }\n    return length;\n}\n/**\n * getLeftLength method \\\n *\n * @returns {  number } getLeftLength method .\\\n * @param {End} source - provide the sPt  value.\n * @param {End} target - provide the sPt  value.\n * @param {string} prevDir - provide the orientation  value.\n * @param {number} segLength - provide the src  value.\n * @private\n */\nfunction getLeftLength(source, target, prevDir, segLength) {\n    if (source.corners.left - source.margin.left > target.corners.left - target.margin.left &&\n        source.corners.left - source.margin.left <= target.corners.right + target.margin.right) {\n        if (target.direction === 'Bottom' && source.point.y < target.point.y) {\n            segLength += source.corners.left - target.corners.left;\n        }\n        else if (target.direction === 'Top' && source.point.y > target.point.y) {\n            segLength += source.corners.left - target.corners.left;\n        }\n        segLength += source.point.x - source.corners.left;\n    }\n    else {\n        if ((prevDir !== undefined && prevDir !== 'Top') && target.direction === 'Bottom' && source.point.y < target.point.y) {\n            segLength += Math.abs(source.point.x - target.corners.right);\n        }\n        else if ((prevDir !== undefined && prevDir !== 'Bottom') &&\n            target.direction === 'Top' && target.point.y < source.point.y) {\n            segLength += Math.abs(source.point.x - target.corners.right);\n        }\n        else {\n            segLength += source.point.x - source.corners.left;\n        }\n    }\n    return segLength;\n}\n/**\n * getRightLength method \\\n *\n * @returns {  number } getRightLength method .\\\n * @param {End} source - provide the sPt  value.\n * @param {End} target - provide the orientation  value.\n * @param {number} length - provide the src  value.\n * @param {string} prevDir - provide the src  value.\n * @private\n */\nfunction getRightLength(source, target, length, prevDir) {\n    if (source.corners.right + source.margin.right < target.corners.right + target.margin.right &&\n        source.corners.right + source.margin.right >= target.corners.left - target.margin.left) {\n        if (target.direction === 'Bottom' && source.point.y < target.point.y) {\n            length += target.corners.right - source.corners.right;\n        }\n        else if (target.direction === 'Top' && source.point.y > target.point.y) {\n            length += target.corners.right - source.corners.right;\n        }\n        length += source.corners.right - source.point.x;\n    }\n    else {\n        if ((prevDir !== undefined && prevDir !== 'Top') && target.direction === 'Bottom' && source.point.y < target.point.y) {\n            length += Math.abs(source.point.x - target.corners.right);\n        }\n        else if ((prevDir !== undefined && prevDir !== 'Bottom') && target.direction === 'Top' && target.point.y < source.point.y) {\n            length += Math.abs(source.point.x - target.corners.right);\n        }\n        else {\n            length += source.corners.right - source.point.x;\n        }\n    }\n    return length;\n}\n/**\n * getBottomLength method \\\n *\n * @returns {  number } getBottomLength method .\\\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @param {number} segLength - provide the segLength  value.\n * @param {string} prevDir - provide the src  value.\n * @private\n */\nfunction getBottomLength(source, target, segLength, prevDir) {\n    if (source.corners.bottom + source.margin.bottom < target.corners.bottom + target.margin.bottom &&\n        source.corners.bottom + source.margin.bottom >= target.corners.top - target.margin.top) {\n        if (target.direction === 'Right' && source.point.x < target.point.x) {\n            segLength += target.corners.bottom - source.corners.bottom;\n        }\n        else if (target.direction === 'Left' && source.point.x > target.point.x) {\n            segLength += target.corners.bottom - source.corners.bottom;\n        }\n        segLength += source.corners.bottom - source.point.y;\n    }\n    else {\n        if ((prevDir !== undefined && prevDir !== 'Left') &&\n            target.direction === 'Right' && source.point.x < target.point.x) {\n            segLength += Math.abs(source.point.y - target.corners.bottom);\n        }\n        else if ((prevDir !== undefined && prevDir !== 'Right') &&\n            target.direction === 'Left' && target.point.x < source.point.x) {\n            segLength += Math.abs(source.point.y - target.corners.bottom);\n        }\n        else {\n            segLength += source.corners.bottom - source.point.y;\n        }\n    }\n    return segLength;\n}\n/**\n * getSwapping method \\\n *\n * @returns {  boolean } getSwapping method .\\\n * @param {string} srcDir - provide the source  value.\n * @param {string} tarDir - provide the target  value.\n * @private\n */\nfunction getSwapping(srcDir, tarDir) {\n    var swap = false;\n    switch (srcDir) {\n        case 'Left':\n            switch (tarDir) {\n                case 'Right':\n                case 'Bottom':\n                    swap = true;\n                    break;\n            }\n            break;\n        case 'Top':\n            switch (tarDir) {\n                case 'Left':\n                case 'Right':\n                case 'Bottom':\n                    swap = true;\n                    break;\n            }\n            break;\n        case 'Bottom':\n            switch (tarDir) {\n                case 'Right':\n                    swap = true;\n                    break;\n            }\n            break;\n    }\n    return swap;\n}\n/**\n * swapPoints method \\\n *\n * @returns {  void } swapPoints method .\\\n * @param {End} source - provide the source  value.\n * @param {End} target - provide the target  value.\n * @private\n */\nfunction swapPoints(source, target) {\n    var direction = source.direction;\n    source.direction = target.direction;\n    target.direction = direction;\n    var point = source.point;\n    source.point = target.point;\n    target.point = point;\n    var corner = source.corners;\n    source.corners = target.corners;\n    target.corners = corner;\n}\n/**\n * getPortDirection method \\\n *\n * @returns {  boolean } getPortDirection method .\\\n * @param {PointModel} point - provide the point  value.\n * @param {Corners} corner - provide the corner  value.\n * @param {Rect} bounds - provide the bounds  value.\n * @param {boolean} closeEdge - provide the closeEdge  value.\n * @private\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function getPortDirection(point, corner, bounds, closeEdge) {\n    var direction;\n    var boundsValue = corner === undefined ? bounds : corner;\n    var one = boundsValue.topLeft;\n    var two = boundsValue.topRight;\n    var three = boundsValue.bottomRight;\n    var four = boundsValue.bottomLeft;\n    var center = boundsValue.center;\n    var angle = findAngle(center, point);\n    var fourty5 = findAngle(center, three);\n    var one35 = findAngle(center, four);\n    var two25 = findAngle(center, one);\n    var three15 = findAngle(center, two);\n    if (angle > two25 && angle < three15) {\n        direction = 'Top';\n        // if (bounds.width < bounds.height && closeEdge) {\n        //     let height: number = (bounds.height - bounds.width) / 2;\n        //     let width: number = bounds.width;\n        //     if (Math.abs(point.x - one.x) < Math.abs(point.x - two.x)) {\n        //         direction = checkCloseEdge(direction, new Rect(one.x, one.y, width, height), point, 'Left');\n        //     } else {\n        //         direction = checkCloseEdge(direction, new Rect(two.x - bounds.width, two.y, width, height), point, 'Right');\n        //     }\n        // }\n    }\n    else if (angle >= fourty5 && angle < one35) {\n        direction = 'Bottom';\n        // if (bounds.width < bounds.height && closeEdge) {\n        //     let height: number = (bounds.height - bounds.width) / 2;\n        //     let width: number = bounds.width;\n        //     if (Math.abs(point.x - four.x) < Math.abs(point.x - three.x)) {\n        //         direction = checkCloseEdge(direction, new Rect(four.x, four.y - height, width, height), point, 'Left');\n        //     } else {\n        //         let value: Rect = new Rect(three.x - bounds.width, three.y - bounds.height / 4, bounds.width, bounds.height / 4);\n        //         direction = checkCloseEdge(direction, value, point, 'Right');\n        //     }\n        // }\n    }\n    else if (angle >= one35 && angle <= two25) {\n        direction = 'Left';\n        // if (bounds.width > bounds.height && closeEdge) {\n        //     let width: number = (bounds.width - bounds.height) / 2;\n        //     let height: number = bounds.height;\n        //     if (Math.abs(point.y - one.y) < Math.abs(point.y - four.y)) {\n        //         direction = checkCloseEdge(direction, new Rect(one.x, one.y, width, height), point, 'Top');\n        //     } else {\n        //         direction = checkCloseEdge(direction, new Rect(four.x, four.y - height, width, height), point, 'Bottom');\n        //     }\n        // }\n    }\n    else if (angle >= three15 || angle < fourty5) {\n        direction = 'Right';\n        // if (bounds.width > bounds.height && closeEdge) {\n        //     let width: number = (bounds.width - bounds.height) / 2;\n        //     let height: number = bounds.height;\n        //     if (Math.abs(point.y - two.y) < Math.abs(point.y - three.y)) {\n        //         direction = checkCloseEdge(direction, new Rect(two.x - width, two.y, width, height), point, 'Top');\n        //     } else {\n        //         direction = checkCloseEdge(direction,\n        //new Rect(three.x - width, three.y - height, width, height), point, 'Bottom');\n        //     }\n        // }\n    }\n    else {\n        direction = 'Right';\n    }\n    return direction;\n}\n// function checkCloseEdge(direction: string, threshold: Rect, port: PointModel, nearest: string): string {\n// if (threshold) {\n//     switch (direction) {\n//         case 'Bottom':\n//         case 'Top':\n//             let left: number = Math.abs(threshold.left - port.x);\n//             let right: number = Math.abs(threshold.right - port.x);\n//             let ver: number = direction === 'Top' ? Math.abs(threshold.top - port.y) : Math.abs(threshold.bottom - port.y);\n//             if (left < right) {\n//                 if (left < ver) {\n//                     return 'Left';\n//                 }\n//             } else {\n//                 if (right < ver) {\n//                     return 'Right';\n//                 }\n//             }\n//             break;\n//         case 'Left':\n//         case 'Right':\n//             let top: number = Math.abs(threshold.top - port.y);\n//             let bottom: number = Math.abs(threshold.bottom - port.y);\n//             let hor: number = direction === 'Left' ? Math.abs(threshold.left - port.x) : Math.abs(threshold.right - port.x);\n//             if (top < bottom) {\n//                 if (top < hor) {\n//                     return 'Top';\n//                 }\n//             } else {\n//                 if (bottom < hor) {\n//                     return 'Bottom';\n//                 }\n//             }\n//             break;\n//     }\n// }\n//Meant for dock port\n//    return direction;\n//  }\n/**\n * getOuterBounds method \\\n *\n * @returns {  Rect } getOuterBounds method .\\\n * @param {Connector} obj - provide the point  value.\n * @private\n */\nexport function getOuterBounds(obj) {\n    //let outerBounds: Rect;\n    var outerBounds = obj.wrapper.children[0].bounds;\n    if (obj.sourceDecorator.shape !== 'None') {\n        outerBounds.uniteRect(obj.wrapper.children[1].bounds);\n    }\n    if (obj.targetDecorator.shape !== 'None') {\n        outerBounds.uniteRect(obj.wrapper.children[2].bounds);\n    }\n    return outerBounds;\n}\n/**\n * getOppositeDirection method \\\n *\n * @returns {  string } getOppositeDirection method .\\\n * @param {string} direction - provide the direction  value.\n * @private\n */\nexport function getOppositeDirection(direction) {\n    switch (direction) {\n        case 'Top':\n            return 'Bottom';\n        case 'Bottom':\n            return 'Top';\n        case 'Left':\n            return 'Right';\n        case 'Right':\n            return 'Left';\n    }\n    return 'auto';\n}\n"]},"metadata":{},"sourceType":"module"}