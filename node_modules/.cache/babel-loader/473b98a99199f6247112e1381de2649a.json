{"ast":null,"code":"/**\n * Connects diagram objects with layout algorithm\n */\nvar ComplexHierarchicalTree =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the hierarchical tree layout module\n   *\n   * @private\n   */\n  function ComplexHierarchicalTree() {//constructs the layout module\n  }\n  /**\n   * To destroy the hierarchical tree module\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  ComplexHierarchicalTree.prototype.destroy = function () {\n    /**\n     * Destroy method performed here\n     */\n  };\n  /**\n   * Core method to return the component name.\n   *\n   * @returns {string}  Core method to return the component name.\n   * @private\n   */\n\n\n  ComplexHierarchicalTree.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the layout\n     *\n     */\n    return 'ComplexHierarchicalTree';\n  };\n  /**\n   * doLayout method\\\n   *\n   * @returns {  void }    doLayout method .\\\n   * @param {INode[]} nodes - provide the nodes value.\n   * @param {{}} nameTable - provide the nameTable value.\n   * @param {Layout} layout - provide the layout value.\n   * @param {PointModel} viewPort - provide the viewPort value.\n   * @param {LineDistribution} lineDistribution - provide the lineDistribution value.\n   * @private\n   */\n\n\n  ComplexHierarchicalTree.prototype.doLayout = function (nodes, nameTable, layout, viewPort, lineDistribution) {\n    new HierarchicalLayoutUtil().doLayout(nodes, nameTable, layout, viewPort, lineDistribution);\n  };\n\n  ComplexHierarchicalTree.prototype.getLayoutNodesCollection = function (nodes) {\n    var nodesCollection = [];\n    var node;\n    var parentId = 'parentId';\n    var processId = 'processId';\n\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n\n      if (node.inEdges.length + node.outEdges.length > 0 && !node[parentId] && !node[processId]) {\n        nodesCollection.push(node);\n      }\n    }\n\n    return nodesCollection;\n  };\n\n  return ComplexHierarchicalTree;\n}();\n\nexport { ComplexHierarchicalTree };\n/**\n * Utility that arranges the nodes in hierarchical structure\n */\n\nvar HierarchicalLayoutUtil =\n/** @class */\nfunction () {\n  function HierarchicalLayoutUtil() {\n    this.nameTable = {};\n    this.crossReduction = new CrossReduction();\n    /**\n     * The preferred vertical offset between edges exiting a vertex Default is 2.\n     */\n\n    this.previousEdgeOffset = 6;\n    /**\n     * The preferred horizontal distance between edges exiting a vertex Default is 5.\n     */\n\n    this.previousEdgeDistance = 5;\n    /**\n     * Holds the collection vertices, that are equivalent to nodes to be arranged\n     */\n\n    this.jettyPositions = {};\n    /**\n     * Internal cache of bottom-most value of Y for each rank\n     */\n\n    this.rankBottomY = null;\n    /**\n     * Internal cache of bottom-most value of X for each rank\n     */\n\n    this.limitX = null;\n    /**\n     * Internal cache of top-most values of Y for each rank\n     */\n\n    this.rankTopY = null;\n    /**\n     * The minimum parallelEdgeSpacing value is 12.\n     */\n\n    this.parallelEdgeSpacing = 10;\n    /**\n     * The minimum distance for an edge jetty from a vertex Default is 12.\n     */\n\n    this.minEdgeJetty = 12;\n  } //Defines a vertex that is equivalent to a node object\n\n\n  HierarchicalLayoutUtil.prototype.createVertex = function (node, value, x, y, width, height) {\n    var geometry = {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n    var vertex = {\n      value: value,\n      geometry: geometry,\n      name: value,\n      vertex: true,\n      inEdges: node.inEdges.slice(),\n      outEdges: node.outEdges.slice()\n    };\n    return vertex;\n  };\n  /**\n   * Initializes the edges collection of the vertices\\\n   *\n   * @returns {  IConnector[] }    Initializes the edges collection of the vertices\\\n   * @param {Vertex} node - provide the node value.\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.getEdges = function (node) {\n    var edges = [];\n\n    if (node) {\n      for (var i = 0; node.inEdges.length > 0 && i < node.inEdges.length; i++) {\n        edges.push(this.nameTable[node.inEdges[i]]);\n      }\n\n      for (var i = 0; node.outEdges.length > 0 && i < node.outEdges.length; i++) {\n        edges.push(this.nameTable[node.outEdges[i]]);\n      }\n    }\n\n    return edges;\n  }; //Finds the root nodes of the layout\n\n\n  HierarchicalLayoutUtil.prototype.findRoots = function (vertices) {\n    var roots = [];\n    var best = null;\n    var maxDiff = -100000;\n\n    for (var _i = 0, _a = Object.keys(vertices); _i < _a.length; _i++) {\n      var i = _a[_i];\n      var cell = vertices[i];\n      var conns = this.getEdges(cell);\n      var outEdges = 0;\n      var inEdges = 0;\n\n      for (var k = 0; k < conns.length; k++) {\n        var src = this.getVisibleTerminal(conns[k], true);\n\n        if (src.name === cell.name) {\n          outEdges++;\n        } else {\n          inEdges++;\n        }\n      }\n\n      if (inEdges === 0 && outEdges > 0) {\n        roots.push(cell);\n      }\n\n      var diff = outEdges - inEdges;\n\n      if (diff > maxDiff) {\n        maxDiff = diff;\n        best = cell;\n      }\n    }\n\n    if (roots.length === 0 && best != null) {\n      roots.push(best);\n    }\n\n    return roots;\n  };\n  /**\n   * Returns the source/target vertex of the given connector \\\n   *\n   * @returns {  Vertex }    Returns the source/target vertex of the given connector \\\n   * @param {IConnector} edge - provide the node value.\n   * @param {boolean} source - provide the node value.\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.getVisibleTerminal = function (edge, source) {\n    var terminalCache = this.nameTable[edge.targetID];\n\n    if (source) {\n      terminalCache = this.nameTable[edge.sourceID];\n    }\n\n    for (var i = 0; i < this.vertices.length; i++) {\n      if (this.vertices[i].name === terminalCache.id) {\n        return this.vertices[i];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Traverses each sub tree, ensures there is no cycle in traversing \\\n   *\n   * @returns {  {} }    Traverses each sub tree, ensures there is no cycle in traversing .\\\n   * @param {Vertex} vertex - provide the vertex value.\n   * @param {boolean} directed - provide the directed value.\n   * @param {IConnector} edge - provide the edge value.\n   * @param {{}} currentComp - provide the currentComp value.\n   * @param {{}[]} hierarchyVertices - provide the hierarchyVertices value.\n   * @param {{}} filledVertices - provide the filledVertices value.\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.traverse = function (vertex, directed, edge, currentComp, hierarchyVertices, filledVertices) {\n    if (vertex != null) {\n      var vertexID = vertex.name;\n\n      if (filledVertices == null ? true : filledVertices[vertexID] != null) {\n        if (currentComp[vertexID] == null) {\n          currentComp[vertexID] = vertex;\n        }\n\n        if (filledVertices != null) {\n          delete filledVertices[vertexID];\n        }\n\n        var edges = this.getEdges(vertex);\n        var edgeIsSource = [];\n\n        for (var i = 0; i < edges.length; i++) {\n          edgeIsSource[i] = this.getVisibleTerminal(edges[i], true) === vertex;\n        }\n\n        for (var i = 0; i < edges.length; i++) {\n          if (!directed || edgeIsSource[i]) {\n            var next = this.getVisibleTerminal(edges[i], !edgeIsSource[i]);\n            var netCount = 1;\n\n            for (var j = 0; j < edges.length; j++) {\n              if (j === i) {\n                continue;\n              } else {\n                var isSource2 = edgeIsSource[j];\n                var otherTerm = this.getVisibleTerminal(edges[j], !isSource2);\n\n                if (otherTerm === next) {\n                  if (isSource2) {\n                    netCount++;\n                  } else {\n                    netCount--;\n                  }\n                }\n              }\n            }\n\n            if (netCount >= 0) {\n              currentComp = this.traverse(next, directed, edges[i], currentComp, hierarchyVertices, filledVertices);\n            }\n          }\n        }\n      } else {\n        if (currentComp[vertexID] == null) {\n          // We've seen this vertex before, but not in the current component This component and the one it's in need to be merged\n          for (var i = 0; i < hierarchyVertices.length; i++) {\n            var comp = hierarchyVertices[i];\n\n            if (comp[vertexID] != null) {\n              for (var _i = 0, _a = Object.keys(comp); _i < _a.length; _i++) {\n                var key = _a[_i];\n                currentComp[key] = comp[key];\n              } // Remove the current component from the hierarchy set\n\n\n              hierarchyVertices.splice(i, 1);\n              return currentComp;\n            }\n          }\n        }\n      }\n    }\n\n    return currentComp;\n  }; //Returns the bounds of the given vertices\n\n\n  HierarchicalLayoutUtil.prototype.getModelBounds = function (nodes) {\n    nodes = nodes.slice();\n    var rect = null;\n    var rect1 = null;\n\n    for (var i = 0; i < nodes.length; i++) {\n      rect = nodes[i].geometry;\n\n      if (rect1) {\n        var right = Math.max(rect1.x + rect1.width, rect.x + rect.width);\n        var bottom = Math.max(rect1.y + rect1.height, rect.y + rect.height);\n        rect1.x = Math.min(rect1.x, rect.x);\n        rect1.y = Math.min(rect1.y, rect.y);\n        rect1.width = right - rect1.x;\n        rect1.height = bottom - rect1.y;\n      } else {\n        rect1 = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n    }\n\n    return rect1;\n  };\n  /* tslint:disable */\n\n  /**\n   *  Initializes the layouting process \\\n   *\n   * @returns {  Vertex }     Initializes the layouting process \\\n   * @param {INode[]} nodes - provide the node value.\n   * @param {{}} nameTable - provide the nameTable value.\n   * @param {Layout} layoutProp - provide the layoutProp value.\n   * @param {PointModel} viewPort - provide the viewPort value.\n   * @param {LineDistribution} lineDistribution - provide the lineDistribution value.\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.doLayout = function (nodes, nameTable, layoutProp, viewPort, lineDistribution) {\n    this.nameTable = nameTable;\n    var canEnableRouting = layoutProp.enableRouting;\n    var layout = {\n      horizontalSpacing: layoutProp.horizontalSpacing,\n      verticalSpacing: layoutProp.verticalSpacing,\n      orientation: layoutProp.orientation,\n      marginX: layoutProp.margin.left,\n      marginY: layoutProp.margin.top,\n      enableLayoutRouting: canEnableRouting\n    };\n    var model;\n\n    if (lineDistribution) {\n      lineDistribution.edgeMapper = [];\n    }\n\n    var nodeWithMultiEdges = [];\n    this.vertices = [];\n    var filledVertexSet = {};\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = this.createVertex(nodes[i], nodes[i].id, 0, 0, nodes[i].actualSize.width, nodes[i].actualSize.height);\n      this.vertices.push(node);\n\n      if (nodes[i].inEdges.length > 0 || nodes[i].outEdges.length > 0) {\n        nodeWithMultiEdges.push(nodes[i]);\n      }\n\n      filledVertexSet[node.name] = node;\n\n      if (lineDistribution) {\n        var outEdges = nodes[i].outEdges.slice();\n\n        for (var j = 0; j < outEdges.length; j++) {\n          var outEdge = nameTable[outEdges[j]];\n          lineDistribution.setEdgeMapper({\n            key: outEdge,\n            value: []\n          });\n        }\n      }\n    }\n\n    var hierarchyVertices = []; //let candidateRoots: Vertex[];\n\n    var candidateRoots = this.findRoots(filledVertexSet);\n\n    for (var i = 0; i < candidateRoots.length; i++) {\n      var vertexSet = {};\n      hierarchyVertices.push(vertexSet);\n      this.traverse(candidateRoots[i], true, null, vertexSet, hierarchyVertices, filledVertexSet);\n    }\n\n    var limit = {\n      marginX: 0,\n      marginY: 0\n    };\n    var tmp = [];\n    var checkLinear = false;\n    var matrixModel;\n\n    for (var i = 0; i < hierarchyVertices.length; i++) {\n      var vertexSet = hierarchyVertices[i]; // eslint-disable-next-line\n\n      for (var _i = 0, _a = Object.keys(vertexSet); _i < _a.length; _i++) {\n        var key = _a[_i];\n        tmp.push(vertexSet[key]);\n      }\n\n      if (layoutProp.arrangement === 'Linear' && i === hierarchyVertices.length - 1 || canEnableRouting) {\n        checkLinear = true;\n      }\n\n      model = new MultiParentModel(this, tmp, candidateRoots, layout);\n      this.cycleStage(model);\n      this.layeringStage(model);\n\n      if (lineDistribution && layoutProp.connectionPointOrigin === 'DifferentPoint' || checkLinear) {\n        matrixModel = this.matrixModel({\n          model: model,\n          matrix: [],\n          rowOffset: []\n        });\n        lineDistribution.arrangeElements(matrixModel, layoutProp);\n      } else {\n        if (layoutProp.arrangement === 'Nonlinear') {\n          this.crossingStage(model);\n          limit = this.placementStage(model, limit.marginX, limit.marginY);\n          tmp = [];\n        }\n      }\n    }\n\n    var modelBounds = this.getModelBounds(this.vertices);\n    this.updateMargin(layoutProp, layout, modelBounds, viewPort);\n\n    for (var i = 0; i < this.vertices.length; i++) {\n      var clnode = this.vertices[i];\n\n      if (clnode) {\n        //Check what is node.source/node.target -  && !clnode.source && !clnode.target) {\n        var dnode = this.nameTable[clnode.name];\n        dnode.offsetX = 0;\n        dnode.offsetY = 0; //initialize layout\n\n        var dx = clnode.geometry.x - (dnode.offsetX - dnode.actualSize.width / 2) + layout.marginX;\n        var dy = clnode.geometry.y - (dnode.offsetY - dnode.actualSize.height / 2) + layout.marginY;\n        var x = dx;\n        var y = dy;\n\n        if (layout.orientation === 'BottomToTop') {\n          if (canEnableRouting) {\n            clnode.geometry.y = modelBounds.height - dy - dnode.actualSize.height / 2;\n          }\n\n          y = modelBounds.height - dy;\n        } else if (layout.orientation === 'RightToLeft') {\n          x = modelBounds.width - dx;\n        }\n\n        dnode.offsetX += x - dnode.offsetX;\n        dnode.offsetY += y - dnode.offsetY;\n      }\n    }\n\n    if (!checkLinear) {\n      for (var i = 0; i < this.vertices.length; i++) {\n        this.isNodeOverLap(this.nameTable[this.vertices[i].name], layoutProp);\n      }\n    }\n\n    if (lineDistribution && layoutProp.connectionPointOrigin === 'DifferentPoint' || canEnableRouting) {\n      lineDistribution.updateLayout(viewPort, modelBounds, layoutProp, layout, nodeWithMultiEdges, nameTable);\n    }\n\n    if (canEnableRouting) {\n      var vertices = {};\n      var matrixrow1 = void 0;\n\n      for (var p = 0; p < matrixModel.matrix.length; p++) {\n        matrixrow1 = matrixModel.matrix[p].value;\n\n        for (var q = 0; q < matrixrow1.length; q++) {\n          var matrixCell = matrixrow1[q];\n\n          for (var r = 0; r < matrixCell.cells.length; r++) {\n            var cell = matrixCell.cells[r];\n            var type = this.getType(cell.type);\n\n            if (type === 'internalVertex') {\n              var internalVertex = cell;\n              vertices[internalVertex.id] = internalVertex;\n            }\n          }\n        }\n      }\n\n      this.updateRankValuess(model);\n\n      for (var i = 0, a = Object.keys(vertices); i < a.length; i++) {\n        var key = a[i];\n        this.setVertexLocationValue(vertices[key], layoutProp.orientation, modelBounds);\n      }\n\n      this.localEdgeProcessing(model, vertices);\n      this.assignRankOffset(model);\n      this.updateEdgeSetXYValue(model);\n      var edges = this.getValues(model.edgeMapper);\n\n      for (var i = 0; i < edges.length; i++) {\n        if (edges[i].x.length > 0) {\n          for (var j = 0; j < edges[i].x.length; j++) {\n            if (layoutProp.orientation !== 'RightToLeft' && layoutProp.orientation !== 'LeftToRight') {\n              edges[i].x[j] = edges[i].x[j] + layout.marginX;\n            } else if (layoutProp.orientation === 'LeftToRight') {\n              edges[i].x[j] = edges[i].x[j] + layoutProp.verticalSpacing / 2;\n            } else {\n              edges[i].x[j] = edges[i].x[j] + layoutProp.verticalSpacing / 2;\n            }\n          }\n        }\n\n        this.setEdgePosition(edges[i], model, layout);\n      }\n\n      for (var p = 0; p < this.vertices.length; p++) {\n        var clnode = this.vertices[p];\n\n        if (clnode.outEdges.length > 1) {\n          this.updateMultiOutEdgesPoints(clnode);\n        }\n      }\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.setEdgeXY = function (ranks, node, spacing, layer) {\n    if (ranks && node.source.id) {\n      var targetValue = void 0;\n      var sourceValue = void 0;\n\n      for (var i = 0; i < ranks.length; i++) {\n        for (var k = 0; k < ranks[i].length; k++) {\n          if (ranks[i][k].id === node.target.id || ranks[i][k].id === node.source.id) {\n            if (ranks[i][k].id === node.target.id && targetValue === undefined) {\n              targetValue = i;\n            }\n\n            if (ranks[i][k].id === node.source.id && sourceValue === undefined) {\n              sourceValue = i;\n            }\n          }\n        }\n      }\n\n      var rankOffsetValue = void 0;\n\n      for (var m = targetValue; m <= sourceValue; m++) {\n        if (rankOffsetValue === undefined) {\n          rankOffsetValue = this[m + '_RankOffset'];\n        }\n\n        if (rankOffsetValue !== undefined && rankOffsetValue < this[m + '_RankOffset']) {\n          rankOffsetValue = this[m + '_RankOffset'];\n        }\n      }\n\n      if (this['edges'] === undefined) {\n        this['edges'] = {};\n      }\n\n      this['edges'][node.ids[0]] = {\n        x: node.x,\n        y: 0\n      };\n      var value = this.resetOffsetXValue(rankOffsetValue, spacing / 10);\n      node.x[layer - node.minRank - 1] = value;\n\n      for (var k = 0; k < node.edges.length; k++) {\n        node.edges[k]['levelSkip'] = true;\n      }\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.resetOffsetXValue = function (value, spacing) {\n    for (var i = 0, a = Object.keys(this['edges']); i < a.length; i++) {\n      var key = a[i];\n      var length_1 = this['edges'][key].x;\n\n      for (var j = 0; j < length_1.length; j++) {\n        var offsetValue = void 0;\n\n        if (this['edges'][key].x[j] === value) {\n          offsetValue = value + spacing;\n          offsetValue = this.resetOffsetXValue(offsetValue, spacing);\n          return offsetValue;\n        }\n      }\n    }\n\n    return value;\n  };\n\n  HierarchicalLayoutUtil.prototype.setEdgePosition = function (cell, model, layout) {\n    // For parallel edges we need to seperate out the points a\n    // little\n    var offsetX = 0; // Only set the edge control points once\n\n    if (cell.temp[0] !== 101207) {\n      if (cell.maxRank === undefined) {\n        cell.maxRank = -1;\n      }\n\n      if (cell.minRank === undefined) {\n        cell.minRank = -1;\n      }\n\n      var maxRank = cell.maxRank;\n      var minRank = cell.minRank;\n\n      if (maxRank === minRank) {\n        maxRank = cell.source.maxRank;\n        minRank = cell.target.minRank;\n      }\n\n      var parallelEdgeCount = 0;\n      var jettys = this.jettyPositions[cell.ids[0]];\n\n      if (cell.isReversed === undefined) {\n        cell.isReversed = false;\n      } else {\n        cell.isReversed = true;\n      }\n\n      var source = cell.isReversed ? cell.target.cell : cell.source.cell;\n      var layoutReversed = false;\n\n      if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'LeftToRight') {\n        if (model.layout.orientation === 'TopToBottom') {\n          layoutReversed = false;\n        }\n\n        if (model.layout.orientation === 'LeftToRight') {\n          if (!cell.isReversed) {\n            layoutReversed = false;\n          } else {\n            layoutReversed = false;\n          }\n        }\n      } else {\n        if (!cell.isReversed) {\n          layoutReversed = true;\n        }\n      }\n\n      for (var i = 0; i < cell.edges.length; i++) {\n        var realEdge = cell.edges[i];\n        var realSource = this.getVisibleTerminal(realEdge, true); //List oldPoints = graph.getPoints(realEdge);\n\n        var newPoints = []; // Single length reversed edges end up with the jettys in the wrong\n        // places. Since single length edges only have jettys, not segment\n        // control points, we just say the edge isn't reversed in this section\n\n        var reversed = cell.isReversed; // if(cell.isReversed===undefined){\n        //     reversed = false\n        // }else{\n        //     reversed =cell.isReversed\n        // }\n\n        if (realSource !== source) {\n          // The real edges include all core model edges and these can go\n          // in both directions. If the source of the hierarchical model edge\n          // isn't the source of the specific real edge in this iteration\n          // treat if as reversed\n          reversed = !reversed;\n        } // First jetty of edge\n\n\n        if (jettys != null) {\n          var arrayOffset = reversed ? 2 : 0;\n          var y = reversed ? layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank] : layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank];\n          var jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];\n\n          if (reversed !== layoutReversed) {\n            jetty = -jetty;\n          }\n\n          if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n            y += jetty;\n          }\n\n          var x = jettys[parallelEdgeCount * 4 + arrayOffset];\n\n          if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n            newPoints.push(this.getPointvalue(x, y + layout.marginY));\n          } else {\n            if (layout.orientation === 'LeftToRight') {\n              newPoints.push(this.getPointvalue(y + jetty, x + layout.marginY));\n            } else {\n              newPoints.push(this.getPointvalue(y, x + layout.marginY));\n            }\n          }\n        }\n\n        var loopStart = cell.x.length - 1;\n        var loopLimit = -1;\n        var loopDelta = -1;\n        var currentRank = cell.maxRank - 1;\n\n        if (reversed) {\n          loopStart = 0;\n          loopLimit = cell.x.length;\n          loopDelta = 1;\n          currentRank = cell.minRank + 1;\n        } // Reversed edges need the points inserted in\n        // reverse order\n\n\n        for (var j = loopStart; cell.maxRank !== cell.minRank && j !== loopLimit; j += loopDelta) {\n          // The horizontal position in a vertical layout\n          var positionX = cell.x[j] + offsetX; // This cell.x determines the deviated points of the connectors and jetty positions\n          //determine the src and targetgeo points .\n          // Work out the vertical positions in a vertical layout\n          // in the edge buffer channels above and below this rank\n\n          var topChannelY = (this.rankTopY[currentRank] + this.rankBottomY[currentRank + 1]) / 2.0;\n          var bottomChannelY = (this.rankTopY[currentRank - 1] + this.rankBottomY[currentRank]) / 2.0;\n\n          if (reversed) {\n            var tmp = topChannelY;\n            topChannelY = bottomChannelY;\n            bottomChannelY = tmp;\n          }\n\n          if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n            newPoints.push(this.getPointvalue(positionX, topChannelY + layout.marginY));\n            newPoints.push(this.getPointvalue(positionX, bottomChannelY + layout.marginY));\n          } else {\n            newPoints.push(this.getPointvalue(topChannelY, positionX + layout.marginY));\n            newPoints.push(this.getPointvalue(bottomChannelY, positionX + layout.marginY));\n          }\n\n          this.limitX = Math.max(this.limitX, positionX);\n          currentRank += loopDelta;\n        } // Second jetty of edge\n\n\n        if (jettys != null) {\n          var arrayOffset = reversed ? 2 : 0;\n          var rankY = reversed ? layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank] : layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank];\n          var jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];\n\n          if (reversed !== layoutReversed) {\n            jetty = -jetty;\n          }\n\n          var y = rankY - jetty;\n          var x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];\n\n          if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n            newPoints.push(this.getPointvalue(x, y + layout.marginY));\n          } else {\n            newPoints.push(this.getPointvalue(y, x + layout.marginY));\n          }\n        }\n\n        this.setEdgePoints(realEdge, newPoints, model); // Increase offset so next edge is drawn next to\n        // this one\n\n        if (offsetX === 0.0) {\n          offsetX = this.parallelEdgeSpacing;\n        } else if (offsetX > 0) {\n          offsetX = -offsetX;\n        } else {\n          offsetX = -offsetX + this.parallelEdgeSpacing;\n        }\n\n        parallelEdgeCount++;\n      }\n\n      cell.temp[0] = 101207;\n    }\n  };\n  /* tslint:enable */\n  // eslint-disable-next-line\n\n\n  HierarchicalLayoutUtil.prototype.getPointvalue = function (x, y) {\n    return {\n      'x': Number(x) || 0,\n      'y': Number(y) || 0\n    };\n  };\n\n  HierarchicalLayoutUtil.prototype.updateEdgeSetXYValue = function (model) {\n    if (model.layout.enableLayoutRouting) {\n      var isHorizontal = false;\n\n      if (model.layout.orientation === 'LeftToRight' || model.layout.orientation === 'RightToLeft') {\n        isHorizontal = true;\n      }\n\n      for (var i = 0; i < model.ranks.length; i++) {\n        var rank = model.ranks[i];\n\n        for (var k = 0; k < rank.length; k++) {\n          var cell = rank[k];\n\n          if (cell.edges && cell.edges.length > 0) {\n            var spacing = model.layout.horizontalSpacing > 0 ? model.layout.horizontalSpacing / 2 : 15;\n            var check = true;\n\n            if (!(cell.minRank === i - 1 || cell.maxRank === i - 1)) {\n              check = false;\n            }\n\n            if (check) {\n              this.setXY(cell, i, undefined, isHorizontal ? true : false, model.ranks, spacing);\n            }\n          }\n        }\n      }\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.getPreviousLayerConnectedCells = function (layer, cell) {\n    if (cell.previousLayerConnectedCells == null) {\n      cell.previousLayerConnectedCells = [];\n      cell.previousLayerConnectedCells[0] = [];\n\n      for (var i = 0; i < cell.connectsAsSource.length; i++) {\n        var edge = cell.connectsAsSource[i];\n\n        if (edge.minRank === -1 || edge.minRank === layer - 1) {\n          // No dummy nodes in edge, add node of other side of edge\n          cell.previousLayerConnectedCells[0].push(edge.target);\n        } else {\n          // Edge spans at least two layers, add edge\n          cell.previousLayerConnectedCells[0].push(edge);\n        }\n      }\n    }\n\n    return cell.previousLayerConnectedCells[0];\n  };\n\n  HierarchicalLayoutUtil.prototype.compare = function (a, b) {\n    if (a != null && b != null) {\n      if (b.weightedValue > a.weightedValue) {\n        return -1;\n      } else if (b.weightedValue < a.weightedValue) {\n        return 1;\n      }\n    }\n\n    return 0;\n  };\n  /* tslint:disable */\n  // eslint-disable-next-line\n\n\n  HierarchicalLayoutUtil.prototype.localEdgeProcessing = function (model, vertices) {\n    // Iterate through each vertex, look at the edges connected in\n    // both directions.\n    for (var rankIndex = 0; rankIndex < model.ranks.length; rankIndex++) {\n      var rank = model.ranks[rankIndex];\n\n      for (var cellIndex = 0; cellIndex < rank.length; cellIndex++) {\n        var cell = rank[cellIndex];\n\n        if (this.crossReduction.isVertex(cell)) {\n          var currentCells = this.getPreviousLayerConnectedCells(rankIndex, cell);\n          var currentRank = rankIndex - 1; // Two loops, last connected cells, and next\n\n          for (var k = 0; k < 2; k++) {\n            if (currentRank > -1 && currentRank < model.ranks.length && currentCells != null && currentCells.length > 0) {\n              var sortedCells = [];\n\n              for (var j = 0; j < currentCells.length; j++) {\n                var sorter = this.weightedCellSorter(currentCells[j], this.getX(currentRank, currentCells[j]));\n                sortedCells.push(sorter);\n              }\n\n              sortedCells.sort(this.compare);\n              cell.width = vertices[cell.id].cell.geometry.width;\n              cell.height = vertices[cell.id].cell.geometry.height;\n              var leftLimit = void 0;\n\n              if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'BottomToTop') {\n                cell.x[0] = vertices[cell.id].cell.geometry.x + vertices[cell.id].cell.geometry.width / 2;\n                leftLimit = cell.x[0] - cell.width / 2 + vertices[cell.id].cell.geometry.height / 2;\n              } else {\n                cell.x[0] = vertices[cell.id].cell.geometry.y;\n                leftLimit = cell.x[0];\n              }\n\n              var rightLimit = leftLimit + cell.width; // Connected edge count starts at 1 to allow for buffer\n              // with edge of vertex\n\n              var connectedEdgeCount = 0;\n              var connectedEdgeGroupCount = 0;\n              var connectedEdges = []; // Calculate width requirements for all connected edges\n\n              for (var j = 0; j < sortedCells.length; j++) {\n                var innerCell = sortedCells[j].cell;\n                var connections = void 0;\n\n                if (this.crossReduction.isVertex(innerCell)) {\n                  // Get the connecting edge\n                  if (k === 0) {\n                    connections = cell.connectsAsSource;\n                  } else {\n                    connections = cell.connectsAsTarget;\n                  }\n\n                  for (var connIndex = 0; connIndex < connections.length; connIndex++) {\n                    if (connections[connIndex].source === innerCell || connections[connIndex].target === innerCell) {\n                      connectedEdgeCount += connections[connIndex].edges.length;\n                      connectedEdgeGroupCount++;\n                      connectedEdges.push(connections[connIndex]);\n                    }\n                  }\n                } else {\n                  connectedEdgeCount += innerCell.edges.length; // eslint-disable-next-line\n\n                  connectedEdgeGroupCount++;\n                  connectedEdges.push(innerCell);\n                }\n              }\n\n              var requiredWidth = (connectedEdgeCount + 1) * this.previousEdgeDistance; // Add a buffer on the edges of the vertex if the edge count allows\n\n              if (cell.width > requiredWidth + 2 * this.previousEdgeDistance) {\n                leftLimit += this.previousEdgeDistance;\n                rightLimit -= this.previousEdgeDistance;\n              }\n\n              var availableWidth = rightLimit - leftLimit;\n              var edgeSpacing = availableWidth / connectedEdgeCount;\n              var currentX = leftLimit + edgeSpacing / 2.0;\n              var currentYOffset = this.minEdgeJetty - this.previousEdgeOffset;\n              var maxYOffset = 0;\n\n              for (var j = 0; j < connectedEdges.length; j++) {\n                var numActualEdges = connectedEdges[j].edges.length;\n\n                if (this.jettyPositions === undefined) {\n                  this.jettyPositions = {};\n                }\n\n                var pos = this.jettyPositions[connectedEdges[j].ids[0]];\n\n                if (pos == null) {\n                  pos = [];\n                  this.jettyPositions[connectedEdges[j].ids[0]] = pos;\n                }\n\n                if (j < connectedEdgeCount / 2) {\n                  currentYOffset += this.previousEdgeOffset;\n                } else if (j > connectedEdgeCount / 2) {\n                  currentYOffset -= this.previousEdgeOffset;\n                } // Ignore the case if equals, this means the second of 2\n                // jettys with the same y (even number of edges)\n\n\n                for (var m = 0; m < numActualEdges; m++) {\n                  pos[m * 4 + k * 2] = currentX;\n                  currentX += edgeSpacing;\n                  pos[m * 4 + k * 2 + 1] = currentYOffset;\n                }\n\n                maxYOffset = Math.max(maxYOffset, currentYOffset);\n              }\n            }\n\n            currentCells = this.getNextLayerConnectedCells(rankIndex, cell);\n            currentRank = rankIndex + 1;\n          }\n        }\n      }\n    }\n  };\n  /* tslint:enable */\n\n\n  HierarchicalLayoutUtil.prototype.updateMultiOutEdgesPoints = function (clnode) {\n    for (var i = 0; i < clnode.outEdges.length / 2; i++) {\n      var connector1 = this.nameTable[clnode.outEdges[i]];\n      var connector2 = this.nameTable[clnode.outEdges[clnode.outEdges.length - (i + 1)]];\n      var geometry = 'geometry';\n      connector2[geometry].points[0].y = connector1[geometry].points[0].y;\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.getNextLayerConnectedCells = function (layer, cell) {\n    if (cell.nextLayerConnectedCells == null) {\n      cell.nextLayerConnectedCells = [];\n      cell.nextLayerConnectedCells[0] = [];\n\n      for (var i = 0; i < cell.connectsAsTarget.length; i++) {\n        var edge = cell.connectsAsTarget[i];\n\n        if (edge.maxRank === -1 || edge.maxRank === layer + 1) {\n          // Either edge is not in any rank or\n          // no dummy nodes in edge, add node of other side of edge\n          cell.nextLayerConnectedCells[0].push(edge.source);\n        } else {\n          // Edge spans at least two layers, add edge\n          cell.nextLayerConnectedCells[0].push(edge);\n        }\n      }\n    }\n\n    return cell.nextLayerConnectedCells[0];\n  };\n\n  HierarchicalLayoutUtil.prototype.getX = function (layer, cell) {\n    if (this.crossReduction.isVertex(cell)) {\n      return cell.x[0];\n    } else if (!this.crossReduction.isVertex(cell)) {\n      return cell.x[layer - cell.minRank - 1] || cell.temp[layer - cell.minRank - 1];\n    }\n\n    return 0.0;\n  };\n\n  HierarchicalLayoutUtil.prototype.getGeometry = function (edge) {\n    var geometry = 'geometry';\n    return edge[geometry];\n  };\n\n  HierarchicalLayoutUtil.prototype.setEdgePoints = function (edge, points, model) {\n    if (edge != null) {\n      var geometryValue = 'geometry';\n      var geometry = this.getGeometry(edge);\n\n      if (points != null) {\n        for (var i = 0; i < points.length; i++) {\n          // eslint-disable-next-line\n          points[i].x = points[i].x; // eslint-disable-next-line\n\n          points[i].y = points[i].y;\n        }\n      }\n\n      geometry.points = points;\n      edge[geometryValue] = geometry;\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.assignRankOffset = function (model) {\n    if (model) {\n      for (var i = 0; i < model.ranks.length; i++) {\n        this.rankCoordinatesAssigment(i, model);\n      }\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.rankCoordinatesAssigment = function (rankValue, model) {\n    var rank = model.ranks[rankValue];\n    var spacing = model.layout.horizontalSpacing;\n    var localOffset;\n\n    for (var i = 0; i < rank.length; i++) {\n      if (this[rankValue + '_' + 'RankOffset'] === undefined) {\n        this[rankValue + '_' + 'RankOffset'] = 0;\n      }\n\n      localOffset = rank[i].x[0];\n\n      if (this[rankValue + '_' + 'RankOffset'] < localOffset) {\n        this[rankValue + '_' + 'RankOffset'] = localOffset + rank[i].width / 2 + spacing;\n      }\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.getType = function (type) {\n    if (type === 'internalVertex') {\n      return 'internalVertex';\n    } else {\n      return 'internalEdge';\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.updateRankValuess = function (model) {\n    this.rankTopY = [];\n    this.rankBottomY = [];\n\n    for (var i = 0; i < model.ranks.length; i++) {\n      this.rankTopY[i] = Number.MAX_VALUE;\n      this.rankBottomY[i] = -Number.MAX_VALUE;\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.setVertexLocationValue = function (cell, orientation, modelBounds) {\n    var cellGeomtry = cell.cell.geometry;\n    var positionX;\n    var positionY;\n\n    if (orientation === 'TopToBottom' || orientation === 'BottomToTop') {\n      positionX = cellGeomtry.x;\n      positionY = cellGeomtry.y;\n    } else {\n      positionX = cellGeomtry.y;\n      positionY = cellGeomtry.x;\n    }\n\n    if (orientation === 'RightToLeft') {\n      // eslint-disable-next-line\n      positionX = cellGeomtry.y;\n      positionY = modelBounds.width - cellGeomtry.x - cellGeomtry.height;\n      this.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank], positionY);\n      this.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY + cellGeomtry.height);\n    } else {\n      this.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY);\n      this.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank], positionY + cellGeomtry.height);\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.matrixModel = function (options) {\n    // eslint-disable-next-line\n    options.model = options.model;\n    options.matrix = options.matrix || [];\n    options.rowOffset = options.rowOffset || [];\n    return options;\n  };\n\n  HierarchicalLayoutUtil.prototype.calculateRectValue = function (dnode) {\n    var rect = {\n      x: 0,\n      y: 0,\n      right: 0,\n      bottom: 0,\n      height: 0,\n      width: 0\n    };\n    rect.x = dnode.offsetX - dnode.actualSize.width / 2;\n    rect.right = dnode.offsetX + dnode.actualSize.width / 2;\n    rect.y = dnode.offsetY - dnode.actualSize.height / 2;\n    rect.bottom = dnode.offsetY + dnode.actualSize.height / 2;\n    return rect;\n  };\n\n  HierarchicalLayoutUtil.prototype.isNodeOverLap = function (dnode, layoutProp) {\n    var nodeRect = {\n      x: 0,\n      y: 0,\n      right: 0,\n      bottom: 0,\n      height: 0,\n      width: 0\n    };\n\n    for (var i = 0; i < this.vertices.length; i++) {\n      var rect = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      }; //let tempnode1: INode;\n\n      var tempnode1 = this.nameTable[this.vertices[i].value];\n\n      if (dnode.id !== tempnode1.id && tempnode1.offsetX !== 0 && tempnode1.offsetY !== 0) {\n        nodeRect = this.calculateRectValue(dnode);\n        rect = this.calculateRectValue(tempnode1);\n\n        if (this.isIntersect(rect, nodeRect, layoutProp)) {\n          if (layoutProp.orientation === 'TopToBottom' || layoutProp.orientation === 'BottomToTop') {\n            dnode.offsetX += layoutProp.horizontalSpacing;\n          } else {\n            dnode.offsetY += layoutProp.verticalSpacing;\n          }\n\n          this.isNodeOverLap(dnode, layoutProp);\n        }\n      }\n    }\n  };\n\n  HierarchicalLayoutUtil.prototype.isIntersect = function (rect, nodeRect, layoutProp) {\n    if (!(Math.floor(rect.right + layoutProp.horizontalSpacing) <= Math.floor(nodeRect.x) || Math.floor(rect.x - layoutProp.horizontalSpacing) >= Math.floor(nodeRect.right) || Math.floor(rect.y - layoutProp.verticalSpacing) >= Math.floor(nodeRect.bottom) || Math.floor(rect.bottom + layoutProp.verticalSpacing) <= Math.floor(nodeRect.y))) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /* eslint-disable */\n\n\n  HierarchicalLayoutUtil.prototype.updateMargin = function (layoutProp, layout, modelBounds, viewPort) {\n    var viewPortBounds = {\n      x: 0,\n      y: 0,\n      width: viewPort.x,\n      height: viewPort.y\n    }; //let layoutBounds: Rect;\n\n    var bounds = {\n      x: modelBounds.x,\n      y: modelBounds.y,\n      right: modelBounds.x + modelBounds.width,\n      bottom: modelBounds.y + modelBounds.height\n    };\n    var layoutBounds = layoutProp.bounds ? layoutProp.bounds : viewPortBounds;\n\n    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n      switch (layoutProp.horizontalAlignment) {\n        case 'Auto':\n        case 'Left':\n          layout.marginX = layoutBounds.x - bounds.x + layoutProp.margin.left;\n          break;\n\n        case 'Right':\n          layout.marginX = layoutBounds.x + layoutBounds.width - layoutProp.margin.right - bounds.right;\n          break;\n\n        case 'Center':\n          layout.marginX = layoutBounds.x + layoutBounds.width / 2 - (bounds.x + bounds.right) / 2;\n          break;\n      }\n\n      switch (layoutProp.verticalAlignment) {\n        case 'Top':\n          //const top: number;\n          var top_1 = layoutBounds.y + layoutProp.margin.top;\n          layout.marginY = layout.orientation === 'TopToBottom' ? top_1 : -top_1;\n          break;\n\n        case 'Bottom':\n          //const bottom: number;\n          var bottom = layoutBounds.y + layoutBounds.height - layoutProp.margin.bottom;\n          layout.marginY = layout.orientation === 'TopToBottom' ? bottom - bounds.bottom : -(bottom - bounds.bottom);\n          break;\n\n        case 'Auto':\n        case 'Center':\n          //const center: number;\n          var center = layoutBounds.y + layoutBounds.height / 2;\n          layout.marginY = layout.orientation === 'TopToBottom' ? center - (bounds.y + bounds.bottom) / 2 : -center + (bounds.y + bounds.bottom) / 2;\n          break;\n      }\n    } else {\n      switch (layoutProp.horizontalAlignment) {\n        case 'Auto':\n        case 'Left':\n          //let left: number;\n          var left = layoutBounds.x + layoutProp.margin.left;\n          layout.marginX = layout.orientation === 'LeftToRight' ? left : -left;\n          break;\n\n        case 'Right':\n          var right = void 0;\n          right = layoutBounds.x + layoutBounds.width - layoutProp.margin.right;\n          layout.marginX = layout.orientation === 'LeftToRight' ? right - bounds.right : bounds.right - right;\n          break;\n\n        case 'Center':\n          var center = void 0;\n          center = layoutBounds.width / 2 + layoutBounds.x;\n          layout.marginX = layout.orientation === 'LeftToRight' ? center - (bounds.y + bounds.bottom) / 2 : -center + (bounds.x + bounds.right) / 2;\n          break;\n      }\n\n      switch (layoutProp.verticalAlignment) {\n        case 'Top':\n          layout.marginY = layoutBounds.y + layoutProp.margin.top - bounds.x;\n          break;\n\n        case 'Auto':\n        case 'Center':\n          layout.marginY = layoutBounds.y + layoutBounds.height / 2 - (bounds.y + bounds.bottom) / 2;\n          break;\n\n        case 'Bottom':\n          layout.marginY = layoutBounds.y + layoutBounds.height - layoutProp.margin.bottom - bounds.bottom;\n          break;\n      }\n    }\n  };\n  /* eslint-enable */\n  //Handles positioning the nodes\n\n\n  HierarchicalLayoutUtil.prototype.placementStage = function (model, marginX, marginY) {\n    var placementStage = this.coordinateAssignment(marginX, marginY, parent, model);\n    placementStage.model = model;\n    placementStage.widestRankValue = null;\n    this.placementStageExecute(placementStage);\n    return {\n      marginX: placementStage.marginX + model.layout.horizontalSpacing,\n      marginY: placementStage.marginY + model.layout.verticalSpacing\n    };\n  }; //Initializes the layout properties for positioning\n\n\n  HierarchicalLayoutUtil.prototype.coordinateAssignment = function (marginX, marginY, parent, model) {\n    var plalementChange = {};\n\n    if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'BottomToTop') {\n      plalementChange.horizontalSpacing = model.layout.horizontalSpacing;\n      plalementChange.verticalSpacing = model.layout.verticalSpacing;\n    } else {\n      plalementChange.horizontalSpacing = model.layout.verticalSpacing;\n      plalementChange.verticalSpacing = model.layout.horizontalSpacing;\n    }\n\n    plalementChange.orientation = 'north'; //Removed the conditions here. So check here in case of any issue\n\n    plalementChange.marginX = plalementChange.marginX = marginX;\n    plalementChange.marginY = plalementChange.marginY = marginY;\n    return plalementChange;\n  }; //Calculate the largest size of the node either height or width depends upon the layoutorientation\n\n\n  HierarchicalLayoutUtil.prototype.calculateWidestRank = function (plalementChange, graph, model) {\n    var isHorizontal = false;\n\n    if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {\n      isHorizontal = true;\n    }\n\n    var offset = -plalementChange.verticalSpacing;\n    var lastRankMaxCellSize = 0.0;\n    plalementChange.rankSizes = [];\n    plalementChange.rankOffset = [];\n\n    for (var rankValue = model.maxRank; rankValue >= 0; rankValue--) {\n      var maxCellSize = 0.0;\n      var rank = model.ranks[rankValue];\n      var localOffset = isHorizontal ? plalementChange.marginY : plalementChange.marginX;\n\n      for (var i = 0; i < rank.length; i++) {\n        var node = rank[i];\n\n        if (this.crossReduction.isVertex(node)) {\n          var vertex = node;\n\n          if (vertex.cell && (vertex.cell.inEdges || vertex.cell.outEdges)) {\n            var obj = this.nameTable[vertex.cell.name];\n            vertex.width = obj.actualSize.width;\n            vertex.height = obj.actualSize.height;\n            maxCellSize = Math.max(maxCellSize, isHorizontal ? vertex.width : vertex.height);\n          }\n        } else {\n          if (node) {\n            var edge = node;\n            var numEdges = 1;\n\n            if (edge.edges != null) {\n              numEdges = edge.edges.length;\n            }\n\n            node.width = (numEdges - 1) * 10;\n          }\n        }\n\n        if (isHorizontal) {\n          if (!node.height) {\n            node.height = 0;\n          }\n        } // Set the initial x-value as being the best result so far\n\n\n        localOffset += (isHorizontal ? node.height : node.width) / 2.0;\n        this.setXY(node, rankValue, localOffset, isHorizontal ? true : false);\n        this.setTempVariable(node, rankValue, localOffset);\n        localOffset += (isHorizontal ? node.height : node.width) / 2.0 + plalementChange.horizontalSpacing;\n\n        if (localOffset > plalementChange.widestRankValue) {\n          plalementChange.widestRankValue = localOffset;\n          plalementChange.widestRank = rankValue;\n        }\n\n        plalementChange.rankSizes[rankValue] = localOffset;\n      }\n\n      plalementChange.rankOffset[rankValue] = offset;\n      var distanceToNextRank = maxCellSize / 2.0 + lastRankMaxCellSize / 2.0 + plalementChange.verticalSpacing;\n      lastRankMaxCellSize = maxCellSize;\n\n      if (plalementChange.orientation === 'north' || plalementChange.orientation === 'west') {\n        offset += distanceToNextRank;\n      } else {\n        offset -= distanceToNextRank;\n      }\n\n      for (var i = 0; i < rank.length; i++) {\n        var cell = rank[i];\n        this.setXY(cell, rankValue, offset, isHorizontal ? false : true);\n      }\n    }\n  };\n  /**\n   * Sets the temp position of the node on the layer \\\n   *\n   * @returns {  void }  Sets the temp position of the node on the layer \\\n   * @param {IVertex} node - provide the nodes value.\n   * @param {number} layer - provide the layer value.\n   * @param {number} value - provide the value value.\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.setTempVariable = function (node, layer, value) {\n    if (this.crossReduction.isVertex(node)) {\n      node.temp[0] = value;\n    } else {\n      node.temp[layer - node.minRank - 1] = value;\n    }\n  }; // eslint-disable-next-line valid-jsdoc\n\n  /**\n   * setXY method \\\n   *\n   * @returns { void }     setXY method .\\\n   * @param {IVertex} node - provide the source value.\n   * @param {number} layer - provide the target value.\n   * @param {number} value - provide the layoutOrientation value.\n   * @param {boolean} isY - provide the layoutOrientation value.\n   * @param {IVertex[][]} ranks - provide the layoutOrientation value.\n   * @param {number} spacing - provide the layoutOrientation value.\n   *\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.setXY = function (node, layer, value, isY, ranks, spacing) {\n    if (node && node.cell) {\n      if (node.cell.inEdges || node.cell.outEdges) {\n        if (isY) {\n          node.y[0] = value;\n        } else {\n          node.x[0] = value;\n        }\n      } else {\n        if (isY) {\n          node.y[layer - node.minRank - 1] = value;\n        } else {\n          node.x[layer - node.minRank - 1] = value;\n        }\n      }\n    } else {\n      this.setEdgeXY(ranks, node, spacing, layer);\n    }\n  }; //Sets geometry position of the layout node on the layout model\n\n\n  HierarchicalLayoutUtil.prototype.rankCoordinates = function (stage, rankValue, graph, model) {\n    var isHorizontal = false;\n\n    if (stage.model.layout.orientation === 'LeftToRight' || stage.model.layout.orientation === 'RightToLeft') {\n      isHorizontal = true;\n    }\n\n    var rank = model.ranks[rankValue];\n    var maxOffset = 0.0;\n    var localOffset = (isHorizontal ? stage.marginY : stage.marginX) + (stage.widestRankValue - stage.rankSizes[rankValue]) / 2;\n\n    for (var i = 0; i < rank.length; i++) {\n      var node = rank[i];\n\n      if (this.crossReduction.isVertex(node)) {\n        var obj = this.nameTable[node.cell.name];\n        node.width = obj.actualSize.width;\n        node.height = obj.actualSize.height;\n        maxOffset = Math.max(maxOffset, node.height);\n      } else {\n        var edge = node;\n        var numEdges = 1;\n\n        if (edge.edges != null) {\n          numEdges = edge.edges.length;\n        }\n\n        if (isHorizontal) {\n          node.height = (numEdges - 1) * 10;\n        } else {\n          node.width = (numEdges - 1) * 10;\n        }\n      }\n\n      var size = (isHorizontal ? node.height : node.width) / 2.0;\n      localOffset += size;\n      this.setXY(node, rankValue, localOffset, isHorizontal ? true : false);\n      this.setTempVariable(node, rankValue, localOffset);\n      localOffset += size + stage.horizontalSpacing;\n    }\n  }; //sets the layout in an initial positioning.it will arange all the ranks as much as possible\n\n\n  HierarchicalLayoutUtil.prototype.initialCoords = function (plalementChange, facade, model) {\n    this.calculateWidestRank(plalementChange, facade, model); // Reverse sweep direction each time from widest rank\n\n    for (var i = plalementChange.widestRank; i >= 0; i--) {\n      if (i < model.maxRank) {\n        this.rankCoordinates(plalementChange, i, facade, model);\n      }\n    }\n\n    for (var i = plalementChange.widestRank + 1; i <= model.maxRank; i++) {\n      if (i > 0) {\n        this.rankCoordinates(plalementChange, i, facade, model);\n      }\n    }\n  };\n  /**\n   *  Checks whether the given node is an ancestor \\\n   *\n   * @returns {  boolean }  Checks whether the given node is an ancestor \\\n   * @param {IVertex} node - provide the nodes value.\n   * @param {IVertex} otherNode - provide the layer value.\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.isAncestor = function (node, otherNode) {\n    // Firstly, the hash code of this node needs to be shorter than the other node\n    if (otherNode != null && node.hashCode != null && otherNode.hashCode != null && node.hashCode.length < otherNode.hashCode.length) {\n      if (node.hashCode === otherNode.hashCode) {\n        return true;\n      }\n\n      if (node.hashCode == null || node.hashCode == null) {\n        return false;\n      }\n\n      for (var i = 0; i < node.hashCode.length; i++) {\n        if (node.hashCode[i] !== otherNode.hashCode[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }; //initializes the sorter object\n\n\n  HierarchicalLayoutUtil.prototype.weightedCellSorter = function (cell, weightedValue) {\n    var weightedCellSorter = {};\n    weightedCellSorter.cell = cell ? cell : null;\n    weightedCellSorter.weightedValue = weightedValue ? weightedValue : 0;\n    weightedCellSorter.visited = false;\n    weightedCellSorter.rankIndex = null;\n    return weightedCellSorter;\n  }; //Performs one node positioning in both directions\n\n\n  HierarchicalLayoutUtil.prototype.minNode = function (plalementChange, model) {\n    var nodeList = [];\n    var map = {\n      map: {}\n    };\n    var rank = [];\n\n    for (var i = 0; i <= model.maxRank; i++) {\n      rank[i] = model.ranks[i];\n\n      for (var j = 0; j < rank[i].length; j++) {\n        var node = rank[i][j];\n        var nodeWrapper = this.weightedCellSorter(node, i);\n        nodeWrapper.rankIndex = j;\n        nodeWrapper.visited = true;\n        nodeList.push(nodeWrapper);\n        model.setDictionaryForSorter(map, node, nodeWrapper, true);\n      }\n    }\n\n    var maxTries = nodeList.length * 10;\n    var count = 0;\n    var tolerance = 1;\n\n    while (nodeList.length > 0 && count <= maxTries) {\n      var cellWrapper = nodeList.shift();\n      var cell = cellWrapper.cell;\n      var rankValue = cellWrapper.weightedValue;\n      var rankIndex = cellWrapper.rankIndex;\n      var nextLayerConnectedCells = this.crossReduction.getConnectedCellsOnLayer(cell, rankValue);\n      var previousLayerConnectedCells = this.crossReduction.getConnectedCellsOnLayer(cell, rankValue, true);\n      var nextConnectedCount = nextLayerConnectedCells.length;\n      var prevConnectedCount = previousLayerConnectedCells.length;\n      var medianNextLevel = this.medianXValue(plalementChange, nextLayerConnectedCells, rankValue + 1);\n      var medianPreviousLevel = this.medianXValue(plalementChange, previousLayerConnectedCells, rankValue - 1);\n      var numConnectedNeighbours = nextConnectedCount + prevConnectedCount;\n      var currentPosition = this.crossReduction.getTempVariable(cell, rankValue);\n      var cellMedian = currentPosition;\n\n      if (numConnectedNeighbours > 0) {\n        cellMedian = (medianNextLevel * nextConnectedCount + medianPreviousLevel * prevConnectedCount) / numConnectedNeighbours;\n      }\n\n      if (nextConnectedCount === 1 && prevConnectedCount === 1) {\n        cellMedian = medianPreviousLevel * prevConnectedCount / prevConnectedCount;\n      } else if (nextConnectedCount === 1) {\n        cellMedian = medianNextLevel * nextConnectedCount / nextConnectedCount;\n      }\n\n      var positionChanged = false;\n      var tempValue = undefined;\n\n      if (cellMedian < currentPosition - tolerance) {\n        if (rankIndex === 0) {\n          tempValue = cellMedian;\n          positionChanged = true;\n        } else {\n          var leftCell = rank[rankValue][rankIndex - 1];\n          var leftLimit = this.crossReduction.getTempVariable(leftCell, rankValue);\n          leftLimit = leftLimit + leftCell.width / 2 + plalementChange.intraCellSpacing + cell.width / 2;\n\n          if (leftLimit < cellMedian) {\n            tempValue = cellMedian;\n            positionChanged = true;\n          } else if (leftLimit < this.crossReduction.getTempVariable(cell, rankValue) - tolerance) {\n            tempValue = leftLimit;\n            positionChanged = true;\n          }\n        }\n      } else if (cellMedian > currentPosition + tolerance) {\n        var rankSize = rank[rankValue].length;\n\n        if (rankIndex === rankSize - 1) {\n          tempValue = cellMedian;\n          positionChanged = true;\n        } else {\n          var rightCell = rank[rankValue][rankIndex + 1];\n          var rightLimit = this.crossReduction.getTempVariable(rightCell, rankValue);\n          rightLimit = rightLimit - rightCell.width / 2 - plalementChange.intraCellSpacing - cell.width / 2;\n\n          if (rightLimit > cellMedian) {\n            tempValue = cellMedian;\n            positionChanged = true;\n          } else if (rightLimit > this.crossReduction.getTempVariable(cell, rankValue) + tolerance) {\n            tempValue = rightLimit;\n            positionChanged = true;\n          }\n        }\n      }\n\n      if (positionChanged) {\n        this.setTempVariable(cell, rankValue, tempValue); // Add connected nodes to map and list\n\n        this.updateNodeList(nodeList, map, nextLayerConnectedCells, model);\n        this.updateNodeList(nodeList, map, previousLayerConnectedCells, model);\n      }\n\n      if (this.crossReduction.isVertex(cellWrapper.cell)) {\n        cellWrapper.visited = false;\n      }\n\n      count++;\n    }\n  }; //Updates the ndoes collection\n\n\n  HierarchicalLayoutUtil.prototype.updateNodeList = function (nodeList, map, collection, model) {\n    for (var i = 0; i < collection.length; i++) {\n      var connectedCell = collection[i];\n      var connectedCellWrapper = model.getDictionaryForSorter(map, connectedCell);\n\n      if (connectedCellWrapper != null) {\n        if (connectedCellWrapper.visited === false) {\n          connectedCellWrapper.visited = true;\n          nodeList.push(connectedCellWrapper);\n        }\n      }\n    }\n  }; //Calculates the node position of the connected cell on the specified rank\n\n\n  HierarchicalLayoutUtil.prototype.medianXValue = function (plalementChange, connectedCells, rankValue) {\n    if (connectedCells.length === 0) {\n      return 0;\n    }\n\n    var medianValues = [];\n\n    for (var i = 0; i < connectedCells.length; i++) {\n      medianValues[i] = this.crossReduction.getTempVariable(connectedCells[i], rankValue);\n    }\n\n    medianValues.sort(function (a, b) {\n      return a - b;\n    });\n\n    if (connectedCells.length % 2 === 1) {\n      return medianValues[Math.floor(connectedCells.length / 2)];\n    } else {\n      var medianPoint = connectedCells.length / 2;\n      var leftMedian = medianValues[medianPoint - 1];\n      var rightMedian = medianValues[medianPoint];\n      return (leftMedian + rightMedian) / 2;\n    }\n  }; //Updates the geometry of the vertices\n\n\n  HierarchicalLayoutUtil.prototype.placementStageExecute = function (plalementChange) {\n    var isHorizontal = false;\n\n    if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {\n      isHorizontal = true;\n    }\n\n    plalementChange.jettyPositions = {};\n    var model = plalementChange.model; // eslint-disable-next-line\n\n    isHorizontal ? plalementChange.currentYDelta = 0.0 : plalementChange.currentXDelta = 0.0;\n    this.initialCoords(plalementChange, {\n      model: model\n    }, model);\n    this.minNode(plalementChange, model);\n    var bestOffsetDelta = 100000000.0;\n\n    if (!plalementChange.maxIterations) {\n      plalementChange.maxIterations = 8;\n    }\n\n    for (var i = 0; i < plalementChange.maxIterations; i++) {\n      // if the total offset is less for the current positioning,\n      //there are less heavily angled edges and so the current positioning is used\n      if ((isHorizontal ? plalementChange.currentYDelta : plalementChange.currentXDelta) < bestOffsetDelta) {\n        for (var j = 0; j < model.ranks.length; j++) {\n          var rank = model.ranks[j];\n\n          for (var k = 0; k < rank.length; k++) {\n            var cell = rank[k];\n            this.setXY(cell, j, this.crossReduction.getTempVariable(cell, j), isHorizontal ? true : false);\n          }\n        }\n\n        bestOffsetDelta = isHorizontal ? plalementChange.currentYDelta : plalementChange.currentXDelta;\n      } // eslint-disable-next-line\n\n\n      isHorizontal ? plalementChange.currentYDelta = 0 : plalementChange.currentXDelta = 0;\n    }\n\n    this.setCellLocations(plalementChange, model);\n  }; //sets the cell position in the after the layout operation\n\n\n  HierarchicalLayoutUtil.prototype.setCellLocations = function (plalementChange, model) {\n    var vertices = this.getValues(model.vertexMapper);\n\n    for (var i = 0; i < vertices.length; i++) {\n      this.setVertexLocation(plalementChange, vertices[i]);\n    }\n  }; //used to specify the geometrical position of the layout model cell\n\n\n  HierarchicalLayoutUtil.prototype.garphModelsetVertexLocation = function (plalementChange, cell, x, y) {\n    //let model: MultiParentModel = plalementChange.model;\n    var geometry = cell.geometry;\n    var result = null;\n\n    if (geometry != null) {\n      result = {\n        x: x,\n        y: y,\n        width: geometry.width,\n        height: geometry.height\n      };\n\n      if (geometry.x !== x || geometry.y !== y) {\n        cell.geometry = result;\n      }\n    }\n\n    return result;\n  }; //set the position of the specified node\n\n\n  HierarchicalLayoutUtil.prototype.setVertexLocation = function (plalementChange, cell) {\n    var isHorizontal = false;\n\n    if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {\n      isHorizontal = true;\n    }\n\n    var realCell = cell.cell;\n    var positionX = cell.x[0] - cell.width / 2;\n    var positionY = cell.y[0] - cell.height / 2;\n    this.garphModelsetVertexLocation(plalementChange, realCell, positionX, positionY);\n\n    if (isHorizontal) {\n      if (!plalementChange.marginY) {\n        plalementChange.marginY = 0;\n      }\n\n      plalementChange.marginY = Math.max(plalementChange.marginY, positionY + cell.height);\n    } else {\n      if (!plalementChange.marginX) {\n        plalementChange.marginX = 0;\n      }\n\n      plalementChange.marginX = Math.max(plalementChange.marginX, positionX + cell.width);\n    }\n  };\n  /**\n   *  get the specific value from the key value pair \\\n   *\n   * @returns {  {}[] }  get the specific value from the key value pair \\\n   * @param {VertexMapper} mapper - provide the mapper value.\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.getValues = function (mapper) {\n    var list = [];\n\n    if (mapper.map) {\n      for (var _i = 0, _a = Object.keys(mapper.map); _i < _a.length; _i++) {\n        var key = _a[_i];\n        list.push(mapper.map[key]);\n      }\n    }\n\n    return list;\n  };\n  /**\n   *Checks and reduces the crosses in between line segments \\\n   *\n   * @returns { void }    Checks and reduces the crosses in between line segments.\\\n   * @param {End} model - provide the model value.\n   *\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.crossingStage = function (model) {\n    this.crossReduction.execute(model);\n  }; //Initializes the ranks of the vertices\n\n\n  HierarchicalLayoutUtil.prototype.layeringStage = function (model) {\n    this.initialRank(model);\n    this.fixRanks(model);\n  }; //determine the initial rank for the each vertex on the relevent direction\n\n\n  HierarchicalLayoutUtil.prototype.initialRank = function (model) {\n    var startNodes = model.startNodes;\n    var internalNodes = model.getDictionaryValues(model.vertexMapper);\n    var startNodesCopy = startNodes.slice();\n\n    while (startNodes.length > 0) {\n      var internalNode = startNodes[0];\n      var layerDeterminingEdges = internalNode.connectsAsTarget;\n      var edgesToBeMarked = internalNode.connectsAsSource;\n      var allEdgesScanned = true;\n      var minimumLayer = 100000000;\n\n      for (var i = 0; i < layerDeterminingEdges.length; i++) {\n        var internalEdge = layerDeterminingEdges[i];\n\n        if (internalEdge.temp[0] === 5270620) {\n          // This edge has been scanned, get the layer of the node on the other end\n          var otherNode = internalEdge.source;\n          minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n        } else {\n          allEdgesScanned = false;\n          break;\n        }\n      } // If all edge have been scanned, assign the layer, mark all edges in the other direction and remove from the nodes list\n\n\n      if (allEdgesScanned) {\n        internalNode.temp[0] = minimumLayer;\n\n        if (!model.maxRank) {\n          model.maxRank = 100000000;\n        }\n\n        model.maxRank = Math.min(model.maxRank, minimumLayer);\n\n        if (edgesToBeMarked != null) {\n          for (var i = 0; i < edgesToBeMarked.length; i++) {\n            var internalEdge = edgesToBeMarked[i];\n            internalEdge.temp[0] = 5270620; // Add node on other end of edge to LinkedList of nodes to be analysed\n\n            var otherNode = internalEdge.target; // Only add node if it hasn't been assigned a layer\n\n            if (otherNode.temp[0] === -1) {\n              startNodes.push(otherNode); // Mark this other node as neither being unassigned nor assigned\n              //so it isn't added to this list again, but it's layer isn't used in any calculation.\n\n              otherNode.temp[0] = -2;\n            }\n          }\n        }\n\n        startNodes.shift();\n      } else {\n        // Not all the edges have been scanned, get to the back of the class and put the dunces cap on\n        var removedCell = startNodes.shift();\n        startNodes.push(internalNode);\n\n        if (removedCell === internalNode && startNodes.length === 1) {\n          // This is an error condition, we can't get out of this loop.\n          //It could happen for more than one node but that's a lot harder to detect. Log the error\n          break;\n        }\n      }\n    }\n\n    for (var i = 0; i < internalNodes.length; i++) {\n      internalNodes[i].temp[0] -= model.maxRank;\n    }\n\n    for (var i = 0; i < startNodesCopy.length; i++) {\n      var internalNode = startNodesCopy[i];\n      var currentMaxLayer = 0;\n      var layerDeterminingEdges = internalNode.connectsAsSource;\n\n      for (var j = 0; j < layerDeterminingEdges.length; j++) {\n        var internalEdge = layerDeterminingEdges[j];\n        var otherNode = internalEdge.target;\n        internalNode.temp[0] = Math.max(currentMaxLayer, otherNode.temp[0] + 1);\n        currentMaxLayer = internalNode.temp[0];\n      }\n    }\n\n    model.maxRank = 100000000 - model.maxRank;\n  }; //used to set the optimum value of each vertex on the layout\n\n\n  HierarchicalLayoutUtil.prototype.fixRanks = function (model) {\n    model.fixRanks();\n  }; //used to determine any cyclic stage have been created on the layout model\n\n\n  HierarchicalLayoutUtil.prototype.cycleStage = function (model) {\n    var seenNodes = {};\n    model.startNodes = [];\n    var unseenNodesArray = model.getDictionaryValues(model.vertexMapper);\n    var unseenNodes = [];\n\n    for (var i = 0; i < unseenNodesArray.length; i++) {\n      unseenNodesArray[i].temp[0] = -1;\n      unseenNodes[unseenNodesArray[i].id] = unseenNodesArray[i];\n    }\n\n    var rootsArray = null;\n\n    if (model.roots != null) {\n      var modelRoots = model.roots;\n      rootsArray = [];\n\n      for (var i = 0; i < modelRoots.length; i++) {\n        rootsArray[i] = model.getDictionary(model.vertexMapper, modelRoots[i]);\n\n        if (rootsArray[i] != null) {\n          model.startNodes.push(rootsArray[i]);\n        }\n      }\n    }\n\n    model.visit('removeParentConnection', rootsArray, true, null, {\n      seenNodes: seenNodes,\n      unseenNodes: unseenNodes\n    });\n    var seenNodesCopy = model.clone(seenNodes, null, true);\n    model.visit('removeNodeConnection', unseenNodes, true, seenNodesCopy, {\n      seenNodes: seenNodes,\n      unseenNodes: unseenNodes\n    });\n  };\n  /**\n   * removes the edge from the given collection \\\n   *\n   * @returns {  IEdge }    removes the edge from the given collection .\\\n   * @param {IEdge} obj - provide the angle value.\n   * @param { IEdge[]} array - provide the angle value.\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.remove = function (obj, array) {\n    var index = array.indexOf(obj);\n\n    if (index !== -1) {\n      array.splice(index, 1);\n    }\n\n    return obj;\n  };\n  /**\n   * Inverts the source and target of an edge \\\n   *\n   * @returns {  void }    Inverts the source and target of an edge .\\\n   * @param {IEdge} connectingEdge - provide the angle value.\n   * @param { number} layer - provide the angle value.\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.invert = function (connectingEdge, layer) {\n    var temp = connectingEdge.source;\n    connectingEdge.source = connectingEdge.target;\n    connectingEdge.target = temp;\n    connectingEdge.isReversed = !connectingEdge.isReversed;\n  };\n  /**\n   * used to get the edges between the given source and target  \\\n   *\n   * @returns {  IConnector[] }    used to get the edges between the given source and target  .\\\n   * @param {Vertex} source - provide the angle value.\n   * @param { Vertex} target - provide the angle value.\n   * @param { boolean} directed - provide the angle value.\n   * @private\n   */\n\n\n  HierarchicalLayoutUtil.prototype.getEdgesBetween = function (source, target, directed) {\n    directed = directed != null ? directed : false;\n    var edges = this.getEdges(source);\n    var result = [];\n\n    for (var i = 0; i < edges.length; i++) {\n      var src = this.getVisibleTerminal(edges[i], true);\n      var trg = this.getVisibleTerminal(edges[i], false);\n\n      if (src === source && trg === target || !directed && src === target && trg === source) {\n        result.push(edges[i]);\n      }\n    }\n\n    return result;\n  };\n\n  return HierarchicalLayoutUtil;\n}();\n/**\n * Handles position the objects in a hierarchical tree structure\n */\n\n\nvar MultiParentModel =\n/** @class */\nfunction () {\n  function MultiParentModel(layout, vertices, roots, dlayout) {\n    this.multiObjectIdentityCounter = 0; //used to count the no of times the parent have been used\n\n    this.dfsCount = 0;\n    this.hierarchicalUtil = new HierarchicalLayoutUtil();\n    this.roots = roots;\n    this.vertexMapper = {\n      map: {}\n    };\n    var internalVertices = [];\n    this.layout = dlayout;\n    this.maxRank = 100000000;\n    this.edgeMapper = {\n      map: {}\n    };\n    this.hierarchicalLayout = layout;\n    this.createInternalCells(layout, vertices, internalVertices, dlayout);\n\n    for (var i = 0; i < vertices.length; i++) {\n      var edges = internalVertices[i].connectsAsSource;\n\n      for (var j = 0; j < edges.length; j++) {\n        var internalEdge = edges[j];\n        var realEdges = internalEdge.edges;\n\n        if (realEdges != null && realEdges.length > 0) {\n          var realEdge = realEdges[0];\n          var targetCell = layout.getVisibleTerminal(realEdge, false);\n          var internalTargetCell = this.getDictionary(this.vertexMapper, targetCell);\n\n          if (internalVertices[i] === internalTargetCell) {\n            targetCell = layout.getVisibleTerminal(realEdge, true);\n            internalTargetCell = this.getDictionary(this.vertexMapper, targetCell);\n          }\n\n          if (internalTargetCell != null && internalVertices[i] !== internalTargetCell) {\n            internalEdge.target = internalTargetCell;\n\n            if (internalTargetCell.connectsAsTarget.length === 0) {\n              internalTargetCell.connectsAsTarget = [];\n            }\n\n            if (internalTargetCell.connectsAsTarget.indexOf(internalEdge) < 0) {\n              internalTargetCell.connectsAsTarget.push(internalEdge);\n            }\n          }\n        }\n      }\n\n      internalVertices[i].temp[0] = 1;\n    }\n  }\n  /* tslint:disable */\n\n\n  MultiParentModel.prototype.resetEdge = function (edge) {\n    var geometry = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      relative: true\n    };\n    var geo = geometry;\n    edge['geometry'] = geo;\n    return edge;\n  }; // eslint-disable-next-line max-len\n\n\n  MultiParentModel.prototype.createInternalCells = function (layout, vertices, internalVertices, dlayout) {\n    for (var i = 0; i < vertices.length; i++) {\n      internalVertices[i] = {\n        x: [],\n        y: [],\n        temp: [],\n        cell: vertices[i],\n        id: vertices[i].name,\n        connectsAsTarget: [],\n        connectsAsSource: [],\n        type: 'internalVertex'\n      };\n      this.setDictionary(this.vertexMapper, vertices[i], internalVertices[i]);\n      var conns = layout.getEdges(vertices[i]);\n      internalVertices[i].connectsAsSource = [];\n\n      for (var j = 0; j < conns.length; j++) {\n        var cell = layout.getVisibleTerminal(conns[j], false);\n\n        if (cell !== vertices[i]) {\n          var undirectedEdges = layout.getEdgesBetween(vertices[i], cell, false);\n          var directedEdges = layout.getEdgesBetween(vertices[i], cell, true);\n\n          if (undirectedEdges != null && undirectedEdges.length > 0 && directedEdges.length * 2 >= undirectedEdges.length) {\n            var internalEdge = {\n              x: [],\n              y: [],\n              temp: [],\n              edges: undirectedEdges,\n              ids: []\n            };\n\n            if (dlayout.enableLayoutRouting) {\n              for (var k = 0; k < undirectedEdges.length; k++) {\n                var edge = undirectedEdges[k];\n                this.setDictionary(this.edgeMapper, undefined, internalEdge, edge.id); // Resets all point on the edge and disables the edge style\n                // without deleting it from the cell style\n\n                this.resetEdge(edge);\n              }\n            }\n\n            internalEdge.source = internalVertices[i];\n\n            for (var m = 0; m < undirectedEdges.length; m++) {\n              internalEdge.ids.push(undirectedEdges[m].id);\n            }\n\n            internalEdge.source = internalVertices[i];\n\n            if (!internalVertices[i].connectsAsSource) {\n              internalVertices[i].connectsAsSource = [];\n            }\n\n            if (internalVertices[i].connectsAsSource.indexOf(internalEdge) < 0) {\n              internalVertices[i].connectsAsSource.push(internalEdge);\n            }\n          }\n        }\n      }\n\n      internalVertices[i].temp[0] = 0;\n    }\n  };\n  /* tslint:enable */\n\n  /**\n   * used to set the optimum value of each vertex on the layout \\\n   *\n   * @returns {  void }   used to set the optimum value of each vertex on the layout .\\\n   * @private\n   */\n\n\n  MultiParentModel.prototype.fixRanks = function () {\n    var rankList = [];\n    this.ranks = [];\n\n    for (var i = 0; i < this.maxRank + 1; i++) {\n      rankList[i] = [];\n      this.ranks[i] = rankList[i];\n    }\n\n    var rootsArray = null;\n\n    if (this.roots != null) {\n      var oldRootsArray = this.roots;\n      rootsArray = [];\n\n      for (var i = 0; i < oldRootsArray.length; i++) {\n        var cell = oldRootsArray[i];\n        var internalNode = this.getDictionary(this.vertexMapper, cell);\n        rootsArray[i] = internalNode;\n      }\n    }\n\n    this.visit('updateMinMaxRank', rootsArray, false, null, {\n      seenNodes: null,\n      unseenNodes: null,\n      rankList: rankList\n    });\n  }; //Updates the min/max rank of the layer\n\n\n  MultiParentModel.prototype.updateMinMaxRank = function (layer, seen, data) {\n    //let seenNodes: {} = data.seenNodes;\n    //let unseenNodes: {} = data.unseenNodes;\n    var parent = data.parent;\n    var node = data.root;\n    var edge = data.edge;\n    var rankList = data.rankList;\n\n    if (!node.maxRank && node.maxRank !== 0) {\n      node.maxRank = -1;\n    }\n\n    if (!node.minRank && node.minRank !== 0) {\n      node.minRank = -1;\n    }\n\n    if (seen === 0 && node.maxRank < 0 && node.minRank < 0) {\n      rankList[node.temp[0]].push(node);\n      node.maxRank = node.temp[0];\n      node.minRank = node.temp[0];\n      node.temp[0] = rankList[node.maxRank].length - 1;\n    }\n\n    if (parent != null && edge != null) {\n      var parentToCellRankDifference = parent.maxRank - node.maxRank;\n\n      if (parentToCellRankDifference > 1) {\n        edge.maxRank = parent.maxRank;\n        edge.minRank = node.maxRank;\n        edge.temp = [];\n        edge.x = [];\n        edge.y = [];\n\n        for (var i = edge.minRank + 1; i < edge.maxRank; i++) {\n          rankList[i].push(edge);\n          this.hierarchicalUtil.setTempVariable(edge, i, rankList[i].length - 1);\n        }\n      }\n    }\n  }; //used to store the value of th given key on the object\n\n\n  MultiParentModel.prototype.setDictionary = function (dic, key, value, edgeId) {\n    if (!edgeId) {\n      var id = key.name;\n      var previous = dic.map[id];\n      dic.map[id] = value;\n      return previous;\n    } else {\n      var previous = dic.map[edgeId];\n      dic.map[edgeId] = value;\n      return previous;\n    }\n  };\n  /**\n   * used to store the value of th given key on the objectt \\\n   *\n   * @returns {  IVertex }   used to store the value of th given key on the object .\\\n   * @param {VertexMapper} dic - provide the angle value.\n   * @param {IVertex} key - provide the angle value.\n   * @param {WeightedCellSorter} value - provide the angle value.\n   * @param {boolean} flag - provide the angle value.\n   * @private\n   */\n\n\n  MultiParentModel.prototype.setDictionaryForSorter = function (dic, key, value, flag) {\n    var id = key.id;\n\n    if (!id) {//id = this._getDictionaryForSorter(dic, key);\n    }\n\n    var previous = dic.map[id];\n    dic.map[id] = value;\n    return previous;\n  };\n  /**\n   * used to get the value of the given key \\\n   *\n   * @returns {  IVertex }  used to get the value of the given key .\\\n   * @param {VertexMapper} dic - provide the angle value.\n   * @param {IVertex} key - provide the angle value.\n   * @private\n   */\n\n\n  MultiParentModel.prototype.getDictionary = function (dic, key) {\n    if (!this.multiObjectIdentityCounter && this.multiObjectIdentityCounter !== 0) {\n      this.multiObjectIdentityCounter = 0;\n    }\n\n    var id = key.name;\n\n    if (!id) {\n      if (!key.layoutObjectId) {\n        ///####\n        key.layoutObjectId = 'graphHierarchyNode#' + this.multiObjectIdentityCounter++;\n        return key.layoutObjectId;\n      } else {\n        return dic.map[key.layoutObjectId];\n      }\n    }\n\n    return dic.map[id];\n  };\n  /**\n   * used to get the value of the given key \\\n   *\n   * @returns {  IVertex }  used to get the value of the given key .\\\n   * @param {VertexMapper} dic - provide the angle value.\n   * @param {IVertex} key - provide the angle value.\n   * @private\n   */\n\n\n  MultiParentModel.prototype.getDictionaryForSorter = function (dic, key) {\n    if (!this.multiObjectIdentityCounter && this.multiObjectIdentityCounter !== 0) {\n      this.multiObjectIdentityCounter = 0;\n    }\n\n    var id = key.id;\n\n    if (!id) {\n      if (!key.layoutObjectId) {\n        ///####\n        key.layoutObjectId = 'graphHierarchyNode#' + this.multiObjectIdentityCounter++;\n        return key.layoutObjectId;\n      } else {\n        return dic.map[key.layoutObjectId];\n      }\n    }\n\n    return dic.map[id];\n  };\n  /**\n   * used to get all the values of the dictionary object \\\n   *\n   * @returns {  IVertex[] }  used to get all the values of the dictionary object .\\\n   * @param {VertexMapper} dic - provide the angle value.\n   * @private\n   */\n\n\n  MultiParentModel.prototype.getDictionaryValues = function (dic) {\n    var result = [];\n\n    for (var _i = 0, _a = Object.keys(dic.map); _i < _a.length; _i++) {\n      var key = _a[_i];\n      result.push(dic.map[key]);\n    }\n\n    return result;\n  };\n  /**\n   * used to visit all the entries on the given dictionary with given function \\\n   *\n   * @returns { void }  used to visit all the entries on the given dictionary with given function .\\\n   * @param {string} visitor - provide the visitor value.\n   * @param {IVertex[]} dfsRoots - provide the dfsRoots value.\n   * @param {boolean} trackAncestors - provide the trackAncestors value.\n   * @param {{}} seenNodes - provide the seenNodes value.\n   * @param {TraverseData} data - provide the data value.\n   * @private\n   */\n\n\n  MultiParentModel.prototype.visit = function (visitor, dfsRoots, trackAncestors, seenNodes, data) {\n    //let seenNodes1: {} = data.seenNodes;\n    //let unseenNodes1: {} = data.unseenNodes;\n    //let rankList: IVertex[][] = data.rankList;\n    // Run depth first search through on all roots\n    if (dfsRoots != null) {\n      for (var i = 0; i < dfsRoots.length; i++) {\n        var internalNode = dfsRoots[i];\n\n        if (internalNode != null) {\n          if (seenNodes == null) {\n            seenNodes = new Object();\n          }\n\n          data.parent = null;\n          data.root = internalNode;\n          data.edge = null;\n\n          if (trackAncestors) {\n            // Set up hash code for root\n            internalNode.hashCode = [];\n            internalNode.hashCode[0] = this.dfsCount;\n            internalNode.hashCode[1] = i;\n            this.extendedDfs(visitor, seenNodes, i, 0, data);\n          } else {\n            this.depthFirstSearch(visitor, seenNodes, 0, data);\n          }\n        }\n      }\n\n      this.dfsCount++;\n    }\n  }; //used to perform the depth fisrt search on the layout model\n\n\n  MultiParentModel.prototype.depthFirstSearch = function (visitor, seen, layer, data) {\n    //let seenNodes1: {} = data.seenNodes;\n    //let unseenNodes1: {} = data.unseenNodes;\n    //let rankList: IVertex[][] = data.rankList;\n    //let parent: IVertex = data.parent;\n    var root = data.root; //let edge: IEdge = data.edge;\n\n    if (root != null) {\n      var rootId = root.id;\n\n      if (seen[rootId] == null) {\n        seen[rootId] = root;\n        this.updateConnectionRank(visitor, layer, 0, data); // Copy the connects as source list so that visitors can change the original for edge direction inversions\n\n        var outgoingEdges = root.connectsAsSource.slice();\n\n        for (var i = 0; i < outgoingEdges.length; i++) {\n          var internalEdge = outgoingEdges[i];\n          var targetNode = internalEdge.target; // Root check is O(|roots|)\n\n          data.parent = root;\n          data.root = targetNode;\n          data.edge = internalEdge;\n          this.depthFirstSearch(visitor, seen, layer + 1, data);\n        }\n      } else {\n        this.updateConnectionRank(visitor, layer, 1, data);\n      }\n    }\n  }; //Updates the rank of the connection\n\n\n  MultiParentModel.prototype.updateConnectionRank = function (visitor, layer, seen, traversedList) {\n    var parent = traversedList.parent;\n    var root = traversedList.root;\n    var edge = traversedList.edge;\n\n    if (visitor === 'removeParentConnection' || visitor === 'removeNodeConnection') {\n      var remove = visitor === 'removeNodeConnection' ? true : false;\n      this.removeConnectionEdge(parent, root, edge, layer, traversedList, remove);\n    }\n\n    if (visitor === 'updateMinMaxRank') {\n      this.updateMinMaxRank(layer, seen, traversedList);\n    }\n  }; //Removes the edge from the collection\n\n\n  MultiParentModel.prototype.removeConnectionEdge = function (parent, node, edge, layer, data, remove) {\n    var seenNodes = data.seenNodes;\n    var unseenNodes = data.unseenNodes; //let rankList: IVertex[][] = data.rankList;\n\n    if (this.hierarchicalUtil.isAncestor(node, parent)) {\n      this.hierarchicalUtil.invert(edge, 0);\n      this.hierarchicalUtil.remove(edge, parent.connectsAsSource);\n\n      if (remove) {\n        node.connectsAsSource.push(edge);\n        parent.connectsAsTarget.push(edge);\n        this.hierarchicalUtil.remove(edge, node.connectsAsTarget);\n      } else {\n        parent.connectsAsTarget.push(edge);\n        this.hierarchicalUtil.remove(edge, node.connectsAsTarget);\n        node.connectsAsSource.push(edge);\n      }\n    }\n\n    seenNodes[node.id] = node;\n    delete unseenNodes[node.id];\n  }; //the dfs extends the default version by keeping track of cells ancestors, but it should be only used when necessary\n\n\n  MultiParentModel.prototype.extendedDfs = function (visitor, seen, cHash, layer, data) {\n    //let seenNodes: {} = data.seenNodes;\n    //let unseenNodes: {} = data.unseenNodes;\n    //let rankList: IVertex[][] = data.rankList;\n    var parent = data.parent;\n    var root = data.root;\n    var edge = data.edge;\n\n    if (root != null) {\n      if (parent != null) {\n        if (root.hashCode == null || root.hashCode[0] !== parent.hashCode[0]) {\n          var hashCodeLength = parent.hashCode.length + 1;\n          root.hashCode = parent.hashCode.slice();\n          root.hashCode[hashCodeLength - 1] = cHash;\n        }\n      }\n\n      var rootId = root.id;\n\n      if (seen[rootId] == null) {\n        seen[rootId] = root;\n        this.updateConnectionRank(visitor, layer, 0, data);\n        var outgoingEdges = root.connectsAsSource.slice();\n\n        for (var i = 0; i < outgoingEdges.length; i++) {\n          var internalEdge = outgoingEdges[i];\n          var targetNode = internalEdge.target;\n          data.parent = root;\n          data.root = targetNode;\n          data.edge = internalEdge;\n          this.extendedDfs(visitor, seen, i, layer + 1, data);\n        }\n      } else {\n        this.updateConnectionRank(visitor, layer, 1, data);\n      }\n    }\n  };\n  /**\n   * used to clone the specified object ignoring all fieldnames in the given array of transient fields \\\n   *\n   * @returns { void }    used to clone the specified object ignoring all fieldnames in the given array of transient fields .\\\n   * @param {Object} obj - provide the source value.\n   * @param {string[]} transients - provide the target value.\n   * @param {boolean} shallow - provide the shallow value.\n   *\n   * @private\n   */\n\n\n  MultiParentModel.prototype.clone = function (obj, transients, shallow) {\n    shallow = shallow != null ? shallow : false;\n\n    if (obj != null && typeof obj.constructor === 'function') {\n      var clonedObj = obj.constructor();\n\n      for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var i = _a[_i];\n\n        if (i !== 'layoutObjectId' && (transients == null || transients.indexOf(i) < 0)) {\n          if (!shallow && typeof obj[i] === 'object') {//not used\n            //  _clone[i] = $.extend(true, {}, obj[i]);\n          } else {\n            clonedObj[i] = obj[i];\n          }\n        }\n      }\n\n      return clonedObj;\n    }\n\n    return null;\n  };\n\n  return MultiParentModel;\n}();\n/**\n * Defines how to reduce the crosses in between the line segments\n */\n\n\nvar CrossReduction =\n/** @class */\nfunction () {\n  function CrossReduction() {}\n  /**\n   *  used to calculate the number of edges crossing the layout model \\\n   *\n   * @returns { number }  used to calculate the number of edges crossing the layout model\\\n   * @param {MultiParentModel} model - provide the model value.\n   *\n   * @private\n   */\n\n\n  CrossReduction.prototype.calculateCrossings = function (model) {\n    var numRanks = model.ranks.length;\n    var totalCrossings = 0;\n\n    for (var i = 1; i < numRanks; i++) {\n      totalCrossings += this.calculateRankCrossing(i, model);\n    }\n\n    return totalCrossings;\n  };\n  /**\n   *  used to get the temp value specified for the node or connector. \\\n   *\n   * @returns { boolean }  used to get the temp value specified for the node or connector.\\\n   * @param {IVertex} node - provide the node value.\n   * @param {IVertex} layer - provide the layer value.\n   *\n   * @private\n   */\n\n\n  CrossReduction.prototype.getTempVariable = function (node, layer) {\n    if (node) {\n      if (this.isVertex(node)) {\n        return node.temp[0];\n      } else {\n        return node.temp[layer - node.minRank - 1];\n      }\n    }\n\n    return 0;\n  }; //used to specify the number of conenctors crossing between the specified rank and its below rank\n\n\n  CrossReduction.prototype.calculateRankCrossing = function (i, model) {\n    var totalCrossings = 0;\n    var rank = model.ranks[i];\n    var previousRank = model.ranks[i - 1];\n    var tmpIndices = []; // Iterate over the top rank and fill in the connection information\n\n    for (var j = 0; j < rank.length; j++) {\n      var node = rank[j];\n      var rankPosition = this.getTempVariable(node, i);\n      var connectedCells = this.getConnectedCellsOnLayer(node, i, true); ///####\n\n      var nodeIndices = [];\n\n      for (var k = 0; k < connectedCells.length; k++) {\n        var connectedNode = connectedCells[k];\n        var otherCellRankPosition = this.getTempVariable(connectedNode, i - 1);\n        nodeIndices.push(otherCellRankPosition);\n      }\n\n      nodeIndices.sort(function (x, y) {\n        return x - y;\n      });\n      tmpIndices[rankPosition] = nodeIndices;\n    }\n\n    var indices = [];\n\n    for (var j = 0; j < tmpIndices.length; j++) {\n      indices = indices.concat(tmpIndices[j]);\n    }\n\n    var firstIndex = 1;\n\n    while (firstIndex < previousRank.length) {\n      firstIndex <<= 1;\n    }\n\n    var treeSize = 2 * firstIndex - 1;\n    firstIndex -= 1;\n    var tree = [];\n\n    for (var j = 0; j < treeSize; ++j) {\n      tree[j] = 0;\n    }\n\n    for (var j = 0; j < indices.length; j++) {\n      var index = indices[j];\n      var treeIndex = index + firstIndex;\n      ++tree[treeIndex];\n\n      while (treeIndex > 0) {\n        if (treeIndex % 2) {\n          totalCrossings += tree[treeIndex + 1];\n        }\n\n        treeIndex = treeIndex - 1 >> 1;\n        ++tree[treeIndex];\n      }\n    }\n\n    return totalCrossings;\n  };\n  /**\n   * Calculates and reduces the crosses between line segments\n   *\n   * @returns { void }Calculates and reduces the crosses between line segments.\\\n   * @param {MultiParentModel} model - provide the target value.\n   * @private\n   */\n\n\n  CrossReduction.prototype.execute = function (model) {\n    // Stores initial ordering\n    this.nestedBestRanks = [];\n\n    for (var i = 0; i < model.ranks.length; i++) {\n      this.nestedBestRanks[i] = model.ranks[i].slice();\n    }\n\n    var iterationsWithoutImprovement = 0;\n    var currentBestCrossings = this.calculateCrossings(model);\n\n    for (var i = 0; i < 24 && iterationsWithoutImprovement < 2; i++) {\n      this.weightedMedian(i, model);\n      var candidateCrossings = this.calculateCrossings(model);\n\n      if (candidateCrossings < currentBestCrossings) {\n        currentBestCrossings = candidateCrossings;\n        iterationsWithoutImprovement = 0;\n\n        for (var j = 0; j < this.nestedBestRanks.length; j++) {\n          var rank = model.ranks[j];\n\n          for (var k = 0; k < rank.length; k++) {\n            var cell = rank[k];\n            var obj = this.nestedBestRanks[j][cell.temp[0]];\n            var check = true;\n\n            if (cell.edges && obj && !obj.edges) {\n              check = false;\n            }\n\n            if (obj && check) {\n              this.nestedBestRanks[j][cell.temp[0]] = cell;\n            }\n          }\n        }\n      } else {\n        // Increase count of iterations\n        iterationsWithoutImprovement++; // Restore the best values to the cells\n\n        for (var j = 0; j < this.nestedBestRanks.length; j++) {\n          var rank = model.ranks[j];\n\n          for (var k = 0; k < rank.length; k++) {\n            var cell = rank[k];\n            this.setTempVariable(cell, j, k);\n          }\n        }\n      }\n\n      if (currentBestCrossings === 0) {\n        break;\n      }\n    } // Store the best rankings but in the model\n\n\n    var ranks = [];\n    var rankList = [];\n\n    for (var i = 0; i < model.maxRank + 1; i++) {\n      rankList[i] = [];\n      ranks[i] = rankList[i];\n    }\n\n    for (var i = 0; i < this.nestedBestRanks.length; i++) {\n      for (var j = 0; j < this.nestedBestRanks[i].length; j++) {\n        rankList[i].push(this.nestedBestRanks[i][j]);\n      }\n    }\n\n    model.ranks = ranks;\n  };\n  /**\n   *  check whether the object is vertext or edge on the layout model. \\\n   *\n   * @returns { boolean }  check whether the object is vertext or edge on the layout model..\\\n   * @param {IVertex} node - provide the iteration value.\n   *\n   * @private\n   */\n\n\n  CrossReduction.prototype.isVertex = function (node) {\n    if (node && node.cell && (node.cell.inEdges || node.cell.outEdges)) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   *  used to move up or move down the node position on the adjacent ranks \\\n   *\n   * @returns { void }  used to move up or move down the node position on the adjacent ranks.\\\n   * @param {number} iteration - provide the iteration value.\n   * @param {MultiParentModel} model - provide the model value.\n   *\n   * @private\n   */\n\n\n  CrossReduction.prototype.weightedMedian = function (iteration, model) {\n    // Reverse sweep direction each time through this method\n    var downwardSweep = iteration % 2 === 0;\n\n    if (downwardSweep) {\n      for (var j = model.maxRank - 1; j >= 0; j--) {\n        this.medianRank(j, downwardSweep);\n      }\n    } else {\n      for (var j = 1; j < model.maxRank; j++) {\n        this.medianRank(j, downwardSweep);\n      }\n    }\n  };\n  /**\n   * used to get the node next(up) connected to the specified node or connector \\\n   *\n   * @returns { void } calculates the rank elements on the specified rank.\\\n   * @param {IVertex} cell - provide the cell value.\n   * @param {number} layer - provide the layer value.\n   * @param {boolean} isPrevious - provide the isPrevious value.\n   *\n   * @private\n   */\n\n\n  CrossReduction.prototype.getConnectedCellsOnLayer = function (cell, layer, isPrevious) {\n    if (isPrevious === void 0) {\n      isPrevious = false;\n    }\n\n    var connectedlayer = 'nextLayerConnectedCells';\n    var connectedAs = 'connectsAsTarget';\n\n    if (isPrevious) {\n      connectedlayer = 'previousLayerConnectedCells';\n      connectedAs = 'connectsAsSource';\n    }\n\n    if (cell) {\n      if (this.isVertex(cell)) {\n        if (cell[connectedlayer] == null) {\n          cell[connectedlayer] = [];\n          cell[connectedlayer][0] = [];\n\n          for (var i = 0; i < cell[connectedAs].length; i++) {\n            var edge = cell[connectedAs][i];\n\n            if (edge.maxRank === undefined) {\n              edge.maxRank = -1;\n            }\n\n            if (edge.maxRank === -1 || (isPrevious ? edge.minRank === layer - 1 : edge.maxRank === layer + 1)) {\n              // Either edge is not in any rank or no dummy nodes in edge, add node of other side of edge\n              cell[connectedlayer][0].push(isPrevious ? edge.target : edge.source);\n            } else {\n              // Edge spans at least two layers, add edge\n              cell[connectedlayer][0].push(edge);\n            }\n          }\n        }\n\n        return cell[connectedlayer][0];\n      } else {\n        if (cell[connectedlayer] == null) {\n          cell[connectedlayer] = [];\n\n          for (var i = 0; i < cell.temp.length; i++) {\n            cell[connectedlayer][i] = [];\n\n            if (i === (isPrevious ? 0 : cell.temp.length - 1)) {\n              cell[connectedlayer][i].push(isPrevious ? cell.target : cell.source);\n            } else {\n              cell[connectedlayer][i].push(cell);\n            }\n          }\n        }\n\n        return cell[connectedlayer][layer - cell.minRank - 1];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * calculates the rank elements on the specified rank \\\n   *\n   * @returns { void } calculates the rank elements on the specified rank.\\\n   * @param {IVertex[]} connectedCells - provide the cell value.\n   * @param {number} rankValue - provide the layer value.\n   *\n   * @private\n   */\n\n\n  CrossReduction.prototype.medianValue = function (connectedCells, rankValue) {\n    var medianValues = [];\n    var arrayCount = 0;\n\n    for (var i = 0; i < connectedCells.length; i++) {\n      var cell = connectedCells[i];\n      medianValues[arrayCount++] = this.getTempVariable(cell, rankValue);\n    } // sorts numerical order sort\n\n\n    medianValues.sort(function (a, b) {\n      return a - b;\n    });\n\n    if (arrayCount % 2 === 1) {\n      // For odd numbers of adjacent vertices return the median\n      return medianValues[Math.floor(arrayCount / 2)];\n    } else if (arrayCount === 2) {\n      return (medianValues[0] + medianValues[1]) / 2.0;\n    } else {\n      var medianPoint = arrayCount / 2;\n      var leftMedian = medianValues[medianPoint - 1] - medianValues[0];\n      var rightMedian = medianValues[arrayCount - 1] - medianValues[medianPoint];\n      return (medianValues[medianPoint - 1] * rightMedian + medianValues[medianPoint] * leftMedian) / (leftMedian + rightMedian);\n    }\n  };\n  /**\n   * get the temp value of the specified layer \\\n   *\n   * @returns { void }     getDirection method .\\\n   * @param {IVertex} cell - provide the cell value.\n   * @param {layer} layer - provide the layer value.\n   * @param {LayoutOrientation} value - provide the value value.\n   *\n   * @private\n   */\n\n\n  CrossReduction.prototype.setTempVariable = function (cell, layer, value) {\n    if (cell) {\n      cell.temp[0] = value;\n    }\n  };\n  /**\n   * used to minimize the node position on this rank and one of its adjacent ranks\n   */\n\n\n  CrossReduction.prototype.medianRank = function (rankValue, downwardSweep) {\n    var numCellsForRank = this.nestedBestRanks[rankValue].length;\n    var medianValues = [];\n    var reservedPositions = [];\n\n    for (var i = 0; i < numCellsForRank; i++) {\n      var cell = this.nestedBestRanks[rankValue][i];\n      var sorterEntry = {\n        medianValue: 0\n      };\n      sorterEntry.cell = cell; // Flip whether or not equal medians are flipped on up and down sweeps\n      //TODO re-implement some kind of nudge medianValues[i].nudge = !downwardSweep;\n\n      var nextLevelConnectedCells = void 0;\n\n      if (downwardSweep) {\n        nextLevelConnectedCells = this.getConnectedCellsOnLayer(cell, rankValue);\n      } else {\n        nextLevelConnectedCells = this.getConnectedCellsOnLayer(cell, rankValue, true);\n      }\n\n      var nextRankValue = void 0; // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\n      downwardSweep ? nextRankValue = rankValue + 1 : nextRankValue = rankValue - 1;\n\n      if (nextLevelConnectedCells != null && nextLevelConnectedCells.length !== 0) {\n        sorterEntry.medianValue = this.medianValue(nextLevelConnectedCells, nextRankValue);\n        medianValues.push(sorterEntry);\n      } else {\n        // Nodes with no adjacent vertices are flagged in the reserved array to\n        //indicate they should be left in their current position.\n        reservedPositions[this.getTempVariable(cell, rankValue)] = true;\n      }\n    }\n\n    medianValues.sort(this.compare); // Set the new position of each node within the rank using its temp variable\n\n    for (var i = 0; i < numCellsForRank; i++) {\n      if (reservedPositions[i] == null && medianValues.length > 0) {\n        var cell = medianValues.shift().cell;\n        this.setTempVariable(cell, rankValue, i);\n      }\n    }\n  }; //compares two values, it sends the values to the compare function,\n  //and sorts the values according to the returned (negative, zero, positive) value\n\n\n  CrossReduction.prototype.compare = function (a, b) {\n    if (a != null && b != null) {\n      if (b.medianValue > a.medianValue) {\n        return -1;\n      } else if (b.medianValue < a.medianValue) {\n        return 1;\n      }\n    }\n\n    return 0;\n  };\n\n  return CrossReduction;\n}();","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/complex-hierarchical-tree.js"],"names":["ComplexHierarchicalTree","prototype","destroy","getModuleName","doLayout","nodes","nameTable","layout","viewPort","lineDistribution","HierarchicalLayoutUtil","getLayoutNodesCollection","nodesCollection","node","parentId","processId","i","length","inEdges","outEdges","push","crossReduction","CrossReduction","previousEdgeOffset","previousEdgeDistance","jettyPositions","rankBottomY","limitX","rankTopY","parallelEdgeSpacing","minEdgeJetty","createVertex","value","x","y","width","height","geometry","vertex","name","slice","getEdges","edges","findRoots","vertices","roots","best","maxDiff","_i","_a","Object","keys","cell","conns","k","src","getVisibleTerminal","diff","edge","source","terminalCache","targetID","sourceID","id","traverse","directed","currentComp","hierarchyVertices","filledVertices","vertexID","edgeIsSource","next","netCount","j","isSource2","otherTerm","comp","key","splice","getModelBounds","rect","rect1","right","Math","max","bottom","min","layoutProp","canEnableRouting","enableRouting","horizontalSpacing","verticalSpacing","orientation","marginX","margin","left","marginY","top","enableLayoutRouting","model","edgeMapper","nodeWithMultiEdges","filledVertexSet","actualSize","outEdge","setEdgeMapper","candidateRoots","vertexSet","limit","tmp","checkLinear","matrixModel","arrangement","MultiParentModel","cycleStage","layeringStage","connectionPointOrigin","matrix","rowOffset","arrangeElements","crossingStage","placementStage","modelBounds","updateMargin","clnode","dnode","offsetX","offsetY","dx","dy","isNodeOverLap","updateLayout","matrixrow1","p","q","matrixCell","r","cells","type","getType","internalVertex","updateRankValuess","a","setVertexLocationValue","localEdgeProcessing","assignRankOffset","updateEdgeSetXYValue","getValues","setEdgePosition","updateMultiOutEdgesPoints","setEdgeXY","ranks","spacing","layer","targetValue","sourceValue","target","undefined","rankOffsetValue","m","ids","resetOffsetXValue","minRank","length_1","offsetValue","temp","maxRank","parallelEdgeCount","jettys","isReversed","layoutReversed","realEdge","realSource","newPoints","reversed","arrayOffset","jetty","getPointvalue","loopStart","loopLimit","loopDelta","currentRank","positionX","topChannelY","bottomChannelY","rankY","setEdgePoints","Number","isHorizontal","rank","check","setXY","getPreviousLayerConnectedCells","previousLayerConnectedCells","connectsAsSource","compare","b","weightedValue","rankIndex","cellIndex","isVertex","currentCells","sortedCells","sorter","weightedCellSorter","getX","sort","leftLimit","rightLimit","connectedEdgeCount","connectedEdgeGroupCount","connectedEdges","innerCell","connections","connectsAsTarget","connIndex","requiredWidth","availableWidth","edgeSpacing","currentX","currentYOffset","maxYOffset","numActualEdges","pos","getNextLayerConnectedCells","connector1","connector2","points","nextLayerConnectedCells","getGeometry","geometryValue","rankCoordinatesAssigment","rankValue","localOffset","MAX_VALUE","cellGeomtry","positionY","options","calculateRectValue","nodeRect","tempnode1","isIntersect","floor","viewPortBounds","bounds","layoutBounds","horizontalAlignment","verticalAlignment","top_1","center","coordinateAssignment","parent","widestRankValue","placementStageExecute","plalementChange","calculateWidestRank","graph","offset","lastRankMaxCellSize","rankSizes","rankOffset","maxCellSize","obj","numEdges","setTempVariable","widestRank","distanceToNextRank","isY","rankCoordinates","stage","maxOffset","size","initialCoords","facade","isAncestor","otherNode","hashCode","visited","minNode","nodeList","map","nodeWrapper","setDictionaryForSorter","maxTries","count","tolerance","cellWrapper","shift","getConnectedCellsOnLayer","nextConnectedCount","prevConnectedCount","medianNextLevel","medianXValue","medianPreviousLevel","numConnectedNeighbours","currentPosition","getTempVariable","cellMedian","positionChanged","tempValue","leftCell","intraCellSpacing","rankSize","rightCell","updateNodeList","collection","connectedCell","connectedCellWrapper","getDictionaryForSorter","connectedCells","medianValues","medianPoint","leftMedian","rightMedian","currentYDelta","currentXDelta","bestOffsetDelta","maxIterations","setCellLocations","vertexMapper","setVertexLocation","garphModelsetVertexLocation","result","realCell","mapper","list","execute","initialRank","fixRanks","startNodes","internalNodes","getDictionaryValues","startNodesCopy","internalNode","layerDeterminingEdges","edgesToBeMarked","allEdgesScanned","minimumLayer","internalEdge","removedCell","currentMaxLayer","seenNodes","unseenNodesArray","unseenNodes","rootsArray","modelRoots","getDictionary","visit","seenNodesCopy","clone","remove","array","index","indexOf","invert","connectingEdge","getEdgesBetween","trg","dlayout","multiObjectIdentityCounter","dfsCount","hierarchicalUtil","internalVertices","hierarchicalLayout","createInternalCells","realEdges","targetCell","internalTargetCell","resetEdge","relative","geo","setDictionary","undirectedEdges","directedEdges","rankList","oldRootsArray","updateMinMaxRank","seen","data","root","parentToCellRankDifference","dic","edgeId","previous","flag","layoutObjectId","visitor","dfsRoots","trackAncestors","extendedDfs","depthFirstSearch","rootId","updateConnectionRank","outgoingEdges","targetNode","traversedList","removeConnectionEdge","cHash","hashCodeLength","transients","shallow","constructor","clonedObj","calculateCrossings","numRanks","totalCrossings","calculateRankCrossing","previousRank","tmpIndices","rankPosition","nodeIndices","connectedNode","otherCellRankPosition","indices","concat","firstIndex","treeSize","tree","treeIndex","nestedBestRanks","iterationsWithoutImprovement","currentBestCrossings","weightedMedian","candidateCrossings","iteration","downwardSweep","medianRank","isPrevious","connectedlayer","connectedAs","medianValue","arrayCount","numCellsForRank","reservedPositions","sorterEntry","nextLevelConnectedCells","nextRankValue"],"mappings":"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","sourcesContent":["/**\n * Connects diagram objects with layout algorithm\n */\nvar ComplexHierarchicalTree = /** @class */ (function () {\n    /**\n     * Constructor for the hierarchical tree layout module\n     *\n     * @private\n     */\n    function ComplexHierarchicalTree() {\n        //constructs the layout module\n    }\n    /**\n     * To destroy the hierarchical tree module\n     *\n     * @returns {void}\n     * @private\n     */\n    ComplexHierarchicalTree.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    ComplexHierarchicalTree.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the layout\n         *\n         */\n        return 'ComplexHierarchicalTree';\n    };\n    /**\n     * doLayout method\\\n     *\n     * @returns {  void }    doLayout method .\\\n     * @param {INode[]} nodes - provide the nodes value.\n     * @param {{}} nameTable - provide the nameTable value.\n     * @param {Layout} layout - provide the layout value.\n     * @param {PointModel} viewPort - provide the viewPort value.\n     * @param {LineDistribution} lineDistribution - provide the lineDistribution value.\n     * @private\n     */\n    ComplexHierarchicalTree.prototype.doLayout = function (nodes, nameTable, layout, viewPort, lineDistribution) {\n        new HierarchicalLayoutUtil().doLayout(nodes, nameTable, layout, viewPort, lineDistribution);\n    };\n    ComplexHierarchicalTree.prototype.getLayoutNodesCollection = function (nodes) {\n        var nodesCollection = [];\n        var node;\n        var parentId = 'parentId';\n        var processId = 'processId';\n        for (var i = 0; i < nodes.length; i++) {\n            node = nodes[i];\n            if ((node.inEdges.length + node.outEdges.length > 0) && !node[parentId] && !node[processId]) {\n                nodesCollection.push(node);\n            }\n        }\n        return nodesCollection;\n    };\n    return ComplexHierarchicalTree;\n}());\nexport { ComplexHierarchicalTree };\n/**\n * Utility that arranges the nodes in hierarchical structure\n */\nvar HierarchicalLayoutUtil = /** @class */ (function () {\n    function HierarchicalLayoutUtil() {\n        this.nameTable = {};\n        this.crossReduction = new CrossReduction();\n        /**\n         * The preferred vertical offset between edges exiting a vertex Default is 2.\n         */\n        this.previousEdgeOffset = 6;\n        /**\n         * The preferred horizontal distance between edges exiting a vertex Default is 5.\n         */\n        this.previousEdgeDistance = 5;\n        /**\n         * Holds the collection vertices, that are equivalent to nodes to be arranged\n         */\n        this.jettyPositions = {};\n        /**\n         * Internal cache of bottom-most value of Y for each rank\n         */\n        this.rankBottomY = null;\n        /**\n         * Internal cache of bottom-most value of X for each rank\n         */\n        this.limitX = null;\n        /**\n         * Internal cache of top-most values of Y for each rank\n         */\n        this.rankTopY = null;\n        /**\n         * The minimum parallelEdgeSpacing value is 12.\n         */\n        this.parallelEdgeSpacing = 10;\n        /**\n         * The minimum distance for an edge jetty from a vertex Default is 12.\n         */\n        this.minEdgeJetty = 12;\n    }\n    //Defines a vertex that is equivalent to a node object\n    HierarchicalLayoutUtil.prototype.createVertex = function (node, value, x, y, width, height) {\n        var geometry = { x: x, y: y, width: width, height: height };\n        var vertex = {\n            value: value, geometry: geometry, name: value, vertex: true,\n            inEdges: node.inEdges.slice(), outEdges: node.outEdges.slice()\n        };\n        return vertex;\n    };\n    /**\n     * Initializes the edges collection of the vertices\\\n     *\n     * @returns {  IConnector[] }    Initializes the edges collection of the vertices\\\n     * @param {Vertex} node - provide the node value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.getEdges = function (node) {\n        var edges = [];\n        if (node) {\n            for (var i = 0; node.inEdges.length > 0 && i < node.inEdges.length; i++) {\n                edges.push(this.nameTable[node.inEdges[i]]);\n            }\n            for (var i = 0; node.outEdges.length > 0 && i < node.outEdges.length; i++) {\n                edges.push(this.nameTable[node.outEdges[i]]);\n            }\n        }\n        return edges;\n    };\n    //Finds the root nodes of the layout\n    HierarchicalLayoutUtil.prototype.findRoots = function (vertices) {\n        var roots = [];\n        var best = null;\n        var maxDiff = -100000;\n        for (var _i = 0, _a = Object.keys(vertices); _i < _a.length; _i++) {\n            var i = _a[_i];\n            var cell = vertices[i];\n            var conns = this.getEdges(cell);\n            var outEdges = 0;\n            var inEdges = 0;\n            for (var k = 0; k < conns.length; k++) {\n                var src = this.getVisibleTerminal(conns[k], true);\n                if (src.name === cell.name) {\n                    outEdges++;\n                }\n                else {\n                    inEdges++;\n                }\n            }\n            if (inEdges === 0 && outEdges > 0) {\n                roots.push(cell);\n            }\n            var diff = outEdges - inEdges;\n            if (diff > maxDiff) {\n                maxDiff = diff;\n                best = cell;\n            }\n        }\n        if (roots.length === 0 && best != null) {\n            roots.push(best);\n        }\n        return roots;\n    };\n    /**\n     * Returns the source/target vertex of the given connector \\\n     *\n     * @returns {  Vertex }    Returns the source/target vertex of the given connector \\\n     * @param {IConnector} edge - provide the node value.\n     * @param {boolean} source - provide the node value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.getVisibleTerminal = function (edge, source) {\n        var terminalCache = this.nameTable[edge.targetID];\n        if (source) {\n            terminalCache = this.nameTable[edge.sourceID];\n        }\n        for (var i = 0; i < this.vertices.length; i++) {\n            if (this.vertices[i].name === terminalCache.id) {\n                return this.vertices[i];\n            }\n        }\n        return null;\n    };\n    /**\n     * Traverses each sub tree, ensures there is no cycle in traversing \\\n     *\n     * @returns {  {} }    Traverses each sub tree, ensures there is no cycle in traversing .\\\n     * @param {Vertex} vertex - provide the vertex value.\n     * @param {boolean} directed - provide the directed value.\n     * @param {IConnector} edge - provide the edge value.\n     * @param {{}} currentComp - provide the currentComp value.\n     * @param {{}[]} hierarchyVertices - provide the hierarchyVertices value.\n     * @param {{}} filledVertices - provide the filledVertices value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.traverse = function (vertex, directed, edge, currentComp, hierarchyVertices, filledVertices) {\n        if (vertex != null) {\n            var vertexID = vertex.name;\n            if ((filledVertices == null ? true : filledVertices[vertexID] != null)) {\n                if (currentComp[vertexID] == null) {\n                    currentComp[vertexID] = vertex;\n                }\n                if (filledVertices != null) {\n                    delete filledVertices[vertexID];\n                }\n                var edges = this.getEdges(vertex);\n                var edgeIsSource = [];\n                for (var i = 0; i < edges.length; i++) {\n                    edgeIsSource[i] = this.getVisibleTerminal(edges[i], true) === vertex;\n                }\n                for (var i = 0; i < edges.length; i++) {\n                    if (!directed || edgeIsSource[i]) {\n                        var next = this.getVisibleTerminal(edges[i], !edgeIsSource[i]);\n                        var netCount = 1;\n                        for (var j = 0; j < edges.length; j++) {\n                            if (j === i) {\n                                continue;\n                            }\n                            else {\n                                var isSource2 = edgeIsSource[j];\n                                var otherTerm = this.getVisibleTerminal(edges[j], !isSource2);\n                                if (otherTerm === next) {\n                                    if (isSource2) {\n                                        netCount++;\n                                    }\n                                    else {\n                                        netCount--;\n                                    }\n                                }\n                            }\n                        }\n                        if (netCount >= 0) {\n                            currentComp = this.traverse(next, directed, edges[i], currentComp, hierarchyVertices, filledVertices);\n                        }\n                    }\n                }\n            }\n            else {\n                if (currentComp[vertexID] == null) {\n                    // We've seen this vertex before, but not in the current component This component and the one it's in need to be merged\n                    for (var i = 0; i < hierarchyVertices.length; i++) {\n                        var comp = hierarchyVertices[i];\n                        if (comp[vertexID] != null) {\n                            for (var _i = 0, _a = Object.keys(comp); _i < _a.length; _i++) {\n                                var key = _a[_i];\n                                currentComp[key] = comp[key];\n                            }\n                            // Remove the current component from the hierarchy set\n                            hierarchyVertices.splice(i, 1);\n                            return currentComp;\n                        }\n                    }\n                }\n            }\n        }\n        return currentComp;\n    };\n    //Returns the bounds of the given vertices\n    HierarchicalLayoutUtil.prototype.getModelBounds = function (nodes) {\n        nodes = nodes.slice();\n        var rect = null;\n        var rect1 = null;\n        for (var i = 0; i < nodes.length; i++) {\n            rect = nodes[i].geometry;\n            if (rect1) {\n                var right = Math.max(rect1.x + rect1.width, rect.x + rect.width);\n                var bottom = Math.max(rect1.y + rect1.height, rect.y + rect.height);\n                rect1.x = Math.min(rect1.x, rect.x);\n                rect1.y = Math.min(rect1.y, rect.y);\n                rect1.width = right - rect1.x;\n                rect1.height = bottom - rect1.y;\n            }\n            else {\n                rect1 = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };\n            }\n        }\n        return rect1;\n    };\n    /* tslint:disable */\n    /**\n     *  Initializes the layouting process \\\n     *\n     * @returns {  Vertex }     Initializes the layouting process \\\n     * @param {INode[]} nodes - provide the node value.\n     * @param {{}} nameTable - provide the nameTable value.\n     * @param {Layout} layoutProp - provide the layoutProp value.\n     * @param {PointModel} viewPort - provide the viewPort value.\n     * @param {LineDistribution} lineDistribution - provide the lineDistribution value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.doLayout = function (nodes, nameTable, layoutProp, viewPort, lineDistribution) {\n        this.nameTable = nameTable;\n        var canEnableRouting = layoutProp.enableRouting;\n        var layout = {\n            horizontalSpacing: layoutProp.horizontalSpacing, verticalSpacing: layoutProp.verticalSpacing,\n            orientation: layoutProp.orientation, marginX: layoutProp.margin.left, marginY: layoutProp.margin.top,\n            enableLayoutRouting: canEnableRouting\n        };\n        var model;\n        if (lineDistribution) {\n            lineDistribution.edgeMapper = [];\n        }\n        var nodeWithMultiEdges = [];\n        this.vertices = [];\n        var filledVertexSet = {};\n        for (var i = 0; i < nodes.length; i++) {\n            var node = this.createVertex(nodes[i], nodes[i].id, 0, 0, nodes[i].actualSize.width, nodes[i].actualSize.height);\n            this.vertices.push(node);\n            if (nodes[i].inEdges.length > 0 || nodes[i].outEdges.length > 0) {\n                nodeWithMultiEdges.push(nodes[i]);\n            }\n            filledVertexSet[node.name] = node;\n            if (lineDistribution) {\n                var outEdges = nodes[i].outEdges.slice();\n                for (var j = 0; j < outEdges.length; j++) {\n                    var outEdge = nameTable[outEdges[j]];\n                    lineDistribution.setEdgeMapper({ key: outEdge, value: [] });\n                }\n            }\n        }\n        var hierarchyVertices = [];\n        //let candidateRoots: Vertex[];\n        var candidateRoots = this.findRoots(filledVertexSet);\n        for (var i = 0; i < candidateRoots.length; i++) {\n            var vertexSet = {};\n            hierarchyVertices.push(vertexSet);\n            this.traverse(candidateRoots[i], true, null, vertexSet, hierarchyVertices, filledVertexSet);\n        }\n        var limit = { marginX: 0, marginY: 0 };\n        var tmp = [];\n        var checkLinear = false;\n        var matrixModel;\n        for (var i = 0; i < hierarchyVertices.length; i++) {\n            var vertexSet = hierarchyVertices[i];\n            // eslint-disable-next-line\n            for (var _i = 0, _a = Object.keys(vertexSet); _i < _a.length; _i++) {\n                var key = _a[_i];\n                tmp.push(vertexSet[key]);\n            }\n            if ((layoutProp.arrangement === 'Linear' && i === hierarchyVertices.length - 1) || canEnableRouting) {\n                checkLinear = true;\n            }\n            model = new MultiParentModel(this, tmp, candidateRoots, layout);\n            this.cycleStage(model);\n            this.layeringStage(model);\n            if ((lineDistribution && layoutProp.connectionPointOrigin === 'DifferentPoint') || checkLinear) {\n                matrixModel = this.matrixModel({ model: model, matrix: [], rowOffset: [] });\n                lineDistribution.arrangeElements(matrixModel, layoutProp);\n            }\n            else {\n                if (layoutProp.arrangement === 'Nonlinear') {\n                    this.crossingStage(model);\n                    limit = this.placementStage(model, limit.marginX, limit.marginY);\n                    tmp = [];\n                }\n            }\n        }\n        var modelBounds = this.getModelBounds(this.vertices);\n        this.updateMargin(layoutProp, layout, modelBounds, viewPort);\n        for (var i = 0; i < this.vertices.length; i++) {\n            var clnode = this.vertices[i];\n            if (clnode) { //Check what is node.source/node.target -  && !clnode.source && !clnode.target) {\n                var dnode = this.nameTable[clnode.name];\n                dnode.offsetX = 0;\n                dnode.offsetY = 0;\n                //initialize layout\n                var dx = (clnode.geometry.x - (dnode.offsetX - (dnode.actualSize.width / 2))) + layout.marginX;\n                var dy = (clnode.geometry.y - (dnode.offsetY - (dnode.actualSize.height / 2))) + layout.marginY;\n                var x = dx;\n                var y = dy;\n                if (layout.orientation === 'BottomToTop') {\n                    if (canEnableRouting) {\n                        clnode.geometry.y = modelBounds.height - dy - dnode.actualSize.height / 2;\n                    }\n                    y = modelBounds.height - dy;\n                }\n                else if (layout.orientation === 'RightToLeft') {\n                    x = modelBounds.width - dx;\n                }\n                dnode.offsetX += x - dnode.offsetX;\n                dnode.offsetY += y - dnode.offsetY;\n            }\n        }\n        if (!checkLinear) {\n            for (var i = 0; i < this.vertices.length; i++) {\n                this.isNodeOverLap(this.nameTable[this.vertices[i].name], layoutProp);\n            }\n        }\n        if ((lineDistribution && layoutProp.connectionPointOrigin === 'DifferentPoint') || canEnableRouting) {\n            lineDistribution.updateLayout(viewPort, modelBounds, layoutProp, layout, nodeWithMultiEdges, nameTable);\n        }\n        if (canEnableRouting) {\n            var vertices = {};\n            var matrixrow1 = void 0;\n            for (var p = 0; p < matrixModel.matrix.length; p++) {\n                matrixrow1 = matrixModel.matrix[p].value;\n                for (var q = 0; q < matrixrow1.length; q++) {\n                    var matrixCell = matrixrow1[q];\n                    for (var r = 0; r < matrixCell.cells.length; r++) {\n                        var cell = matrixCell.cells[r];\n                        var type = this.getType(cell.type);\n                        if (type === 'internalVertex') {\n                            var internalVertex = cell;\n                            vertices[internalVertex.id] = internalVertex;\n                        }\n                    }\n                }\n            }\n            this.updateRankValuess(model);\n            for (var i = 0, a = Object.keys(vertices); i < a.length; i++) {\n                var key = a[i];\n                this.setVertexLocationValue(vertices[key], layoutProp.orientation, modelBounds);\n            }\n            this.localEdgeProcessing(model, vertices);\n            this.assignRankOffset(model);\n            this.updateEdgeSetXYValue(model);\n            var edges = this.getValues(model.edgeMapper);\n            for (var i = 0; i < edges.length; i++) {\n                if ((edges[i]).x.length > 0) {\n                    for (var j = 0; j < (edges[i]).x.length; j++) {\n                        if (layoutProp.orientation !== 'RightToLeft' && layoutProp.orientation !== 'LeftToRight') {\n                            (edges[i]).x[j] = (edges[i]).x[j] + layout.marginX;\n                        }\n                        else if (layoutProp.orientation === 'LeftToRight') {\n                            (edges[i]).x[j] = (edges[i]).x[j] + layoutProp.verticalSpacing / 2;\n                        }\n                        else {\n                            (edges[i]).x[j] = (edges[i]).x[j] + layoutProp.verticalSpacing / 2;\n                        }\n                    }\n                }\n                this.setEdgePosition(edges[i], model, layout);\n            }\n            for (var p = 0; p < this.vertices.length; p++) {\n                var clnode = this.vertices[p];\n                if (clnode.outEdges.length > 1) {\n                    this.updateMultiOutEdgesPoints(clnode);\n                }\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.setEdgeXY = function (ranks, node, spacing, layer) {\n        if (ranks && node.source.id) {\n            var targetValue = void 0;\n            var sourceValue = void 0;\n            for (var i = 0; i < ranks.length; i++) {\n                for (var k = 0; k < ranks[i].length; k++) {\n                    if (ranks[i][k].id === node.target.id || ranks[i][k].id === node.source.id) {\n                        if (ranks[i][k].id === node.target.id && targetValue === undefined) {\n                            targetValue = i;\n                        }\n                        if (ranks[i][k].id === node.source.id && sourceValue === undefined) {\n                            sourceValue = i;\n                        }\n                    }\n                }\n            }\n            var rankOffsetValue = void 0;\n            for (var m = targetValue; m <= sourceValue; m++) {\n                if (rankOffsetValue === undefined) {\n                    rankOffsetValue = this[m + '_RankOffset'];\n                }\n                if (rankOffsetValue !== undefined && rankOffsetValue < this[m + '_RankOffset']) {\n                    rankOffsetValue = this[m + '_RankOffset'];\n                }\n            }\n            if (this['edges'] === undefined) {\n                this['edges'] = {};\n            }\n            this['edges'][(node).ids[0]] = { x: node.x, y: 0 };\n            var value = this.resetOffsetXValue(rankOffsetValue, spacing / 10);\n            node.x[layer - node.minRank - 1] = value;\n            for (var k = 0; k < (node).edges.length; k++) {\n                (node).edges[k]['levelSkip'] = true;\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.resetOffsetXValue = function (value, spacing) {\n        for (var i = 0, a = Object.keys(this['edges']); i < a.length; i++) {\n            var key = a[i];\n            var length_1 = this['edges'][key].x;\n            for (var j = 0; j < length_1.length; j++) {\n                var offsetValue = void 0;\n                if (this['edges'][key].x[j] === value) {\n                    offsetValue = value + spacing;\n                    offsetValue = this.resetOffsetXValue(offsetValue, spacing);\n                    return offsetValue;\n                }\n            }\n        }\n        return value;\n    };\n    HierarchicalLayoutUtil.prototype.setEdgePosition = function (cell, model, layout) {\n        // For parallel edges we need to seperate out the points a\n        // little\n        var offsetX = 0;\n        // Only set the edge control points once\n        if (cell.temp[0] !== 101207) {\n            if (cell.maxRank === undefined) {\n                cell.maxRank = -1;\n            }\n            if (cell.minRank === undefined) {\n                cell.minRank = -1;\n            }\n            var maxRank = cell.maxRank;\n            var minRank = cell.minRank;\n            if (maxRank === minRank) {\n                maxRank = cell.source.maxRank;\n                minRank = cell.target.minRank;\n            }\n            var parallelEdgeCount = 0;\n            var jettys = this.jettyPositions[cell.ids[0]];\n            if (cell.isReversed === undefined) {\n                cell.isReversed = false;\n            }\n            else {\n                cell.isReversed = true;\n            }\n            var source = cell.isReversed ? cell.target.cell : cell.source.cell;\n            var layoutReversed = false;\n            if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'LeftToRight') {\n                if (model.layout.orientation === 'TopToBottom') {\n                    layoutReversed = false;\n                }\n                if (model.layout.orientation === 'LeftToRight') {\n                    if (!cell.isReversed) {\n                        layoutReversed = false;\n                    }\n                    else {\n                        layoutReversed = false;\n                    }\n                }\n            }\n            else {\n                if (!cell.isReversed) {\n                    layoutReversed = true;\n                }\n            }\n            for (var i = 0; i < cell.edges.length; i++) {\n                var realEdge = cell.edges[i];\n                var realSource = this.getVisibleTerminal(realEdge, true);\n                //List oldPoints = graph.getPoints(realEdge);\n                var newPoints = [];\n                // Single length reversed edges end up with the jettys in the wrong\n                // places. Since single length edges only have jettys, not segment\n                // control points, we just say the edge isn't reversed in this section\n                var reversed = cell.isReversed;\n                // if(cell.isReversed===undefined){\n                //     reversed = false\n                // }else{\n                //     reversed =cell.isReversed\n                // }\n                if (realSource !== source) {\n                    // The real edges include all core model edges and these can go\n                    // in both directions. If the source of the hierarchical model edge\n                    // isn't the source of the specific real edge in this iteration\n                    // treat if as reversed\n                    reversed = !reversed;\n                }\n                // First jetty of edge\n                if (jettys != null) {\n                    var arrayOffset = reversed ? 2 : 0;\n                    var y = reversed ?\n                        (layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank]) :\n                        (layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank]);\n                    var jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];\n                    if (reversed !== layoutReversed) {\n                        jetty = -jetty;\n                    }\n                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n                        y += jetty;\n                    }\n                    var x = jettys[parallelEdgeCount * 4 + arrayOffset];\n                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n                        newPoints.push(this.getPointvalue(x, y + layout.marginY));\n                    }\n                    else {\n                        if (layout.orientation === 'LeftToRight') {\n                            newPoints.push(this.getPointvalue(y + jetty, x + layout.marginY));\n                        }\n                        else {\n                            newPoints.push(this.getPointvalue(y, x + layout.marginY));\n                        }\n                    }\n                }\n                var loopStart = cell.x.length - 1;\n                var loopLimit = -1;\n                var loopDelta = -1;\n                var currentRank = cell.maxRank - 1;\n                if (reversed) {\n                    loopStart = 0;\n                    loopLimit = cell.x.length;\n                    loopDelta = 1;\n                    currentRank = cell.minRank + 1;\n                }\n                // Reversed edges need the points inserted in\n                // reverse order\n                for (var j = loopStart; (cell.maxRank !== cell.minRank) && j !== loopLimit; j += loopDelta) {\n                    // The horizontal position in a vertical layout\n                    var positionX = cell.x[j] + offsetX;\n                    // This cell.x determines the deviated points of the connectors and jetty positions\n                    //determine the src and targetgeo points .\n                    // Work out the vertical positions in a vertical layout\n                    // in the edge buffer channels above and below this rank\n                    var topChannelY = (this.rankTopY[currentRank] + this.rankBottomY[currentRank + 1]) / 2.0;\n                    var bottomChannelY = (this.rankTopY[currentRank - 1] + this.rankBottomY[currentRank]) / 2.0;\n                    if (reversed) {\n                        var tmp = topChannelY;\n                        topChannelY = bottomChannelY;\n                        bottomChannelY = tmp;\n                    }\n                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n                        newPoints.push(this.getPointvalue(positionX, topChannelY + layout.marginY));\n                        newPoints.push(this.getPointvalue(positionX, bottomChannelY + layout.marginY));\n                    }\n                    else {\n                        newPoints.push(this.getPointvalue(topChannelY, positionX + layout.marginY));\n                        newPoints.push(this.getPointvalue(bottomChannelY, positionX + layout.marginY));\n                    }\n                    this.limitX = Math.max(this.limitX, positionX);\n                    currentRank += loopDelta;\n                }\n                // Second jetty of edge\n                if (jettys != null) {\n                    var arrayOffset = reversed ? 2 : 0;\n                    var rankY = reversed ?\n                        (layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank]) :\n                        (layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank]);\n                    var jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];\n                    if (reversed !== layoutReversed) {\n                        jetty = -jetty;\n                    }\n                    var y = rankY - jetty;\n                    var x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];\n                    if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n                        newPoints.push(this.getPointvalue(x, y + layout.marginY));\n                    }\n                    else {\n                        newPoints.push(this.getPointvalue(y, x + layout.marginY));\n                    }\n                }\n                this.setEdgePoints(realEdge, newPoints, model);\n                // Increase offset so next edge is drawn next to\n                // this one\n                if (offsetX === 0.0) {\n                    offsetX = this.parallelEdgeSpacing;\n                }\n                else if (offsetX > 0) {\n                    offsetX = -offsetX;\n                }\n                else {\n                    offsetX = -offsetX + this.parallelEdgeSpacing;\n                }\n                parallelEdgeCount++;\n            }\n            cell.temp[0] = 101207;\n        }\n    };\n    /* tslint:enable */\n    // eslint-disable-next-line\n    HierarchicalLayoutUtil.prototype.getPointvalue = function (x, y) {\n        return { 'x': Number(x) || 0, 'y': Number(y) || 0 };\n    };\n    HierarchicalLayoutUtil.prototype.updateEdgeSetXYValue = function (model) {\n        if (model.layout.enableLayoutRouting) {\n            var isHorizontal = false;\n            if (model.layout.orientation === 'LeftToRight' || model.layout.orientation === 'RightToLeft') {\n                isHorizontal = true;\n            }\n            for (var i = 0; i < model.ranks.length; i++) {\n                var rank = model.ranks[i];\n                for (var k = 0; k < rank.length; k++) {\n                    var cell = rank[k];\n                    if ((cell).edges && (cell).edges.length > 0) {\n                        var spacing = model.layout.horizontalSpacing > 0 ? (model.layout.horizontalSpacing / 2) : 15;\n                        var check = true;\n                        if (!(cell.minRank === i - 1 || cell.maxRank === i - 1)) {\n                            check = false;\n                        }\n                        if (check) {\n                            this.setXY(cell, i, undefined, isHorizontal ? true : false, model.ranks, spacing);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.getPreviousLayerConnectedCells = function (layer, cell) {\n        if (cell.previousLayerConnectedCells == null) {\n            cell.previousLayerConnectedCells = [];\n            cell.previousLayerConnectedCells[0] = [];\n            for (var i = 0; i < cell.connectsAsSource.length; i++) {\n                var edge = cell.connectsAsSource[i];\n                if (edge.minRank === -1 || edge.minRank === layer - 1) {\n                    // No dummy nodes in edge, add node of other side of edge\n                    cell.previousLayerConnectedCells[0].push(edge.target);\n                }\n                else {\n                    // Edge spans at least two layers, add edge\n                    cell.previousLayerConnectedCells[0].push(edge);\n                }\n            }\n        }\n        return cell.previousLayerConnectedCells[0];\n    };\n    HierarchicalLayoutUtil.prototype.compare = function (a, b) {\n        if (a != null && b != null) {\n            if (b.weightedValue > a.weightedValue) {\n                return -1;\n            }\n            else if (b.weightedValue < a.weightedValue) {\n                return 1;\n            }\n        }\n        return 0;\n    };\n    /* tslint:disable */\n    // eslint-disable-next-line\n    HierarchicalLayoutUtil.prototype.localEdgeProcessing = function (model, vertices) {\n        // Iterate through each vertex, look at the edges connected in\n        // both directions.\n        for (var rankIndex = 0; rankIndex < model.ranks.length; rankIndex++) {\n            var rank = model.ranks[rankIndex];\n            for (var cellIndex = 0; cellIndex < rank.length; cellIndex++) {\n                var cell = rank[cellIndex];\n                if (this.crossReduction.isVertex(cell)) {\n                    var currentCells = this.getPreviousLayerConnectedCells(rankIndex, cell);\n                    var currentRank = rankIndex - 1;\n                    // Two loops, last connected cells, and next\n                    for (var k = 0; k < 2; k++) {\n                        if (currentRank > -1\n                            && currentRank < model.ranks.length\n                            && currentCells != null\n                            && currentCells.length > 0) {\n                            var sortedCells = [];\n                            for (var j = 0; j < currentCells.length; j++) {\n                                var sorter = this.weightedCellSorter(currentCells[j], this.getX(currentRank, currentCells[j]));\n                                sortedCells.push(sorter);\n                            }\n                            sortedCells.sort(this.compare);\n                            cell.width = vertices[cell.id].cell.geometry.width;\n                            cell.height = vertices[cell.id].cell.geometry.height;\n                            var leftLimit = void 0;\n                            if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'BottomToTop') {\n                                cell.x[0] = vertices[cell.id].cell.geometry.x + vertices[cell.id].cell.geometry.width / 2;\n                                leftLimit = cell.x[0] - cell.width / 2 + vertices[cell.id].cell.geometry.height / 2;\n                            }\n                            else {\n                                cell.x[0] = vertices[cell.id].cell.geometry.y;\n                                leftLimit = cell.x[0];\n                            }\n                            var rightLimit = leftLimit + cell.width;\n                            // Connected edge count starts at 1 to allow for buffer\n                            // with edge of vertex\n                            var connectedEdgeCount = 0;\n                            var connectedEdgeGroupCount = 0;\n                            var connectedEdges = [];\n                            // Calculate width requirements for all connected edges\n                            for (var j = 0; j < sortedCells.length; j++) {\n                                var innerCell = sortedCells[j].cell;\n                                var connections = void 0;\n                                if (this.crossReduction.isVertex(innerCell)) {\n                                    // Get the connecting edge\n                                    if (k === 0) {\n                                        connections = cell.connectsAsSource;\n                                    }\n                                    else {\n                                        connections = cell.connectsAsTarget;\n                                    }\n                                    for (var connIndex = 0; connIndex < connections.length; connIndex++) {\n                                        if (connections[connIndex].source === innerCell\n                                            || connections[connIndex].target === innerCell) {\n                                            connectedEdgeCount += connections[connIndex].edges\n                                                .length;\n                                            connectedEdgeGroupCount++;\n                                            connectedEdges.push(connections[connIndex]);\n                                        }\n                                    }\n                                }\n                                else {\n                                    connectedEdgeCount += innerCell.edges.length;\n                                    // eslint-disable-next-line\n                                    connectedEdgeGroupCount++;\n                                    connectedEdges.push(innerCell);\n                                }\n                            }\n                            var requiredWidth = (connectedEdgeCount + 1)\n                                * this.previousEdgeDistance;\n                            // Add a buffer on the edges of the vertex if the edge count allows\n                            if (cell.width > requiredWidth\n                                + (2 * this.previousEdgeDistance)) {\n                                leftLimit += this.previousEdgeDistance;\n                                rightLimit -= this.previousEdgeDistance;\n                            }\n                            var availableWidth = rightLimit - leftLimit;\n                            var edgeSpacing = availableWidth / connectedEdgeCount;\n                            var currentX = leftLimit + edgeSpacing / 2.0;\n                            var currentYOffset = this.minEdgeJetty - this.previousEdgeOffset;\n                            var maxYOffset = 0;\n                            for (var j = 0; j < connectedEdges.length; j++) {\n                                var numActualEdges = connectedEdges[j].edges\n                                    .length;\n                                if (this.jettyPositions === undefined) {\n                                    this.jettyPositions = {};\n                                }\n                                var pos = this.jettyPositions[connectedEdges[j].ids[0]];\n                                if (pos == null) {\n                                    pos = [];\n                                    this.jettyPositions[connectedEdges[j].ids[0]] = pos;\n                                }\n                                if (j < connectedEdgeCount / 2) {\n                                    currentYOffset += this.previousEdgeOffset;\n                                }\n                                else if (j > connectedEdgeCount / 2) {\n                                    currentYOffset -= this.previousEdgeOffset;\n                                }\n                                // Ignore the case if equals, this means the second of 2\n                                // jettys with the same y (even number of edges)\n                                for (var m = 0; m < numActualEdges; m++) {\n                                    pos[m * 4 + k * 2] = currentX;\n                                    currentX += edgeSpacing;\n                                    pos[m * 4 + k * 2 + 1] = currentYOffset;\n                                }\n                                maxYOffset = Math.max(maxYOffset, currentYOffset);\n                            }\n                        }\n                        currentCells = this.getNextLayerConnectedCells(rankIndex, cell);\n                        currentRank = rankIndex + 1;\n                    }\n                }\n            }\n        }\n    };\n    /* tslint:enable */\n    HierarchicalLayoutUtil.prototype.updateMultiOutEdgesPoints = function (clnode) {\n        for (var i = 0; i < clnode.outEdges.length / 2; i++) {\n            var connector1 = this.nameTable[clnode.outEdges[i]];\n            var connector2 = this.nameTable[clnode.outEdges[clnode.outEdges.length - (i + 1)]];\n            var geometry = 'geometry';\n            connector2[geometry].points[0].y = connector1[geometry].points[0].y;\n        }\n    };\n    HierarchicalLayoutUtil.prototype.getNextLayerConnectedCells = function (layer, cell) {\n        if (cell.nextLayerConnectedCells == null) {\n            cell.nextLayerConnectedCells = [];\n            cell.nextLayerConnectedCells[0] = [];\n            for (var i = 0; i < cell.connectsAsTarget.length; i++) {\n                var edge = cell.connectsAsTarget[i];\n                if (edge.maxRank === -1 || edge.maxRank === layer + 1) {\n                    // Either edge is not in any rank or\n                    // no dummy nodes in edge, add node of other side of edge\n                    cell.nextLayerConnectedCells[0].push(edge.source);\n                }\n                else {\n                    // Edge spans at least two layers, add edge\n                    cell.nextLayerConnectedCells[0].push(edge);\n                }\n            }\n        }\n        return cell.nextLayerConnectedCells[0];\n    };\n    HierarchicalLayoutUtil.prototype.getX = function (layer, cell) {\n        if (this.crossReduction.isVertex(cell)) {\n            return cell.x[0];\n        }\n        else if (!this.crossReduction.isVertex(cell)) {\n            return cell.x[layer - cell.minRank - 1] || cell.temp[layer - cell.minRank - 1];\n        }\n        return 0.0;\n    };\n    HierarchicalLayoutUtil.prototype.getGeometry = function (edge) {\n        var geometry = 'geometry';\n        return edge[geometry];\n    };\n    HierarchicalLayoutUtil.prototype.setEdgePoints = function (edge, points, model) {\n        if (edge != null) {\n            var geometryValue = 'geometry';\n            var geometry = this.getGeometry(edge);\n            if (points != null) {\n                for (var i = 0; i < points.length; i++) {\n                    // eslint-disable-next-line\n                    points[i].x = points[i].x;\n                    // eslint-disable-next-line\n                    points[i].y = points[i].y;\n                }\n            }\n            geometry.points = points;\n            edge[geometryValue] = geometry;\n        }\n    };\n    HierarchicalLayoutUtil.prototype.assignRankOffset = function (model) {\n        if (model) {\n            for (var i = 0; i < model.ranks.length; i++) {\n                this.rankCoordinatesAssigment(i, model);\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.rankCoordinatesAssigment = function (rankValue, model) {\n        var rank = model.ranks[rankValue];\n        var spacing = model.layout.horizontalSpacing;\n        var localOffset;\n        for (var i = 0; i < rank.length; i++) {\n            if (this[rankValue + '_' + 'RankOffset'] === undefined) {\n                this[rankValue + '_' + 'RankOffset'] = 0;\n            }\n            localOffset = rank[i].x[0];\n            if (this[rankValue + '_' + 'RankOffset'] < localOffset) {\n                this[rankValue + '_' + 'RankOffset'] = localOffset + rank[i].width / 2 + spacing;\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.getType = function (type) {\n        if (type === 'internalVertex') {\n            return 'internalVertex';\n        }\n        else {\n            return 'internalEdge';\n        }\n    };\n    HierarchicalLayoutUtil.prototype.updateRankValuess = function (model) {\n        this.rankTopY = [];\n        this.rankBottomY = [];\n        for (var i = 0; i < model.ranks.length; i++) {\n            this.rankTopY[i] = Number.MAX_VALUE;\n            this.rankBottomY[i] = -Number.MAX_VALUE;\n        }\n    };\n    HierarchicalLayoutUtil.prototype.setVertexLocationValue = function (cell, orientation, modelBounds) {\n        var cellGeomtry = cell.cell.geometry;\n        var positionX;\n        var positionY;\n        if (orientation === 'TopToBottom' || orientation === 'BottomToTop') {\n            positionX = cellGeomtry.x;\n            positionY = cellGeomtry.y;\n        }\n        else {\n            positionX = cellGeomtry.y;\n            positionY = cellGeomtry.x;\n        }\n        if (orientation === 'RightToLeft') {\n            // eslint-disable-next-line\n            positionX = cellGeomtry.y;\n            positionY = modelBounds.width - cellGeomtry.x - cellGeomtry.height;\n            this.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank], positionY);\n            this.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY + cellGeomtry.height);\n        }\n        else {\n            this.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY);\n            this.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank], positionY + cellGeomtry.height);\n        }\n    };\n    HierarchicalLayoutUtil.prototype.matrixModel = function (options) {\n        // eslint-disable-next-line\n        options.model = options.model;\n        options.matrix = options.matrix || [];\n        options.rowOffset = options.rowOffset || [];\n        return options;\n    };\n    HierarchicalLayoutUtil.prototype.calculateRectValue = function (dnode) {\n        var rect = { x: 0, y: 0, right: 0, bottom: 0, height: 0, width: 0 };\n        rect.x = dnode.offsetX - dnode.actualSize.width / 2;\n        rect.right = dnode.offsetX + dnode.actualSize.width / 2;\n        rect.y = dnode.offsetY - dnode.actualSize.height / 2;\n        rect.bottom = dnode.offsetY + dnode.actualSize.height / 2;\n        return rect;\n    };\n    HierarchicalLayoutUtil.prototype.isNodeOverLap = function (dnode, layoutProp) {\n        var nodeRect = { x: 0, y: 0, right: 0, bottom: 0, height: 0, width: 0 };\n        for (var i = 0; i < this.vertices.length; i++) {\n            var rect = { x: 0, y: 0, width: 0, height: 0 };\n            //let tempnode1: INode;\n            var tempnode1 = this.nameTable[this.vertices[i].value];\n            if (dnode.id !== tempnode1.id && tempnode1.offsetX !== 0 && tempnode1.offsetY !== 0) {\n                nodeRect = this.calculateRectValue(dnode);\n                rect = this.calculateRectValue(tempnode1);\n                if (this.isIntersect(rect, nodeRect, layoutProp)) {\n                    if (layoutProp.orientation === 'TopToBottom' || layoutProp.orientation === 'BottomToTop') {\n                        dnode.offsetX += layoutProp.horizontalSpacing;\n                    }\n                    else {\n                        dnode.offsetY += layoutProp.verticalSpacing;\n                    }\n                    this.isNodeOverLap(dnode, layoutProp);\n                }\n            }\n        }\n    };\n    HierarchicalLayoutUtil.prototype.isIntersect = function (rect, nodeRect, layoutProp) {\n        if (!(Math.floor(rect.right + layoutProp.horizontalSpacing) <= Math.floor(nodeRect.x) ||\n            Math.floor(rect.x - layoutProp.horizontalSpacing) >= Math.floor(nodeRect.right)\n            || Math.floor(rect.y - layoutProp.verticalSpacing) >= Math.floor(nodeRect.bottom)\n            || Math.floor(rect.bottom + layoutProp.verticalSpacing) <= Math.floor(nodeRect.y))) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /* eslint-disable */\n    HierarchicalLayoutUtil.prototype.updateMargin = function (layoutProp, layout, modelBounds, viewPort) {\n        var viewPortBounds = { x: 0, y: 0, width: viewPort.x, height: viewPort.y };\n        //let layoutBounds: Rect;\n        var bounds = {\n            x: modelBounds.x, y: modelBounds.y,\n            right: modelBounds.x + modelBounds.width,\n            bottom: modelBounds.y + modelBounds.height\n        };\n        var layoutBounds = layoutProp.bounds ? layoutProp.bounds : viewPortBounds;\n        if (layout.orientation === 'TopToBottom' || layout.orientation === 'BottomToTop') {\n            switch (layoutProp.horizontalAlignment) {\n                case 'Auto':\n                case 'Left':\n                    layout.marginX = (layoutBounds.x - bounds.x) + layoutProp.margin.left;\n                    break;\n                case 'Right':\n                    layout.marginX = layoutBounds.x + layoutBounds.width - layoutProp.margin.right - bounds.right;\n                    break;\n                case 'Center':\n                    layout.marginX = layoutBounds.x + layoutBounds.width / 2 - (bounds.x + bounds.right) / 2;\n                    break;\n            }\n            switch (layoutProp.verticalAlignment) {\n                case 'Top':\n                    //const top: number;\n                    var top_1 = layoutBounds.y + layoutProp.margin.top;\n                    layout.marginY = layout.orientation === 'TopToBottom' ? top_1 : -top_1;\n                    break;\n                case 'Bottom':\n                    //const bottom: number;\n                    var bottom = layoutBounds.y + layoutBounds.height - layoutProp.margin.bottom;\n                    layout.marginY = layout.orientation === 'TopToBottom' ? bottom - bounds.bottom : -(bottom - bounds.bottom);\n                    break;\n                case 'Auto':\n                case 'Center':\n                    //const center: number;\n                    var center = layoutBounds.y + layoutBounds.height / 2;\n                    layout.marginY = layout.orientation === 'TopToBottom' ?\n                        center - (bounds.y + bounds.bottom) / 2 : -center + (bounds.y + bounds.bottom) / 2;\n                    break;\n            }\n        }\n        else {\n            switch (layoutProp.horizontalAlignment) {\n                case 'Auto':\n                case 'Left':\n                    //let left: number;\n                    var left = layoutBounds.x + layoutProp.margin.left;\n                    layout.marginX = layout.orientation === 'LeftToRight' ? left : -left;\n                    break;\n                case 'Right':\n                    var right = void 0;\n                    right = layoutBounds.x + layoutBounds.width - layoutProp.margin.right;\n                    layout.marginX = layout.orientation === 'LeftToRight' ? right - bounds.right : bounds.right - right;\n                    break;\n                case 'Center':\n                    var center = void 0;\n                    center = layoutBounds.width / 2 + layoutBounds.x;\n                    layout.marginX = layout.orientation === 'LeftToRight' ?\n                        center - (bounds.y + bounds.bottom) / 2 : -center + (bounds.x + bounds.right) / 2;\n                    break;\n            }\n            switch (layoutProp.verticalAlignment) {\n                case 'Top':\n                    layout.marginY = layoutBounds.y + layoutProp.margin.top - bounds.x;\n                    break;\n                case 'Auto':\n                case 'Center':\n                    layout.marginY = layoutBounds.y + layoutBounds.height / 2 - (bounds.y + bounds.bottom) / 2;\n                    break;\n                case 'Bottom':\n                    layout.marginY = layoutBounds.y + layoutBounds.height - layoutProp.margin.bottom - bounds.bottom;\n                    break;\n            }\n        }\n    };\n    /* eslint-enable */\n    //Handles positioning the nodes\n    HierarchicalLayoutUtil.prototype.placementStage = function (model, marginX, marginY) {\n        var placementStage = this.coordinateAssignment(marginX, marginY, parent, model);\n        placementStage.model = model;\n        placementStage.widestRankValue = null;\n        this.placementStageExecute(placementStage);\n        return {\n            marginX: placementStage.marginX + model.layout.horizontalSpacing,\n            marginY: placementStage.marginY + model.layout.verticalSpacing\n        };\n    };\n    //Initializes the layout properties for positioning\n    HierarchicalLayoutUtil.prototype.coordinateAssignment = function (marginX, marginY, parent, model) {\n        var plalementChange = {};\n        if (model.layout.orientation === 'TopToBottom' || model.layout.orientation === 'BottomToTop') {\n            plalementChange.horizontalSpacing = model.layout.horizontalSpacing;\n            plalementChange.verticalSpacing = model.layout.verticalSpacing;\n        }\n        else {\n            plalementChange.horizontalSpacing = model.layout.verticalSpacing;\n            plalementChange.verticalSpacing = model.layout.horizontalSpacing;\n        }\n        plalementChange.orientation = 'north';\n        //Removed the conditions here. So check here in case of any issue\n        plalementChange.marginX = plalementChange.marginX = marginX;\n        plalementChange.marginY = plalementChange.marginY = marginY;\n        return plalementChange;\n    };\n    //Calculate the largest size of the node either height or width depends upon the layoutorientation\n    HierarchicalLayoutUtil.prototype.calculateWidestRank = function (plalementChange, graph, model) {\n        var isHorizontal = false;\n        if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {\n            isHorizontal = true;\n        }\n        var offset = -plalementChange.verticalSpacing;\n        var lastRankMaxCellSize = 0.0;\n        plalementChange.rankSizes = [];\n        plalementChange.rankOffset = [];\n        for (var rankValue = model.maxRank; rankValue >= 0; rankValue--) {\n            var maxCellSize = 0.0;\n            var rank = model.ranks[rankValue];\n            var localOffset = isHorizontal ? plalementChange.marginY : plalementChange.marginX;\n            for (var i = 0; i < rank.length; i++) {\n                var node = rank[i];\n                if (this.crossReduction.isVertex(node)) {\n                    var vertex = node;\n                    if (vertex.cell && (vertex.cell.inEdges || vertex.cell.outEdges)) {\n                        var obj = this.nameTable[vertex.cell.name];\n                        vertex.width = obj.actualSize.width;\n                        vertex.height = obj.actualSize.height;\n                        maxCellSize = Math.max(maxCellSize, (isHorizontal ? vertex.width : vertex.height));\n                    }\n                }\n                else {\n                    if (node) {\n                        var edge = node;\n                        var numEdges = 1;\n                        if (edge.edges != null) {\n                            numEdges = edge.edges.length;\n                        }\n                        node.width = (numEdges - 1) * 10;\n                    }\n                }\n                if (isHorizontal) {\n                    if (!node.height) {\n                        node.height = 0;\n                    }\n                }\n                // Set the initial x-value as being the best result so far\n                localOffset += (isHorizontal ? node.height : node.width) / 2.0;\n                this.setXY(node, rankValue, localOffset, isHorizontal ? true : false);\n                this.setTempVariable(node, rankValue, localOffset);\n                localOffset += ((isHorizontal ? node.height : node.width) / 2.0) + plalementChange.horizontalSpacing;\n                if (localOffset > plalementChange.widestRankValue) {\n                    plalementChange.widestRankValue = localOffset;\n                    plalementChange.widestRank = rankValue;\n                }\n                plalementChange.rankSizes[rankValue] = localOffset;\n            }\n            plalementChange.rankOffset[rankValue] = offset;\n            var distanceToNextRank = maxCellSize / 2.0 + lastRankMaxCellSize / 2.0 + plalementChange.verticalSpacing;\n            lastRankMaxCellSize = maxCellSize;\n            if (plalementChange.orientation === 'north' || plalementChange.orientation === 'west') {\n                offset += distanceToNextRank;\n            }\n            else {\n                offset -= distanceToNextRank;\n            }\n            for (var i = 0; i < rank.length; i++) {\n                var cell = rank[i];\n                this.setXY(cell, rankValue, offset, isHorizontal ? false : true);\n            }\n        }\n    };\n    /**\n     * Sets the temp position of the node on the layer \\\n     *\n     * @returns {  void }  Sets the temp position of the node on the layer \\\n     * @param {IVertex} node - provide the nodes value.\n     * @param {number} layer - provide the layer value.\n     * @param {number} value - provide the value value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.setTempVariable = function (node, layer, value) {\n        if (this.crossReduction.isVertex(node)) {\n            node.temp[0] = value;\n        }\n        else {\n            node.temp[layer - node.minRank - 1] = value;\n        }\n    };\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * setXY method \\\n     *\n     * @returns { void }     setXY method .\\\n     * @param {IVertex} node - provide the source value.\n     * @param {number} layer - provide the target value.\n     * @param {number} value - provide the layoutOrientation value.\n     * @param {boolean} isY - provide the layoutOrientation value.\n     * @param {IVertex[][]} ranks - provide the layoutOrientation value.\n     * @param {number} spacing - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.setXY = function (node, layer, value, isY, ranks, spacing) {\n        if (node && node.cell) {\n            if (node.cell.inEdges || node.cell.outEdges) {\n                if (isY) {\n                    node.y[0] = value;\n                }\n                else {\n                    node.x[0] = value;\n                }\n            }\n            else {\n                if (isY) {\n                    node.y[layer - node.minRank - 1] = value;\n                }\n                else {\n                    node.x[layer - node.minRank - 1] = value;\n                }\n            }\n        }\n        else {\n            this.setEdgeXY(ranks, node, spacing, layer);\n        }\n    };\n    //Sets geometry position of the layout node on the layout model\n    HierarchicalLayoutUtil.prototype.rankCoordinates = function (stage, rankValue, graph, model) {\n        var isHorizontal = false;\n        if (stage.model.layout.orientation === 'LeftToRight' || stage.model.layout.orientation === 'RightToLeft') {\n            isHorizontal = true;\n        }\n        var rank = model.ranks[rankValue];\n        var maxOffset = 0.0;\n        var localOffset = (isHorizontal ? stage.marginY : stage.marginX) + (stage.widestRankValue - stage.rankSizes[rankValue]) / 2;\n        for (var i = 0; i < rank.length; i++) {\n            var node = rank[i];\n            if (this.crossReduction.isVertex(node)) {\n                var obj = this.nameTable[node.cell.name];\n                node.width = obj.actualSize.width;\n                node.height = obj.actualSize.height;\n                maxOffset = Math.max(maxOffset, node.height);\n            }\n            else {\n                var edge = node;\n                var numEdges = 1;\n                if (edge.edges != null) {\n                    numEdges = edge.edges.length;\n                }\n                if (isHorizontal) {\n                    node.height = (numEdges - 1) * 10;\n                }\n                else {\n                    node.width = (numEdges - 1) * 10;\n                }\n            }\n            var size = (isHorizontal ? node.height : node.width) / 2.0;\n            localOffset += size;\n            this.setXY(node, rankValue, localOffset, isHorizontal ? true : false);\n            this.setTempVariable(node, rankValue, localOffset);\n            localOffset += (size + stage.horizontalSpacing);\n        }\n    };\n    //sets the layout in an initial positioning.it will arange all the ranks as much as possible\n    HierarchicalLayoutUtil.prototype.initialCoords = function (plalementChange, facade, model) {\n        this.calculateWidestRank(plalementChange, facade, model);\n        // Reverse sweep direction each time from widest rank\n        for (var i = plalementChange.widestRank; i >= 0; i--) {\n            if (i < model.maxRank) {\n                this.rankCoordinates(plalementChange, i, facade, model);\n            }\n        }\n        for (var i = plalementChange.widestRank + 1; i <= model.maxRank; i++) {\n            if (i > 0) {\n                this.rankCoordinates(plalementChange, i, facade, model);\n            }\n        }\n    };\n    /**\n     *  Checks whether the given node is an ancestor \\\n     *\n     * @returns {  boolean }  Checks whether the given node is an ancestor \\\n     * @param {IVertex} node - provide the nodes value.\n     * @param {IVertex} otherNode - provide the layer value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.isAncestor = function (node, otherNode) {\n        // Firstly, the hash code of this node needs to be shorter than the other node\n        if (otherNode != null && node.hashCode != null && otherNode.hashCode != null\n            && node.hashCode.length < otherNode.hashCode.length) {\n            if (node.hashCode === otherNode.hashCode) {\n                return true;\n            }\n            if (node.hashCode == null || node.hashCode == null) {\n                return false;\n            }\n            for (var i = 0; i < node.hashCode.length; i++) {\n                if (node.hashCode[i] !== otherNode.hashCode[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    //initializes the sorter object\n    HierarchicalLayoutUtil.prototype.weightedCellSorter = function (cell, weightedValue) {\n        var weightedCellSorter = {};\n        weightedCellSorter.cell = cell ? cell : null;\n        weightedCellSorter.weightedValue = weightedValue ? weightedValue : 0;\n        weightedCellSorter.visited = false;\n        weightedCellSorter.rankIndex = null;\n        return weightedCellSorter;\n    };\n    //Performs one node positioning in both directions\n    HierarchicalLayoutUtil.prototype.minNode = function (plalementChange, model) {\n        var nodeList = [];\n        var map = { map: {} };\n        var rank = [];\n        for (var i = 0; i <= model.maxRank; i++) {\n            rank[i] = model.ranks[i];\n            for (var j = 0; j < rank[i].length; j++) {\n                var node = rank[i][j];\n                var nodeWrapper = this.weightedCellSorter(node, i);\n                nodeWrapper.rankIndex = j;\n                nodeWrapper.visited = true;\n                nodeList.push(nodeWrapper);\n                model.setDictionaryForSorter(map, node, nodeWrapper, true);\n            }\n        }\n        var maxTries = nodeList.length * 10;\n        var count = 0;\n        var tolerance = 1;\n        while (nodeList.length > 0 && count <= maxTries) {\n            var cellWrapper = nodeList.shift();\n            var cell = cellWrapper.cell;\n            var rankValue = cellWrapper.weightedValue;\n            var rankIndex = cellWrapper.rankIndex;\n            var nextLayerConnectedCells = this.crossReduction.getConnectedCellsOnLayer(cell, rankValue);\n            var previousLayerConnectedCells = this.crossReduction.getConnectedCellsOnLayer(cell, rankValue, true);\n            var nextConnectedCount = nextLayerConnectedCells.length;\n            var prevConnectedCount = previousLayerConnectedCells.length;\n            var medianNextLevel = this.medianXValue(plalementChange, nextLayerConnectedCells, rankValue + 1);\n            var medianPreviousLevel = this.medianXValue(plalementChange, previousLayerConnectedCells, rankValue - 1);\n            var numConnectedNeighbours = nextConnectedCount + prevConnectedCount;\n            var currentPosition = this.crossReduction.getTempVariable(cell, rankValue);\n            var cellMedian = currentPosition;\n            if (numConnectedNeighbours > 0) {\n                cellMedian = (medianNextLevel * nextConnectedCount + medianPreviousLevel * prevConnectedCount) / numConnectedNeighbours;\n            }\n            if (nextConnectedCount === 1 && prevConnectedCount === 1) {\n                cellMedian = (medianPreviousLevel * prevConnectedCount) / prevConnectedCount;\n            }\n            else if (nextConnectedCount === 1) {\n                cellMedian = (medianNextLevel * nextConnectedCount) / nextConnectedCount;\n            }\n            var positionChanged = false;\n            var tempValue = undefined;\n            if (cellMedian < currentPosition - tolerance) {\n                if (rankIndex === 0) {\n                    tempValue = cellMedian;\n                    positionChanged = true;\n                }\n                else {\n                    var leftCell = rank[rankValue][rankIndex - 1];\n                    var leftLimit = this.crossReduction.getTempVariable(leftCell, rankValue);\n                    leftLimit = leftLimit + leftCell.width / 2 + plalementChange.intraCellSpacing + cell.width / 2;\n                    if (leftLimit < cellMedian) {\n                        tempValue = cellMedian;\n                        positionChanged = true;\n                    }\n                    else if (leftLimit < this.crossReduction.getTempVariable(cell, rankValue) - tolerance) {\n                        tempValue = leftLimit;\n                        positionChanged = true;\n                    }\n                }\n            }\n            else if (cellMedian > currentPosition + tolerance) {\n                var rankSize = rank[rankValue].length;\n                if (rankIndex === rankSize - 1) {\n                    tempValue = cellMedian;\n                    positionChanged = true;\n                }\n                else {\n                    var rightCell = rank[rankValue][rankIndex + 1];\n                    var rightLimit = this.crossReduction.getTempVariable(rightCell, rankValue);\n                    rightLimit = rightLimit - rightCell.width / 2 - plalementChange.intraCellSpacing - cell.width / 2;\n                    if (rightLimit > cellMedian) {\n                        tempValue = cellMedian;\n                        positionChanged = true;\n                    }\n                    else if (rightLimit > this.crossReduction.getTempVariable(cell, rankValue) + tolerance) {\n                        tempValue = rightLimit;\n                        positionChanged = true;\n                    }\n                }\n            }\n            if (positionChanged) {\n                this.setTempVariable(cell, rankValue, tempValue);\n                // Add connected nodes to map and list\n                this.updateNodeList(nodeList, map, nextLayerConnectedCells, model);\n                this.updateNodeList(nodeList, map, previousLayerConnectedCells, model);\n            }\n            if (this.crossReduction.isVertex(cellWrapper.cell)) {\n                cellWrapper.visited = false;\n            }\n            count++;\n        }\n    };\n    //Updates the ndoes collection\n    HierarchicalLayoutUtil.prototype.updateNodeList = function (nodeList, map, collection, model) {\n        for (var i = 0; i < collection.length; i++) {\n            var connectedCell = collection[i];\n            var connectedCellWrapper = model.getDictionaryForSorter(map, connectedCell);\n            if (connectedCellWrapper != null) {\n                if (connectedCellWrapper.visited === false) {\n                    connectedCellWrapper.visited = true;\n                    nodeList.push(connectedCellWrapper);\n                }\n            }\n        }\n    };\n    //Calculates the node position of the connected cell on the specified rank\n    HierarchicalLayoutUtil.prototype.medianXValue = function (plalementChange, connectedCells, rankValue) {\n        if (connectedCells.length === 0) {\n            return 0;\n        }\n        var medianValues = [];\n        for (var i = 0; i < connectedCells.length; i++) {\n            medianValues[i] = this.crossReduction.getTempVariable(connectedCells[i], rankValue);\n        }\n        medianValues.sort(function (a, b) {\n            return a - b;\n        });\n        if (connectedCells.length % 2 === 1) {\n            return medianValues[Math.floor(connectedCells.length / 2)];\n        }\n        else {\n            var medianPoint = connectedCells.length / 2;\n            var leftMedian = medianValues[medianPoint - 1];\n            var rightMedian = medianValues[medianPoint];\n            return ((leftMedian + rightMedian) / 2);\n        }\n    };\n    //Updates the geometry of the vertices\n    HierarchicalLayoutUtil.prototype.placementStageExecute = function (plalementChange) {\n        var isHorizontal = false;\n        if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {\n            isHorizontal = true;\n        }\n        plalementChange.jettyPositions = {};\n        var model = plalementChange.model;\n        // eslint-disable-next-line\n        isHorizontal ? plalementChange.currentYDelta = 0.0 : plalementChange.currentXDelta = 0.0;\n        this.initialCoords(plalementChange, { model: model }, model);\n        this.minNode(plalementChange, model);\n        var bestOffsetDelta = 100000000.0;\n        if (!plalementChange.maxIterations) {\n            plalementChange.maxIterations = 8;\n        }\n        for (var i = 0; i < plalementChange.maxIterations; i++) {\n            // if the total offset is less for the current positioning,\n            //there are less heavily angled edges and so the current positioning is used\n            if ((isHorizontal ? plalementChange.currentYDelta : plalementChange.currentXDelta) < bestOffsetDelta) {\n                for (var j = 0; j < model.ranks.length; j++) {\n                    var rank = model.ranks[j];\n                    for (var k = 0; k < rank.length; k++) {\n                        var cell = rank[k];\n                        this.setXY(cell, j, this.crossReduction.getTempVariable(cell, j), isHorizontal ? true : false);\n                    }\n                }\n                bestOffsetDelta = isHorizontal ? plalementChange.currentYDelta : plalementChange.currentXDelta;\n            }\n            // eslint-disable-next-line\n            isHorizontal ? plalementChange.currentYDelta = 0 : plalementChange.currentXDelta = 0;\n        }\n        this.setCellLocations(plalementChange, model);\n    };\n    //sets the cell position in the after the layout operation\n    HierarchicalLayoutUtil.prototype.setCellLocations = function (plalementChange, model) {\n        var vertices = this.getValues(model.vertexMapper);\n        for (var i = 0; i < vertices.length; i++) {\n            this.setVertexLocation(plalementChange, vertices[i]);\n        }\n    };\n    //used to specify the geometrical position of the layout model cell\n    HierarchicalLayoutUtil.prototype.garphModelsetVertexLocation = function (plalementChange, cell, x, y) {\n        //let model: MultiParentModel = plalementChange.model;\n        var geometry = cell.geometry;\n        var result = null;\n        if (geometry != null) {\n            result = { x: x, y: y, width: geometry.width, height: geometry.height };\n            if (geometry.x !== x || geometry.y !== y) {\n                cell.geometry = result;\n            }\n        }\n        return result;\n    };\n    //set the position of the specified node\n    HierarchicalLayoutUtil.prototype.setVertexLocation = function (plalementChange, cell) {\n        var isHorizontal = false;\n        if (plalementChange.model.layout.orientation === 'LeftToRight' || plalementChange.model.layout.orientation === 'RightToLeft') {\n            isHorizontal = true;\n        }\n        var realCell = cell.cell;\n        var positionX = cell.x[0] - cell.width / 2;\n        var positionY = cell.y[0] - cell.height / 2;\n        this.garphModelsetVertexLocation(plalementChange, realCell, positionX, positionY);\n        if (isHorizontal) {\n            if (!plalementChange.marginY) {\n                plalementChange.marginY = 0;\n            }\n            plalementChange.marginY = Math.max(plalementChange.marginY, positionY + cell.height);\n        }\n        else {\n            if (!plalementChange.marginX) {\n                plalementChange.marginX = 0;\n            }\n            plalementChange.marginX = Math.max(plalementChange.marginX, positionX + cell.width);\n        }\n    };\n    /**\n     *  get the specific value from the key value pair \\\n     *\n     * @returns {  {}[] }  get the specific value from the key value pair \\\n     * @param {VertexMapper} mapper - provide the mapper value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.getValues = function (mapper) {\n        var list = [];\n        if (mapper.map) {\n            for (var _i = 0, _a = Object.keys(mapper.map); _i < _a.length; _i++) {\n                var key = _a[_i];\n                list.push(mapper.map[key]);\n            }\n        }\n        return list;\n    };\n    /**\n     *Checks and reduces the crosses in between line segments \\\n     *\n     * @returns { void }    Checks and reduces the crosses in between line segments.\\\n     * @param {End} model - provide the model value.\n     *\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.crossingStage = function (model) {\n        this.crossReduction.execute(model);\n    };\n    //Initializes the ranks of the vertices\n    HierarchicalLayoutUtil.prototype.layeringStage = function (model) {\n        this.initialRank(model);\n        this.fixRanks(model);\n    };\n    //determine the initial rank for the each vertex on the relevent direction\n    HierarchicalLayoutUtil.prototype.initialRank = function (model) {\n        var startNodes = model.startNodes;\n        var internalNodes = model.getDictionaryValues(model.vertexMapper);\n        var startNodesCopy = startNodes.slice();\n        while (startNodes.length > 0) {\n            var internalNode = startNodes[0];\n            var layerDeterminingEdges = internalNode.connectsAsTarget;\n            var edgesToBeMarked = internalNode.connectsAsSource;\n            var allEdgesScanned = true;\n            var minimumLayer = 100000000;\n            for (var i = 0; i < layerDeterminingEdges.length; i++) {\n                var internalEdge = layerDeterminingEdges[i];\n                if (internalEdge.temp[0] === 5270620) {\n                    // This edge has been scanned, get the layer of the node on the other end\n                    var otherNode = internalEdge.source;\n                    minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n                }\n                else {\n                    allEdgesScanned = false;\n                    break;\n                }\n            }\n            // If all edge have been scanned, assign the layer, mark all edges in the other direction and remove from the nodes list\n            if (allEdgesScanned) {\n                internalNode.temp[0] = minimumLayer;\n                if (!model.maxRank) {\n                    model.maxRank = 100000000;\n                }\n                model.maxRank = Math.min(model.maxRank, minimumLayer);\n                if (edgesToBeMarked != null) {\n                    for (var i = 0; i < edgesToBeMarked.length; i++) {\n                        var internalEdge = edgesToBeMarked[i];\n                        internalEdge.temp[0] = 5270620;\n                        // Add node on other end of edge to LinkedList of nodes to be analysed\n                        var otherNode = internalEdge.target;\n                        // Only add node if it hasn't been assigned a layer\n                        if (otherNode.temp[0] === -1) {\n                            startNodes.push(otherNode);\n                            // Mark this other node as neither being unassigned nor assigned\n                            //so it isn't added to this list again, but it's layer isn't used in any calculation.\n                            otherNode.temp[0] = -2;\n                        }\n                    }\n                }\n                startNodes.shift();\n            }\n            else {\n                // Not all the edges have been scanned, get to the back of the class and put the dunces cap on\n                var removedCell = startNodes.shift();\n                startNodes.push(internalNode);\n                if (removedCell === internalNode && startNodes.length === 1) {\n                    // This is an error condition, we can't get out of this loop.\n                    //It could happen for more than one node but that's a lot harder to detect. Log the error\n                    break;\n                }\n            }\n        }\n        for (var i = 0; i < internalNodes.length; i++) {\n            internalNodes[i].temp[0] -= model.maxRank;\n        }\n        for (var i = 0; i < startNodesCopy.length; i++) {\n            var internalNode = startNodesCopy[i];\n            var currentMaxLayer = 0;\n            var layerDeterminingEdges = internalNode.connectsAsSource;\n            for (var j = 0; j < layerDeterminingEdges.length; j++) {\n                var internalEdge = layerDeterminingEdges[j];\n                var otherNode = internalEdge.target;\n                internalNode.temp[0] = Math.max(currentMaxLayer, otherNode.temp[0] + 1);\n                currentMaxLayer = internalNode.temp[0];\n            }\n        }\n        model.maxRank = 100000000 - model.maxRank;\n    };\n    //used to set the optimum value of each vertex on the layout\n    HierarchicalLayoutUtil.prototype.fixRanks = function (model) {\n        model.fixRanks();\n    };\n    //used to determine any cyclic stage have been created on the layout model\n    HierarchicalLayoutUtil.prototype.cycleStage = function (model) {\n        var seenNodes = {};\n        model.startNodes = [];\n        var unseenNodesArray = model.getDictionaryValues(model.vertexMapper);\n        var unseenNodes = [];\n        for (var i = 0; i < unseenNodesArray.length; i++) {\n            unseenNodesArray[i].temp[0] = -1;\n            unseenNodes[unseenNodesArray[i].id] = unseenNodesArray[i];\n        }\n        var rootsArray = null;\n        if (model.roots != null) {\n            var modelRoots = model.roots;\n            rootsArray = [];\n            for (var i = 0; i < modelRoots.length; i++) {\n                rootsArray[i] = model.getDictionary(model.vertexMapper, modelRoots[i]);\n                if (rootsArray[i] != null) {\n                    model.startNodes.push(rootsArray[i]);\n                }\n            }\n        }\n        model.visit('removeParentConnection', rootsArray, true, null, { seenNodes: seenNodes, unseenNodes: unseenNodes });\n        var seenNodesCopy = model.clone(seenNodes, null, true);\n        model.visit('removeNodeConnection', unseenNodes, true, seenNodesCopy, { seenNodes: seenNodes, unseenNodes: unseenNodes });\n    };\n    /**\n     * removes the edge from the given collection \\\n     *\n     * @returns {  IEdge }    removes the edge from the given collection .\\\n     * @param {IEdge} obj - provide the angle value.\n     * @param { IEdge[]} array - provide the angle value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.remove = function (obj, array) {\n        var index = array.indexOf(obj);\n        if (index !== -1) {\n            array.splice(index, 1);\n        }\n        return obj;\n    };\n    /**\n     * Inverts the source and target of an edge \\\n     *\n     * @returns {  void }    Inverts the source and target of an edge .\\\n     * @param {IEdge} connectingEdge - provide the angle value.\n     * @param { number} layer - provide the angle value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.invert = function (connectingEdge, layer) {\n        var temp = connectingEdge.source;\n        connectingEdge.source = connectingEdge.target;\n        connectingEdge.target = temp;\n        connectingEdge.isReversed = !connectingEdge.isReversed;\n    };\n    /**\n     * used to get the edges between the given source and target  \\\n     *\n     * @returns {  IConnector[] }    used to get the edges between the given source and target  .\\\n     * @param {Vertex} source - provide the angle value.\n     * @param { Vertex} target - provide the angle value.\n     * @param { boolean} directed - provide the angle value.\n     * @private\n     */\n    HierarchicalLayoutUtil.prototype.getEdgesBetween = function (source, target, directed) {\n        directed = (directed != null) ? directed : false;\n        var edges = this.getEdges(source);\n        var result = [];\n        for (var i = 0; i < edges.length; i++) {\n            var src = this.getVisibleTerminal(edges[i], true);\n            var trg = this.getVisibleTerminal(edges[i], false);\n            if ((src === source && trg === target) || (!directed && src === target && trg === source)) {\n                result.push(edges[i]);\n            }\n        }\n        return result;\n    };\n    return HierarchicalLayoutUtil;\n}());\n/**\n * Handles position the objects in a hierarchical tree structure\n */\nvar MultiParentModel = /** @class */ (function () {\n    function MultiParentModel(layout, vertices, roots, dlayout) {\n        this.multiObjectIdentityCounter = 0;\n        //used to count the no of times the parent have been used\n        this.dfsCount = 0;\n        this.hierarchicalUtil = new HierarchicalLayoutUtil();\n        this.roots = roots;\n        this.vertexMapper = { map: {} };\n        var internalVertices = [];\n        this.layout = dlayout;\n        this.maxRank = 100000000;\n        this.edgeMapper = { map: {} };\n        this.hierarchicalLayout = layout;\n        this.createInternalCells(layout, vertices, internalVertices, dlayout);\n        for (var i = 0; i < vertices.length; i++) {\n            var edges = internalVertices[i].connectsAsSource;\n            for (var j = 0; j < edges.length; j++) {\n                var internalEdge = edges[j];\n                var realEdges = internalEdge.edges;\n                if (realEdges != null && realEdges.length > 0) {\n                    var realEdge = realEdges[0];\n                    var targetCell = layout.getVisibleTerminal(realEdge, false);\n                    var internalTargetCell = this.getDictionary(this.vertexMapper, targetCell);\n                    if (internalVertices[i] === internalTargetCell) {\n                        targetCell = layout.getVisibleTerminal(realEdge, true);\n                        internalTargetCell = this.getDictionary(this.vertexMapper, targetCell);\n                    }\n                    if (internalTargetCell != null && internalVertices[i] !== internalTargetCell) {\n                        internalEdge.target = internalTargetCell;\n                        if (internalTargetCell.connectsAsTarget.length === 0) {\n                            internalTargetCell.connectsAsTarget = [];\n                        }\n                        if (internalTargetCell.connectsAsTarget.indexOf(internalEdge) < 0) {\n                            internalTargetCell.connectsAsTarget.push(internalEdge);\n                        }\n                    }\n                }\n            }\n            internalVertices[i].temp[0] = 1;\n        }\n    }\n    /* tslint:disable */\n    MultiParentModel.prototype.resetEdge = function (edge) {\n        var geometry = { x: 0, y: 0, width: 0, height: 0, relative: true };\n        var geo = geometry;\n        edge['geometry'] = geo;\n        return edge;\n    };\n    // eslint-disable-next-line max-len\n    MultiParentModel.prototype.createInternalCells = function (layout, vertices, internalVertices, dlayout) {\n        for (var i = 0; i < vertices.length; i++) {\n            internalVertices[i] = {\n                x: [], y: [], temp: [], cell: vertices[i],\n                id: vertices[i].name, connectsAsTarget: [], connectsAsSource: [], type: 'internalVertex'\n            };\n            this.setDictionary(this.vertexMapper, vertices[i], internalVertices[i]);\n            var conns = layout.getEdges(vertices[i]);\n            internalVertices[i].connectsAsSource = [];\n            for (var j = 0; j < conns.length; j++) {\n                var cell = layout.getVisibleTerminal(conns[j], false);\n                if (cell !== vertices[i]) {\n                    var undirectedEdges = layout.getEdgesBetween(vertices[i], cell, false);\n                    var directedEdges = layout.getEdgesBetween(vertices[i], cell, true);\n                    if (undirectedEdges != null && undirectedEdges.length > 0 && directedEdges.length * 2 >= undirectedEdges.length) {\n                        var internalEdge = { x: [], y: [], temp: [], edges: undirectedEdges, ids: [] };\n                        if (dlayout.enableLayoutRouting) {\n                            for (var k = 0; k < undirectedEdges.length; k++) {\n                                var edge = undirectedEdges[k];\n                                this.setDictionary(this.edgeMapper, undefined, internalEdge, edge.id);\n                                // Resets all point on the edge and disables the edge style\n                                // without deleting it from the cell style\n                                this.resetEdge(edge);\n                            }\n                        }\n                        internalEdge.source = internalVertices[i];\n                        for (var m = 0; m < undirectedEdges.length; m++) {\n                            internalEdge.ids.push(undirectedEdges[m].id);\n                        }\n                        internalEdge.source = internalVertices[i];\n                        if (!internalVertices[i].connectsAsSource) {\n                            internalVertices[i].connectsAsSource = [];\n                        }\n                        if (internalVertices[i].connectsAsSource.indexOf(internalEdge) < 0) {\n                            internalVertices[i].connectsAsSource.push(internalEdge);\n                        }\n                    }\n                }\n            }\n            internalVertices[i].temp[0] = 0;\n        }\n    };\n    /* tslint:enable */\n    /**\n     * used to set the optimum value of each vertex on the layout \\\n     *\n     * @returns {  void }   used to set the optimum value of each vertex on the layout .\\\n     * @private\n     */\n    MultiParentModel.prototype.fixRanks = function () {\n        var rankList = [];\n        this.ranks = [];\n        for (var i = 0; i < this.maxRank + 1; i++) {\n            rankList[i] = [];\n            this.ranks[i] = rankList[i];\n        }\n        var rootsArray = null;\n        if (this.roots != null) {\n            var oldRootsArray = this.roots;\n            rootsArray = [];\n            for (var i = 0; i < oldRootsArray.length; i++) {\n                var cell = oldRootsArray[i];\n                var internalNode = this.getDictionary(this.vertexMapper, cell);\n                rootsArray[i] = internalNode;\n            }\n        }\n        this.visit('updateMinMaxRank', rootsArray, false, null, { seenNodes: null, unseenNodes: null, rankList: rankList });\n    };\n    //Updates the min/max rank of the layer\n    MultiParentModel.prototype.updateMinMaxRank = function (layer, seen, data) {\n        //let seenNodes: {} = data.seenNodes;\n        //let unseenNodes: {} = data.unseenNodes;\n        var parent = data.parent;\n        var node = data.root;\n        var edge = data.edge;\n        var rankList = data.rankList;\n        if (!node.maxRank && node.maxRank !== 0) {\n            node.maxRank = -1;\n        }\n        if (!node.minRank && node.minRank !== 0) {\n            node.minRank = -1;\n        }\n        if (seen === 0 && node.maxRank < 0 && node.minRank < 0) {\n            rankList[node.temp[0]].push(node);\n            node.maxRank = node.temp[0];\n            node.minRank = node.temp[0];\n            node.temp[0] = rankList[node.maxRank].length - 1;\n        }\n        if (parent != null && edge != null) {\n            var parentToCellRankDifference = parent.maxRank - node.maxRank;\n            if (parentToCellRankDifference > 1) {\n                edge.maxRank = parent.maxRank;\n                edge.minRank = node.maxRank;\n                edge.temp = [];\n                edge.x = [];\n                edge.y = [];\n                for (var i = edge.minRank + 1; i < edge.maxRank; i++) {\n                    rankList[i].push(edge);\n                    this.hierarchicalUtil.setTempVariable(edge, i, rankList[i].length - 1);\n                }\n            }\n        }\n    };\n    //used to store the value of th given key on the object\n    MultiParentModel.prototype.setDictionary = function (dic, key, value, edgeId) {\n        if (!edgeId) {\n            var id = key.name;\n            var previous = dic.map[id];\n            dic.map[id] = value;\n            return previous;\n        }\n        else {\n            var previous = dic.map[edgeId];\n            dic.map[edgeId] = value;\n            return previous;\n        }\n    };\n    /**\n     * used to store the value of th given key on the objectt \\\n     *\n     * @returns {  IVertex }   used to store the value of th given key on the object .\\\n     * @param {VertexMapper} dic - provide the angle value.\n     * @param {IVertex} key - provide the angle value.\n     * @param {WeightedCellSorter} value - provide the angle value.\n     * @param {boolean} flag - provide the angle value.\n     * @private\n     */\n    MultiParentModel.prototype.setDictionaryForSorter = function (dic, key, value, flag) {\n        var id = key.id;\n        if (!id) {\n            //id = this._getDictionaryForSorter(dic, key);\n        }\n        var previous = dic.map[id];\n        dic.map[id] = value;\n        return previous;\n    };\n    /**\n     * used to get the value of the given key \\\n     *\n     * @returns {  IVertex }  used to get the value of the given key .\\\n     * @param {VertexMapper} dic - provide the angle value.\n     * @param {IVertex} key - provide the angle value.\n     * @private\n     */\n    MultiParentModel.prototype.getDictionary = function (dic, key) {\n        if (!this.multiObjectIdentityCounter && this.multiObjectIdentityCounter !== 0) {\n            this.multiObjectIdentityCounter = 0;\n        }\n        var id = key.name;\n        if (!id) {\n            if (!key.layoutObjectId) { ///####\n                key.layoutObjectId = 'graphHierarchyNode#' + this.multiObjectIdentityCounter++;\n                return key.layoutObjectId;\n            }\n            else {\n                return dic.map[key.layoutObjectId];\n            }\n        }\n        return dic.map[id];\n    };\n    /**\n     * used to get the value of the given key \\\n     *\n     * @returns {  IVertex }  used to get the value of the given key .\\\n     * @param {VertexMapper} dic - provide the angle value.\n     * @param {IVertex} key - provide the angle value.\n     * @private\n     */\n    MultiParentModel.prototype.getDictionaryForSorter = function (dic, key) {\n        if (!this.multiObjectIdentityCounter && this.multiObjectIdentityCounter !== 0) {\n            this.multiObjectIdentityCounter = 0;\n        }\n        var id = key.id;\n        if (!id) {\n            if (!key.layoutObjectId) { ///####\n                key.layoutObjectId = 'graphHierarchyNode#' + this.multiObjectIdentityCounter++;\n                return key.layoutObjectId;\n            }\n            else {\n                return dic.map[key.layoutObjectId];\n            }\n        }\n        return dic.map[id];\n    };\n    /**\n     * used to get all the values of the dictionary object \\\n     *\n     * @returns {  IVertex[] }  used to get all the values of the dictionary object .\\\n     * @param {VertexMapper} dic - provide the angle value.\n     * @private\n     */\n    MultiParentModel.prototype.getDictionaryValues = function (dic) {\n        var result = [];\n        for (var _i = 0, _a = Object.keys(dic.map); _i < _a.length; _i++) {\n            var key = _a[_i];\n            result.push(dic.map[key]);\n        }\n        return result;\n    };\n    /**\n     * used to visit all the entries on the given dictionary with given function \\\n     *\n     * @returns { void }  used to visit all the entries on the given dictionary with given function .\\\n     * @param {string} visitor - provide the visitor value.\n     * @param {IVertex[]} dfsRoots - provide the dfsRoots value.\n     * @param {boolean} trackAncestors - provide the trackAncestors value.\n     * @param {{}} seenNodes - provide the seenNodes value.\n     * @param {TraverseData} data - provide the data value.\n     * @private\n     */\n    MultiParentModel.prototype.visit = function (visitor, dfsRoots, trackAncestors, seenNodes, data) {\n        //let seenNodes1: {} = data.seenNodes;\n        //let unseenNodes1: {} = data.unseenNodes;\n        //let rankList: IVertex[][] = data.rankList;\n        // Run depth first search through on all roots\n        if (dfsRoots != null) {\n            for (var i = 0; i < dfsRoots.length; i++) {\n                var internalNode = dfsRoots[i];\n                if (internalNode != null) {\n                    if (seenNodes == null) {\n                        seenNodes = new Object();\n                    }\n                    data.parent = null;\n                    data.root = internalNode;\n                    data.edge = null;\n                    if (trackAncestors) {\n                        // Set up hash code for root\n                        internalNode.hashCode = [];\n                        internalNode.hashCode[0] = this.dfsCount;\n                        internalNode.hashCode[1] = i;\n                        this.extendedDfs(visitor, seenNodes, i, 0, data);\n                    }\n                    else {\n                        this.depthFirstSearch(visitor, seenNodes, 0, data);\n                    }\n                }\n            }\n            this.dfsCount++;\n        }\n    };\n    //used to perform the depth fisrt search on the layout model\n    MultiParentModel.prototype.depthFirstSearch = function (visitor, seen, layer, data) {\n        //let seenNodes1: {} = data.seenNodes;\n        //let unseenNodes1: {} = data.unseenNodes;\n        //let rankList: IVertex[][] = data.rankList;\n        //let parent: IVertex = data.parent;\n        var root = data.root;\n        //let edge: IEdge = data.edge;\n        if (root != null) {\n            var rootId = root.id;\n            if (seen[rootId] == null) {\n                seen[rootId] = root;\n                this.updateConnectionRank(visitor, layer, 0, data);\n                // Copy the connects as source list so that visitors can change the original for edge direction inversions\n                var outgoingEdges = root.connectsAsSource.slice();\n                for (var i = 0; i < outgoingEdges.length; i++) {\n                    var internalEdge = outgoingEdges[i];\n                    var targetNode = internalEdge.target;\n                    // Root check is O(|roots|)\n                    data.parent = root;\n                    data.root = targetNode;\n                    data.edge = internalEdge;\n                    this.depthFirstSearch(visitor, seen, layer + 1, data);\n                }\n            }\n            else {\n                this.updateConnectionRank(visitor, layer, 1, data);\n            }\n        }\n    };\n    //Updates the rank of the connection\n    MultiParentModel.prototype.updateConnectionRank = function (visitor, layer, seen, traversedList) {\n        var parent = traversedList.parent;\n        var root = traversedList.root;\n        var edge = traversedList.edge;\n        if (visitor === 'removeParentConnection' || visitor === 'removeNodeConnection') {\n            var remove = visitor === 'removeNodeConnection' ? true : false;\n            this.removeConnectionEdge(parent, root, edge, layer, traversedList, remove);\n        }\n        if (visitor === 'updateMinMaxRank') {\n            this.updateMinMaxRank(layer, seen, traversedList);\n        }\n    };\n    //Removes the edge from the collection\n    MultiParentModel.prototype.removeConnectionEdge = function (parent, node, edge, layer, data, remove) {\n        var seenNodes = data.seenNodes;\n        var unseenNodes = data.unseenNodes;\n        //let rankList: IVertex[][] = data.rankList;\n        if (this.hierarchicalUtil.isAncestor(node, parent)) {\n            this.hierarchicalUtil.invert(edge, 0);\n            this.hierarchicalUtil.remove(edge, parent.connectsAsSource);\n            if (remove) {\n                node.connectsAsSource.push(edge);\n                parent.connectsAsTarget.push(edge);\n                this.hierarchicalUtil.remove(edge, node.connectsAsTarget);\n            }\n            else {\n                parent.connectsAsTarget.push(edge);\n                this.hierarchicalUtil.remove(edge, node.connectsAsTarget);\n                node.connectsAsSource.push(edge);\n            }\n        }\n        seenNodes[node.id] = node;\n        delete unseenNodes[node.id];\n    };\n    //the dfs extends the default version by keeping track of cells ancestors, but it should be only used when necessary\n    MultiParentModel.prototype.extendedDfs = function (visitor, seen, cHash, layer, data) {\n        //let seenNodes: {} = data.seenNodes;\n        //let unseenNodes: {} = data.unseenNodes;\n        //let rankList: IVertex[][] = data.rankList;\n        var parent = data.parent;\n        var root = data.root;\n        var edge = data.edge;\n        if (root != null) {\n            if (parent != null) {\n                if (root.hashCode == null ||\n                    root.hashCode[0] !== parent.hashCode[0]) {\n                    var hashCodeLength = parent.hashCode.length + 1;\n                    root.hashCode = parent.hashCode.slice();\n                    root.hashCode[hashCodeLength - 1] = cHash;\n                }\n            }\n            var rootId = root.id;\n            if (seen[rootId] == null) {\n                seen[rootId] = root;\n                this.updateConnectionRank(visitor, layer, 0, data);\n                var outgoingEdges = root.connectsAsSource.slice();\n                for (var i = 0; i < outgoingEdges.length; i++) {\n                    var internalEdge = outgoingEdges[i];\n                    var targetNode = internalEdge.target;\n                    data.parent = root;\n                    data.root = targetNode;\n                    data.edge = internalEdge;\n                    this.extendedDfs(visitor, seen, i, layer + 1, data);\n                }\n            }\n            else {\n                this.updateConnectionRank(visitor, layer, 1, data);\n            }\n        }\n    };\n    /**\n     * used to clone the specified object ignoring all fieldnames in the given array of transient fields \\\n     *\n     * @returns { void }    used to clone the specified object ignoring all fieldnames in the given array of transient fields .\\\n     * @param {Object} obj - provide the source value.\n     * @param {string[]} transients - provide the target value.\n     * @param {boolean} shallow - provide the shallow value.\n     *\n     * @private\n     */\n    MultiParentModel.prototype.clone = function (obj, transients, shallow) {\n        shallow = (shallow != null) ? shallow : false;\n        if (obj != null && typeof (obj.constructor) === 'function') {\n            var clonedObj = obj.constructor();\n            for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n                var i = _a[_i];\n                if (i !== 'layoutObjectId' && (transients == null || transients.indexOf(i) < 0)) {\n                    if (!shallow && typeof (obj[i]) === 'object') {\n                        //not used\n                        //  _clone[i] = $.extend(true, {}, obj[i]);\n                    }\n                    else {\n                        clonedObj[i] = obj[i];\n                    }\n                }\n            }\n            return clonedObj;\n        }\n        return null;\n    };\n    return MultiParentModel;\n}());\n/**\n * Defines how to reduce the crosses in between the line segments\n */\nvar CrossReduction = /** @class */ (function () {\n    function CrossReduction() {\n    }\n    /**\n     *  used to calculate the number of edges crossing the layout model \\\n     *\n     * @returns { number }  used to calculate the number of edges crossing the layout model\\\n     * @param {MultiParentModel} model - provide the model value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.calculateCrossings = function (model) {\n        var numRanks = model.ranks.length;\n        var totalCrossings = 0;\n        for (var i = 1; i < numRanks; i++) {\n            totalCrossings += this.calculateRankCrossing(i, model);\n        }\n        return totalCrossings;\n    };\n    /**\n     *  used to get the temp value specified for the node or connector. \\\n     *\n     * @returns { boolean }  used to get the temp value specified for the node or connector.\\\n     * @param {IVertex} node - provide the node value.\n     * @param {IVertex} layer - provide the layer value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.getTempVariable = function (node, layer) {\n        if (node) {\n            if (this.isVertex(node)) {\n                return node.temp[0];\n            }\n            else {\n                return node.temp[layer - node.minRank - 1];\n            }\n        }\n        return 0;\n    };\n    //used to specify the number of conenctors crossing between the specified rank and its below rank\n    CrossReduction.prototype.calculateRankCrossing = function (i, model) {\n        var totalCrossings = 0;\n        var rank = model.ranks[i];\n        var previousRank = model.ranks[i - 1];\n        var tmpIndices = [];\n        // Iterate over the top rank and fill in the connection information\n        for (var j = 0; j < rank.length; j++) {\n            var node = rank[j];\n            var rankPosition = this.getTempVariable(node, i);\n            var connectedCells = this.getConnectedCellsOnLayer(node, i, true);\n            ///####\n            var nodeIndices = [];\n            for (var k = 0; k < connectedCells.length; k++) {\n                var connectedNode = connectedCells[k];\n                var otherCellRankPosition = this.getTempVariable(connectedNode, i - 1);\n                nodeIndices.push(otherCellRankPosition);\n            }\n            nodeIndices.sort(function (x, y) { return x - y; });\n            tmpIndices[rankPosition] = nodeIndices;\n        }\n        var indices = [];\n        for (var j = 0; j < tmpIndices.length; j++) {\n            indices = indices.concat(tmpIndices[j]);\n        }\n        var firstIndex = 1;\n        while (firstIndex < previousRank.length) {\n            firstIndex <<= 1;\n        }\n        var treeSize = 2 * firstIndex - 1;\n        firstIndex -= 1;\n        var tree = [];\n        for (var j = 0; j < treeSize; ++j) {\n            tree[j] = 0;\n        }\n        for (var j = 0; j < indices.length; j++) {\n            var index = indices[j];\n            var treeIndex = index + firstIndex;\n            ++tree[treeIndex];\n            while (treeIndex > 0) {\n                if (treeIndex % 2) {\n                    totalCrossings += tree[treeIndex + 1];\n                }\n                treeIndex = (treeIndex - 1) >> 1;\n                ++tree[treeIndex];\n            }\n        }\n        return totalCrossings;\n    };\n    /**\n     * Calculates and reduces the crosses between line segments\n     *\n     * @returns { void }Calculates and reduces the crosses between line segments.\\\n     * @param {MultiParentModel} model - provide the target value.\n     * @private\n     */\n    CrossReduction.prototype.execute = function (model) {\n        // Stores initial ordering\n        this.nestedBestRanks = [];\n        for (var i = 0; i < model.ranks.length; i++) {\n            this.nestedBestRanks[i] = model.ranks[i].slice();\n        }\n        var iterationsWithoutImprovement = 0;\n        var currentBestCrossings = this.calculateCrossings(model);\n        for (var i = 0; i < 24 && iterationsWithoutImprovement < 2; i++) {\n            this.weightedMedian(i, model);\n            var candidateCrossings = this.calculateCrossings(model);\n            if (candidateCrossings < currentBestCrossings) {\n                currentBestCrossings = candidateCrossings;\n                iterationsWithoutImprovement = 0;\n                for (var j = 0; j < this.nestedBestRanks.length; j++) {\n                    var rank = model.ranks[j];\n                    for (var k = 0; k < rank.length; k++) {\n                        var cell = rank[k];\n                        var obj = this.nestedBestRanks[j][cell.temp[0]];\n                        var check = true;\n                        if (cell.edges && obj && !obj.edges) {\n                            check = false;\n                        }\n                        if (obj && check) {\n                            this.nestedBestRanks[j][cell.temp[0]] = cell;\n                        }\n                    }\n                }\n            }\n            else {\n                // Increase count of iterations\n                iterationsWithoutImprovement++;\n                // Restore the best values to the cells\n                for (var j = 0; j < this.nestedBestRanks.length; j++) {\n                    var rank = model.ranks[j];\n                    for (var k = 0; k < rank.length; k++) {\n                        var cell = rank[k];\n                        this.setTempVariable(cell, j, k);\n                    }\n                }\n            }\n            if (currentBestCrossings === 0) {\n                break;\n            }\n        }\n        // Store the best rankings but in the model\n        var ranks = [];\n        var rankList = [];\n        for (var i = 0; i < model.maxRank + 1; i++) {\n            rankList[i] = [];\n            ranks[i] = rankList[i];\n        }\n        for (var i = 0; i < this.nestedBestRanks.length; i++) {\n            for (var j = 0; j < this.nestedBestRanks[i].length; j++) {\n                rankList[i].push(this.nestedBestRanks[i][j]);\n            }\n        }\n        model.ranks = ranks;\n    };\n    /**\n     *  check whether the object is vertext or edge on the layout model. \\\n     *\n     * @returns { boolean }  check whether the object is vertext or edge on the layout model..\\\n     * @param {IVertex} node - provide the iteration value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.isVertex = function (node) {\n        if (node && node.cell && (node.cell.inEdges || node.cell.outEdges)) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     *  used to move up or move down the node position on the adjacent ranks \\\n     *\n     * @returns { void }  used to move up or move down the node position on the adjacent ranks.\\\n     * @param {number} iteration - provide the iteration value.\n     * @param {MultiParentModel} model - provide the model value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.weightedMedian = function (iteration, model) {\n        // Reverse sweep direction each time through this method\n        var downwardSweep = (iteration % 2 === 0);\n        if (downwardSweep) {\n            for (var j = model.maxRank - 1; j >= 0; j--) {\n                this.medianRank(j, downwardSweep);\n            }\n        }\n        else {\n            for (var j = 1; j < model.maxRank; j++) {\n                this.medianRank(j, downwardSweep);\n            }\n        }\n    };\n    /**\n     * used to get the node next(up) connected to the specified node or connector \\\n     *\n     * @returns { void } calculates the rank elements on the specified rank.\\\n     * @param {IVertex} cell - provide the cell value.\n     * @param {number} layer - provide the layer value.\n     * @param {boolean} isPrevious - provide the isPrevious value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.getConnectedCellsOnLayer = function (cell, layer, isPrevious) {\n        if (isPrevious === void 0) { isPrevious = false; }\n        var connectedlayer = 'nextLayerConnectedCells';\n        var connectedAs = 'connectsAsTarget';\n        if (isPrevious) {\n            connectedlayer = 'previousLayerConnectedCells';\n            connectedAs = 'connectsAsSource';\n        }\n        if (cell) {\n            if (this.isVertex(cell)) {\n                if (cell[connectedlayer] == null) {\n                    cell[connectedlayer] = [];\n                    cell[connectedlayer][0] = [];\n                    for (var i = 0; i < cell[connectedAs].length; i++) {\n                        var edge = cell[connectedAs][i];\n                        if (edge.maxRank === undefined) {\n                            edge.maxRank = -1;\n                        }\n                        if (edge.maxRank === -1 || (isPrevious ? (edge.minRank === layer - 1) : (edge.maxRank === layer + 1))) {\n                            // Either edge is not in any rank or no dummy nodes in edge, add node of other side of edge\n                            cell[connectedlayer][0].push(isPrevious ? edge.target : edge.source);\n                        }\n                        else {\n                            // Edge spans at least two layers, add edge\n                            cell[connectedlayer][0].push(edge);\n                        }\n                    }\n                }\n                return cell[connectedlayer][0];\n            }\n            else {\n                if (cell[connectedlayer] == null) {\n                    cell[connectedlayer] = [];\n                    for (var i = 0; i < cell.temp.length; i++) {\n                        cell[connectedlayer][i] = [];\n                        if (i === (isPrevious ? 0 : (cell.temp.length - 1))) {\n                            cell[connectedlayer][i].push(isPrevious ? cell.target : cell.source);\n                        }\n                        else {\n                            cell[connectedlayer][i].push(cell);\n                        }\n                    }\n                }\n                return cell[connectedlayer][layer - cell.minRank - 1];\n            }\n        }\n        return null;\n    };\n    /**\n     * calculates the rank elements on the specified rank \\\n     *\n     * @returns { void } calculates the rank elements on the specified rank.\\\n     * @param {IVertex[]} connectedCells - provide the cell value.\n     * @param {number} rankValue - provide the layer value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.medianValue = function (connectedCells, rankValue) {\n        var medianValues = [];\n        var arrayCount = 0;\n        for (var i = 0; i < connectedCells.length; i++) {\n            var cell = connectedCells[i];\n            medianValues[arrayCount++] = this.getTempVariable(cell, rankValue);\n        }\n        // sorts numerical order sort\n        medianValues.sort(function (a, b) { return a - b; });\n        if (arrayCount % 2 === 1) {\n            // For odd numbers of adjacent vertices return the median\n            return medianValues[Math.floor(arrayCount / 2)];\n        }\n        else if (arrayCount === 2) {\n            return ((medianValues[0] + medianValues[1]) / 2.0);\n        }\n        else {\n            var medianPoint = arrayCount / 2;\n            var leftMedian = medianValues[medianPoint - 1] - medianValues[0];\n            var rightMedian = medianValues[arrayCount - 1]\n                - medianValues[medianPoint];\n            return (medianValues[medianPoint - 1] * rightMedian + medianValues[medianPoint] * leftMedian) / (leftMedian + rightMedian);\n        }\n    };\n    /**\n     * get the temp value of the specified layer \\\n     *\n     * @returns { void }     getDirection method .\\\n     * @param {IVertex} cell - provide the cell value.\n     * @param {layer} layer - provide the layer value.\n     * @param {LayoutOrientation} value - provide the value value.\n     *\n     * @private\n     */\n    CrossReduction.prototype.setTempVariable = function (cell, layer, value) {\n        if (cell) {\n            cell.temp[0] = value;\n        }\n    };\n    /**\n     * used to minimize the node position on this rank and one of its adjacent ranks\n     */\n    CrossReduction.prototype.medianRank = function (rankValue, downwardSweep) {\n        var numCellsForRank = this.nestedBestRanks[rankValue].length;\n        var medianValues = [];\n        var reservedPositions = [];\n        for (var i = 0; i < numCellsForRank; i++) {\n            var cell = this.nestedBestRanks[rankValue][i];\n            var sorterEntry = { medianValue: 0 };\n            sorterEntry.cell = cell;\n            // Flip whether or not equal medians are flipped on up and down sweeps\n            //TODO re-implement some kind of nudge medianValues[i].nudge = !downwardSweep;\n            var nextLevelConnectedCells = void 0;\n            if (downwardSweep) {\n                nextLevelConnectedCells = this.getConnectedCellsOnLayer(cell, rankValue);\n            }\n            else {\n                nextLevelConnectedCells = this.getConnectedCellsOnLayer(cell, rankValue, true);\n            }\n            var nextRankValue = void 0;\n            // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n            downwardSweep ? nextRankValue = rankValue + 1 : nextRankValue = rankValue - 1;\n            if (nextLevelConnectedCells != null && nextLevelConnectedCells.length !== 0) {\n                sorterEntry.medianValue = this.medianValue(nextLevelConnectedCells, nextRankValue);\n                medianValues.push(sorterEntry);\n            }\n            else {\n                // Nodes with no adjacent vertices are flagged in the reserved array to\n                //indicate they should be left in their current position.\n                reservedPositions[this.getTempVariable(cell, rankValue)] = true;\n            }\n        }\n        medianValues.sort(this.compare);\n        // Set the new position of each node within the rank using its temp variable\n        for (var i = 0; i < numCellsForRank; i++) {\n            if (reservedPositions[i] == null && medianValues.length > 0) {\n                var cell = medianValues.shift().cell;\n                this.setTempVariable(cell, rankValue, i);\n            }\n        }\n    };\n    //compares two values, it sends the values to the compare function,\n    //and sorts the values according to the returned (negative, zero, positive) value\n    CrossReduction.prototype.compare = function (a, b) {\n        if (a != null && b != null) {\n            if (b.medianValue > a.medianValue) {\n                return -1;\n            }\n            else if (b.medianValue < a.medianValue) {\n                return 1;\n            }\n        }\n        return 0;\n    };\n    return CrossReduction;\n}());\n"]},"metadata":{},"sourceType":"module"}