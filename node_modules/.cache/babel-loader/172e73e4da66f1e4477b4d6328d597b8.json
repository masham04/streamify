{"ast":null,"code":"import { Rect } from '../primitives/rect';\nimport { getPortDirection } from '../utility/connector';\nimport { canEnableRouting } from '../utility/constraints-util';\n/**\n * Line Routing\n */\n\nvar LineRouting =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the line routing module\n   *\n   * @private\n   */\n  function LineRouting() {\n    this.size = 20;\n    this.intermediatePoints = [];\n    this.gridCollection = [];\n    this.startArray = [];\n    this.targetGridCollection = [];\n    this.sourceGridCollection = [];\n    this.considerWalkable = []; //constructs the line routing module\n  }\n  /**\n   * lineRouting method \\\n   *\n   * @returns { void }     lineRouting method .\\\n   * @param {Diagram} diagram - provide the source value.\n   *\n   * @private\n   */\n\n\n  LineRouting.prototype.lineRouting = function (diagram) {\n    var length = diagram.connectors.length;\n    this.renderVirtualRegion(diagram);\n\n    if (length > 0) {\n      for (var k = 0; k < length; k++) {\n        var connector = diagram.connectors[k];\n\n        if (connector.type === 'Orthogonal' && connector.visible) {\n          this.refreshConnectorSegments(diagram, connector, true);\n        }\n      }\n    }\n  };\n  /** @private */\n\n  /**\n   * renderVirtualRegion method \\\n   *\n   * @returns { void }     renderVirtualRegion method .\\\n   * @param {Diagram} diagram - provide the source value.\n   * @param {boolean} isUpdate - provide the target value.\n   *\n   * @private\n   */\n\n\n  LineRouting.prototype.renderVirtualRegion = function (diagram, isUpdate) {\n    /* tslint:disable */\n    var extraBounds = this.size;\n\n    if (diagram.spatialSearch['pageTop'] < 0 || diagram.spatialSearch['pageLeft'] < 0) {\n      extraBounds = this.size + this.size / 2;\n    }\n\n    var right = diagram.spatialSearch['pageRight'] + extraBounds;\n    var bottom = diagram.spatialSearch['pageBottom'] + extraBounds;\n    var left = diagram.spatialSearch['pageLeft'] - extraBounds;\n    var top = diagram.spatialSearch['pageTop'] - extraBounds;\n    left = left < 0 ? left - 20 : 0;\n    top = top < 0 ? top - 20 : 0;\n    /* tslint:enable */\n\n    if (isUpdate && (this.width !== right - left || this.height !== bottom - top || this.diagramStartX !== left || this.diagramStartY !== top) || isUpdate === undefined) {\n      this.width = right - left;\n      this.height = bottom - top;\n      this.diagramStartX = left;\n      this.diagramStartY = top;\n      this.gridCollection = [];\n      this.noOfRows = this.width / this.size;\n      this.noOfCols = this.height / this.size;\n      var size = this.size;\n      var x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n      var y = this.diagramStartY < 0 ? this.diagramStartY : 0;\n\n      for (var i = 0; i < this.noOfCols; i++) {\n        for (var j = 0; j < this.noOfRows; j++) {\n          if (i === 0) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.gridCollection.push([0]);\n          }\n\n          var grid = {\n            x: x,\n            y: y,\n            width: size,\n            height: size,\n            gridX: j,\n            gridY: i,\n            walkable: true,\n            tested: undefined,\n            nodeId: []\n          };\n          this.gridCollection[j][i] = grid;\n          x += size;\n        }\n\n        x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n        y += size;\n      }\n    }\n\n    var nodes = this.findNodes(diagram.nodes);\n    this.updateNodesInVirtualRegion(nodes);\n  };\n\n  LineRouting.prototype.findNodes = function (nodes) {\n    var objects = [];\n    var node;\n\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n\n      if (node.shape.type !== 'SwimLane' && !node.isLane && !node.isPhase && !node.isHeader && node.visible) {\n        objects.push(node);\n      }\n    }\n\n    return objects;\n  };\n\n  LineRouting.prototype.updateNodesInVirtualRegion = function (diagramNodes) {\n    var size = this.size;\n    var x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n    var y = this.diagramStartY < 0 ? this.diagramStartY : 0;\n\n    for (var i = 0; i < this.noOfCols; i++) {\n      for (var j = 0; j < this.noOfRows; j++) {\n        var grid = this.gridCollection[j][i];\n        var rectangle = new Rect(x, y, this.size, this.size);\n        var isContains = void 0;\n        var k = void 0;\n        grid.walkable = true;\n        grid.tested = undefined;\n        grid.nodeId = [];\n\n        for (k = 0; k < diagramNodes.length; k++) {\n          if (diagramNodes[k].wrapper.bounds) {\n            isContains = this.intersectRect(rectangle, diagramNodes[k].wrapper.bounds);\n          }\n\n          if (isContains) {\n            grid.nodeId.push(diagramNodes[k].id);\n            grid.walkable = false;\n\n            if (diagramNodes[k].parentId !== '') {\n              grid.parentNodeId = diagramNodes[k].parentId;\n            }\n          }\n        }\n\n        x += size;\n      }\n\n      x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n      y += size;\n    }\n  };\n\n  LineRouting.prototype.intersectRect = function (r1, r2) {\n    return !(r2.left >= r1.right || r2.right <= r1.left || r2.top >= r1.bottom || r2.bottom <= r1.top);\n  };\n\n  LineRouting.prototype.findEndPoint = function (connector, isSource, isPortBounds) {\n    var endPoint;\n    var portDirection;\n\n    if (isSource && connector.sourcePortID !== '' || !isSource && connector.targetPortID !== '') {\n      endPoint = isSource ? {\n        x: connector.sourcePortWrapper.offsetX,\n        y: connector.sourcePortWrapper.offsetY\n      } : {\n        x: connector.targetPortWrapper.offsetX,\n        y: connector.targetPortWrapper.offsetY\n      };\n      portDirection = getPortDirection(endPoint, undefined, isSource ? connector.sourceWrapper.bounds : connector.targetWrapper.bounds, false);\n      var bounds = isSource ? connector.sourcePortWrapper.bounds : connector.targetPortWrapper.bounds;\n\n      if (isPortBounds) {\n        if (portDirection === 'Top') {\n          endPoint = {\n            x: bounds.topCenter.x,\n            y: bounds.topCenter.y\n          };\n        } else if (portDirection === 'Left') {\n          endPoint = {\n            x: bounds.middleLeft.x,\n            y: bounds.middleLeft.y\n          };\n        } else if (portDirection === 'Right') {\n          endPoint = {\n            x: bounds.middleRight.x,\n            y: bounds.middleRight.y\n          };\n        } else {\n          endPoint = {\n            x: bounds.bottomCenter.x,\n            y: bounds.bottomCenter.y\n          };\n        }\n      } else {\n        endPoint = {\n          x: bounds.center.x,\n          y: bounds.center.y\n        };\n      }\n    } else {\n      if (isSource && this.startNode || !isSource && this.targetNode) {\n        endPoint = isSource ? {\n          x: this.startNode.wrapper.offsetX,\n          y: this.startNode.wrapper.offsetY\n        } : {\n          x: this.targetNode.wrapper.offsetX,\n          y: this.targetNode.wrapper.offsetY\n        };\n      } else {\n        endPoint = isSource ? {\n          x: connector.sourcePoint.x,\n          y: connector.sourcePoint.y\n        } : {\n          x: connector.targetPoint.x,\n          y: connector.targetPoint.y\n        };\n      }\n    }\n\n    return endPoint;\n  };\n  /**\n   * refreshConnectorSegments method \\\n   *\n   * @returns { void }     refreshConnectorSegments method .\\\n   * @param {Diagram} diagram - provide the diagram value.\n   * @param {Connector} connector - provide the connector value.\n   * @param {boolean} isUpdate - provide the diagram value.\n   *\n   * @private\n   */\n\n\n  LineRouting.prototype.refreshConnectorSegments = function (diagram, connector, isUpdate) {\n    var sourceId = connector.sourceID;\n    var targetId = connector.targetID;\n    var sourcePortID = connector.sourcePortID;\n    var targetPortID = connector.targetPortID;\n    var startPoint;\n    var targetPoint;\n    var sourcePortDirection;\n    var targetPortDirection;\n    var grid;\n    var sourceTop;\n    var sourceBottom;\n    var isBreak;\n    var sourceLeft;\n    var sourceRight;\n    var targetRight;\n    var targetTop;\n    var targetBottom;\n    var targetLeft;\n\n    if (canEnableRouting(connector, diagram)) {\n      this.startNode = diagram.nameTable[sourceId];\n      this.targetNode = diagram.nameTable[targetId];\n      this.intermediatePoints = [];\n      this.startArray = [];\n      this.targetGridCollection = [];\n      this.sourceGridCollection = [];\n      this.startGrid = undefined;\n      this.targetGrid = undefined;\n\n      for (var i = 0; i < this.noOfCols; i++) {\n        for (var j = 0; j < this.noOfRows; j++) {\n          this.gridCollection[j][i].tested = this.gridCollection[j][i].parent = undefined;\n          this.gridCollection[j][i].previousDistance = this.gridCollection[j][i].afterDistance = undefined;\n          this.gridCollection[j][i].totalDistance = undefined;\n        }\n      } // Set the source point and target point\n\n\n      startPoint = this.findEndPoint(connector, true);\n      targetPoint = this.findEndPoint(connector, false); // Find the start grid and target grid\n\n      for (var i = 0; i < this.noOfRows; i++) {\n        for (var j = 0; j < this.noOfCols; j++) {\n          grid = this.gridCollection[i][j];\n          var rectangle = new Rect(grid.x, grid.y, grid.width, grid.height);\n\n          if (rectangle.containsPoint(startPoint) && !this.startGrid && (grid.nodeId.indexOf(sourceId) !== -1 || sourceId === '')) {\n            this.startGrid = sourcePortID && this.startGrid && (sourcePortDirection === 'Left' || sourcePortDirection === 'Top') ? this.startGrid : grid;\n          }\n\n          if (rectangle.containsPoint(targetPoint) && !this.targetGrid && (grid.nodeId.indexOf(targetId) !== -1 || targetId === '')) {\n            this.targetGrid = targetPortID && this.targetGrid && (targetPortDirection === 'Left' || targetPortDirection === 'Top') ? this.targetGrid : grid;\n          }\n\n          if (!sourcePortID && this.startNode) {\n            var bounds = this.startNode.wrapper.bounds;\n\n            if (rectangle.containsPoint(bounds.topCenter) && !sourceTop) {\n              sourceTop = grid;\n            }\n\n            if (rectangle.containsPoint(bounds.middleLeft) && !sourceLeft) {\n              sourceLeft = grid;\n            }\n\n            if (rectangle.containsPoint(bounds.middleRight) && !sourceRight) {\n              sourceRight = grid;\n            }\n\n            if (rectangle.containsPoint(bounds.bottomCenter) && !sourceBottom) {\n              sourceBottom = grid;\n            }\n          }\n\n          if (!targetPortID && this.targetNode) {\n            var bounds = this.targetNode.wrapper.bounds;\n\n            if (rectangle.containsPoint(bounds.topCenter) && !targetTop) {\n              targetTop = grid;\n            }\n\n            if (rectangle.containsPoint(bounds.middleLeft) && !targetLeft) {\n              targetLeft = grid;\n            }\n\n            if (rectangle.containsPoint(bounds.middleRight) && !targetRight) {\n              targetRight = grid;\n            }\n\n            if (rectangle.containsPoint({\n              x: bounds.bottomCenter.x,\n              y: bounds.bottomCenter.y\n            }) && !targetBottom) {\n              targetBottom = grid;\n            }\n          }\n        }\n      }\n\n      this.findEdgeBoundary(sourcePortID, sourceLeft, sourceRight, sourceTop, sourceBottom, true);\n      this.findEdgeBoundary(targetPortID, targetLeft, targetRight, targetTop, targetBottom, false);\n      this.startGrid.totalDistance = 0;\n      this.startGrid.previousDistance = 0;\n      this.intermediatePoints.push({\n        x: this.startGrid.gridX,\n        y: this.startGrid.gridY\n      });\n      this.startArray.push(this.startGrid);\n\n      if (connector && targetLeft && targetRight && targetTop && targetBottom) {\n        this.checkObstacles(connector, diagram, targetLeft, targetRight, targetTop, targetBottom);\n      } // eslint-disable-next-line no-labels\n\n\n      renderPathElement: while (this.startArray.length > 0) {\n        var startGridNode = this.startArray.pop();\n\n        for (var i = 0; i < this.targetGridCollection.length; i++) {\n          var target = this.targetGridCollection[i];\n\n          if (startGridNode.gridX === target.gridX && startGridNode.gridY === target.gridY) {\n            this.getIntermediatePoints(startGridNode);\n            isBreak = this.updateConnectorSegments(diagram, this.intermediatePoints, this.gridCollection, connector, isUpdate);\n\n            if (!isBreak) {\n              this.targetGridCollection.splice(this.targetGridCollection.indexOf(target), 1);\n              startGridNode = this.startArray.pop();\n            } else {\n              this.considerWalkable = []; // eslint-disable-next-line no-labels\n\n              break renderPathElement;\n            }\n          }\n        }\n\n        this.findPath(startGridNode);\n      }\n    }\n  };\n\n  LineRouting.prototype.checkChildNodes = function (grid, isSource) {\n    var check = false;\n    var reject = false;\n\n    if (grid.nodeId.length >= 1 && !isSource) {\n      for (var i = 0; i < grid.nodeId.length; i++) {\n        var id = grid.nodeId[i];\n\n        for (var j = 0; j < grid.nodeId.length; j++) {\n          if (this.targetNode.parentId === grid.nodeId[j]) {\n            reject = true;\n          }\n        }\n\n        if (!reject && this.targetNode.id === id) {\n          check = true;\n        } else {\n          check = false;\n        }\n      }\n    } else {\n      if (grid.nodeId.length === 1) {\n        check = true;\n      }\n    }\n\n    return check;\n  };\n\n  LineRouting.prototype.findEdgeBoundary = function (portID, left, right, top, bottom, isSource) {\n    var grid;\n    var collection = isSource ? this.sourceGridCollection : this.targetGridCollection;\n\n    if (!portID && (isSource ? this.startNode : this.targetNode)) {\n      for (var i = left.gridX; i <= right.gridX; i++) {\n        grid = this.gridCollection[i][left.gridY];\n\n        if (this.checkChildNodes(grid, isSource) && (i === left.gridX || i === right.gridX) || i !== left.gridX && i !== right.gridX) {\n          collection.push(grid);\n        }\n      }\n\n      for (var i = top.gridY; i <= bottom.gridY; i++) {\n        grid = this.gridCollection[top.gridX][i];\n\n        if ((this.checkChildNodes(grid, isSource) && (i === top.gridY || i === bottom.gridY) || i !== top.gridY && i !== bottom.gridY) && collection.indexOf(grid) === -1) {\n          collection.push(grid);\n        }\n      }\n    } else {\n      collection.push(isSource ? this.startGrid : this.targetGrid);\n    }\n  };\n\n  LineRouting.prototype.checkObstacles = function (connector, diagram, targetLeft, targetRight, targetTop, targetBottom) {\n    var neigbours = this.findNearestNeigbours(this.startGrid, this.gridCollection, true);\n\n    if (neigbours.length === 0) {\n      if (connector.sourcePortID !== '') {\n        var endPoint = {\n          x: connector.sourcePortWrapper.offsetX,\n          y: connector.sourcePortWrapper.offsetY\n        };\n        var portDirection = getPortDirection(endPoint, undefined, connector.sourceWrapper.bounds, false);\n\n        if (portDirection === 'Top') {\n          this.resetGridColl(this.startGrid, 'top', true);\n        } else if (portDirection === 'Right') {\n          this.resetGridColl(this.startGrid, 'right', true);\n        } else if (portDirection === 'Bottom') {\n          this.resetGridColl(this.startGrid, 'bottom', true);\n        } else {\n          this.resetGridColl(this.startGrid, 'left', true);\n        }\n      } else {\n        this.resetGridColl(this.startGrid, 'top', true);\n        this.resetGridColl(this.startGrid, 'right', true);\n        this.resetGridColl(this.startGrid, 'bottom', true);\n        this.resetGridColl(this.startGrid, 'left', true);\n      }\n    }\n\n    neigbours = this.findNearestNeigbours(this.targetGrid, this.gridCollection, false);\n\n    if (neigbours.length === 0) {\n      if (connector.targetPortID !== '') {\n        var endPoint = {\n          x: connector.targetPortWrapper.offsetX,\n          y: connector.targetPortWrapper.offsetY\n        };\n        var portDirection = getPortDirection(endPoint, undefined, connector.targetWrapper.bounds, false);\n\n        if (portDirection === 'Top') {\n          this.resetGridColl(this.targetGrid, 'top', true);\n        } else if (portDirection === 'Right') {\n          this.resetGridColl(this.targetGrid, 'right', true);\n        } else if (portDirection === 'Bottom') {\n          this.resetGridColl(this.targetGrid, 'bottom', true);\n        } else {\n          this.resetGridColl(this.targetGrid, 'left', true);\n        }\n      } else {\n        this.resetGridColl(this.targetGrid, 'top', false);\n        this.resetGridColl(this.targetGrid, 'right', false);\n        this.resetGridColl(this.targetGrid, 'bottom', false);\n        this.resetGridColl(this.targetGrid, 'left', false);\n      }\n    }\n\n    if (this.targetGridCollection.length > 0 && this.targetGridCollection[0].nodeId.length > 1) {\n      for (var i = 0; i <= 1; i++) {\n        var gridX = this.targetGridCollection[i].gridX;\n        var gridY = this.targetGridCollection[i].gridY;\n        var gridNodes = this.targetGridCollection[i].nodeId;\n        var targetNode = void 0;\n\n        for (var k = 0; k < gridNodes.length; k++) {\n          if (this.targetNode.id != gridNodes[k]) {\n            targetNode = gridNodes[k];\n            break;\n          }\n        }\n\n        var targetNodewrapper = void 0;\n        var overLapNode = void 0;\n        var contains = void 0;\n\n        if (diagram.nameTable[this.targetNode.id]) {\n          targetNodewrapper = diagram.nameTable[this.targetNode.id].wrapper;\n        }\n\n        if (diagram.nameTable[targetNode]) {\n          overLapNode = diagram.nameTable[targetNode].wrapper;\n        }\n\n        if (targetNodewrapper && overLapNode) {\n          contains = this.contains(overLapNode.bounds, targetNodewrapper.bounds);\n        }\n\n        var reject = void 0;\n\n        for (var j = 0; j < gridNodes.length; j++) {\n          if (this.targetNode.parentId === gridNodes[j]) {\n            reject = true;\n          }\n        }\n\n        if (!this.gridCollection[gridX][gridY].walkable && contains && !reject) {\n          var grid = void 0;\n          var diff = void 0;\n          grid = this.getEndvalue(targetLeft, \"left\");\n          diff = targetLeft.gridX - grid.gridX;\n          this.changeValue(targetLeft, diff, \"left\");\n          grid = this.getEndvalue(targetRight, \"right\");\n          diff = grid.gridX - targetRight.gridX;\n          this.changeValue(targetRight, diff, \"right\");\n          grid = this.getEndvalue(targetTop, \"top\");\n          diff = targetTop.gridY - grid.gridY;\n          this.changeValue(targetTop, diff, \"top\");\n          grid = this.getEndvalue(targetBottom, \"bottom\");\n          diff = targetBottom.gridY - grid.gridY;\n          this.changeValue(targetBottom, diff, \"top\");\n        }\n      }\n    }\n  };\n\n  LineRouting.prototype.contains = function (rect1, rect2) {\n    return rect1.left <= rect2.left && rect1.right >= rect2.right && rect1.top <= rect2.top && rect1.bottom >= rect2.bottom;\n  };\n\n  LineRouting.prototype.getEndvalue = function (target, direction) {\n    if (!this.gridCollection[target.gridX][target.gridY].walkable) {\n      if (direction === 'left') {\n        return this.getEndvalue(this.gridCollection[target.gridX - 1][target.gridY], direction);\n      }\n\n      if (direction === 'right') {\n        return this.getEndvalue(this.gridCollection[target.gridX + 1][target.gridY], direction);\n      }\n\n      if (direction === 'top') {\n        return this.getEndvalue(this.gridCollection[target.gridX][target.gridY - 1], direction);\n      }\n\n      if (direction === 'bottom') {\n        return this.getEndvalue(this.gridCollection[target.gridX][target.gridY + 1], direction);\n      }\n    } else {\n      return target;\n    }\n\n    return target;\n  };\n\n  LineRouting.prototype.changeValue = function (targetLeft, diff, direction) {\n    if (!targetLeft.walkable) {\n      this.considerWalkable.push(targetLeft);\n    }\n\n    var grid;\n\n    for (var i = 0; i <= diff; i++) {\n      if (direction === 'left') {\n        grid = this.gridCollection[targetLeft.gridX - i][targetLeft.gridY];\n      } else if (direction === 'right') {\n        grid = this.gridCollection[targetLeft.gridX + i][targetLeft.gridY];\n      } else if (direction === 'top') {\n        grid = this.gridCollection[targetLeft.gridX][targetLeft.gridY - i];\n      } else if (direction === 'bottom') {\n        grid = this.gridCollection[targetLeft.gridX][targetLeft.gridY + i];\n      }\n\n      if (!grid.walkable) {\n        this.considerWalkable.push(grid);\n      }\n    }\n  }; // Get all the intermediated points from target grid\n\n\n  LineRouting.prototype.getIntermediatePoints = function (target) {\n    var distance;\n    this.intermediatePoints = [];\n\n    while (target) {\n      this.intermediatePoints.push({\n        x: target.gridX,\n        y: target.gridY\n      });\n      target = target.parent;\n    }\n\n    this.intermediatePoints.reverse();\n\n    if (this.intermediatePoints.length >= 1) {\n      if (this.intermediatePoints[0].x === this.intermediatePoints[1].x) {\n        if (this.intermediatePoints[0].y < this.intermediatePoints[1].y) {\n          distance = this.neigbour(this.startGrid, 'bottom', undefined, true);\n          this.intermediatePoints[0].y += distance - 1;\n        } else {\n          distance = this.neigbour(this.startGrid, 'top', undefined, true);\n          this.intermediatePoints[0].y -= distance - 1;\n        }\n      } else {\n        if (this.intermediatePoints[0].x < this.intermediatePoints[1].x) {\n          distance = this.neigbour(this.startGrid, 'right', undefined, true);\n          this.intermediatePoints[0].x += distance - 1;\n        } else {\n          distance = this.neigbour(this.startGrid, 'left', undefined, true);\n          this.intermediatePoints[0].x -= distance - 1;\n        }\n      }\n    }\n  }; // Connector rendering\n\n  /* tslint:disable */\n\n\n  LineRouting.prototype.updateConnectorSegments = function (diagram, intermediatePoints, gridCollection, connector, isUpdate) {\n    var segments = [];\n    var seg;\n    var targetPoint;\n    var pointX;\n    var pointY;\n    var node;\n    var points = [];\n    var direction;\n    var length;\n    var currentdirection;\n    var prevDirection;\n    var targetWrapper = connector.targetWrapper;\n    var sourceWrapper = connector.sourceWrapper;\n    var sourcePoint = this.findEndPoint(connector, true);\n\n    if (connector.targetPortID !== '' || !connector.targetWrapper) {\n      targetPoint = this.findEndPoint(connector, false, true);\n    }\n\n    for (var i = 0; i < intermediatePoints.length; i++) {\n      node = gridCollection[intermediatePoints[i].x][intermediatePoints[i].y];\n      pointX = node.x + node.width / 2;\n      pointY = node.y + node.height / 2;\n      points.push({\n        x: pointX,\n        y: pointY\n      });\n\n      if (i >= 1) {\n        if (points[points.length - 2].x !== points[points.length - 1].x) {\n          currentdirection = points[points.length - 2].x > points[points.length - 1].x ? 'Left' : 'Right';\n        } else {\n          currentdirection = points[points.length - 2].y > points[points.length - 1].y ? 'Top' : 'Bottom';\n        }\n      }\n\n      if (i >= 2 && prevDirection === currentdirection) {\n        points.splice(points.length - 2, 1);\n      }\n\n      prevDirection = currentdirection;\n    }\n\n    for (var j = 0; j < points.length - 1; j++) {\n      if (points[j].x !== points[j + 1].x) {\n        if (j === 0 && connector.sourcePortID === '' && sourceWrapper) {\n          sourcePoint = points[j].x > points[j + 1].x ? sourceWrapper.bounds.middleLeft : sourceWrapper.bounds.middleRight;\n        }\n\n        if (j === points.length - 2 && connector.targetPortID === '' && targetWrapper) {\n          targetPoint = points[j].x > points[j + 1].x ? targetWrapper.bounds.middleRight : targetWrapper.bounds.middleLeft;\n        }\n\n        if (j === 0 && sourcePoint) {\n          points[j].x = sourcePoint.x;\n          points[j].y = points[j + 1].y = sourcePoint.y;\n        }\n\n        if (j === points.length - 2 && targetPoint) {\n          if (targetPoint.x - points[j + 1].x < 0 && Math.abs(targetPoint.x - points[j].x) < connector.targetDecorator.width + 1) {\n            points[j].x = points[j - 1].x -= this.size / 2;\n          }\n\n          if (targetPoint.x - points[j + 1].x > 0 && Math.abs(targetPoint.x - points[j].x) < connector.targetDecorator.width + 1) {\n            points[j].x = points[j - 1].x += this.size / 2;\n          }\n\n          points[j + 1].x = targetPoint.x;\n          points[j].y = points[j + 1].y = targetPoint.y;\n        }\n      } else {\n        if (j === 0 && sourceWrapper) {\n          sourcePoint = points[j].y > points[j + 1].y ? sourceWrapper.bounds.topCenter : sourceWrapper.bounds.bottomCenter;\n        }\n\n        if (j === points.length - 2 && connector.targetPortID === '' && targetWrapper) {\n          targetPoint = points[j].y > points[j + 1].y ? targetWrapper.bounds.bottomCenter : targetWrapper.bounds.topCenter;\n        }\n\n        if (j === 0 && sourcePoint) {\n          points[j].y = sourcePoint.y;\n          points[j].x = points[j + 1].x = sourcePoint.x;\n        }\n\n        if (j === points.length - 2 && targetPoint) {\n          if (targetPoint.y - points[j + 1].y < 0 && Math.abs(targetPoint.y - points[j].y) < connector.targetDecorator.height + 1) {\n            points[j].y = points[j - 1].y -= this.size / 2;\n          }\n\n          if (targetPoint.y - points[j + 1].y > 0 && Math.abs(targetPoint.y - points[j].y) < connector.targetDecorator.width + 1) {\n            points[j].y = points[j - 1].y += this.size / 2;\n          }\n\n          points[j + 1].y = targetPoint.y;\n          points[j].x = points[j + 1].x = targetPoint.x;\n        }\n      }\n    }\n\n    for (var j = 0; j < points.length - 1; j++) {\n      if (points[j].x !== points[j + 1].x) {\n        if (points[j].x > points[j + 1].x) {\n          direction = 'Left';\n          length = points[j].x - points[j + 1].x;\n        } else {\n          direction = 'Right';\n          length = points[j + 1].x - points[j].x;\n        }\n      } else {\n        if (points[j].y > points[j + 1].y) {\n          direction = 'Top';\n          length = points[j].y - points[j + 1].y;\n        } else {\n          direction = 'Bottom';\n          length = points[j + 1].y - points[j].y;\n        }\n      }\n\n      seg = {\n        type: 'Orthogonal',\n        length: length,\n        direction: direction\n      };\n      segments.push(seg);\n    }\n\n    var lastSeg = segments[segments.length - 1];\n\n    if (segments.length === 1) {\n      lastSeg.length -= 20;\n    }\n\n    if (lastSeg.length < 10 && segments.length === 2) {\n      segments.pop();\n      segments[0].length -= 20;\n      lastSeg = segments[0];\n    }\n\n    if ((lastSeg.direction === 'Top' || lastSeg.direction === 'Bottom') && lastSeg.length > connector.targetDecorator.height + 1 || (lastSeg.direction === 'Right' || lastSeg.direction === 'Left') && lastSeg.length > connector.targetDecorator.width + 1) {\n      connector.segments = segments;\n\n      if (isUpdate) {\n        diagram.connectorPropertyChange(connector, {}, {\n          type: 'Orthogonal',\n          segments: segments\n        });\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /* tslint:enable */\n  // Shortest path\n\n\n  LineRouting.prototype.findPath = function (startGrid) {\n    var intermediatePoint;\n    var collection = [];\n    var neigbours = this.findNearestNeigbours(startGrid, this.gridCollection, true);\n\n    for (var i = 0; i < neigbours.length; i++) {\n      intermediatePoint = this.findIntermediatePoints(neigbours[i].gridX, neigbours[i].gridY, startGrid.gridX, startGrid.gridY, this.targetGrid.gridX, this.targetGrid.gridY);\n\n      if (intermediatePoint !== null) {\n        var grid = this.gridCollection[intermediatePoint.x][intermediatePoint.y];\n        var h = this.octile(Math.abs(intermediatePoint.x - startGrid.gridX), Math.abs(intermediatePoint.y - startGrid.gridY));\n        var l = startGrid.previousDistance + h;\n\n        if ((!grid.previousDistance || grid.previousDistance > l) && !(intermediatePoint.x === startGrid.gridX && intermediatePoint.y === startGrid.gridY)) {\n          collection.push(intermediatePoint);\n          grid.previousDistance = l;\n          grid.afterDistance = grid.afterDistance || this.manhattan(Math.abs(intermediatePoint.x - this.targetGrid.gridX), Math.abs(intermediatePoint.y - this.targetGrid.gridY));\n          grid.totalDistance = grid.previousDistance + grid.afterDistance;\n          grid.parent = startGrid;\n        }\n      }\n    }\n\n    if (collection.length > 0) {\n      for (var i = 0; i < collection.length; i++) {\n        var grid = this.gridCollection[collection[i].x][collection[i].y];\n\n        if (this.startArray.indexOf(grid) === -1) {\n          this.startArray.push(grid);\n        }\n      }\n    }\n\n    this.sorting(this.startArray);\n  }; // sorting the array based on total distance between source and target node\n\n\n  LineRouting.prototype.sorting = function (array) {\n    var done = false;\n\n    while (!done) {\n      done = true;\n\n      for (var i = 1; i < array.length; i += 1) {\n        if (array[i - 1].totalDistance < array[i].totalDistance) {\n          done = false;\n          var tmp = array[i - 1];\n          array[i - 1] = array[i];\n          array[i] = tmp;\n        }\n      }\n    }\n\n    return array;\n  };\n\n  LineRouting.prototype.octile = function (t, e) {\n    var r = Math.SQRT2 - 1;\n    return e > t ? r * t + e : r * e + t;\n  };\n\n  LineRouting.prototype.manhattan = function (t, e) {\n    return t + e;\n  }; // Find the nearest neigbour from the current boundaries, the neigbour is use to find next intermdiate point.\n\n\n  LineRouting.prototype.findNearestNeigbours = function (startGrid, gridCollection, isSource) {\n    var neigbours = [];\n    var parent = startGrid.parent;\n\n    if (parent) {\n      var dx = (startGrid.gridX - parent.gridX) / Math.max(Math.abs(startGrid.gridX - parent.gridX), 1);\n      var dy = (startGrid.gridY - parent.gridY) / Math.max(Math.abs(startGrid.gridY - parent.gridY), 1);\n\n      if (dx !== 0) {\n        if (this.isWalkable(startGrid.gridX, startGrid.gridY - 1, true) && this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY - 1]) === -1) {\n          neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY - 1]);\n        }\n\n        if (this.isWalkable(startGrid.gridX, startGrid.gridY + 1, true) && this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY + 1])) {\n          neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY + 1]);\n        }\n\n        if (this.isWalkable(startGrid.gridX + dx, startGrid.gridY, true) && this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX + dx][startGrid.gridY]) === -1) {\n          neigbours.push(gridCollection[startGrid.gridX + dx][startGrid.gridY]);\n        }\n      } else if (dy !== 0) {\n        if (this.isWalkable(startGrid.gridX - 1, startGrid.gridY, true) && this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX - 1][startGrid.gridY]) === -1) {\n          neigbours.push(gridCollection[startGrid.gridX - 1][startGrid.gridY]);\n        }\n\n        if (this.isWalkable(startGrid.gridX + 1, startGrid.gridY, true) && this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX + 1][startGrid.gridY]) === -1) {\n          neigbours.push(gridCollection[startGrid.gridX + 1][startGrid.gridY]);\n        }\n\n        if (this.isWalkable(startGrid.gridX, startGrid.gridY + dy, true) && this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY + dy]) === -1) {\n          neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY + dy]);\n        }\n      }\n    } else {\n      this.neigbour(startGrid, 'top', neigbours, isSource);\n      this.neigbour(startGrid, 'right', neigbours, isSource);\n      this.neigbour(startGrid, 'bottom', neigbours, isSource);\n      this.neigbour(startGrid, 'left', neigbours, isSource);\n    }\n\n    return neigbours;\n  };\n\n  LineRouting.prototype.neigbour = function (startGrid, direction, neigbours, isSource) {\n    var i = 1;\n    var nearGrid;\n\n    while (i > 0) {\n      var x = direction === 'top' || direction === 'bottom' ? startGrid.gridX : direction === 'left' ? startGrid.gridX - i : startGrid.gridX + i;\n      var y = direction === 'right' || direction === 'left' ? startGrid.gridY : direction === 'top' ? startGrid.gridY - i : startGrid.gridY + i;\n      nearGrid = this.gridCollection[x][y];\n\n      if (nearGrid && (isSource && this.sourceGridCollection.indexOf(nearGrid) === -1 || !isSource && this.targetGridCollection.indexOf(nearGrid) === -1)) {\n        if (neigbours && this.isWalkable(x, y)) {\n          neigbours.push(nearGrid);\n        }\n\n        return i;\n      }\n\n      if (x > 0 && y > 0) {\n        i++;\n      } else {\n        break;\n      }\n    }\n\n    return null;\n  };\n\n  LineRouting.prototype.resetGridColl = function (grid, direction, isSource) {\n    var i = 1;\n    var nearGrid;\n\n    while (i > 0) {\n      var x = direction === 'top' || direction === 'bottom' ? grid.gridX : direction === 'left' ? grid.gridX - i : grid.gridX + i;\n      var y = direction === 'right' || direction === 'left' ? grid.gridY : direction === 'top' ? grid.gridY - i : grid.gridY + i;\n      nearGrid = this.gridCollection[x][y];\n\n      if (nearGrid && (isSource && this.sourceGridCollection.indexOf(nearGrid) === -1 || !isSource && this.targetGridCollection.indexOf(nearGrid) === -1)) {\n        if (this.isWalkable(x, y)) {\n          break;\n        } else {\n          var grid_1 = this.gridCollection[x][y];\n          this.considerWalkable.push(grid_1);\n        }\n      }\n\n      if (x > 0 && y > 0) {\n        if (direction === 'top' || direction === 'left') {\n          i--;\n        } else {\n          i++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return null;\n  };\n\n  LineRouting.prototype.isWalkable = function (x, y, isparent) {\n    if (x >= 0 && x < this.noOfRows && y >= 0 && y < this.noOfCols) {\n      var grid = this.gridCollection[x][y];\n\n      if (grid && (grid.walkable || (grid.nodeId.length === 1 || grid.nodeId.length === 2 && grid.parentNodeId || this.considerWalkable.indexOf(grid) !== -1) && (this.sourceGridCollection.indexOf(grid) !== -1 || this.targetGridCollection.indexOf(grid) !== -1 || this.considerWalkable.indexOf(grid) !== -1))) {\n        if (isparent && !grid.parent || !isparent) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  LineRouting.prototype.findIntermediatePoints = function (neigbourGridX, neigbourGridY, startGridX, startGridY, endGridX, endGridY) {\n    var dx = neigbourGridX - startGridX;\n    var dy = neigbourGridY - startGridY;\n    var gridX = neigbourGridX;\n    var gridY = neigbourGridY;\n\n    for (var i = 0; i < this.targetGridCollection.length; i++) {\n      if (neigbourGridX === this.targetGridCollection[i].gridX && neigbourGridY === this.targetGridCollection[i].gridY) {\n        return {\n          x: neigbourGridX,\n          y: neigbourGridY\n        };\n      }\n    }\n\n    if (!this.isWalkable(neigbourGridX, neigbourGridY)) {\n      return null;\n    }\n\n    var neigbourGrid = this.gridCollection[neigbourGridX][neigbourGridY];\n\n    if (neigbourGrid.tested) {\n      return {\n        x: neigbourGridX,\n        y: neigbourGridY\n      };\n    }\n\n    neigbourGrid.tested = true;\n\n    if (dx !== 0) {\n      dx = dx > 0 ? 1 : -1;\n\n      if (this.isWalkable(gridX, gridY - 1) && !this.isWalkable(gridX - dx, gridY - 1) || this.isWalkable(gridX, gridY + 1) && !this.isWalkable(gridX - dx, gridY + 1)) {\n        return {\n          x: neigbourGridX,\n          y: neigbourGridY\n        };\n      }\n    }\n\n    if (dy !== 0) {\n      dy = dy > 0 ? 1 : -1;\n\n      if (this.isWalkable(gridX - 1, gridY) && !this.isWalkable(gridX - 1, gridY - dy) || this.isWalkable(gridX + 1, gridY) && !this.isWalkable(gridX + 1, gridY - dy)) {\n        return {\n          x: neigbourGridX,\n          y: neigbourGridY\n        };\n      }\n\n      if (this.findIntermediatePoints(gridX + 1, gridY, gridX, gridY, endGridX, endGridY) || this.findIntermediatePoints(gridX - 1, gridY, gridX, gridY, endGridX, endGridY)) {\n        return {\n          x: neigbourGridX,\n          y: neigbourGridY\n        };\n      }\n    }\n\n    return this.findIntermediatePoints(gridX + dx, gridY + dy, gridX, gridY, endGridX, endGridY);\n  };\n  /**\n   *To destroy the line routing\n   *\n   * @returns {void} To destroy the line routing\n   */\n\n\n  LineRouting.prototype.destroy = function () {\n    /**\n     * Destroys the line routing module\n     */\n  };\n  /**\n   * Core method to return the component name.\n   *\n   * @returns {string}  Core method to return the component name.\n   * @private\n   */\n\n\n  LineRouting.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'LineRouting';\n  };\n\n  return LineRouting;\n}();\n\nexport { LineRouting };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/line-routing.js"],"names":["Rect","getPortDirection","canEnableRouting","LineRouting","size","intermediatePoints","gridCollection","startArray","targetGridCollection","sourceGridCollection","considerWalkable","prototype","lineRouting","diagram","length","connectors","renderVirtualRegion","k","connector","type","visible","refreshConnectorSegments","isUpdate","extraBounds","spatialSearch","right","bottom","left","top","width","height","diagramStartX","diagramStartY","undefined","noOfRows","noOfCols","x","y","i","j","push","grid","gridX","gridY","walkable","tested","nodeId","nodes","findNodes","updateNodesInVirtualRegion","objects","node","shape","isLane","isPhase","isHeader","diagramNodes","rectangle","isContains","wrapper","bounds","intersectRect","id","parentId","parentNodeId","r1","r2","findEndPoint","isSource","isPortBounds","endPoint","portDirection","sourcePortID","targetPortID","sourcePortWrapper","offsetX","offsetY","targetPortWrapper","sourceWrapper","targetWrapper","topCenter","middleLeft","middleRight","bottomCenter","center","startNode","targetNode","sourcePoint","targetPoint","sourceId","sourceID","targetId","targetID","startPoint","sourcePortDirection","targetPortDirection","sourceTop","sourceBottom","isBreak","sourceLeft","sourceRight","targetRight","targetTop","targetBottom","targetLeft","nameTable","startGrid","targetGrid","parent","previousDistance","afterDistance","totalDistance","containsPoint","indexOf","findEdgeBoundary","checkObstacles","renderPathElement","startGridNode","pop","target","getIntermediatePoints","updateConnectorSegments","splice","findPath","checkChildNodes","check","reject","portID","collection","neigbours","findNearestNeigbours","resetGridColl","gridNodes","targetNodewrapper","overLapNode","contains","diff","getEndvalue","changeValue","rect1","rect2","direction","distance","reverse","neigbour","segments","seg","pointX","pointY","points","currentdirection","prevDirection","Math","abs","targetDecorator","lastSeg","connectorPropertyChange","intermediatePoint","findIntermediatePoints","h","octile","l","manhattan","sorting","array","done","tmp","t","e","r","SQRT2","dx","max","dy","isWalkable","nearGrid","grid_1","isparent","neigbourGridX","neigbourGridY","startGridX","startGridY","endGridX","endGridY","neigbourGrid","destroy","getModuleName"],"mappings":"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","sourcesContent":["import { Rect } from '../primitives/rect';\nimport { getPortDirection } from '../utility/connector';\nimport { canEnableRouting } from '../utility/constraints-util';\n/**\n * Line Routing\n */\nvar LineRouting = /** @class */ (function () {\n    /**\n     * Constructor for the line routing module\n     *\n     * @private\n     */\n    function LineRouting() {\n        this.size = 20;\n        this.intermediatePoints = [];\n        this.gridCollection = [];\n        this.startArray = [];\n        this.targetGridCollection = [];\n        this.sourceGridCollection = [];\n        this.considerWalkable = [];\n        //constructs the line routing module\n    }\n    /**\n     * lineRouting method \\\n     *\n     * @returns { void }     lineRouting method .\\\n     * @param {Diagram} diagram - provide the source value.\n     *\n     * @private\n     */\n    LineRouting.prototype.lineRouting = function (diagram) {\n        var length = diagram.connectors.length;\n        this.renderVirtualRegion(diagram);\n        if (length > 0) {\n            for (var k = 0; k < length; k++) {\n                var connector = diagram.connectors[k];\n                if (connector.type === 'Orthogonal' && connector.visible) {\n                    this.refreshConnectorSegments(diagram, connector, true);\n                }\n            }\n        }\n    };\n    /** @private */\n    /**\n     * renderVirtualRegion method \\\n     *\n     * @returns { void }     renderVirtualRegion method .\\\n     * @param {Diagram} diagram - provide the source value.\n     * @param {boolean} isUpdate - provide the target value.\n     *\n     * @private\n     */\n    LineRouting.prototype.renderVirtualRegion = function (diagram, isUpdate) {\n        /* tslint:disable */\n        var extraBounds = this.size;\n        if (diagram.spatialSearch['pageTop'] < 0 || diagram.spatialSearch['pageLeft'] < 0) {\n            extraBounds = this.size + (this.size / 2);\n        }\n        var right = diagram.spatialSearch['pageRight'] + extraBounds;\n        var bottom = diagram.spatialSearch['pageBottom'] + extraBounds;\n        var left = diagram.spatialSearch['pageLeft'] - extraBounds;\n        var top = diagram.spatialSearch['pageTop'] - extraBounds;\n        left = left < 0 ? left - 20 : 0;\n        top = top < 0 ? top - 20 : 0;\n        /* tslint:enable */\n        if ((isUpdate && (this.width !== (right - left) || this.height !== (bottom - top) ||\n            this.diagramStartX !== left || this.diagramStartY !== top)) || isUpdate === undefined) {\n            this.width = right - left;\n            this.height = bottom - top;\n            this.diagramStartX = left;\n            this.diagramStartY = top;\n            this.gridCollection = [];\n            this.noOfRows = this.width / this.size;\n            this.noOfCols = this.height / this.size;\n            var size = this.size;\n            var x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n            var y = this.diagramStartY < 0 ? this.diagramStartY : 0;\n            for (var i = 0; i < this.noOfCols; i++) {\n                for (var j = 0; j < this.noOfRows; j++) {\n                    if (i === 0) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        this.gridCollection.push([0]);\n                    }\n                    var grid = {\n                        x: x, y: y, width: size, height: size, gridX: j,\n                        gridY: i, walkable: true, tested: undefined, nodeId: []\n                    };\n                    this.gridCollection[j][i] = grid;\n                    x += size;\n                }\n                x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n                y += size;\n            }\n        }\n        var nodes = this.findNodes(diagram.nodes);\n        this.updateNodesInVirtualRegion(nodes);\n    };\n    LineRouting.prototype.findNodes = function (nodes) {\n        var objects = [];\n        var node;\n        for (var i = 0; i < nodes.length; i++) {\n            node = nodes[i];\n            if (node.shape.type !== 'SwimLane' && !node.isLane && !node.isPhase && !node.isHeader && node.visible) {\n                objects.push(node);\n            }\n        }\n        return objects;\n    };\n    LineRouting.prototype.updateNodesInVirtualRegion = function (diagramNodes) {\n        var size = this.size;\n        var x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n        var y = this.diagramStartY < 0 ? this.diagramStartY : 0;\n        for (var i = 0; i < this.noOfCols; i++) {\n            for (var j = 0; j < this.noOfRows; j++) {\n                var grid = this.gridCollection[j][i];\n                var rectangle = new Rect(x, y, this.size, this.size);\n                var isContains = void 0;\n                var k = void 0;\n                grid.walkable = true;\n                grid.tested = undefined;\n                grid.nodeId = [];\n                for (k = 0; k < diagramNodes.length; k++) {\n                    if (diagramNodes[k].wrapper.bounds) {\n                        isContains = this.intersectRect(rectangle, diagramNodes[k].wrapper.bounds);\n                    }\n                    if (isContains) {\n                        grid.nodeId.push(diagramNodes[k].id);\n                        grid.walkable = false;\n                        if (diagramNodes[k].parentId !== '') {\n                            grid.parentNodeId = diagramNodes[k].parentId;\n                        }\n                    }\n                }\n                x += size;\n            }\n            x = this.diagramStartX < 0 ? this.diagramStartX : 0;\n            y += size;\n        }\n    };\n    LineRouting.prototype.intersectRect = function (r1, r2) {\n        return !(r2.left >= r1.right || r2.right <= r1.left ||\n            r2.top >= r1.bottom || r2.bottom <= r1.top);\n    };\n    LineRouting.prototype.findEndPoint = function (connector, isSource, isPortBounds) {\n        var endPoint;\n        var portDirection;\n        if ((isSource && connector.sourcePortID !== '') || (!isSource && connector.targetPortID !== '')) {\n            endPoint = (isSource) ? { x: connector.sourcePortWrapper.offsetX, y: connector.sourcePortWrapper.offsetY } :\n                { x: connector.targetPortWrapper.offsetX, y: connector.targetPortWrapper.offsetY };\n            portDirection = getPortDirection(endPoint, undefined, (isSource) ? connector.sourceWrapper.bounds : connector.targetWrapper.bounds, false);\n            var bounds = (isSource) ? connector.sourcePortWrapper.bounds : connector.targetPortWrapper.bounds;\n            if (isPortBounds) {\n                if (portDirection === 'Top') {\n                    endPoint = { x: bounds.topCenter.x, y: bounds.topCenter.y };\n                }\n                else if (portDirection === 'Left') {\n                    endPoint = { x: bounds.middleLeft.x, y: bounds.middleLeft.y };\n                }\n                else if (portDirection === 'Right') {\n                    endPoint = { x: bounds.middleRight.x, y: bounds.middleRight.y };\n                }\n                else {\n                    endPoint = { x: bounds.bottomCenter.x, y: bounds.bottomCenter.y };\n                }\n            }\n            else {\n                endPoint = { x: bounds.center.x, y: bounds.center.y };\n            }\n        }\n        else {\n            if ((isSource && this.startNode) || (!isSource && this.targetNode)) {\n                endPoint = (isSource) ? { x: this.startNode.wrapper.offsetX, y: this.startNode.wrapper.offsetY } :\n                    { x: this.targetNode.wrapper.offsetX, y: this.targetNode.wrapper.offsetY };\n            }\n            else {\n                endPoint = (isSource) ? { x: connector.sourcePoint.x, y: connector.sourcePoint.y } :\n                    { x: connector.targetPoint.x, y: connector.targetPoint.y };\n            }\n        }\n        return endPoint;\n    };\n    /**\n     * refreshConnectorSegments method \\\n     *\n     * @returns { void }     refreshConnectorSegments method .\\\n     * @param {Diagram} diagram - provide the diagram value.\n     * @param {Connector} connector - provide the connector value.\n     * @param {boolean} isUpdate - provide the diagram value.\n     *\n     * @private\n     */\n    LineRouting.prototype.refreshConnectorSegments = function (diagram, connector, isUpdate) {\n        var sourceId = connector.sourceID;\n        var targetId = connector.targetID;\n        var sourcePortID = connector.sourcePortID;\n        var targetPortID = connector.targetPortID;\n        var startPoint;\n        var targetPoint;\n        var sourcePortDirection;\n        var targetPortDirection;\n        var grid;\n        var sourceTop;\n        var sourceBottom;\n        var isBreak;\n        var sourceLeft;\n        var sourceRight;\n        var targetRight;\n        var targetTop;\n        var targetBottom;\n        var targetLeft;\n        if (canEnableRouting(connector, diagram)) {\n            this.startNode = diagram.nameTable[sourceId];\n            this.targetNode = diagram.nameTable[targetId];\n            this.intermediatePoints = [];\n            this.startArray = [];\n            this.targetGridCollection = [];\n            this.sourceGridCollection = [];\n            this.startGrid = undefined;\n            this.targetGrid = undefined;\n            for (var i = 0; i < this.noOfCols; i++) {\n                for (var j = 0; j < this.noOfRows; j++) {\n                    this.gridCollection[j][i].tested = this.gridCollection[j][i].parent = undefined;\n                    this.gridCollection[j][i].previousDistance = this.gridCollection[j][i].afterDistance = undefined;\n                    this.gridCollection[j][i].totalDistance = undefined;\n                }\n            }\n            // Set the source point and target point\n            startPoint = this.findEndPoint(connector, true);\n            targetPoint = this.findEndPoint(connector, false);\n            // Find the start grid and target grid\n            for (var i = 0; i < this.noOfRows; i++) {\n                for (var j = 0; j < this.noOfCols; j++) {\n                    grid = this.gridCollection[i][j];\n                    var rectangle = new Rect(grid.x, grid.y, grid.width, grid.height);\n                    if (rectangle.containsPoint(startPoint) && !this.startGrid &&\n                        (grid.nodeId.indexOf(sourceId) !== -1 || sourceId === '')) {\n                        this.startGrid = (sourcePortID && this.startGrid &&\n                            (sourcePortDirection === 'Left' || sourcePortDirection === 'Top')) ? this.startGrid : grid;\n                    }\n                    if (rectangle.containsPoint(targetPoint) && !this.targetGrid &&\n                        (grid.nodeId.indexOf(targetId) !== -1 || targetId === '')) {\n                        this.targetGrid = (targetPortID && this.targetGrid &&\n                            (targetPortDirection === 'Left' || targetPortDirection === 'Top')) ? this.targetGrid : grid;\n                    }\n                    if (!sourcePortID && this.startNode) {\n                        var bounds = this.startNode.wrapper.bounds;\n                        if (rectangle.containsPoint(bounds.topCenter) && !sourceTop) {\n                            sourceTop = grid;\n                        }\n                        if (rectangle.containsPoint(bounds.middleLeft) && !sourceLeft) {\n                            sourceLeft = grid;\n                        }\n                        if (rectangle.containsPoint(bounds.middleRight) && !sourceRight) {\n                            sourceRight = grid;\n                        }\n                        if (rectangle.containsPoint(bounds.bottomCenter) && !sourceBottom) {\n                            sourceBottom = grid;\n                        }\n                    }\n                    if (!targetPortID && this.targetNode) {\n                        var bounds = this.targetNode.wrapper.bounds;\n                        if (rectangle.containsPoint(bounds.topCenter) && !targetTop) {\n                            targetTop = grid;\n                        }\n                        if (rectangle.containsPoint(bounds.middleLeft) && !targetLeft) {\n                            targetLeft = grid;\n                        }\n                        if (rectangle.containsPoint(bounds.middleRight) && !targetRight) {\n                            targetRight = grid;\n                        }\n                        if (rectangle.containsPoint({ x: bounds.bottomCenter.x, y: bounds.bottomCenter.y }) && !targetBottom) {\n                            targetBottom = grid;\n                        }\n                    }\n                }\n            }\n            this.findEdgeBoundary(sourcePortID, sourceLeft, sourceRight, sourceTop, sourceBottom, true);\n            this.findEdgeBoundary(targetPortID, targetLeft, targetRight, targetTop, targetBottom, false);\n            this.startGrid.totalDistance = 0;\n            this.startGrid.previousDistance = 0;\n            this.intermediatePoints.push({ x: this.startGrid.gridX, y: this.startGrid.gridY });\n            this.startArray.push(this.startGrid);\n            if (connector && targetLeft && targetRight && targetTop && targetBottom) {\n                this.checkObstacles(connector, diagram, targetLeft, targetRight, targetTop, targetBottom);\n            }\n            // eslint-disable-next-line no-labels\n            renderPathElement: while (this.startArray.length > 0) {\n                var startGridNode = this.startArray.pop();\n                for (var i = 0; i < this.targetGridCollection.length; i++) {\n                    var target = this.targetGridCollection[i];\n                    if (startGridNode.gridX === target.gridX && startGridNode.gridY === target.gridY) {\n                        this.getIntermediatePoints(startGridNode);\n                        isBreak = this.updateConnectorSegments(diagram, this.intermediatePoints, this.gridCollection, connector, isUpdate);\n                        if (!isBreak) {\n                            this.targetGridCollection.splice(this.targetGridCollection.indexOf(target), 1);\n                            startGridNode = this.startArray.pop();\n                        }\n                        else {\n                            this.considerWalkable = [];\n                            // eslint-disable-next-line no-labels\n                            break renderPathElement;\n                        }\n                    }\n                }\n                this.findPath(startGridNode);\n            }\n        }\n    };\n    LineRouting.prototype.checkChildNodes = function (grid, isSource) {\n        var check = false;\n        var reject = false;\n        if (grid.nodeId.length >= 1 && !isSource) {\n            for (var i = 0; i < grid.nodeId.length; i++) {\n                var id = grid.nodeId[i];\n                for (var j = 0; j < grid.nodeId.length; j++) {\n                    if (this.targetNode.parentId === grid.nodeId[j]) {\n                        reject = true;\n                    }\n                }\n                if (!reject && this.targetNode.id === id) {\n                    check = true;\n                }\n                else {\n                    check = false;\n                }\n            }\n        }\n        else {\n            if (grid.nodeId.length === 1) {\n                check = true;\n            }\n        }\n        return check;\n    };\n    LineRouting.prototype.findEdgeBoundary = function (portID, left, right, top, bottom, isSource) {\n        var grid;\n        var collection = (isSource) ? this.sourceGridCollection : this.targetGridCollection;\n        if (!portID && ((isSource) ? this.startNode : this.targetNode)) {\n            for (var i = left.gridX; i <= right.gridX; i++) {\n                grid = this.gridCollection[i][left.gridY];\n                if ((this.checkChildNodes(grid, isSource) && (i === left.gridX || i === right.gridX)) ||\n                    (i !== left.gridX && i !== right.gridX)) {\n                    collection.push(grid);\n                }\n            }\n            for (var i = top.gridY; i <= bottom.gridY; i++) {\n                grid = this.gridCollection[top.gridX][i];\n                if (((this.checkChildNodes(grid, isSource) && (i === top.gridY || i === bottom.gridY)) ||\n                    (i !== top.gridY && i !== bottom.gridY)) && collection.indexOf(grid) === -1) {\n                    collection.push(grid);\n                }\n            }\n        }\n        else {\n            collection.push((isSource) ? this.startGrid : this.targetGrid);\n        }\n    };\n    LineRouting.prototype.checkObstacles = function (connector, diagram, targetLeft, targetRight, targetTop, targetBottom) {\n        var neigbours = this.findNearestNeigbours(this.startGrid, this.gridCollection, true);\n        if (neigbours.length === 0) {\n            if (connector.sourcePortID !== '') {\n                var endPoint = { x: connector.sourcePortWrapper.offsetX, y: connector.sourcePortWrapper.offsetY };\n                var portDirection = getPortDirection(endPoint, undefined, connector.sourceWrapper.bounds, false);\n                if (portDirection === 'Top') {\n                    this.resetGridColl(this.startGrid, 'top', true);\n                }\n                else if (portDirection === 'Right') {\n                    this.resetGridColl(this.startGrid, 'right', true);\n                }\n                else if (portDirection === 'Bottom') {\n                    this.resetGridColl(this.startGrid, 'bottom', true);\n                }\n                else {\n                    this.resetGridColl(this.startGrid, 'left', true);\n                }\n            }\n            else {\n                this.resetGridColl(this.startGrid, 'top', true);\n                this.resetGridColl(this.startGrid, 'right', true);\n                this.resetGridColl(this.startGrid, 'bottom', true);\n                this.resetGridColl(this.startGrid, 'left', true);\n            }\n        }\n        neigbours = this.findNearestNeigbours(this.targetGrid, this.gridCollection, false);\n        if (neigbours.length === 0) {\n            if (connector.targetPortID !== '') {\n                var endPoint = { x: connector.targetPortWrapper.offsetX, y: connector.targetPortWrapper.offsetY };\n                var portDirection = getPortDirection(endPoint, undefined, connector.targetWrapper.bounds, false);\n                if (portDirection === 'Top') {\n                    this.resetGridColl(this.targetGrid, 'top', true);\n                }\n                else if (portDirection === 'Right') {\n                    this.resetGridColl(this.targetGrid, 'right', true);\n                }\n                else if (portDirection === 'Bottom') {\n                    this.resetGridColl(this.targetGrid, 'bottom', true);\n                }\n                else {\n                    this.resetGridColl(this.targetGrid, 'left', true);\n                }\n            }\n            else {\n                this.resetGridColl(this.targetGrid, 'top', false);\n                this.resetGridColl(this.targetGrid, 'right', false);\n                this.resetGridColl(this.targetGrid, 'bottom', false);\n                this.resetGridColl(this.targetGrid, 'left', false);\n            }\n        }\n        if (this.targetGridCollection.length > 0 && this.targetGridCollection[0].nodeId.length > 1) {\n            for (var i = 0; i <= 1; i++) {\n                var gridX = this.targetGridCollection[i].gridX;\n                var gridY = this.targetGridCollection[i].gridY;\n                var gridNodes = this.targetGridCollection[i].nodeId;\n                var targetNode = void 0;\n                for (var k = 0; k < gridNodes.length; k++) {\n                    if (this.targetNode.id != gridNodes[k]) {\n                        targetNode = gridNodes[k];\n                        break;\n                    }\n                }\n                var targetNodewrapper = void 0;\n                var overLapNode = void 0;\n                var contains = void 0;\n                if (diagram.nameTable[this.targetNode.id]) {\n                    targetNodewrapper = diagram.nameTable[this.targetNode.id].wrapper;\n                }\n                if (diagram.nameTable[targetNode]) {\n                    overLapNode = diagram.nameTable[targetNode].wrapper;\n                }\n                if (targetNodewrapper && overLapNode) {\n                    contains = this.contains(overLapNode.bounds, targetNodewrapper.bounds);\n                }\n                var reject = void 0;\n                for (var j = 0; j < gridNodes.length; j++) {\n                    if (this.targetNode.parentId === gridNodes[j]) {\n                        reject = true;\n                    }\n                }\n                if (!this.gridCollection[gridX][gridY].walkable && contains && !reject) {\n                    var grid = void 0;\n                    var diff = void 0;\n                    grid = this.getEndvalue(targetLeft, \"left\");\n                    diff = targetLeft.gridX - grid.gridX;\n                    this.changeValue(targetLeft, diff, \"left\");\n                    grid = this.getEndvalue(targetRight, \"right\");\n                    diff = grid.gridX - targetRight.gridX;\n                    this.changeValue(targetRight, diff, \"right\");\n                    grid = this.getEndvalue(targetTop, \"top\");\n                    diff = targetTop.gridY - grid.gridY;\n                    this.changeValue(targetTop, diff, \"top\");\n                    grid = this.getEndvalue(targetBottom, \"bottom\");\n                    diff = targetBottom.gridY - grid.gridY;\n                    this.changeValue(targetBottom, diff, \"top\");\n                }\n            }\n        }\n    };\n    LineRouting.prototype.contains = function (rect1, rect2) {\n        return rect1.left <= rect2.left && rect1.right >= rect2.right && rect1.top <= rect2.top && rect1.bottom >= rect2.bottom;\n    };\n    LineRouting.prototype.getEndvalue = function (target, direction) {\n        if (!this.gridCollection[target.gridX][target.gridY].walkable) {\n            if (direction === 'left') {\n                return this.getEndvalue(this.gridCollection[target.gridX - 1][target.gridY], direction);\n            }\n            if (direction === 'right') {\n                return this.getEndvalue(this.gridCollection[target.gridX + 1][target.gridY], direction);\n            }\n            if (direction === 'top') {\n                return this.getEndvalue(this.gridCollection[target.gridX][target.gridY - 1], direction);\n            }\n            if (direction === 'bottom') {\n                return this.getEndvalue(this.gridCollection[target.gridX][target.gridY + 1], direction);\n            }\n        }\n        else {\n            return target;\n        }\n        return target;\n    };\n    LineRouting.prototype.changeValue = function (targetLeft, diff, direction) {\n        if (!targetLeft.walkable) {\n            this.considerWalkable.push(targetLeft);\n        }\n        var grid;\n        for (var i = 0; i <= diff; i++) {\n            if (direction === 'left') {\n                grid = this.gridCollection[targetLeft.gridX - i][targetLeft.gridY];\n            }\n            else if (direction === 'right') {\n                grid = this.gridCollection[targetLeft.gridX + i][targetLeft.gridY];\n            }\n            else if (direction === 'top') {\n                grid = this.gridCollection[targetLeft.gridX][targetLeft.gridY - i];\n            }\n            else if (direction === 'bottom') {\n                grid = this.gridCollection[targetLeft.gridX][targetLeft.gridY + i];\n            }\n            if (!grid.walkable) {\n                this.considerWalkable.push(grid);\n            }\n        }\n    };\n    // Get all the intermediated points from target grid\n    LineRouting.prototype.getIntermediatePoints = function (target) {\n        var distance;\n        this.intermediatePoints = [];\n        while (target) {\n            this.intermediatePoints.push({ x: target.gridX, y: target.gridY });\n            target = target.parent;\n        }\n        this.intermediatePoints.reverse();\n        if (this.intermediatePoints.length >= 1) {\n            if (this.intermediatePoints[0].x === this.intermediatePoints[1].x) {\n                if (this.intermediatePoints[0].y < this.intermediatePoints[1].y) {\n                    distance = this.neigbour(this.startGrid, 'bottom', undefined, true);\n                    this.intermediatePoints[0].y += distance - 1;\n                }\n                else {\n                    distance = this.neigbour(this.startGrid, 'top', undefined, true);\n                    this.intermediatePoints[0].y -= distance - 1;\n                }\n            }\n            else {\n                if (this.intermediatePoints[0].x < this.intermediatePoints[1].x) {\n                    distance = this.neigbour(this.startGrid, 'right', undefined, true);\n                    this.intermediatePoints[0].x += distance - 1;\n                }\n                else {\n                    distance = this.neigbour(this.startGrid, 'left', undefined, true);\n                    this.intermediatePoints[0].x -= distance - 1;\n                }\n            }\n        }\n    };\n    // Connector rendering\n    /* tslint:disable */\n    LineRouting.prototype.updateConnectorSegments = function (diagram, intermediatePoints, gridCollection, connector, isUpdate) {\n        var segments = [];\n        var seg;\n        var targetPoint;\n        var pointX;\n        var pointY;\n        var node;\n        var points = [];\n        var direction;\n        var length;\n        var currentdirection;\n        var prevDirection;\n        var targetWrapper = connector.targetWrapper;\n        var sourceWrapper = connector.sourceWrapper;\n        var sourcePoint = this.findEndPoint(connector, true);\n        if (connector.targetPortID !== '' || !connector.targetWrapper) {\n            targetPoint = this.findEndPoint(connector, false, true);\n        }\n        for (var i = 0; i < intermediatePoints.length; i++) {\n            node = gridCollection[intermediatePoints[i].x][intermediatePoints[i].y];\n            pointX = node.x + node.width / 2;\n            pointY = node.y + node.height / 2;\n            points.push({ x: pointX, y: pointY });\n            if (i >= 1) {\n                if (points[points.length - 2].x !== points[points.length - 1].x) {\n                    currentdirection = (points[points.length - 2].x > points[points.length - 1].x) ? 'Left' : 'Right';\n                }\n                else {\n                    currentdirection = (points[points.length - 2].y > points[points.length - 1].y) ? 'Top' : 'Bottom';\n                }\n            }\n            if (i >= 2 && prevDirection === currentdirection) {\n                points.splice(points.length - 2, 1);\n            }\n            prevDirection = currentdirection;\n        }\n        for (var j = 0; j < points.length - 1; j++) {\n            if (points[j].x !== points[j + 1].x) {\n                if (j === 0 && connector.sourcePortID === '' && sourceWrapper) {\n                    sourcePoint = (points[j].x > points[j + 1].x) ? sourceWrapper.bounds.middleLeft : sourceWrapper.bounds.middleRight;\n                }\n                if (j === points.length - 2 && connector.targetPortID === '' && targetWrapper) {\n                    targetPoint = (points[j].x > points[j + 1].x) ? targetWrapper.bounds.middleRight : targetWrapper.bounds.middleLeft;\n                }\n                if (j === 0 && sourcePoint) {\n                    points[j].x = sourcePoint.x;\n                    points[j].y = points[j + 1].y = sourcePoint.y;\n                }\n                if (j === points.length - 2 && targetPoint) {\n                    if (((targetPoint.x - points[j + 1].x) < 0) &&\n                        (Math.abs(targetPoint.x - points[j].x) < connector.targetDecorator.width + 1)) {\n                        points[j].x = points[j - 1].x -= this.size / 2;\n                    }\n                    if (((targetPoint.x - points[j + 1].x) > 0) &&\n                        (Math.abs(targetPoint.x - points[j].x) < connector.targetDecorator.width + 1)) {\n                        points[j].x = points[j - 1].x += this.size / 2;\n                    }\n                    points[j + 1].x = targetPoint.x;\n                    points[j].y = points[j + 1].y = targetPoint.y;\n                }\n            }\n            else {\n                if (j === 0 && sourceWrapper) {\n                    sourcePoint = (points[j].y > points[j + 1].y) ? sourceWrapper.bounds.topCenter : sourceWrapper.bounds.bottomCenter;\n                }\n                if (j === points.length - 2 && connector.targetPortID === '' && targetWrapper) {\n                    targetPoint = (points[j].y > points[j + 1].y) ? targetWrapper.bounds.bottomCenter : targetWrapper.bounds.topCenter;\n                }\n                if (j === 0 && sourcePoint) {\n                    points[j].y = sourcePoint.y;\n                    points[j].x = points[j + 1].x = sourcePoint.x;\n                }\n                if (j === points.length - 2 && targetPoint) {\n                    if (((targetPoint.y - points[j + 1].y) < 0) &&\n                        (Math.abs(targetPoint.y - points[j].y) < connector.targetDecorator.height + 1)) {\n                        points[j].y = points[j - 1].y -= this.size / 2;\n                    }\n                    if (((targetPoint.y - points[j + 1].y) > 0) &&\n                        (Math.abs(targetPoint.y - points[j].y) < connector.targetDecorator.width + 1)) {\n                        points[j].y = points[j - 1].y += this.size / 2;\n                    }\n                    points[j + 1].y = targetPoint.y;\n                    points[j].x = points[j + 1].x = targetPoint.x;\n                }\n            }\n        }\n        for (var j = 0; j < points.length - 1; j++) {\n            if (points[j].x !== points[j + 1].x) {\n                if (points[j].x > points[j + 1].x) {\n                    direction = 'Left';\n                    length = points[j].x - points[j + 1].x;\n                }\n                else {\n                    direction = 'Right';\n                    length = points[j + 1].x - points[j].x;\n                }\n            }\n            else {\n                if (points[j].y > points[j + 1].y) {\n                    direction = 'Top';\n                    length = points[j].y - points[j + 1].y;\n                }\n                else {\n                    direction = 'Bottom';\n                    length = points[j + 1].y - points[j].y;\n                }\n            }\n            seg = { type: 'Orthogonal', length: length, direction: direction };\n            segments.push(seg);\n        }\n        var lastSeg = segments[segments.length - 1];\n        if (segments.length === 1) {\n            lastSeg.length -= 20;\n        }\n        if (lastSeg.length < 10 && segments.length === 2) {\n            segments.pop();\n            segments[0].length -= 20;\n            lastSeg = segments[0];\n        }\n        if (((lastSeg.direction === 'Top' || lastSeg.direction === 'Bottom') && lastSeg.length > connector.targetDecorator.height + 1) ||\n            ((lastSeg.direction === 'Right' || lastSeg.direction === 'Left') && lastSeg.length > connector.targetDecorator.width + 1)) {\n            connector.segments = segments;\n            if (isUpdate) {\n                diagram.connectorPropertyChange(connector, {}, { type: 'Orthogonal', segments: segments });\n            }\n            return true;\n        }\n        return false;\n    };\n    /* tslint:enable */\n    // Shortest path\n    LineRouting.prototype.findPath = function (startGrid) {\n        var intermediatePoint;\n        var collection = [];\n        var neigbours = this.findNearestNeigbours(startGrid, this.gridCollection, true);\n        for (var i = 0; i < neigbours.length; i++) {\n            intermediatePoint = this.findIntermediatePoints(neigbours[i].gridX, neigbours[i].gridY, startGrid.gridX, startGrid.gridY, this.targetGrid.gridX, this.targetGrid.gridY);\n            if (intermediatePoint !== null) {\n                var grid = this.gridCollection[intermediatePoint.x][intermediatePoint.y];\n                var h = this.octile(Math.abs(intermediatePoint.x - startGrid.gridX), Math.abs(intermediatePoint.y - startGrid.gridY));\n                var l = startGrid.previousDistance + h;\n                if ((!grid.previousDistance || grid.previousDistance > l) &&\n                    (!(intermediatePoint.x === startGrid.gridX && intermediatePoint.y === startGrid.gridY))) {\n                    collection.push(intermediatePoint);\n                    grid.previousDistance = l;\n                    grid.afterDistance = grid.afterDistance || this.manhattan(Math.abs(intermediatePoint.x - this.targetGrid.gridX), Math.abs(intermediatePoint.y - this.targetGrid.gridY));\n                    grid.totalDistance = grid.previousDistance + grid.afterDistance;\n                    grid.parent = startGrid;\n                }\n            }\n        }\n        if (collection.length > 0) {\n            for (var i = 0; i < collection.length; i++) {\n                var grid = this.gridCollection[collection[i].x][collection[i].y];\n                if (this.startArray.indexOf(grid) === -1) {\n                    this.startArray.push(grid);\n                }\n            }\n        }\n        this.sorting(this.startArray);\n    };\n    // sorting the array based on total distance between source and target node\n    LineRouting.prototype.sorting = function (array) {\n        var done = false;\n        while (!done) {\n            done = true;\n            for (var i = 1; i < array.length; i += 1) {\n                if (array[i - 1].totalDistance < array[i].totalDistance) {\n                    done = false;\n                    var tmp = array[i - 1];\n                    array[i - 1] = array[i];\n                    array[i] = tmp;\n                }\n            }\n        }\n        return array;\n    };\n    LineRouting.prototype.octile = function (t, e) {\n        var r = Math.SQRT2 - 1;\n        return e > t ? r * t + e : r * e + t;\n    };\n    LineRouting.prototype.manhattan = function (t, e) {\n        return t + e;\n    };\n    // Find the nearest neigbour from the current boundaries, the neigbour is use to find next intermdiate point.\n    LineRouting.prototype.findNearestNeigbours = function (startGrid, gridCollection, isSource) {\n        var neigbours = [];\n        var parent = startGrid.parent;\n        if (parent) {\n            var dx = (startGrid.gridX - parent.gridX) / Math.max(Math.abs(startGrid.gridX - parent.gridX), 1);\n            var dy = (startGrid.gridY - parent.gridY) / Math.max(Math.abs(startGrid.gridY - parent.gridY), 1);\n            if (dx !== 0) {\n                if (this.isWalkable(startGrid.gridX, startGrid.gridY - 1, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY - 1]) === -1) {\n                    neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY - 1]);\n                }\n                if (this.isWalkable(startGrid.gridX, startGrid.gridY + 1, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY + 1])) {\n                    neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY + 1]);\n                }\n                if (this.isWalkable(startGrid.gridX + dx, startGrid.gridY, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX + dx][startGrid.gridY]) === -1) {\n                    neigbours.push(gridCollection[startGrid.gridX + dx][startGrid.gridY]);\n                }\n            }\n            else if (dy !== 0) {\n                if (this.isWalkable(startGrid.gridX - 1, startGrid.gridY, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX - 1][startGrid.gridY]) === -1) {\n                    neigbours.push(gridCollection[startGrid.gridX - 1][startGrid.gridY]);\n                }\n                if (this.isWalkable(startGrid.gridX + 1, startGrid.gridY, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX + 1][startGrid.gridY]) === -1) {\n                    neigbours.push(gridCollection[startGrid.gridX + 1][startGrid.gridY]);\n                }\n                if (this.isWalkable(startGrid.gridX, startGrid.gridY + dy, true) &&\n                    this.sourceGridCollection.indexOf(gridCollection[startGrid.gridX][startGrid.gridY + dy]) === -1) {\n                    neigbours.push(gridCollection[startGrid.gridX][startGrid.gridY + dy]);\n                }\n            }\n        }\n        else {\n            this.neigbour(startGrid, 'top', neigbours, isSource);\n            this.neigbour(startGrid, 'right', neigbours, isSource);\n            this.neigbour(startGrid, 'bottom', neigbours, isSource);\n            this.neigbour(startGrid, 'left', neigbours, isSource);\n        }\n        return neigbours;\n    };\n    LineRouting.prototype.neigbour = function (startGrid, direction, neigbours, isSource) {\n        var i = 1;\n        var nearGrid;\n        while (i > 0) {\n            var x = (direction === 'top' || direction === 'bottom') ?\n                (startGrid.gridX) : ((direction === 'left') ? startGrid.gridX - i : startGrid.gridX + i);\n            var y = (direction === 'right' || direction === 'left') ?\n                (startGrid.gridY) : ((direction === 'top') ? startGrid.gridY - i : startGrid.gridY + i);\n            nearGrid = this.gridCollection[x][y];\n            if (nearGrid && ((isSource && this.sourceGridCollection.indexOf(nearGrid) === -1)\n                || (!isSource && this.targetGridCollection.indexOf(nearGrid) === -1))) {\n                if (neigbours && this.isWalkable(x, y)) {\n                    neigbours.push(nearGrid);\n                }\n                return i;\n            }\n            if (x > 0 && y > 0) {\n                i++;\n            }\n            else {\n                break;\n            }\n        }\n        return null;\n    };\n    LineRouting.prototype.resetGridColl = function (grid, direction, isSource) {\n        var i = 1;\n        var nearGrid;\n        while (i > 0) {\n            var x = (direction === 'top' || direction === 'bottom') ?\n                (grid.gridX) : ((direction === 'left') ? grid.gridX - i : grid.gridX + i);\n            var y = (direction === 'right' || direction === 'left') ?\n                (grid.gridY) : ((direction === 'top') ? grid.gridY - i : grid.gridY + i);\n            nearGrid = this.gridCollection[x][y];\n            if (nearGrid && ((isSource && this.sourceGridCollection.indexOf(nearGrid) === -1) ||\n                (!isSource && this.targetGridCollection.indexOf(nearGrid) === -1))) {\n                if (this.isWalkable(x, y)) {\n                    break;\n                }\n                else {\n                    var grid_1 = this.gridCollection[x][y];\n                    this.considerWalkable.push(grid_1);\n                }\n            }\n            if (x > 0 && y > 0) {\n                if (direction === 'top' || direction === 'left') {\n                    i--;\n                }\n                else {\n                    i++;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        return null;\n    };\n    LineRouting.prototype.isWalkable = function (x, y, isparent) {\n        if (x >= 0 && x < this.noOfRows && y >= 0 && y < this.noOfCols) {\n            var grid = this.gridCollection[x][y];\n            if (grid && (grid.walkable || ((grid.nodeId.length === 1 || (grid.nodeId.length === 2 && grid.parentNodeId || (this.considerWalkable.indexOf(grid) !== -1))) &&\n                (this.sourceGridCollection.indexOf(grid) !== -1 || this.targetGridCollection.indexOf(grid) !== -1 ||\n                    this.considerWalkable.indexOf(grid) !== -1)))) {\n                if ((isparent && !grid.parent) || !isparent) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    LineRouting.prototype.findIntermediatePoints = function (neigbourGridX, neigbourGridY, startGridX, startGridY, endGridX, endGridY) {\n        var dx = neigbourGridX - startGridX;\n        var dy = neigbourGridY - startGridY;\n        var gridX = neigbourGridX;\n        var gridY = neigbourGridY;\n        for (var i = 0; i < this.targetGridCollection.length; i++) {\n            if (neigbourGridX === this.targetGridCollection[i].gridX && neigbourGridY === this.targetGridCollection[i].gridY) {\n                return { x: neigbourGridX, y: neigbourGridY };\n            }\n        }\n        if (!this.isWalkable(neigbourGridX, neigbourGridY)) {\n            return null;\n        }\n        var neigbourGrid = this.gridCollection[neigbourGridX][neigbourGridY];\n        if (neigbourGrid.tested) {\n            return { x: neigbourGridX, y: neigbourGridY };\n        }\n        neigbourGrid.tested = true;\n        if (dx !== 0) {\n            dx = (dx > 0) ? 1 : -1;\n            if ((this.isWalkable(gridX, gridY - 1) && !this.isWalkable(gridX - dx, gridY - 1)) ||\n                (this.isWalkable(gridX, gridY + 1) && !this.isWalkable(gridX - dx, gridY + 1))) {\n                return { x: neigbourGridX, y: neigbourGridY };\n            }\n        }\n        if (dy !== 0) {\n            dy = (dy > 0) ? 1 : -1;\n            if ((this.isWalkable(gridX - 1, gridY) && !this.isWalkable(gridX - 1, gridY - dy)) ||\n                (this.isWalkable(gridX + 1, gridY) && !this.isWalkable(gridX + 1, gridY - dy))) {\n                return { x: neigbourGridX, y: neigbourGridY };\n            }\n            if (this.findIntermediatePoints(gridX + 1, gridY, gridX, gridY, endGridX, endGridY) ||\n                this.findIntermediatePoints(gridX - 1, gridY, gridX, gridY, endGridX, endGridY)) {\n                return { x: neigbourGridX, y: neigbourGridY };\n            }\n        }\n        return this.findIntermediatePoints(gridX + dx, gridY + dy, gridX, gridY, endGridX, endGridY);\n    };\n    /**\n     *To destroy the line routing\n     *\n     * @returns {void} To destroy the line routing\n     */\n    LineRouting.prototype.destroy = function () {\n        /**\n         * Destroys the line routing module\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    LineRouting.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'LineRouting';\n    };\n    return LineRouting;\n}());\nexport { LineRouting };\n"]},"metadata":{},"sourceType":"module"}