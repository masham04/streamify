{"ast":null,"code":"/* eslint-disable jsdoc/require-returns */\n\n/* eslint-disable valid-jsdoc */\nimport { Point } from '../primitives/point';\nimport { Rect } from '../primitives/rect';\nimport { intersect2 } from '../utility/diagram-util';\nimport { canBridge } from '../utility/constraints-util';\n/**\n * ConnectorBridging defines the bridging behavior\n */\n\n/** @private */\n\nvar ConnectorBridging =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the bridging module\n   *\n   * @private\n   */\n  function ConnectorBridging() {//constructs the bridging module\n  }\n  /**\n   * @param {Connector}conn - provide the target  value.\n   * @param {Diagram}diagram - provide the target  value.\n   * @private\n   */\n\n\n  ConnectorBridging.prototype.updateBridging = function (conn, diagram) {\n    var lastBridge = [];\n    var bounds;\n    conn.bridges = [];\n\n    if (canBridge(conn, diagram)) {\n      // if (this.canBridge(conn, diagram)) {\n      var points1 = this.getPoints(conn);\n      bounds = Rect.toBounds(points1);\n      var bridgeSpacing = conn.bridgeSpace;\n      var bgedir = diagram.bridgeDirection;\n      var count = -1;\n      var quads = diagram.connectors;\n\n      for (var q = 0; q < quads.length; q++) {\n        var connector1 = quads[q];\n\n        if (conn && connector1 && conn.id !== connector1.id) {\n          var points2 = this.getPoints(connector1);\n          var bounds1 = Rect.toBounds(points2);\n\n          if (this.intersectsRect(bounds, bounds1)) {\n            var intersectPts = this.intersect(points1, points2, false, bgedir, true);\n\n            if (intersectPts.length > 0) {\n              for (var i = 0; i < intersectPts.length; i++) {\n                var fullLength = 0;\n                var length_1 = 0;\n                var segmentIndex = 0;\n                var pointIndex = 0;\n                var obj = this.getLengthAtFractionPoint(conn, intersectPts[i]);\n\n                if (obj.pointIndex !== -1) {\n                  length_1 = obj.lengthFractionIndex;\n                  fullLength = obj.fullLength;\n                  segmentIndex = obj.segmentIndex;\n                  pointIndex = obj.pointIndex;\n                  var stBridge = this.getPointAtLength(length_1 - bridgeSpacing / 2, points1);\n                  var enBridge = this.getPointAtLength(length_1 + bridgeSpacing / 2, points1);\n                  var fractLength = (length_1 - bridgeSpacing / 2) / fullLength; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n                  fractLength = (length_1 + bridgeSpacing / 2) / fullLength;\n\n                  if (this.isEmptyPoint(enBridge)) {\n                    enBridge = stBridge;\n                  }\n\n                  var end = void 0;\n                  var start = conn.sourcePoint;\n\n                  if (conn.type === 'Straight') {\n                    end = conn.targetPoint;\n                  } else {\n                    end = conn.intermediatePoints[pointIndex];\n                  }\n\n                  var angle = this.angleCalculation(start, end);\n\n                  if (lastBridge.length) {\n                    var fixedPoint = conn.sourcePoint;\n                    var fix = Math.abs(this.lengthCalculation(fixedPoint, enBridge));\n                    var var1 = 0;\n                    var insertAt = -1;\n                    count = -1;\n\n                    for (var k = 0; k < lastBridge[segmentIndex].bridges.length; k++) {\n                      count++;\n                      var arcSeg = lastBridge[segmentIndex].bridges[k];\n                      var1 = Math.abs(this.lengthCalculation(fixedPoint, arcSeg.endPoint));\n\n                      if (fix < var1) {\n                        insertAt = count;\n                        break;\n                      }\n                    }\n\n                    if (insertAt >= 0) {\n                      //let paths: ArcSegment;\n                      // eslint-disable-next-line max-len\n                      var paths = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);\n                      paths.target = connector1.id;\n                      lastBridge[segmentIndex].bridges.splice(insertAt, 0, paths);\n                      lastBridge[segmentIndex].bridges.join();\n                      lastBridge[segmentIndex].bridgeStartPoint.splice(insertAt, 0, stBridge);\n                      lastBridge[segmentIndex].bridgeStartPoint.join();\n                      lastBridge[segmentIndex].segmentIndex = segmentIndex;\n                    } else {\n                      //let paths: ArcSegment;\n                      // eslint-disable-next-line max-len\n                      var paths = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);\n                      paths.target = connector1.id;\n                      lastBridge[segmentIndex].bridges.push(paths);\n                      lastBridge[segmentIndex].bridgeStartPoint.push(stBridge);\n                      lastBridge[segmentIndex].segmentIndex = segmentIndex;\n                    }\n                  } else {\n                    if (!isNaN(stBridge.x) && !isNaN(stBridge.y) && !this.isEmptyPoint(enBridge)) {\n                      //let arcs: ArcSegment;\n                      var bges = [];\n                      var bgept = []; // eslint-disable-next-line max-len\n\n                      var arcs = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);\n                      var bgseg = {\n                        bridges: bges,\n                        bridgeStartPoint: bgept,\n                        segmentIndex: segmentIndex\n                      };\n                      arcs.target = connector1.id;\n                      var stPoints = [];\n                      var edPoints = [];\n                      stPoints.push(stBridge);\n                      edPoints.push(enBridge);\n                      lastBridge[segmentIndex] = bgseg;\n                      lastBridge[segmentIndex].bridges.push(arcs);\n                      lastBridge[segmentIndex].bridgeStartPoint = stPoints;\n                      lastBridge[segmentIndex].segmentIndex = segmentIndex;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (lastBridge.length !== 0) {\n        this.firstBridge(lastBridge, conn, bridgeSpacing);\n      }\n    }\n  };\n  /**\n   * @param {BridgeSegment[]}bridgeList - provide the bridgeList  value.\n   * @param {Connector}connector - provide the connector  value.\n   * @param {number}bridgeSpacing - provide the bridgeSpacing  value.\n   * @private\n   */\n\n\n  ConnectorBridging.prototype.firstBridge = function (bridgeList, connector, bridgeSpacing) {\n    for (var i = 0; i < bridgeList.length; i++) {\n      var bridge = bridgeList[i];\n\n      for (var k = 1; k < bridge.bridges.length; k++) {\n        if (Point.findLength(bridge.bridges[k].endPoint, bridge.bridges[k - 1].endPoint) < bridgeSpacing) {\n          bridge.bridges[k - 1].endPoint = bridge.bridges[k].endPoint;\n          var subBridge = bridge.bridges[k - 1];\n          var arc = this.createBridgeSegment(subBridge.startPoint, subBridge.endPoint, subBridge.angle, bridgeSpacing, subBridge.sweep);\n          bridge.bridges[k - 1].path = arc;\n          bridge.bridges.splice(k, 1);\n          bridge.bridgeStartPoint.splice(k, 1);\n          k--;\n        }\n      }\n\n      var pre = connector.sourcePoint;\n\n      for (var j = 0; j < bridge.bridges.length; j++) {\n        var subBridge = bridge.bridges[j]; //const preventChecking: boolean = true;\n\n        pre = subBridge.endPoint;\n        connector.bridges.push(subBridge);\n      }\n    }\n  };\n  /**\n   * @returns { ArcSegment } checkSourcePointInTarget method .\\\n   * @param {PointModel}st- provide the st  value.\n   * @param {PointModel}end- provide the end  value.\n   * @param {number}angle- provide the angle  value.\n   * @param {BridgeDirection}direction- provide the direction  value.\n   * @param {number}index- provide the index  value.\n   * @param {Connector}conn- provide the conn  value.\n   * @param {Diagram} diagram- provide the diagram  value.\n   * @private\n   */\n\n\n  ConnectorBridging.prototype.createSegment = function (st, end, angle, direction, index, conn, diagram) {\n    //let arc: string;\n    //let sweep: number;\n    var path = {\n      angle: 0,\n      endPoint: {\n        x: 0,\n        y: 0\n      },\n      target: '',\n      path: '',\n      segmentPointIndex: -1,\n      startPoint: {\n        x: 0,\n        y: 0\n      },\n      sweep: 1,\n      rendered: false\n    };\n    var sweep = this.sweepDirection(angle, direction, conn, diagram);\n    var arc = this.createBridgeSegment(st, end, angle, conn.bridgeSpace, sweep);\n    path.path = arc;\n    path.startPoint = st;\n    path.endPoint = end;\n    path.angle = angle;\n    path.segmentPointIndex = index;\n    path.sweep = sweep;\n    return path;\n  };\n  /**\n   * @param {PointModel}startPt- provide the startPt  value.\n   * @param {PointModel}endPt- provide the endPt  value.\n   * @param {number}angle- provide the angle  value.\n   * @param {number}bridgeSpace- provide the bridgeSpace  value.\n   * @param {number}sweep- provide the sweep  value.\n   * @private\n   */\n\n\n  ConnectorBridging.prototype.createBridgeSegment = function (startPt, endPt, angle, bridgeSpace, sweep) {\n    var path = 'A ' + bridgeSpace / 2 + ' ' + bridgeSpace / 2 + ' ' + angle + ' , 1 ' + sweep + ' ' + endPt.x + ',' + endPt.y;\n    return path;\n  };\n  /**\n   * @param {number}angle- provide the source value.\n   * @param {BridgeDirection}bridgeDirection- provide the source value.\n   * @param {Connector}connector- provide the source value.\n   * @param {Diagram}diagram- provide the source value.\n   * @private\n   */\n\n\n  ConnectorBridging.prototype.sweepDirection = function (angle, bridgeDirection, connector, diagram) {\n    var angle1 = Math.abs(angle);\n    var sweep;\n\n    switch (bridgeDirection) {\n      case 'Top':\n      case 'Bottom':\n        sweep = 1;\n\n        if (angle1 >= 0 && angle1 <= 90) {\n          sweep = 0;\n        }\n\n        break;\n\n      case 'Left':\n      case 'Right':\n        sweep = 1;\n\n        if (angle < 0 && angle >= -180) {\n          sweep = 0;\n        }\n\n        break;\n    }\n\n    if (bridgeDirection === 'Right' || bridgeDirection === 'Bottom') {\n      if (sweep === 0) {\n        sweep = 1;\n      } else {\n        sweep = 0;\n      }\n    }\n\n    return sweep;\n  };\n  /** @private */\n\n\n  ConnectorBridging.prototype.getPointAtLength = function (length, pts) {\n    var run = 0;\n    var pre;\n    var found = {\n      x: 0,\n      y: 0\n    };\n\n    for (var i = 0; i < pts.length; i++) {\n      var pt = pts[i];\n\n      if (!pre) {\n        pre = pt;\n        continue;\n      } else {\n        var l = this.lengthCalculation(pre, pt);\n\n        if (run + l > length) {\n          var r = length - run;\n          var deg = Point.findAngle(pre, pt);\n          var x = r * Math.cos(deg * Math.PI / 180);\n          var y = r * Math.sin(deg * Math.PI / 180);\n          found = {\n            x: pre.x + x,\n            y: pre.y + y\n          };\n          break;\n        } else {\n          run += l;\n        }\n      }\n\n      pre = pt;\n    }\n\n    return found;\n  };\n  /**\n   * @param {PointModel[]}connector- provide the source value.\n   * @private\n   */\n\n\n  ConnectorBridging.prototype.getPoints = function (connector) {\n    var points = [];\n\n    if (connector.intermediatePoints && (connector.type === 'Straight' || connector.type === 'Orthogonal')) {\n      for (var j = 0; j < connector.intermediatePoints.length; j++) {\n        points.push(connector.intermediatePoints[j]);\n      }\n    }\n\n    return points;\n  };\n\n  ConnectorBridging.prototype.intersectsRect = function (rect1, rect2) {\n    return rect2.x < rect1.x + rect1.width && rect1.x < rect2.x + rect2.width && rect2.y < rect1.y + rect1.height && rect1.y < rect2.y + rect2.height;\n  };\n  /**\n   * @param {PointModel[]}points1- provide the source value.\n   * @param {PointModel[]}points2- provide the source value.\n   * @param {boolean}self- provide the source value.\n   * @param {BridgeDirection}bridgeDirection- provide the source value.\n   * @param {PointModel[]}zOrder- provide the source value.\n   * @private\n   */\n\n\n  ConnectorBridging.prototype.intersect = function (points1, points2, self, bridgeDirection, zOrder) {\n    if (self && points2.length >= 2) {\n      points2.splice(0, 1);\n      points2.splice(0, 1);\n    }\n\n    var points = [];\n\n    for (var i = 0; i < points1.length - 1; i++) {\n      var pt = this.inter1(points1[i], points1[i + 1], points2, zOrder, bridgeDirection);\n\n      if (pt.length > 0) {\n        for (var k = 0; k < pt.length; k++) {\n          points.push(pt[k]);\n        }\n      }\n\n      if (self && points2.length >= 1) {\n        points2.splice(0, 1);\n      }\n    }\n\n    return points;\n  };\n  /**\n   * @param {PointModel}startPt- provide the target  value.\n   * @param {PointModel}endPt- provide the target  value.\n   * @param {PointModel[]}pts- provide the target  value.\n   * @param {boolean}zOrder- provide the target  value.\n   * @param {BridgeDirection}bridgeDirection- provide the target  value.\n   * @private\n   */\n\n\n  ConnectorBridging.prototype.inter1 = function (startPt, endPt, pts, zOrder, bridgeDirection) {\n    var points1 = [];\n\n    for (var i = 0; i < pts.length - 1; i++) {\n      var point = intersect2(startPt, endPt, pts[i], pts[i + 1]);\n\n      if (!this.isEmptyPoint(point)) {\n        var angle = this.angleCalculation(startPt, endPt);\n        var angle1 = this.angleCalculation(pts[i], pts[i + 1]);\n        angle = this.checkForHorizontalLine(angle);\n        angle1 = this.checkForHorizontalLine(angle1);\n\n        switch (bridgeDirection) {\n          case 'Left':\n          case 'Right':\n            if (angle > angle1) {\n              points1.push(point);\n            }\n\n            break;\n\n          case 'Top':\n          case 'Bottom':\n            if (angle < angle1) {\n              points1.push(point);\n            }\n\n            break;\n        }\n\n        if (angle === angle1 && zOrder) {\n          points1.push(point);\n        }\n      }\n    }\n\n    return points1;\n  };\n\n  ConnectorBridging.prototype.checkForHorizontalLine = function (angle) {\n    var temp = 0;\n    var roundedAngle = Math.abs(angle);\n\n    if (roundedAngle > 90) {\n      temp = 180 - roundedAngle;\n    } else {\n      temp = roundedAngle;\n    }\n\n    return temp;\n  };\n\n  ConnectorBridging.prototype.isEmptyPoint = function (point) {\n    return point.x === 0 && point.y === 0;\n  };\n\n  ConnectorBridging.prototype.getLengthAtFractionPoint = function (connector, pointAt) {\n    var confirm = 100;\n    var pointIndex = -1;\n    var fullLength = 0;\n    var segmentIndex = -1;\n    var count = 0;\n    var lengthAtFractionPt = 0;\n    var pt1 = connector.sourcePoint;\n    var previouspt2 = pt1;\n    var points = [];\n\n    for (var i = 0; i < connector.intermediatePoints.length; i++) {\n      var point2 = connector.intermediatePoints[i];\n      points.push(point2);\n    }\n\n    for (var j = 0; j < points.length; j++) {\n      var pt2 = points[j];\n      var suspect = this.getSlope(pt2, pt1, pointAt, connector);\n\n      if (suspect < confirm) {\n        confirm = suspect;\n        lengthAtFractionPt = fullLength + this.lengthCalculation(pointAt, previouspt2);\n        segmentIndex = count;\n        pointIndex = j;\n      }\n\n      fullLength += Point.findLength(pt2, pt1);\n      pt1 = pt2;\n      previouspt2 = pt2;\n    }\n\n    count++;\n    var lengthFraction = {\n      lengthFractionIndex: lengthAtFractionPt,\n      fullLength: fullLength,\n      segmentIndex: segmentIndex,\n      pointIndex: pointIndex\n    };\n    return lengthFraction;\n  }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  ConnectorBridging.prototype.getSlope = function (startPt, endPt, point, connector) {\n    var three = 3.0;\n    var delX = Math.abs(startPt.x - endPt.x);\n    var delY = Math.abs(startPt.y - endPt.y);\n    var lhs = (point.y - startPt.y) / (endPt.y - startPt.y);\n    var rhs = (point.x - startPt.x) / (endPt.x - startPt.x);\n\n    if (!isFinite(lhs) || !isFinite(rhs) || isNaN(lhs) || isNaN(rhs)) {\n      if (startPt.x === endPt.x) {\n        if (startPt.y === endPt.y) {\n          return 10000;\n        } else if (startPt.y > point.y && point.y > endPt.y || startPt.y < point.y && point.y < endPt.y) {\n          return Math.abs(startPt.x - point.x);\n        }\n      } else if (startPt.y === endPt.y) {\n        if (startPt.x > point.x && point.x > endPt.x || startPt.x < point.x && point.x < endPt.x) {\n          return Math.abs(startPt.y - point.y);\n        }\n      }\n    } else {\n      if (startPt.x >= point.x && point.x >= endPt.x || startPt.x <= point.x && point.x <= endPt.x || delX < three) {\n        if (startPt.y >= point.y && point.y >= endPt.y || startPt.y <= point.y && point.y <= endPt.y || delY < three) {\n          return Math.abs(lhs - rhs);\n        }\n      }\n    }\n\n    return 10000;\n  };\n  /**\n   * @param {PointModel}startPt- provide the target  value.\n   * @param {PointModel}endPt- provide the target  value.\n   * @private\n   */\n\n\n  ConnectorBridging.prototype.angleCalculation = function (startPt, endPt) {\n    var xDiff = startPt.x - endPt.x;\n    var yDiff = startPt.y - endPt.y;\n    return Math.atan2(yDiff, xDiff) * (180 / Math.PI);\n  };\n\n  ConnectorBridging.prototype.lengthCalculation = function (startPt, endPt) {\n    //removed a try catch from here\n    var len = Math.sqrt((startPt.x - endPt.x) * (startPt.x - endPt.x) + (startPt.y - endPt.y) * (startPt.y - endPt.y));\n    return len;\n  };\n  /**\n   *To destroy the ruler\n   *\n   * @returns {void} To destroy the ruler\n   */\n\n\n  ConnectorBridging.prototype.destroy = function () {\n    /**\n     * Destroys the bridging module\n     */\n  };\n  /**\n   * Core method to return the component name.\n   *\n   * @returns {string}  Core method to return the component name.\n   * @private\n   */\n\n\n  ConnectorBridging.prototype.getModuleName = function () {\n    /**\n     * Returns the module name\n     */\n    return 'Bridging';\n  };\n\n  return ConnectorBridging;\n}();\n\nexport { ConnectorBridging };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector-bridging.js"],"names":["Point","Rect","intersect2","canBridge","ConnectorBridging","prototype","updateBridging","conn","diagram","lastBridge","bounds","bridges","points1","getPoints","toBounds","bridgeSpacing","bridgeSpace","bgedir","bridgeDirection","count","quads","connectors","q","length","connector1","id","points2","bounds1","intersectsRect","intersectPts","intersect","i","fullLength","length_1","segmentIndex","pointIndex","obj","getLengthAtFractionPoint","lengthFractionIndex","stBridge","getPointAtLength","enBridge","fractLength","isEmptyPoint","end","start","sourcePoint","type","targetPoint","intermediatePoints","angle","angleCalculation","fixedPoint","fix","Math","abs","lengthCalculation","var1","insertAt","k","arcSeg","endPoint","paths","createSegment","target","splice","join","bridgeStartPoint","push","isNaN","x","y","bges","bgept","arcs","bgseg","stPoints","edPoints","firstBridge","bridgeList","connector","bridge","findLength","subBridge","arc","createBridgeSegment","startPoint","sweep","path","pre","j","st","direction","index","segmentPointIndex","rendered","sweepDirection","startPt","endPt","angle1","pts","run","found","pt","l","r","deg","findAngle","cos","PI","sin","points","rect1","rect2","width","height","self","zOrder","inter1","point","checkForHorizontalLine","temp","roundedAngle","pointAt","confirm","lengthAtFractionPt","pt1","previouspt2","point2","pt2","suspect","getSlope","lengthFraction","three","delX","delY","lhs","rhs","isFinite","xDiff","yDiff","atan2","len","sqrt","destroy","getModuleName"],"mappings":"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","sourcesContent":["/* eslint-disable jsdoc/require-returns */\n/* eslint-disable valid-jsdoc */\nimport { Point } from '../primitives/point';\nimport { Rect } from '../primitives/rect';\nimport { intersect2 } from '../utility/diagram-util';\nimport { canBridge } from '../utility/constraints-util';\n/**\n * ConnectorBridging defines the bridging behavior\n */\n/** @private */\nvar ConnectorBridging = /** @class */ (function () {\n    /**\n     * Constructor for the bridging module\n     *\n     * @private\n     */\n    function ConnectorBridging() {\n        //constructs the bridging module\n    }\n    /**\n     * @param {Connector}conn - provide the target  value.\n     * @param {Diagram}diagram - provide the target  value.\n     * @private\n     */\n    ConnectorBridging.prototype.updateBridging = function (conn, diagram) {\n        var lastBridge = [];\n        var bounds;\n        conn.bridges = [];\n        if (canBridge(conn, diagram)) {\n            // if (this.canBridge(conn, diagram)) {\n            var points1 = this.getPoints(conn);\n            bounds = Rect.toBounds(points1);\n            var bridgeSpacing = conn.bridgeSpace;\n            var bgedir = diagram.bridgeDirection;\n            var count = -1;\n            var quads = diagram.connectors;\n            for (var q = 0; q < quads.length; q++) {\n                var connector1 = quads[q];\n                if (conn && connector1 && conn.id !== connector1.id) {\n                    var points2 = this.getPoints(connector1);\n                    var bounds1 = Rect.toBounds(points2);\n                    if (this.intersectsRect(bounds, bounds1)) {\n                        var intersectPts = this.intersect(points1, points2, false, bgedir, true);\n                        if (intersectPts.length > 0) {\n                            for (var i = 0; i < intersectPts.length; i++) {\n                                var fullLength = 0;\n                                var length_1 = 0;\n                                var segmentIndex = 0;\n                                var pointIndex = 0;\n                                var obj = this.getLengthAtFractionPoint(conn, intersectPts[i]);\n                                if (obj.pointIndex !== -1) {\n                                    length_1 = obj.lengthFractionIndex;\n                                    fullLength = obj.fullLength;\n                                    segmentIndex = obj.segmentIndex;\n                                    pointIndex = obj.pointIndex;\n                                    var stBridge = this.getPointAtLength((length_1 - (bridgeSpacing / 2)), points1);\n                                    var enBridge = this.getPointAtLength((length_1 + (bridgeSpacing / 2)), points1);\n                                    var fractLength = (length_1 - (bridgeSpacing / 2)) / fullLength;\n                                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                                    fractLength = (length_1 + (bridgeSpacing / 2)) / fullLength;\n                                    if (this.isEmptyPoint(enBridge)) {\n                                        enBridge = stBridge;\n                                    }\n                                    var end = void 0;\n                                    var start = conn.sourcePoint;\n                                    if (conn.type === 'Straight') {\n                                        end = conn.targetPoint;\n                                    }\n                                    else {\n                                        end = conn.intermediatePoints[pointIndex];\n                                    }\n                                    var angle = this.angleCalculation(start, end);\n                                    if (lastBridge.length) {\n                                        var fixedPoint = conn.sourcePoint;\n                                        var fix = Math.abs(this.lengthCalculation(fixedPoint, enBridge));\n                                        var var1 = 0;\n                                        var insertAt = -1;\n                                        count = -1;\n                                        for (var k = 0; k < lastBridge[segmentIndex].bridges.length; k++) {\n                                            count++;\n                                            var arcSeg = lastBridge[segmentIndex].bridges[k];\n                                            var1 = Math.abs(this.lengthCalculation(fixedPoint, arcSeg.endPoint));\n                                            if (fix < var1) {\n                                                insertAt = count;\n                                                break;\n                                            }\n                                        }\n                                        if (insertAt >= 0) {\n                                            //let paths: ArcSegment;\n                                            // eslint-disable-next-line max-len\n                                            var paths = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);\n                                            paths.target = connector1.id;\n                                            lastBridge[segmentIndex].bridges.splice(insertAt, 0, paths);\n                                            lastBridge[segmentIndex].bridges.join();\n                                            lastBridge[segmentIndex].bridgeStartPoint.splice(insertAt, 0, stBridge);\n                                            lastBridge[segmentIndex].bridgeStartPoint.join();\n                                            lastBridge[segmentIndex].segmentIndex = segmentIndex;\n                                        }\n                                        else {\n                                            //let paths: ArcSegment;\n                                            // eslint-disable-next-line max-len\n                                            var paths = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);\n                                            paths.target = connector1.id;\n                                            lastBridge[segmentIndex].bridges.push(paths);\n                                            lastBridge[segmentIndex].bridgeStartPoint.push(stBridge);\n                                            lastBridge[segmentIndex].segmentIndex = segmentIndex;\n                                        }\n                                    }\n                                    else {\n                                        if (!isNaN(stBridge.x) && !isNaN(stBridge.y) && !this.isEmptyPoint(enBridge)) {\n                                            //let arcs: ArcSegment;\n                                            var bges = [];\n                                            var bgept = [];\n                                            // eslint-disable-next-line max-len\n                                            var arcs = this.createSegment(stBridge, enBridge, angle, bgedir, pointIndex, conn, diagram);\n                                            var bgseg = {\n                                                bridges: bges, bridgeStartPoint: bgept, segmentIndex: segmentIndex\n                                            };\n                                            arcs.target = connector1.id;\n                                            var stPoints = [];\n                                            var edPoints = [];\n                                            stPoints.push(stBridge);\n                                            edPoints.push(enBridge);\n                                            lastBridge[segmentIndex] = bgseg;\n                                            lastBridge[segmentIndex].bridges.push(arcs);\n                                            lastBridge[segmentIndex].bridgeStartPoint = stPoints;\n                                            lastBridge[segmentIndex].segmentIndex = segmentIndex;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (lastBridge.length !== 0) {\n                this.firstBridge(lastBridge, conn, bridgeSpacing);\n            }\n        }\n    };\n    /**\n     * @param {BridgeSegment[]}bridgeList - provide the bridgeList  value.\n     * @param {Connector}connector - provide the connector  value.\n     * @param {number}bridgeSpacing - provide the bridgeSpacing  value.\n     * @private\n     */\n    ConnectorBridging.prototype.firstBridge = function (bridgeList, connector, bridgeSpacing) {\n        for (var i = 0; i < bridgeList.length; i++) {\n            var bridge = bridgeList[i];\n            for (var k = 1; k < bridge.bridges.length; k++) {\n                if (Point.findLength(bridge.bridges[k].endPoint, bridge.bridges[k - 1].endPoint) < bridgeSpacing) {\n                    bridge.bridges[k - 1].endPoint = bridge.bridges[k].endPoint;\n                    var subBridge = bridge.bridges[k - 1];\n                    var arc = this.createBridgeSegment(subBridge.startPoint, subBridge.endPoint, subBridge.angle, bridgeSpacing, subBridge.sweep);\n                    bridge.bridges[k - 1].path = arc;\n                    bridge.bridges.splice(k, 1);\n                    bridge.bridgeStartPoint.splice(k, 1);\n                    k--;\n                }\n            }\n            var pre = connector.sourcePoint;\n            for (var j = 0; j < bridge.bridges.length; j++) {\n                var subBridge = bridge.bridges[j]; //const preventChecking: boolean = true;\n                pre = subBridge.endPoint;\n                connector.bridges.push(subBridge);\n            }\n        }\n    };\n    /**\n     * @returns { ArcSegment } checkSourcePointInTarget method .\\\n     * @param {PointModel}st- provide the st  value.\n     * @param {PointModel}end- provide the end  value.\n     * @param {number}angle- provide the angle  value.\n     * @param {BridgeDirection}direction- provide the direction  value.\n     * @param {number}index- provide the index  value.\n     * @param {Connector}conn- provide the conn  value.\n     * @param {Diagram} diagram- provide the diagram  value.\n     * @private\n     */\n    ConnectorBridging.prototype.createSegment = function (st, end, angle, direction, index, conn, diagram) {\n        //let arc: string;\n        //let sweep: number;\n        var path = {\n            angle: 0, endPoint: { x: 0, y: 0 }, target: '', path: '',\n            segmentPointIndex: -1, startPoint: { x: 0, y: 0 }, sweep: 1, rendered: false\n        };\n        var sweep = this.sweepDirection(angle, direction, conn, diagram);\n        var arc = this.createBridgeSegment(st, end, angle, conn.bridgeSpace, sweep);\n        path.path = arc;\n        path.startPoint = st;\n        path.endPoint = end;\n        path.angle = angle;\n        path.segmentPointIndex = index;\n        path.sweep = sweep;\n        return path;\n    };\n    /**\n     * @param {PointModel}startPt- provide the startPt  value.\n     * @param {PointModel}endPt- provide the endPt  value.\n     * @param {number}angle- provide the angle  value.\n     * @param {number}bridgeSpace- provide the bridgeSpace  value.\n     * @param {number}sweep- provide the sweep  value.\n     * @private\n     */\n    ConnectorBridging.prototype.createBridgeSegment = function (startPt, endPt, angle, bridgeSpace, sweep) {\n        var path = 'A ' + bridgeSpace / 2 + ' ' + bridgeSpace / 2 + ' ' + angle + ' , 1 ' + sweep + ' ' + endPt.x + ',' + endPt.y;\n        return path;\n    };\n    /**\n     * @param {number}angle- provide the source value.\n     * @param {BridgeDirection}bridgeDirection- provide the source value.\n     * @param {Connector}connector- provide the source value.\n     * @param {Diagram}diagram- provide the source value.\n     * @private\n     */\n    ConnectorBridging.prototype.sweepDirection = function (angle, bridgeDirection, connector, diagram) {\n        var angle1 = Math.abs(angle);\n        var sweep;\n        switch (bridgeDirection) {\n            case 'Top':\n            case 'Bottom':\n                sweep = 1;\n                if (angle1 >= 0 && angle1 <= 90) {\n                    sweep = 0;\n                }\n                break;\n            case 'Left':\n            case 'Right':\n                sweep = 1;\n                if (angle < 0 && angle >= -180) {\n                    sweep = 0;\n                }\n                break;\n        }\n        if (bridgeDirection === 'Right' || bridgeDirection === 'Bottom') {\n            if (sweep === 0) {\n                sweep = 1;\n            }\n            else {\n                sweep = 0;\n            }\n        }\n        return sweep;\n    };\n    /** @private */\n    ConnectorBridging.prototype.getPointAtLength = function (length, pts) {\n        var run = 0;\n        var pre;\n        var found = { x: 0, y: 0 };\n        for (var i = 0; i < pts.length; i++) {\n            var pt = pts[i];\n            if (!pre) {\n                pre = pt;\n                continue;\n            }\n            else {\n                var l = this.lengthCalculation(pre, pt);\n                if (run + l > length) {\n                    var r = length - run;\n                    var deg = Point.findAngle(pre, pt);\n                    var x = r * Math.cos(deg * Math.PI / 180);\n                    var y = r * Math.sin(deg * Math.PI / 180);\n                    found = { x: pre.x + x, y: pre.y + y };\n                    break;\n                }\n                else {\n                    run += l;\n                }\n            }\n            pre = pt;\n        }\n        return found;\n    };\n    /**\n     * @param {PointModel[]}connector- provide the source value.\n     * @private\n     */\n    ConnectorBridging.prototype.getPoints = function (connector) {\n        var points = [];\n        if (connector.intermediatePoints && (connector.type === 'Straight' || connector.type === 'Orthogonal')) {\n            for (var j = 0; j < connector.intermediatePoints.length; j++) {\n                points.push(connector.intermediatePoints[j]);\n            }\n        }\n        return points;\n    };\n    ConnectorBridging.prototype.intersectsRect = function (rect1, rect2) {\n        return ((((rect2.x < (rect1.x + rect1.width)) && (rect1.x < (rect2.x + rect2.width)))\n            && (rect2.y < (rect1.y + rect1.height))) && (rect1.y < (rect2.y + rect2.height)));\n    };\n    /**\n     * @param {PointModel[]}points1- provide the source value.\n     * @param {PointModel[]}points2- provide the source value.\n     * @param {boolean}self- provide the source value.\n     * @param {BridgeDirection}bridgeDirection- provide the source value.\n     * @param {PointModel[]}zOrder- provide the source value.\n     * @private\n     */\n    ConnectorBridging.prototype.intersect = function (points1, points2, self, bridgeDirection, zOrder) {\n        if (self && points2.length >= 2) {\n            points2.splice(0, 1);\n            points2.splice(0, 1);\n        }\n        var points = [];\n        for (var i = 0; i < points1.length - 1; i++) {\n            var pt = this.inter1(points1[i], points1[i + 1], points2, zOrder, bridgeDirection);\n            if (pt.length > 0) {\n                for (var k = 0; k < pt.length; k++) {\n                    points.push(pt[k]);\n                }\n            }\n            if (self && points2.length >= 1) {\n                points2.splice(0, 1);\n            }\n        }\n        return points;\n    };\n    /**\n     * @param {PointModel}startPt- provide the target  value.\n     * @param {PointModel}endPt- provide the target  value.\n     * @param {PointModel[]}pts- provide the target  value.\n     * @param {boolean}zOrder- provide the target  value.\n     * @param {BridgeDirection}bridgeDirection- provide the target  value.\n     * @private\n     */\n    ConnectorBridging.prototype.inter1 = function (startPt, endPt, pts, zOrder, bridgeDirection) {\n        var points1 = [];\n        for (var i = 0; i < pts.length - 1; i++) {\n            var point = intersect2(startPt, endPt, pts[i], pts[i + 1]);\n            if (!this.isEmptyPoint(point)) {\n                var angle = this.angleCalculation(startPt, endPt);\n                var angle1 = this.angleCalculation(pts[i], pts[i + 1]);\n                angle = this.checkForHorizontalLine(angle);\n                angle1 = this.checkForHorizontalLine(angle1);\n                switch (bridgeDirection) {\n                    case 'Left':\n                    case 'Right':\n                        if (angle > angle1) {\n                            points1.push(point);\n                        }\n                        break;\n                    case 'Top':\n                    case 'Bottom':\n                        if (angle < angle1) {\n                            points1.push(point);\n                        }\n                        break;\n                }\n                if (angle === angle1 && zOrder) {\n                    points1.push(point);\n                }\n            }\n        }\n        return points1;\n    };\n    ConnectorBridging.prototype.checkForHorizontalLine = function (angle) {\n        var temp = 0;\n        var roundedAngle = Math.abs(angle);\n        if (roundedAngle > 90) {\n            temp = 180 - roundedAngle;\n        }\n        else {\n            temp = roundedAngle;\n        }\n        return temp;\n    };\n    ConnectorBridging.prototype.isEmptyPoint = function (point) {\n        return point.x === 0 && point.y === 0;\n    };\n    ConnectorBridging.prototype.getLengthAtFractionPoint = function (connector, pointAt) {\n        var confirm = 100;\n        var pointIndex = -1;\n        var fullLength = 0;\n        var segmentIndex = -1;\n        var count = 0;\n        var lengthAtFractionPt = 0;\n        var pt1 = connector.sourcePoint;\n        var previouspt2 = pt1;\n        var points = [];\n        for (var i = 0; i < connector.intermediatePoints.length; i++) {\n            var point2 = connector.intermediatePoints[i];\n            points.push(point2);\n        }\n        for (var j = 0; j < points.length; j++) {\n            var pt2 = points[j];\n            var suspect = this.getSlope(pt2, pt1, pointAt, connector);\n            if (suspect < confirm) {\n                confirm = suspect;\n                lengthAtFractionPt = fullLength + this.lengthCalculation(pointAt, previouspt2);\n                segmentIndex = count;\n                pointIndex = j;\n            }\n            fullLength += Point.findLength(pt2, pt1);\n            pt1 = pt2;\n            previouspt2 = pt2;\n        }\n        count++;\n        var lengthFraction = {\n            lengthFractionIndex: lengthAtFractionPt, fullLength: fullLength,\n            segmentIndex: segmentIndex, pointIndex: pointIndex\n        };\n        return lengthFraction;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ConnectorBridging.prototype.getSlope = function (startPt, endPt, point, connector) {\n        var three = 3.0;\n        var delX = Math.abs(startPt.x - endPt.x);\n        var delY = Math.abs(startPt.y - endPt.y);\n        var lhs = ((point.y - startPt.y) / (endPt.y - startPt.y));\n        var rhs = ((point.x - startPt.x) / (endPt.x - startPt.x));\n        if (!isFinite(lhs) || !isFinite(rhs) || isNaN(lhs) || isNaN(rhs)) {\n            if (startPt.x === endPt.x) {\n                if (startPt.y === endPt.y) {\n                    return 10000;\n                }\n                else if (((startPt.y > point.y) && (point.y > endPt.y)) || ((startPt.y < point.y) && (point.y < endPt.y))) {\n                    return Math.abs(startPt.x - point.x);\n                }\n            }\n            else if (startPt.y === endPt.y) {\n                if (((startPt.x > point.x) && (point.x > endPt.x)) || ((startPt.x < point.x) && (point.x < endPt.x))) {\n                    return Math.abs(startPt.y - point.y);\n                }\n            }\n        }\n        else {\n            if ((startPt.x >= point.x && point.x >= endPt.x) || (startPt.x <= point.x && point.x <= endPt.x) || delX < three) {\n                if ((startPt.y >= point.y && point.y >= endPt.y) || (startPt.y <= point.y && point.y <= endPt.y) || delY < three) {\n                    return Math.abs(lhs - rhs);\n                }\n            }\n        }\n        return 10000;\n    };\n    /**\n     * @param {PointModel}startPt- provide the target  value.\n     * @param {PointModel}endPt- provide the target  value.\n     * @private\n     */\n    ConnectorBridging.prototype.angleCalculation = function (startPt, endPt) {\n        var xDiff = startPt.x - endPt.x;\n        var yDiff = startPt.y - endPt.y;\n        return Math.atan2(yDiff, xDiff) * (180 / Math.PI);\n    };\n    ConnectorBridging.prototype.lengthCalculation = function (startPt, endPt) {\n        //removed a try catch from here\n        var len = Math.sqrt(((startPt.x - endPt.x) * (startPt.x - endPt.x)) + ((startPt.y - endPt.y) * (startPt.y - endPt.y)));\n        return len;\n    };\n    /**\n     *To destroy the ruler\n     *\n     * @returns {void} To destroy the ruler\n     */\n    ConnectorBridging.prototype.destroy = function () {\n        /**\n         * Destroys the bridging module\n         */\n    };\n    /**\n     * Core method to return the component name.\n     *\n     * @returns {string}  Core method to return the component name.\n     * @private\n     */\n    ConnectorBridging.prototype.getModuleName = function () {\n        /**\n         * Returns the module name\n         */\n        return 'Bridging';\n    };\n    return ConnectorBridging;\n}());\nexport { ConnectorBridging };\n"]},"metadata":{},"sourceType":"module"}