{"ast":null,"code":"import { NodeConstraints, AnnotationConstraints } from '../enum/enum';\nimport { Node } from '../objects/node';\nimport { randomId } from './../utility/base-util';\n/**\n * These utility methods help to process the data and to convert it to desired dimensions\n */\n\n/**\n * getULMClassifierShapes method \\\n *\n * @returns {DiagramElement} getULMClassifierShapes method .\\\n * @param { DiagramElement} content - provide the content  value.\n * @param {NodeModel} node - provide the node  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\n\nexport function getULMClassifierShapes(content, node, diagram) {\n  var classifier;\n  var textWrap = 'NoWrap';\n\n  if (node.shape.classifier === 'Class') {\n    classifier = node.shape.classShape;\n  } else if (node.shape.classifier === 'Enumeration') {\n    classifier = node.shape.enumerationShape;\n  } else if (node.shape.classifier === 'Interface') {\n    classifier = node.shape.interfaceShape;\n  } //let attributeText: string = '';\n\n\n  node.container = {\n    type: 'Stack',\n    orientation: 'Vertical'\n  };\n  node.constraints = (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Resize);\n  node.style = {\n    fill: node.style.fill,\n    strokeColor: node.style.strokeColor,\n    strokeWidth: 1.5\n  };\n  node.children = [];\n\n  if (node.maxWidth) {\n    textWrap = 'Wrap';\n  }\n\n  var newObj = new Node(diagram, 'nodes', {\n    id: node.id + '_umlClass_header',\n    annotations: [{\n      id: 'name',\n      content: classifier.name,\n      offset: {\n        x: 0.5,\n        y: 0.65\n      },\n      margin: {\n        left: 10,\n        right: 10\n      },\n      style: {\n        bold: true,\n        fontSize: 14,\n        color: classifier.style.color,\n        fill: classifier.style.fill,\n        textWrapping: textWrap\n      }\n    }, {\n      content: '<<' + node.shape.classifier + '>>',\n      margin: {\n        left: 10,\n        right: 10\n      },\n      id: 'class',\n      style: {\n        fontSize: classifier.style.fontSize,\n        color: classifier.style.color,\n        fill: classifier.style.fill,\n        textWrapping: textWrap\n      },\n      offset: {\n        x: 0.5,\n        y: 0.3\n      },\n      constraints: AnnotationConstraints.ReadOnly\n    }],\n    constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),\n    verticalAlignment: 'Stretch',\n    horizontalAlignment: 'Stretch',\n    style: {\n      fill: node.style.fill,\n      strokeColor: node.style.strokeColor === 'black' ? '#ffffff00' : node.style.strokeColor\n    }\n  }, true);\n  diagram.initObject(newObj);\n  diagram.nodes.push(newObj);\n  diagram.UpdateBlazorDiagramModel(newObj, 'Node');\n  node.children.push(newObj.id);\n  getClassNodes(node, diagram, classifier, textWrap);\n  getClassMembers(node, diagram, classifier, textWrap);\n  /* eslint-disable */\n\n  node.offsetX = node.offsetX;\n  node.offsetY = node.offsetY;\n  node.style.fill = node.style.fill;\n  node.borderColor = node.borderColor;\n  diagram.initObject(node);\n  /* eslint-enable */\n\n  return content;\n}\n/**\n * getClassNodes method \\\n *\n * @returns {void} getClassNodes method .\\\n * @param { Node} node - provide the node  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {UmlClassModel} classifier - provide the classifier  value.\n * @param {TextWrap} textWrap - provide the textWrap  value.\n * @private\n */\n\nexport function getClassNodes(node, diagram, classifier, textWrap) {\n  if (node.shape.classifier === 'Enumeration') {\n    var member = classifier.members;\n\n    if (member && member.length) {\n      addSeparator(node, diagram);\n      var memberText = '';\n\n      for (var i = 0; i < member.length; i++) {\n        var members = member[i];\n\n        if (members.name !== '') {\n          memberText += members.name;\n        }\n\n        if (i !== member.length) {\n          var style = getStyle(node, members);\n          var temp = new Node(diagram, 'nodes', {\n            id: randomId() + '_umlMember',\n            annotations: [{\n              id: 'name',\n              content: memberText,\n              offset: {\n                x: 0,\n                y: 0.5\n              },\n              style: {\n                bold: true,\n                fontSize: style.fontSize,\n                color: style.color,\n                fill: style.fill,\n                textWrapping: textWrap\n              },\n              margin: {\n                left: 14,\n                right: 5\n              },\n              horizontalAlignment: 'Left'\n            }],\n            verticalAlignment: 'Stretch',\n            horizontalAlignment: 'Stretch',\n            style: {\n              fill: node.style.fill,\n              strokeColor: node.style.strokeColor === 'black' ? '#ffffff00' : node.style.strokeColor,\n              textWrapping: textWrap\n            },\n            constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),\n            minHeight: 25\n          }, true);\n          diagram.initObject(temp);\n          diagram.nodes.push(temp);\n          diagram.UpdateBlazorDiagramModel(temp, 'Node');\n          node.children.push(temp.id);\n          memberText = '';\n\n          if (members.isSeparator && i !== member.length - 1) {\n            addSeparator(node, diagram);\n          }\n        }\n      }\n    }\n  } else {\n    var attributes = classifier.attributes;\n\n    if (attributes.length) {\n      var attributeText = '';\n      addSeparator(node, diagram);\n\n      for (var i = 0; i < attributes.length; i++) {\n        var text = void 0;\n        var attribute = attributes[i];\n\n        if (attribute.scope && attribute.scope === 'Public') {\n          text = ' +';\n        } else if (attribute.scope && attribute.scope === 'Private') {\n          text = '-';\n        } else if (attribute.scope && attribute.scope === 'Protected') {\n          text = '#';\n        } else {\n          text = '~';\n        }\n\n        if (attribute.name !== '') {\n          if (text) {\n            attributeText += text + ' ' + attribute.name + ' ' + ': ' + attribute.type;\n          }\n        }\n\n        if (i !== attributes.length) {\n          var style = getStyle(node, attribute);\n          var temp = new Node(diagram, 'nodes', {\n            id: randomId() + '_umlProperty',\n            style: {\n              fill: node.style.fill,\n              strokeColor: node.style.strokeColor === 'black' ? '#ffffff00' : node.style.strokeColor\n            },\n            annotations: [{\n              id: 'name',\n              content: attributeText,\n              offset: {\n                x: 0,\n                y: 0.5\n              },\n              style: {\n                bold: true,\n                fontSize: style.fontSize,\n                color: style.color,\n                fill: style.fill,\n                textWrapping: textWrap\n              },\n              margin: {\n                left: 14,\n                right: 5\n              },\n              horizontalAlignment: 'Left'\n            }],\n            verticalAlignment: 'Stretch',\n            horizontalAlignment: 'Stretch',\n            constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),\n            minHeight: 25\n          }, true);\n          diagram.initObject(temp);\n          diagram.nodes.push(temp);\n          diagram.UpdateBlazorDiagramModel(temp, 'Node');\n          node.children.push(temp.id);\n          attributeText = '';\n\n          if (attribute.isSeparator && i !== attributes.length - 1) {\n            addSeparator(node, diagram);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * getClassMembers method \\\n *\n * @returns {void} getClassMembers method .\\\n * @param { Node} node - provide the node  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {UmlClassModel} classifier - provide the classifier  value.\n * @param {TextWrap} textWrap - provide the textWrap  value.\n * @private\n */\n\nexport function getClassMembers(node, diagram, classifier, textWrap) {\n  if (classifier.methods && classifier.methods.length) {\n    var methods = classifier.methods;\n    addSeparator(node, diagram);\n    var argumentText = '';\n    var methodText = '';\n    var text = void 0;\n\n    for (var i = 0; i < methods.length; i++) {\n      var method = methods[i];\n\n      if (method.scope && method.scope === 'Public') {\n        text = ' +';\n      } else if (method.scope && method.scope === 'Private') {\n        text = '-';\n      } else if (method.scope && method.scope === 'Protected') {\n        text = '#';\n      } else {\n        text = '~';\n      }\n\n      if (method.parameters) {\n        for (var j = 0; j < method.parameters.length; j++) {\n          if (method.parameters[j].type) {\n            argumentText += method.parameters[j].name + ':' + method.parameters[j].type;\n          } else {\n            argumentText += method.parameters[j].name;\n          }\n\n          if (j !== method.parameters.length - 1) {\n            argumentText += ',';\n          }\n        }\n      }\n\n      if (method.name !== '') {\n        if (text) {\n          methodText += text + ' ' + method.name + '(' + argumentText + ')' + ' ' + ':' + ' ' + method.type;\n        }\n      }\n\n      if (i !== methods.length) {\n        var style = getStyle(node, method);\n        var temp = new Node(diagram, 'nodes', {\n          id: randomId() + '_umlMethods',\n          verticalAlignment: 'Stretch',\n          horizontalAlignment: 'Stretch',\n          annotations: [{\n            id: 'name',\n            content: methodText,\n            offset: {\n              x: 0,\n              y: 0.5\n            },\n            style: {\n              bold: true,\n              fontSize: style.fontSize,\n              color: style.color,\n              fill: style.fill,\n              textWrapping: textWrap\n            },\n            margin: {\n              left: 14,\n              right: 5\n            },\n            horizontalAlignment: 'Left'\n          }],\n          style: {\n            fill: node.style.fill,\n            strokeColor: node.style.strokeColor === 'black' ? '#ffffff00' : node.style.strokeColor\n          },\n          minHeight: 25,\n          constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize)\n        }, true);\n        diagram.initObject(temp);\n        diagram.nodes.push(temp);\n        diagram.UpdateBlazorDiagramModel(temp, 'Node');\n        node.children.push(temp.id);\n        methodText = '';\n\n        if (method.isSeparator && i !== methods.length - 1) {\n          addSeparator(node, diagram);\n        }\n      }\n    }\n  }\n}\n/**\n * addSeparator method \\\n *\n * @returns {void} addSeparator method .\\\n * @param { Node} stack - provide the stack  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\n\nexport function addSeparator(stack, diagram) {\n  var lineObject = new Node(diagram, 'nodes', {\n    id: randomId() + '_path',\n    height: 1,\n    constraints: NodeConstraints.Default & ~NodeConstraints.Select,\n    verticalAlignment: 'Stretch',\n    horizontalAlignment: 'Stretch',\n    style: {\n      strokeColor: stack.style.strokeColor === 'black' ? '#ffffff00' : stack.style.strokeColor\n    }\n  }, true);\n  diagram.initObject(lineObject);\n  diagram.nodes.push(lineObject);\n  stack.children.push(lineObject.id);\n}\n/**\n * getStyle method \\\n *\n * @returns {TextStyleModel} addSeparator method .\\\n * @param { Node} stack - provide the stack  value.\n * @param {UmlClassModel} node - provide the node  value.\n * @private\n */\n\nexport function getStyle(stack, node) {\n  var newStyle = {};\n  var style = node.style;\n  newStyle.fill = style.fill !== 'transparent' ? style.fill : stack.style.fill;\n  newStyle.color = style.color;\n  newStyle.fontSize = style.fontSize !== 12 ? style.fontSize : stack.style.fontSize;\n  newStyle.strokeColor = style.strokeColor !== 'black' ? style.strokeColor : stack.style.strokeColor;\n  newStyle.strokeWidth = style.strokeWidth !== 1 ? style.strokeWidth : stack.style.strokeWidth;\n  return newStyle;\n}","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/utility/uml-util.js"],"names":["NodeConstraints","AnnotationConstraints","Node","randomId","getULMClassifierShapes","content","node","diagram","classifier","textWrap","shape","classShape","enumerationShape","interfaceShape","container","type","orientation","constraints","Default","HideThumbs","Rotate","Resize","style","fill","strokeColor","strokeWidth","children","maxWidth","newObj","id","annotations","name","offset","x","y","margin","left","right","bold","fontSize","color","textWrapping","ReadOnly","Drag","verticalAlignment","horizontalAlignment","initObject","nodes","push","UpdateBlazorDiagramModel","getClassNodes","getClassMembers","offsetX","offsetY","borderColor","member","members","length","addSeparator","memberText","i","getStyle","temp","minHeight","isSeparator","attributes","attributeText","text","attribute","scope","methods","argumentText","methodText","method","parameters","j","stack","lineObject","height","Select","newStyle"],"mappings":"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","sourcesContent":["import { NodeConstraints, AnnotationConstraints } from '../enum/enum';\nimport { Node } from '../objects/node';\nimport { randomId } from './../utility/base-util';\n/**\n * These utility methods help to process the data and to convert it to desired dimensions\n */\n/**\n * getULMClassifierShapes method \\\n *\n * @returns {DiagramElement} getULMClassifierShapes method .\\\n * @param { DiagramElement} content - provide the content  value.\n * @param {NodeModel} node - provide the node  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nexport function getULMClassifierShapes(content, node, diagram) {\n    var classifier;\n    var textWrap = 'NoWrap';\n    if (node.shape.classifier === 'Class') {\n        classifier = node.shape.classShape;\n    }\n    else if (node.shape.classifier === 'Enumeration') {\n        classifier = node.shape.enumerationShape;\n    }\n    else if (node.shape.classifier === 'Interface') {\n        classifier = node.shape.interfaceShape;\n    }\n    //let attributeText: string = '';\n    node.container = { type: 'Stack', orientation: 'Vertical' };\n    node.constraints = (NodeConstraints.Default | NodeConstraints.HideThumbs) &\n        ~(NodeConstraints.Rotate | NodeConstraints.Resize);\n    node.style = {\n        fill: node.style.fill, strokeColor: node.style.strokeColor,\n        strokeWidth: 1.5\n    };\n    node.children = [];\n    if (node.maxWidth) {\n        textWrap = 'Wrap';\n    }\n    var newObj = new Node(diagram, 'nodes', {\n        id: node.id + '_umlClass_header',\n        annotations: [\n            {\n                id: 'name', content: classifier.name,\n                offset: { x: 0.5, y: 0.65 }, margin: { left: 10, right: 10 },\n                style: {\n                    bold: true, fontSize: 14, color: classifier.style.color, fill: classifier.style.fill,\n                    textWrapping: textWrap\n                }\n            }, {\n                content: '<<' + node.shape.classifier + '>>', margin: { left: 10, right: 10 },\n                id: 'class', style: {\n                    fontSize: classifier.style.fontSize,\n                    color: classifier.style.color, fill: classifier.style.fill,\n                    textWrapping: textWrap\n                }, offset: { x: 0.5, y: 0.3 }, constraints: AnnotationConstraints.ReadOnly\n            }\n        ],\n        constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),\n        verticalAlignment: 'Stretch',\n        horizontalAlignment: 'Stretch',\n        style: { fill: node.style.fill, strokeColor: (node.style.strokeColor === 'black') ? '#ffffff00' : node.style.strokeColor }\n    }, true);\n    diagram.initObject(newObj);\n    diagram.nodes.push(newObj);\n    diagram.UpdateBlazorDiagramModel(newObj, 'Node');\n    node.children.push(newObj.id);\n    getClassNodes(node, diagram, classifier, textWrap);\n    getClassMembers(node, diagram, classifier, textWrap);\n    /* eslint-disable */\n    node.offsetX = node.offsetX;\n    node.offsetY = node.offsetY;\n    node.style.fill = node.style.fill;\n    node.borderColor = node.borderColor;\n    diagram.initObject(node);\n    /* eslint-enable */\n    return content;\n}\n/**\n * getClassNodes method \\\n *\n * @returns {void} getClassNodes method .\\\n * @param { Node} node - provide the node  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {UmlClassModel} classifier - provide the classifier  value.\n * @param {TextWrap} textWrap - provide the textWrap  value.\n * @private\n */\nexport function getClassNodes(node, diagram, classifier, textWrap) {\n    if (node.shape.classifier === 'Enumeration') {\n        var member = classifier.members;\n        if (member && member.length) {\n            addSeparator(node, diagram);\n            var memberText = '';\n            for (var i = 0; i < member.length; i++) {\n                var members = member[i];\n                if (members.name !== '') {\n                    memberText += members.name;\n                }\n                if (i !== member.length) {\n                    var style = getStyle(node, members);\n                    var temp = new Node(diagram, 'nodes', {\n                        id: randomId() + '_umlMember',\n                        annotations: [\n                            {\n                                id: 'name', content: memberText, offset: { x: 0, y: 0.5 },\n                                style: {\n                                    bold: true, fontSize: style.fontSize, color: style.color, fill: style.fill,\n                                    textWrapping: textWrap\n                                },\n                                margin: { left: 14, right: 5 }, horizontalAlignment: 'Left'\n                            }\n                        ], verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',\n                        style: {\n                            fill: node.style.fill, strokeColor: (node.style.strokeColor === 'black') ?\n                                '#ffffff00' : node.style.strokeColor, textWrapping: textWrap\n                        },\n                        constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),\n                        minHeight: 25\n                    }, true);\n                    diagram.initObject(temp);\n                    diagram.nodes.push(temp);\n                    diagram.UpdateBlazorDiagramModel(temp, 'Node');\n                    node.children.push(temp.id);\n                    memberText = '';\n                    if (members.isSeparator && (i !== member.length - 1)) {\n                        addSeparator(node, diagram);\n                    }\n                }\n            }\n        }\n    }\n    else {\n        var attributes = classifier.attributes;\n        if (attributes.length) {\n            var attributeText = '';\n            addSeparator(node, diagram);\n            for (var i = 0; i < attributes.length; i++) {\n                var text = void 0;\n                var attribute = attributes[i];\n                if (attribute.scope && (attribute).scope === 'Public') {\n                    text = ' +';\n                }\n                else if (attribute.scope && attribute.scope === 'Private') {\n                    text = '-';\n                }\n                else if (attribute.scope && attribute.scope === 'Protected') {\n                    text = '#';\n                }\n                else {\n                    text = '~';\n                }\n                if (attribute.name !== '') {\n                    if (text) {\n                        attributeText += text + ' ' + attribute.name + ' ' + ': ' + attribute.type;\n                    }\n                }\n                if (i !== attributes.length) {\n                    var style = getStyle(node, attribute);\n                    var temp = new Node(diagram, 'nodes', {\n                        id: randomId() + '_umlProperty', style: { fill: node.style.fill,\n                            strokeColor: (node.style.strokeColor === 'black') ? '#ffffff00' : node.style.strokeColor },\n                        annotations: [\n                            {\n                                id: 'name', content: attributeText, offset: { x: 0, y: 0.5 },\n                                style: {\n                                    bold: true, fontSize: style.fontSize, color: style.color, fill: style.fill,\n                                    textWrapping: textWrap\n                                },\n                                margin: { left: 14, right: 5 }, horizontalAlignment: 'Left'\n                            }\n                        ], verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',\n                        constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize),\n                        minHeight: 25\n                    }, true);\n                    diagram.initObject(temp);\n                    diagram.nodes.push(temp);\n                    diagram.UpdateBlazorDiagramModel(temp, 'Node');\n                    node.children.push(temp.id);\n                    attributeText = '';\n                    if (attribute.isSeparator && (i !== attributes.length - 1)) {\n                        addSeparator(node, diagram);\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * getClassMembers method \\\n *\n * @returns {void} getClassMembers method .\\\n * @param { Node} node - provide the node  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @param {UmlClassModel} classifier - provide the classifier  value.\n * @param {TextWrap} textWrap - provide the textWrap  value.\n * @private\n */\nexport function getClassMembers(node, diagram, classifier, textWrap) {\n    if (classifier.methods && classifier.methods.length) {\n        var methods = classifier.methods;\n        addSeparator(node, diagram);\n        var argumentText = '';\n        var methodText = '';\n        var text = void 0;\n        for (var i = 0; i < methods.length; i++) {\n            var method = methods[i];\n            if (method.scope && method.scope === 'Public') {\n                text = ' +';\n            }\n            else if (method.scope && method.scope === 'Private') {\n                text = '-';\n            }\n            else if (method.scope && method.scope === 'Protected') {\n                text = '#';\n            }\n            else {\n                text = '~';\n            }\n            if (method.parameters) {\n                for (var j = 0; j < method.parameters.length; j++) {\n                    if (method.parameters[j].type) {\n                        argumentText += method.parameters[j].name + ':' + method.parameters[j].type;\n                    }\n                    else {\n                        argumentText += method.parameters[j].name;\n                    }\n                    if (j !== method.parameters.length - 1) {\n                        argumentText += ',';\n                    }\n                }\n            }\n            if (method.name !== '') {\n                if (text) {\n                    methodText += text + ' ' + method.name + '(' + argumentText + ')' + ' ' + ':' + ' ' + method.type;\n                }\n            }\n            if (i !== methods.length) {\n                var style = getStyle(node, method);\n                var temp = new Node(diagram, 'nodes', {\n                    id: randomId() + '_umlMethods', verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',\n                    annotations: [\n                        {\n                            id: 'name', content: methodText, offset: { x: 0, y: 0.5 },\n                            style: {\n                                bold: true, fontSize: style.fontSize, color: style.color, fill: style.fill,\n                                textWrapping: textWrap\n                            },\n                            margin: { left: 14, right: 5 }, horizontalAlignment: 'Left'\n                        }\n                    ],\n                    style: {\n                        fill: node.style.fill, strokeColor: (node.style.strokeColor === 'black') ?\n                            '#ffffff00' : node.style.strokeColor\n                    }, minHeight: 25,\n                    constraints: (NodeConstraints.Default | NodeConstraints.HideThumbs) & ~(NodeConstraints.Rotate | NodeConstraints.Drag | NodeConstraints.Resize)\n                }, true);\n                diagram.initObject(temp);\n                diagram.nodes.push(temp);\n                diagram.UpdateBlazorDiagramModel(temp, 'Node');\n                node.children.push(temp.id);\n                methodText = '';\n                if (method.isSeparator && (i !== methods.length - 1)) {\n                    addSeparator(node, diagram);\n                }\n            }\n        }\n    }\n}\n/**\n * addSeparator method \\\n *\n * @returns {void} addSeparator method .\\\n * @param { Node} stack - provide the stack  value.\n * @param {Diagram} diagram - provide the diagram  value.\n * @private\n */\nexport function addSeparator(stack, diagram) {\n    var lineObject = new Node(diagram, 'nodes', {\n        id: randomId() + '_path', height: 1, constraints: NodeConstraints.Default & ~(NodeConstraints.Select),\n        verticalAlignment: 'Stretch', horizontalAlignment: 'Stretch',\n        style: { strokeColor: (stack.style.strokeColor === 'black') ? '#ffffff00' : stack.style.strokeColor }\n    }, true);\n    diagram.initObject(lineObject);\n    diagram.nodes.push(lineObject);\n    stack.children.push(lineObject.id);\n}\n/**\n * getStyle method \\\n *\n * @returns {TextStyleModel} addSeparator method .\\\n * @param { Node} stack - provide the stack  value.\n * @param {UmlClassModel} node - provide the node  value.\n * @private\n */\nexport function getStyle(stack, node) {\n    var newStyle = {};\n    var style = node.style;\n    newStyle.fill = (style.fill !== 'transparent') ? style.fill : stack.style.fill;\n    newStyle.color = style.color;\n    newStyle.fontSize = (style.fontSize !== 12) ? style.fontSize : stack.style.fontSize;\n    newStyle.strokeColor = (style.strokeColor !== 'black') ? style.strokeColor : stack.style.strokeColor;\n    newStyle.strokeWidth = (style.strokeWidth !== 1) ? style.strokeWidth : stack.style.strokeWidth;\n    return newStyle;\n}\n"]},"metadata":{},"sourceType":"module"}