{"ast":null,"code":"import { isBlazor } from '@syncfusion/ej2-base';\nimport { Node } from '../objects/node';\nimport { Diagram } from '../diagram';\nimport { Selector } from '../objects/node';\nimport { Size } from '../primitives/size';\nimport { cloneObject } from './../utility/base-util';\nimport { getObjectType } from './../utility/diagram-util';\nimport { Rect } from '../primitives/rect';\nimport { getAdornerLayerSvg } from '../utility/dom-util';\nimport { swimLaneMeasureAndArrange, checkLaneSize, checkPhaseOffset, canLaneInterchange } from '../utility/swim-lane-util';\nimport { updatePhaseMaxWidth, updateHeaderMaxWidth, updateConnectorsProperties } from '../utility/swim-lane-util';\nimport { considerSwimLanePadding } from '../utility/swim-lane-util';\nimport { DiagramAction, DiagramConstraints, NodeConstraints } from '../enum/enum';\nimport { getDiagramElement } from '../utility/dom-util';\n/**\n * Interaction for Container\n */\n//#region canvas Container interaction\n\n/**\n * updateCanvasBounds method\\\n *\n * @returns {  void }    updateCanvasBounds method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @param {PointModel} position - provide the position value.\n * @param {boolean} isBoundsUpdate - provide the isBoundsUpdate value.\n * @private\n */\n\nexport function updateCanvasBounds(diagram, obj, position, isBoundsUpdate) {\n  var container;\n  var connectorList = [];\n  var groupAction = false;\n\n  if (checkParentAsContainer(diagram, obj, true)) {\n    diagram.protectPropertyChange(true);\n    container = diagram.nameTable[obj.parentId];\n    var wrapper = container.wrapper;\n\n    if (container && container.container.type === 'Canvas') {\n      if (isBoundsUpdate || wrapper.bounds.x <= position.x && wrapper.bounds.right >= position.x && wrapper.bounds.y <= position.y && wrapper.bounds.bottom >= position.y) {\n        var parentWrapper = void 0;\n        var y = wrapper.bounds.y;\n        var x = wrapper.bounds.x;\n        var parent_1 = diagram.nameTable[container.parentId] || container;\n        var shape = parent_1.shape;\n\n        if (shape.type === 'SwimLane') {\n          groupAction = updateLaneBoundsAfterAddChild(container, parent_1, obj, diagram, true);\n        } else {\n          var parent_2 = diagram.nameTable[container.parentId] || container;\n          var shape_1 = parent_2.shape;\n          parentWrapper = parent_2.wrapper;\n\n          if (wrapper.actualSize.width < wrapper.outerBounds.width && !(wrapper.bounds.x > wrapper.outerBounds.x)) {\n            if (container.rowIndex !== undefined) {\n              //const columnIndex:number = parent.columns.length - 1;\n              parentWrapper.updateColumnWidth(container.columnIndex, wrapper.outerBounds.width, true);\n\n              if (shape_1.orientation === 'Horizontal' && shape_1.phaseSize) {\n                updatePhaseMaxWidth(parent_2, diagram, wrapper, container.columnIndex);\n              }\n\n              updateHeaderMaxWidth(diagram, parent_2);\n              diagram.drag(parent_2, x - wrapper.bounds.x, y - wrapper.bounds.y);\n            } else {\n              diagram.scale(container, 1 + (wrapper.outerBounds.width - wrapper.actualSize.width) / wrapper.actualSize.width, 1, wrapper.outerBounds.x < wrapper.bounds.x ? {\n                x: 1,\n                y: 0.5\n              } : {\n                x: 0,\n                y: 0.5\n              });\n            }\n          }\n\n          if (wrapper.actualSize.height < wrapper.outerBounds.height && !(wrapper.bounds.y > wrapper.outerBounds.y)) {\n            if (container.rowIndex !== undefined) {\n              parentWrapper.updateRowHeight(container.rowIndex, wrapper.outerBounds.height, true);\n              diagram.drag(parent_2, x - wrapper.bounds.x, y - wrapper.bounds.y);\n            } else {\n              diagram.scale(container, 1, 1 + (wrapper.outerBounds.height - wrapper.actualSize.height) / wrapper.actualSize.height, wrapper.outerBounds.y < wrapper.bounds.y ? {\n                x: 0.5,\n                y: 1\n              } : {\n                x: 0.5,\n                y: 0\n              });\n            }\n          }\n        }\n      }\n\n      diagram.select([obj]);\n      updateConnectorsProperties(connectorList, diagram);\n    }\n\n    diagram.protectPropertyChange(false);\n  }\n\n  return groupAction;\n}\n/**\n * removeChildInContainer method\\\n *\n * @returns {  void }    removeChildInContainer method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @param {PointModel} position - provide the position value.\n * @param {boolean} isBoundsUpdate - provide the isBoundsUpdate value.\n * @private\n */\n\nexport function removeChildInContainer(diagram, obj, position, isBoundsUpdate) {\n  var container; //let connectorList: string[] = [];\n\n  if (checkParentAsContainer(diagram, obj, true)) {\n    var isProtectedOnChange = 'isProtectedOnChange';\n    var propertyChangeValue = diagram[isProtectedOnChange];\n    diagram.protectPropertyChange(true);\n    container = diagram.nameTable[obj.parentId];\n    var wrapper = container.wrapper;\n\n    if (container && container.container.type === 'Canvas') {\n      if (!isBoundsUpdate && !(wrapper.bounds.x <= position.x && wrapper.bounds.right >= position.x && wrapper.bounds.y <= position.y && wrapper.bounds.bottom >= position.y)) {\n        if (!(obj.constraints & NodeConstraints.AllowMovingOutsideLane)) {\n          var undoObj = cloneObject(obj);\n          diagram.clearSelection();\n          removeChildrenInLane(diagram, obj);\n          obj.parentId = '';\n          var entry = {\n            type: 'ChildCollectionChanged',\n            category: 'Internal',\n            undoObject: undoObj,\n            redoObject: cloneObject(obj)\n          };\n          diagram.addHistoryEntry(entry);\n\n          if (diagram.commandHandler.isContainer) {\n            diagram.commandHandler.isContainer = false;\n            diagram.endGroupAction();\n          }\n\n          moveSwinLaneChild(obj, diagram);\n        }\n      }\n    }\n\n    diagram.protectPropertyChange(propertyChangeValue);\n  }\n}\n/**\n * findBounds method\\\n *\n * @returns {  NodeModel | ConnectorModel  }    findBounds method .\\\n * @param {NodeModel} obj - provide the diagram value.\n * @param {number} columnIndex - provide the isVertical value.\n * @param {boolean} isHeader - provide the isVertical value.\n * @private\n */\n\nexport function findBounds(obj, columnIndex, isHeader) {\n  var rect = new Rect();\n  var rows = obj.shape.type === 'SwimLane' ? obj.wrapper.children[0].rows : obj.wrapper.rows;\n\n  for (var i = isHeader ? 1 : 0; i < rows.length; i++) {\n    rect.uniteRect(rows[i].cells[columnIndex].bounds);\n  }\n\n  return rect;\n}\n/**\n * createHelper method\\\n *\n * @returns {  NodeModel | ConnectorModel  }    createHelper method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @private\n */\n\nexport function createHelper(diagram, obj) {\n  var newObj;\n  var cloneObject = {};\n\n  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n    var prop = _a[_i];\n    cloneObject[prop] = obj[prop];\n  }\n\n  if (getObjectType(obj) === Node) {\n    newObj = new Node(diagram, 'nodes', cloneObject, true);\n    newObj.id = obj.id;\n    diagram.initObject(newObj);\n  }\n\n  diagram.updateDiagramObject(newObj);\n  return newObj;\n}\n/**\n * renderContainerHelper method\\\n *\n * @returns {  NodeModel | ConnectorModel  }    renderContainerHelper method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @private\n */\n\nexport function renderContainerHelper(diagram, obj) {\n  diagram.enableServerDataBinding(false);\n  var object;\n  var container;\n  var nodes;\n\n  if (!isBlazor() || isBlazor() && diagram.diagramActions & DiagramAction.ToolAction) {\n    if (diagram.selectedObject.helperObject) {\n      nodes = diagram.selectedObject.helperObject;\n    } else if (diagram.selectedItems.nodes.length > 0 || diagram.selectedItems.connectors.length > 0) {\n      if (obj instanceof Selector && obj.nodes.length + obj.connectors.length === 1) {\n        object = obj.nodes.length > 0 ? obj.nodes[0] : obj.connectors[0];\n        container = diagram.selectedItems.wrapper.children[0];\n      } else {\n        object = obj;\n\n        if (isBlazor()) {\n          if (obj === diagram.selectedItems.nodes[0]) {\n            container = diagram.selectedItems.wrapper;\n          } else {\n            container = obj.wrapper;\n          }\n        } else {\n          container = diagram.selectedItems.wrapper;\n        }\n      }\n\n      diagram.selectedObject.actualObject = object;\n\n      if (!diagram.currentSymbol && (object.isLane && canLaneInterchange(object, diagram) && checkParentAsContainer(diagram, object) || !object.isLane && checkParentAsContainer(diagram, object) || diagram.constraints & DiagramConstraints.LineRouting && diagram.selectedItems.nodes.length > 0)) {\n        var node = {\n          id: 'helper',\n          rotateAngle: container.rotateAngle,\n          offsetX: container.offsetX,\n          offsetY: container.offsetY,\n          minWidth: container.minWidth,\n          minHeight: container.minHeight,\n          maxWidth: container.maxWidth,\n          maxHeight: container.maxHeight,\n          width: container.actualSize.width,\n          height: container.actualSize.height,\n          style: {\n            strokeDashArray: '2 2',\n            fill: 'transparent',\n            strokeColor: '#7D7D7D',\n            strokeWidth: 2\n          }\n        };\n        nodes = createHelper(diagram, node);\n        diagram.selectedObject.helperObject = nodes;\n      }\n    }\n  }\n\n  diagram.enableServerDataBinding(true);\n  return nodes;\n}\n/**\n * checkParentAsContainer method\\\n *\n * @returns {  void  }    checkParentAsContainer method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @param {boolean} isChild - provide the isChild value.\n * @private\n */\n\nexport function checkParentAsContainer(diagram, obj, isChild) {\n  var parentNode = isChild ? diagram.nameTable[obj.parentId] : diagram.nameTable[obj.parentId] || obj;\n\n  if (parentNode && parentNode.container) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * checkChildNodeInContainer method\\\n *\n * @returns {  void  }    checkChildNodeInContainer method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel} obj - provide the isVertical value.\n * @private\n */\n\nexport function checkChildNodeInContainer(diagram, obj) {\n  var parentNode = diagram.nameTable[obj.parentId];\n\n  if (parentNode.container.type === 'Canvas') {\n    obj.margin.left = obj.offsetX - parentNode.wrapper.bounds.x - obj.width / 2;\n    obj.margin.top = obj.offsetY - parentNode.wrapper.bounds.y - obj.height / 2;\n  }\n\n  diagram.nodePropertyChange(obj, {}, {\n    width: obj.width,\n    height: obj.height,\n    offsetX: obj.offsetX,\n    offsetY: obj.offsetY,\n    margin: {\n      left: obj.margin.left,\n      right: obj.margin.right,\n      top: obj.margin.top,\n      bottom: obj.margin.bottom\n    },\n    rotateAngle: obj.rotateAngle\n  });\n\n  if (!parentNode.isLane) {\n    parentNode.wrapper.measure(new Size());\n    parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);\n  }\n}\n\nfunction removeChildrenInLane(diagram, node) {\n  if (node.parentId && node.parentId !== '') {\n    var prevParentNode = diagram.nameTable[node.parentId];\n\n    if (prevParentNode.isLane && prevParentNode.parentId) {\n      var swimlane = diagram.nameTable[prevParentNode.parentId];\n      var canvasId = prevParentNode.id.slice(swimlane.id.length);\n      var prevParentId = canvasId.substring(0, canvasId.length - 1);\n      var lanes = swimlane.shape.lanes;\n      var lane = void 0;\n\n      for (var i = 0; i < lanes.length; i++) {\n        lane = lanes[i];\n\n        if (prevParentId === lane.id) {\n          for (var j = 0; j < lane.children.length; j++) {\n            if (lane.children[j].id === node.id) {\n              lane.children.splice(j, 1);\n              j--;\n            }\n          }\n        }\n      }\n    }\n\n    diagram.deleteChild(node);\n  }\n}\n/**\n * addChildToContainer method\\\n *\n * @returns {  void  }    addChildToContainer method .\\\n * @param {DiagramElement} diagram - provide the element value.\n * @param {boolean} parent - provide the isVertical value.\n * @param {PointModel} node - provide the node value.\n * @param {Diagram} isUndo - provide the isUndo value.\n * @param {boolean} historyAction - provide the historyAction value.\n * @private\n */\n\n\nexport function addChildToContainer(diagram, parent, node, isUndo, historyAction) {\n  if (!diagram.currentSymbol) {\n    diagram.protectPropertyChange(true);\n    var swimlane = diagram.nameTable[parent.parentId];\n    node = diagram.getObject(node.id) || node;\n    var child = diagram.nodes.indexOf(node) !== -1 ? node.id : node;\n\n    if (parent.container.type === 'Canvas' && !historyAction) {\n      var left = node.wrapper.offsetX - node.wrapper.actualSize.width / 2 - (parent.wrapper.offsetX - parent.wrapper.actualSize.width / 2);\n      var top_1 = node.wrapper.offsetY - node.wrapper.actualSize.height / 2 - (parent.wrapper.offsetY - parent.wrapper.actualSize.height / 2);\n      node.margin.left = left;\n      node.margin.top = top_1;\n    } else if (swimlane) {\n      var swimLaneBounds = swimlane.wrapper.bounds;\n      var parentBounds = parent.wrapper.bounds;\n\n      if (swimlane.shape.orientation === 'Horizontal') {\n        node.margin.left -= parentBounds.x - swimLaneBounds.x;\n      } else {\n        var laneHeaderId = parent.parentId + swimlane.shape.lanes[0].id + '_0_header';\n        node.margin.top -= parentBounds.y - swimLaneBounds.y - diagram.nameTable[laneHeaderId].wrapper.bounds.height;\n      }\n    }\n\n    var container = diagram.nameTable[parent.id];\n\n    if (!container.children) {\n      container.children = [];\n    }\n\n    if (container.children.indexOf(node.id) === -1) {\n      removeChildrenInLane(diagram, node);\n\n      if (diagram.getObject(node.id)) {\n        diagram.removeElements(node);\n      }\n\n      var undoObj = cloneObject(node);\n      diagram.addChild(container, child);\n      node = diagram.getObject(node.id);\n\n      if (container.isLane && container.parentId) {\n        swimlane = diagram.nameTable[container.parentId];\n        var lanes = swimlane.shape.lanes;\n        var canvasId = container.id.slice(swimlane.id.length);\n        var currentParentId = canvasId.substring(0, canvasId.length - 1);\n\n        for (var i = 0; i < lanes.length; i++) {\n          if (container.isLane && currentParentId === lanes[i].id) {\n            // eslint-disable-next-line\n            if (!(node.parentObj instanceof Diagram)) {\n              // eslint-disable-next-line\n              node.parentObj = lanes[i];\n            }\n\n            lanes[i].children.push(node);\n          }\n        }\n      }\n\n      diagram.updateDiagramObject(node);\n      moveSwinLaneChild(node, diagram);\n\n      if (!container.parentId) {\n        diagram.updateDiagramObject(container);\n      } else if (!isUndo) {\n        updateLaneBoundsAfterAddChild(container, swimlane, node, diagram);\n      }\n\n      if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n        var entry = {\n          type: 'ChildCollectionChanged',\n          category: 'Internal',\n          undoObject: undoObj,\n          redoObject: cloneObject(node),\n          historyAction: historyAction ? 'AddNodeToLane' : undefined\n        };\n        diagram.addHistoryEntry(entry);\n      }\n    }\n\n    diagram.protectPropertyChange(false);\n  }\n}\n\nfunction moveSwinLaneChild(node, diagram) {\n  var sourceNode = getDiagramElement(node.id + '_groupElement', diagram.element.id);\n  var targetId = node.parentId ? node.parentId + '_groupElement' : diagram.element.id + '_diagramLayer';\n  var targetNode = getDiagramElement(targetId, diagram.element.id);\n\n  if (sourceNode && targetNode) {\n    targetNode.appendChild(sourceNode);\n  }\n}\n\nexport function updateLaneBoundsAfterAddChild(container, swimLane, node, diagram, isBoundsUpdate) {\n  var undoObject = cloneObject(container);\n  var isUpdateRow;\n  var isGroupAction = false;\n  var padding = swimLane.shape.padding;\n  var containerBounds = container.wrapper.bounds;\n  var containerOuterBounds = container.wrapper.outerBounds;\n  var nodeBounds = node.wrapper.bounds;\n\n  if (swimLane && swimLane.shape.type === 'SwimLane' && (containerBounds.right < nodeBounds.right + padding || containerBounds.bottom < nodeBounds.bottom + padding)) {\n    var grid = swimLane.wrapper.children[0];\n    var x = grid.bounds.x;\n    var y = grid.bounds.y;\n    var size = void 0;\n\n    if (containerBounds.right < nodeBounds.right + padding && containerOuterBounds.x <= containerBounds.x) {\n      size = nodeBounds.right - containerBounds.right;\n      isUpdateRow = false;\n      grid.updateColumnWidth(container.columnIndex, containerBounds.width + size, true, padding);\n    }\n\n    if (containerBounds.bottom < nodeBounds.bottom + padding && containerOuterBounds.y <= containerBounds.y) {\n      size = nodeBounds.bottom - containerBounds.bottom;\n      isUpdateRow = true;\n      grid.updateRowHeight(container.rowIndex, containerBounds.height + size, true, padding);\n    }\n\n    if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n      if (isBoundsUpdate) {\n        diagram.startGroupAction();\n        isGroupAction = true;\n      }\n\n      if (isUpdateRow !== undefined) {\n        var entry = {\n          category: 'Internal',\n          type: isUpdateRow ? 'RowHeightChanged' : 'ColumnWidthChanged',\n          undoObject: undoObject,\n          redoObject: cloneObject(container)\n        };\n        diagram.addHistoryEntry(entry);\n      }\n    }\n\n    swimLane.width = swimLane.wrapper.width = grid.width;\n    swimLane.height = swimLane.wrapper.height = grid.height;\n    swimLaneMeasureAndArrange(swimLane);\n\n    if (swimLane.shape.orientation === 'Horizontal') {\n      updatePhaseMaxWidth(swimLane, diagram, container.wrapper, container.columnIndex);\n    }\n\n    updateHeaderMaxWidth(diagram, swimLane);\n    diagram.drag(swimLane, x - grid.bounds.x, y - grid.bounds.y);\n    checkPhaseOffset(swimLane, diagram);\n    checkLaneSize(swimLane);\n  }\n\n  considerSwimLanePadding(diagram, node, padding);\n  diagram.updateDiagramElementQuad();\n  return isGroupAction;\n} //#endregion\n//# reginon stack panel interaction\n\n/**\n * renderStackHighlighter method\\\n *\n * @returns {  void  }    renderStackHighlighter method .\\\n * @param {DiagramElement} element - provide the element value.\n * @param {boolean} isVertical - provide the isVertical value.\n * @param {PointModel} position - provide the position value.\n * @param {Diagram} diagram - provide the diagram value.\n * @param {boolean} isUml - provide the isUml value.\n * @param {boolean} isSwimlane - provide the isSwimlane value.\n * @private\n */\n\nexport function renderStackHighlighter(element, isVertical, position, diagram, isUml, isSwimlane) {\n  var adornerSvg = getAdornerLayerSvg(diagram.element.id);\n  diagram.diagramRenderer.renderStackHighlighter(element, adornerSvg, diagram.scroller.transform, isVertical, position, isUml, isSwimlane);\n}\n/**\n * moveChildInStack method\\\n *\n * @returns {  void }    moveChildInStack method .\\\n * @param {Node} sourceNode - provide the sourceNode value.\n * @param {Node} target - provide the target value.\n * @param {Diagram} diagram - provide the diagram value.\n * @param {Actions} action - provide the action value.\n * @private\n */\n\nexport function moveChildInStack(sourceNode, target, diagram, action) {\n  var obj = sourceNode;\n  var parent = diagram.nameTable[obj.parentId];\n  var sourceParent = diagram.nameTable[obj.parentId];\n\n  if (target && sourceParent && sourceParent.container && sourceParent.container.type === 'Stack' && target.container && target.container.type === 'Stack' && sourceParent.id !== target.parentId) {\n    var value = sourceParent.wrapper.children.indexOf(obj.wrapper);\n\n    if (value > -1) {\n      diagram.nameTable[obj.id].parentId = target.id;\n      sourceParent.wrapper.children.splice(value, 1);\n    }\n  }\n\n  if (target && target.parentId && obj.parentId && action === 'Drag' && sourceParent.container && sourceParent.container.type === 'Stack') {\n    var targetIndex = parent.wrapper.children.indexOf(target.wrapper);\n    var sourceIndex = parent.wrapper.children.indexOf(obj.wrapper);\n    var undoElement = {\n      targetIndex: targetIndex,\n      target: target,\n      sourceIndex: sourceIndex,\n      source: sourceNode\n    };\n    parent.wrapper.children.splice(sourceIndex, 1);\n    parent.wrapper.children.splice(targetIndex, 0, obj.wrapper);\n    var redoElement = {\n      targetIndex: sourceIndex,\n      target: target,\n      sourceIndex: targetIndex,\n      source: sourceNode\n    };\n    var entry = {\n      type: 'StackChildPositionChanged',\n      redoObject: redoElement,\n      undoObject: undoElement,\n      category: 'Internal'\n    };\n    diagram.commandHandler.addHistoryEntry(entry);\n  }\n} //#end region\n//# region Swimlane rendering\n//#end region","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/container-interaction.js"],"names":["isBlazor","Node","Diagram","Selector","Size","cloneObject","getObjectType","Rect","getAdornerLayerSvg","swimLaneMeasureAndArrange","checkLaneSize","checkPhaseOffset","canLaneInterchange","updatePhaseMaxWidth","updateHeaderMaxWidth","updateConnectorsProperties","considerSwimLanePadding","DiagramAction","DiagramConstraints","NodeConstraints","getDiagramElement","updateCanvasBounds","diagram","obj","position","isBoundsUpdate","container","connectorList","groupAction","checkParentAsContainer","protectPropertyChange","nameTable","parentId","wrapper","type","bounds","x","right","y","bottom","parentWrapper","parent_1","shape","updateLaneBoundsAfterAddChild","parent_2","shape_1","actualSize","width","outerBounds","rowIndex","undefined","updateColumnWidth","columnIndex","orientation","phaseSize","drag","scale","height","updateRowHeight","select","removeChildInContainer","isProtectedOnChange","propertyChangeValue","constraints","AllowMovingOutsideLane","undoObj","clearSelection","removeChildrenInLane","entry","category","undoObject","redoObject","addHistoryEntry","commandHandler","isContainer","endGroupAction","moveSwinLaneChild","findBounds","isHeader","rect","rows","children","i","length","uniteRect","cells","createHelper","newObj","_i","_a","Object","keys","prop","id","initObject","updateDiagramObject","renderContainerHelper","enableServerDataBinding","object","nodes","diagramActions","ToolAction","selectedObject","helperObject","selectedItems","connectors","actualObject","currentSymbol","isLane","LineRouting","node","rotateAngle","offsetX","offsetY","minWidth","minHeight","maxWidth","maxHeight","style","strokeDashArray","fill","strokeColor","strokeWidth","isChild","parentNode","checkChildNodeInContainer","margin","left","top","nodePropertyChange","measure","arrange","desiredSize","prevParentNode","swimlane","canvasId","slice","prevParentId","substring","lanes","lane","j","splice","deleteChild","addChildToContainer","parent","isUndo","historyAction","getObject","child","indexOf","top_1","swimLaneBounds","parentBounds","laneHeaderId","removeElements","addChild","currentParentId","parentObj","push","UndoRedo","sourceNode","element","targetId","targetNode","appendChild","swimLane","isUpdateRow","isGroupAction","padding","containerBounds","containerOuterBounds","nodeBounds","grid","size","startGroupAction","updateDiagramElementQuad","renderStackHighlighter","isVertical","isUml","isSwimlane","adornerSvg","diagramRenderer","scroller","transform","moveChildInStack","target","action","sourceParent","value","targetIndex","sourceIndex","undoElement","source","redoElement"],"mappings":"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","sourcesContent":["import { isBlazor } from '@syncfusion/ej2-base';\nimport { Node } from '../objects/node';\nimport { Diagram } from '../diagram';\nimport { Selector } from '../objects/node';\nimport { Size } from '../primitives/size';\nimport { cloneObject } from './../utility/base-util';\nimport { getObjectType } from './../utility/diagram-util';\nimport { Rect } from '../primitives/rect';\nimport { getAdornerLayerSvg } from '../utility/dom-util';\nimport { swimLaneMeasureAndArrange, checkLaneSize, checkPhaseOffset, canLaneInterchange } from '../utility/swim-lane-util';\nimport { updatePhaseMaxWidth, updateHeaderMaxWidth, updateConnectorsProperties } from '../utility/swim-lane-util';\nimport { considerSwimLanePadding } from '../utility/swim-lane-util';\nimport { DiagramAction, DiagramConstraints, NodeConstraints } from '../enum/enum';\nimport { getDiagramElement } from '../utility/dom-util';\n/**\n * Interaction for Container\n */\n//#region canvas Container interaction\n/**\n * updateCanvasBounds method\\\n *\n * @returns {  void }    updateCanvasBounds method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @param {PointModel} position - provide the position value.\n * @param {boolean} isBoundsUpdate - provide the isBoundsUpdate value.\n * @private\n */\nexport function updateCanvasBounds(diagram, obj, position, isBoundsUpdate) {\n    var container;\n    var connectorList = [];\n    var groupAction = false;\n    if (checkParentAsContainer(diagram, obj, true)) {\n        diagram.protectPropertyChange(true);\n        container = diagram.nameTable[obj.parentId];\n        var wrapper = container.wrapper;\n        if (container && container.container.type === 'Canvas') {\n            if ((isBoundsUpdate || (wrapper.bounds.x <= position.x && wrapper.bounds.right >= position.x &&\n                (wrapper.bounds.y <= position.y && wrapper.bounds.bottom >= position.y)))) {\n                var parentWrapper = void 0;\n                var y = wrapper.bounds.y;\n                var x = wrapper.bounds.x;\n                var parent_1 = diagram.nameTable[container.parentId] || container;\n                var shape = parent_1.shape;\n                if (shape.type === 'SwimLane') {\n                    groupAction = updateLaneBoundsAfterAddChild(container, parent_1, obj, diagram, true);\n                }\n                else {\n                    var parent_2 = diagram.nameTable[container.parentId] || container;\n                    var shape_1 = parent_2.shape;\n                    parentWrapper = parent_2.wrapper;\n                    if (wrapper.actualSize.width < wrapper.outerBounds.width &&\n                        (!(wrapper.bounds.x > wrapper.outerBounds.x))) {\n                        if (container.rowIndex !== undefined) {\n                            //const columnIndex:number = parent.columns.length - 1;\n                            parentWrapper.updateColumnWidth(container.columnIndex, wrapper.outerBounds.width, true);\n                            if (shape_1.orientation === 'Horizontal' && shape_1.phaseSize) {\n                                updatePhaseMaxWidth(parent_2, diagram, wrapper, container.columnIndex);\n                            }\n                            updateHeaderMaxWidth(diagram, parent_2);\n                            diagram.drag(parent_2, x - wrapper.bounds.x, y - wrapper.bounds.y);\n                        }\n                        else {\n                            diagram.scale(container, (1 + ((wrapper.outerBounds.width - wrapper.actualSize.width) / wrapper.actualSize.width)), 1, ((wrapper.outerBounds.x < wrapper.bounds.x) ? { x: 1, y: 0.5 } : { x: 0, y: 0.5 }));\n                        }\n                    }\n                    if (wrapper.actualSize.height < wrapper.outerBounds.height &&\n                        (!(wrapper.bounds.y > wrapper.outerBounds.y))) {\n                        if (container.rowIndex !== undefined) {\n                            parentWrapper.updateRowHeight(container.rowIndex, wrapper.outerBounds.height, true);\n                            diagram.drag(parent_2, x - wrapper.bounds.x, y - wrapper.bounds.y);\n                        }\n                        else {\n                            diagram.scale(container, 1, (1 + ((wrapper.outerBounds.height - wrapper.actualSize.height) / wrapper.actualSize.height)), ((wrapper.outerBounds.y < wrapper.bounds.y) ? { x: 0.5, y: 1 } : { x: 0.5, y: 0 }));\n                        }\n                    }\n                }\n            }\n            diagram.select([obj]);\n            updateConnectorsProperties(connectorList, diagram);\n        }\n        diagram.protectPropertyChange(false);\n    }\n    return groupAction;\n}\n/**\n * removeChildInContainer method\\\n *\n * @returns {  void }    removeChildInContainer method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @param {PointModel} position - provide the position value.\n * @param {boolean} isBoundsUpdate - provide the isBoundsUpdate value.\n * @private\n */\nexport function removeChildInContainer(diagram, obj, position, isBoundsUpdate) {\n    var container; //let connectorList: string[] = [];\n    if (checkParentAsContainer(diagram, obj, true)) {\n        var isProtectedOnChange = 'isProtectedOnChange';\n        var propertyChangeValue = diagram[isProtectedOnChange];\n        diagram.protectPropertyChange(true);\n        container = diagram.nameTable[obj.parentId];\n        var wrapper = container.wrapper;\n        if (container && container.container.type === 'Canvas') {\n            if ((!isBoundsUpdate && (!(wrapper.bounds.x <= position.x && wrapper.bounds.right >= position.x &&\n                (wrapper.bounds.y <= position.y && wrapper.bounds.bottom >= position.y))))) {\n                if (!(obj.constraints & NodeConstraints.AllowMovingOutsideLane)) {\n                    var undoObj = cloneObject(obj);\n                    diagram.clearSelection();\n                    removeChildrenInLane(diagram, obj);\n                    obj.parentId = '';\n                    var entry = {\n                        type: 'ChildCollectionChanged', category: 'Internal',\n                        undoObject: undoObj, redoObject: cloneObject(obj)\n                    };\n                    diagram.addHistoryEntry(entry);\n                    if (diagram.commandHandler.isContainer) {\n                        diagram.commandHandler.isContainer = false;\n                        diagram.endGroupAction();\n                    }\n                    moveSwinLaneChild(obj, diagram);\n                }\n            }\n        }\n        diagram.protectPropertyChange(propertyChangeValue);\n    }\n}\n/**\n * findBounds method\\\n *\n * @returns {  NodeModel | ConnectorModel  }    findBounds method .\\\n * @param {NodeModel} obj - provide the diagram value.\n * @param {number} columnIndex - provide the isVertical value.\n * @param {boolean} isHeader - provide the isVertical value.\n * @private\n */\nexport function findBounds(obj, columnIndex, isHeader) {\n    var rect = new Rect();\n    var rows = (obj.shape.type === 'SwimLane') ?\n        obj.wrapper.children[0].rows : obj.wrapper.rows;\n    for (var i = ((isHeader) ? 1 : 0); i < rows.length; i++) {\n        rect.uniteRect(rows[i].cells[columnIndex].bounds);\n    }\n    return rect;\n}\n/**\n * createHelper method\\\n *\n * @returns {  NodeModel | ConnectorModel  }    createHelper method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @private\n */\nexport function createHelper(diagram, obj) {\n    var newObj;\n    var cloneObject = {};\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var prop = _a[_i];\n        cloneObject[prop] = obj[prop];\n    }\n    if (getObjectType(obj) === Node) {\n        newObj = new Node(diagram, 'nodes', cloneObject, true);\n        newObj.id = obj.id;\n        diagram.initObject(newObj);\n    }\n    diagram.updateDiagramObject(newObj);\n    return newObj;\n}\n/**\n * renderContainerHelper method\\\n *\n * @returns {  NodeModel | ConnectorModel  }    renderContainerHelper method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @private\n */\nexport function renderContainerHelper(diagram, obj) {\n    diagram.enableServerDataBinding(false);\n    var object;\n    var container;\n    var nodes;\n    if ((!isBlazor()) || (isBlazor() && (diagram.diagramActions & DiagramAction.ToolAction))) {\n        if (diagram.selectedObject.helperObject) {\n            nodes = diagram.selectedObject.helperObject;\n        }\n        else if (diagram.selectedItems.nodes.length > 0 || diagram.selectedItems.connectors.length > 0) {\n            if (obj instanceof Selector && obj.nodes.length + obj.connectors.length === 1) {\n                object = (obj.nodes.length > 0) ? obj.nodes[0] : obj.connectors[0];\n                container = diagram.selectedItems.wrapper.children[0];\n            }\n            else {\n                object = obj;\n                if (isBlazor()) {\n                    if (obj === diagram.selectedItems.nodes[0]) {\n                        container = diagram.selectedItems.wrapper;\n                    }\n                    else {\n                        container = obj.wrapper;\n                    }\n                }\n                else {\n                    container = diagram.selectedItems.wrapper;\n                }\n            }\n            diagram.selectedObject.actualObject = object;\n            if ((!diagram.currentSymbol) && (((object.isLane && canLaneInterchange(object, diagram) &&\n                checkParentAsContainer(diagram, object))\n                || ((!object.isLane) && checkParentAsContainer(diagram, object))) ||\n                ((diagram.constraints & DiagramConstraints.LineRouting) && diagram.selectedItems.nodes.length > 0))) {\n                var node = {\n                    id: 'helper',\n                    rotateAngle: container.rotateAngle,\n                    offsetX: container.offsetX, offsetY: container.offsetY,\n                    minWidth: container.minWidth, minHeight: container.minHeight,\n                    maxWidth: container.maxWidth, maxHeight: container.maxHeight,\n                    width: container.actualSize.width,\n                    height: container.actualSize.height,\n                    style: { strokeDashArray: '2 2', fill: 'transparent', strokeColor: '#7D7D7D', strokeWidth: 2 }\n                };\n                nodes = createHelper(diagram, node);\n                diagram.selectedObject.helperObject = nodes;\n            }\n        }\n    }\n    diagram.enableServerDataBinding(true);\n    return nodes;\n}\n/**\n * checkParentAsContainer method\\\n *\n * @returns {  void  }    checkParentAsContainer method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel | ConnectorModel} obj - provide the isVertical value.\n * @param {boolean} isChild - provide the isChild value.\n * @private\n */\nexport function checkParentAsContainer(diagram, obj, isChild) {\n    var parentNode = (isChild) ? diagram.nameTable[obj.parentId] :\n        (diagram.nameTable[obj.parentId] || obj);\n    if (parentNode && parentNode.container) {\n        return true;\n    }\n    return false;\n}\n/**\n * checkChildNodeInContainer method\\\n *\n * @returns {  void  }    checkChildNodeInContainer method .\\\n * @param {Diagram} diagram - provide the diagram value.\n * @param {NodeModel} obj - provide the isVertical value.\n * @private\n */\nexport function checkChildNodeInContainer(diagram, obj) {\n    var parentNode = diagram.nameTable[obj.parentId];\n    if (parentNode.container.type === 'Canvas') {\n        obj.margin.left = (obj.offsetX - parentNode.wrapper.bounds.x - (obj.width / 2));\n        obj.margin.top = (obj.offsetY - parentNode.wrapper.bounds.y - (obj.height / 2));\n    }\n    diagram.nodePropertyChange(obj, {}, {\n        width: obj.width, height: obj.height,\n        offsetX: obj.offsetX, offsetY: obj.offsetY,\n        margin: {\n            left: obj.margin.left,\n            right: obj.margin.right, top: obj.margin.top,\n            bottom: obj.margin.bottom\n        }, rotateAngle: obj.rotateAngle\n    });\n    if (!parentNode.isLane) {\n        parentNode.wrapper.measure(new Size());\n        parentNode.wrapper.arrange(parentNode.wrapper.desiredSize);\n    }\n}\nfunction removeChildrenInLane(diagram, node) {\n    if (node.parentId && node.parentId !== '') {\n        var prevParentNode = diagram.nameTable[node.parentId];\n        if (prevParentNode.isLane && prevParentNode.parentId) {\n            var swimlane = diagram.nameTable[prevParentNode.parentId];\n            var canvasId = (prevParentNode.id.slice(swimlane.id.length));\n            var prevParentId = canvasId.substring(0, canvasId.length - 1);\n            var lanes = swimlane.shape.lanes;\n            var lane = void 0;\n            for (var i = 0; i < lanes.length; i++) {\n                lane = lanes[i];\n                if (prevParentId === lane.id) {\n                    for (var j = 0; j < lane.children.length; j++) {\n                        if (lane.children[j].id === node.id) {\n                            lane.children.splice(j, 1);\n                            j--;\n                        }\n                    }\n                }\n            }\n        }\n        diagram.deleteChild(node);\n    }\n}\n/**\n * addChildToContainer method\\\n *\n * @returns {  void  }    addChildToContainer method .\\\n * @param {DiagramElement} diagram - provide the element value.\n * @param {boolean} parent - provide the isVertical value.\n * @param {PointModel} node - provide the node value.\n * @param {Diagram} isUndo - provide the isUndo value.\n * @param {boolean} historyAction - provide the historyAction value.\n * @private\n */\nexport function addChildToContainer(diagram, parent, node, isUndo, historyAction) {\n    if (!diagram.currentSymbol) {\n        diagram.protectPropertyChange(true);\n        var swimlane = diagram.nameTable[parent.parentId];\n        node = diagram.getObject(node.id) || node;\n        var child = (diagram.nodes.indexOf(node) !== -1) ? node.id : node;\n        if (parent.container.type === 'Canvas' && !historyAction) {\n            var left = (node.wrapper.offsetX - node.wrapper.actualSize.width / 2) -\n                (parent.wrapper.offsetX - parent.wrapper.actualSize.width / 2);\n            var top_1 = (node.wrapper.offsetY - node.wrapper.actualSize.height / 2) -\n                (parent.wrapper.offsetY - parent.wrapper.actualSize.height / 2);\n            node.margin.left = left;\n            node.margin.top = top_1;\n        }\n        else if (swimlane) {\n            var swimLaneBounds = swimlane.wrapper.bounds;\n            var parentBounds = parent.wrapper.bounds;\n            if (swimlane.shape.orientation === 'Horizontal') {\n                node.margin.left -= parentBounds.x - swimLaneBounds.x;\n            }\n            else {\n                var laneHeaderId = parent.parentId + swimlane.shape.lanes[0].id + '_0_header';\n                node.margin.top -= parentBounds.y - swimLaneBounds.y - diagram.nameTable[laneHeaderId].wrapper.bounds.height;\n            }\n        }\n        var container = diagram.nameTable[parent.id];\n        if (!container.children) {\n            container.children = [];\n        }\n        if (container.children.indexOf(node.id) === -1) {\n            removeChildrenInLane(diagram, node);\n            if (diagram.getObject(node.id)) {\n                diagram.removeElements(node);\n            }\n            var undoObj = cloneObject(node);\n            diagram.addChild(container, child);\n            node = diagram.getObject(node.id);\n            if (container.isLane && container.parentId) {\n                swimlane = diagram.nameTable[container.parentId];\n                var lanes = swimlane.shape.lanes;\n                var canvasId = (container.id.slice(swimlane.id.length));\n                var currentParentId = canvasId.substring(0, canvasId.length - 1);\n                for (var i = 0; i < lanes.length; i++) {\n                    if (container.isLane && currentParentId === lanes[i].id) {\n                        // eslint-disable-next-line\n                        if (!(node.parentObj instanceof Diagram)) {\n                            // eslint-disable-next-line\n                            node.parentObj = lanes[i];\n                        }\n                        lanes[i].children.push(node);\n                    }\n                }\n            }\n            diagram.updateDiagramObject(node);\n            moveSwinLaneChild(node, diagram);\n            if (!container.parentId) {\n                diagram.updateDiagramObject(container);\n            }\n            else if (!isUndo) {\n                updateLaneBoundsAfterAddChild(container, swimlane, node, diagram);\n            }\n            if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n                var entry = {\n                    type: 'ChildCollectionChanged', category: 'Internal',\n                    undoObject: undoObj, redoObject: cloneObject(node), historyAction: historyAction ? 'AddNodeToLane' : undefined\n                };\n                diagram.addHistoryEntry(entry);\n            }\n        }\n        diagram.protectPropertyChange(false);\n    }\n}\nfunction moveSwinLaneChild(node, diagram) {\n    var sourceNode = getDiagramElement(node.id + '_groupElement', diagram.element.id);\n    var targetId = (node.parentId) ? node.parentId + '_groupElement' : diagram.element.id + '_diagramLayer';\n    var targetNode = getDiagramElement(targetId, diagram.element.id);\n    if (sourceNode && targetNode) {\n        targetNode.appendChild(sourceNode);\n    }\n}\nexport function updateLaneBoundsAfterAddChild(container, swimLane, node, diagram, isBoundsUpdate) {\n    var undoObject = cloneObject(container);\n    var isUpdateRow;\n    var isGroupAction = false;\n    var padding = swimLane.shape.padding;\n    var containerBounds = container.wrapper.bounds;\n    var containerOuterBounds = container.wrapper.outerBounds;\n    var nodeBounds = node.wrapper.bounds;\n    if (swimLane && swimLane.shape.type === 'SwimLane' &&\n        (containerBounds.right < nodeBounds.right + padding ||\n            containerBounds.bottom < nodeBounds.bottom + padding)) {\n        var grid = swimLane.wrapper.children[0];\n        var x = grid.bounds.x;\n        var y = grid.bounds.y;\n        var size = void 0;\n        if (containerBounds.right < nodeBounds.right + padding &&\n            containerOuterBounds.x <= containerBounds.x) {\n            size = nodeBounds.right - containerBounds.right;\n            isUpdateRow = false;\n            grid.updateColumnWidth(container.columnIndex, containerBounds.width + size, true, padding);\n        }\n        if (containerBounds.bottom < nodeBounds.bottom + padding &&\n            containerOuterBounds.y <= containerBounds.y) {\n            size = nodeBounds.bottom - containerBounds.bottom;\n            isUpdateRow = true;\n            grid.updateRowHeight(container.rowIndex, containerBounds.height + size, true, padding);\n        }\n        if (!(diagram.diagramActions & DiagramAction.UndoRedo)) {\n            if (isBoundsUpdate) {\n                diagram.startGroupAction();\n                isGroupAction = true;\n            }\n            if (isUpdateRow !== undefined) {\n                var entry = {\n                    category: 'Internal',\n                    type: (isUpdateRow) ? 'RowHeightChanged' : 'ColumnWidthChanged',\n                    undoObject: undoObject, redoObject: cloneObject(container)\n                };\n                diagram.addHistoryEntry(entry);\n            }\n        }\n        swimLane.width = swimLane.wrapper.width = grid.width;\n        swimLane.height = swimLane.wrapper.height = grid.height;\n        swimLaneMeasureAndArrange(swimLane);\n        if (swimLane.shape.orientation === 'Horizontal') {\n            updatePhaseMaxWidth(swimLane, diagram, container.wrapper, container.columnIndex);\n        }\n        updateHeaderMaxWidth(diagram, swimLane);\n        diagram.drag(swimLane, x - grid.bounds.x, y - grid.bounds.y);\n        checkPhaseOffset(swimLane, diagram);\n        checkLaneSize(swimLane);\n    }\n    considerSwimLanePadding(diagram, node, padding);\n    diagram.updateDiagramElementQuad();\n    return isGroupAction;\n}\n//#endregion\n//# reginon stack panel interaction\n/**\n * renderStackHighlighter method\\\n *\n * @returns {  void  }    renderStackHighlighter method .\\\n * @param {DiagramElement} element - provide the element value.\n * @param {boolean} isVertical - provide the isVertical value.\n * @param {PointModel} position - provide the position value.\n * @param {Diagram} diagram - provide the diagram value.\n * @param {boolean} isUml - provide the isUml value.\n * @param {boolean} isSwimlane - provide the isSwimlane value.\n * @private\n */\nexport function renderStackHighlighter(element, isVertical, position, diagram, isUml, isSwimlane) {\n    var adornerSvg = getAdornerLayerSvg(diagram.element.id);\n    diagram.diagramRenderer.renderStackHighlighter(element, adornerSvg, diagram.scroller.transform, isVertical, position, isUml, isSwimlane);\n}\n/**\n * moveChildInStack method\\\n *\n * @returns {  void }    moveChildInStack method .\\\n * @param {Node} sourceNode - provide the sourceNode value.\n * @param {Node} target - provide the target value.\n * @param {Diagram} diagram - provide the diagram value.\n * @param {Actions} action - provide the action value.\n * @private\n */\nexport function moveChildInStack(sourceNode, target, diagram, action) {\n    var obj = sourceNode;\n    var parent = diagram.nameTable[obj.parentId];\n    var sourceParent = diagram.nameTable[obj.parentId];\n    if (target && sourceParent && sourceParent.container && sourceParent.container.type === 'Stack' &&\n        target.container && target.container.type === 'Stack' && (sourceParent.id !== target.parentId)) {\n        var value = sourceParent.wrapper.children.indexOf(obj.wrapper);\n        if (value > -1) {\n            diagram.nameTable[obj.id].parentId = target.id;\n            sourceParent.wrapper.children.splice(value, 1);\n        }\n    }\n    if (target && target.parentId && obj.parentId && action === 'Drag' &&\n        sourceParent.container && sourceParent.container.type === 'Stack') {\n        var targetIndex = parent.wrapper.children.indexOf(target.wrapper);\n        var sourceIndex = parent.wrapper.children.indexOf(obj.wrapper);\n        var undoElement = {\n            targetIndex: targetIndex, target: target,\n            sourceIndex: sourceIndex, source: sourceNode\n        };\n        parent.wrapper.children.splice(sourceIndex, 1);\n        parent.wrapper.children.splice(targetIndex, 0, obj.wrapper);\n        var redoElement = {\n            targetIndex: sourceIndex, target: target,\n            sourceIndex: targetIndex, source: sourceNode\n        };\n        var entry = {\n            type: 'StackChildPositionChanged', redoObject: redoElement,\n            undoObject: undoElement, category: 'Internal'\n        };\n        diagram.commandHandler.addHistoryEntry(entry);\n    }\n}\n//#end region\n//# region Swimlane rendering\n//#end region\n"]},"metadata":{},"sourceType":"module"}