{"ast":null,"code":"import { DiagramAction } from '../enum/enum';\nimport { Rect } from '../primitives/rect';\nimport { OrthogonalSegment } from '../objects/connector';\nimport { getFunction } from '../utility/base-util';\nimport { Point } from '../primitives/point';\nimport { updateLayoutValue } from '../utility/diagram-util';\n/**\n * Hierarchical Tree and Organizational Chart\n */\n\nvar HierarchicalTree =\n/** @class */\nfunction () {\n  /**\n   * Constructor for the organizational chart module.\n   *\n   * @private\n   */\n  function HierarchicalTree() {\n    /**\n     * Defines the layout animation\n     *\n     */\n    this.isAnimation = false; //constructs the layout module\n  }\n  /**\n   * To destroy the organizational chart\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  HierarchicalTree.prototype.destroy = function () {\n    /**\n     * Destroy method performed here\n     */\n  };\n  /**\n   * Get module name.\n   */\n\n\n  HierarchicalTree.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the layout\n     */\n    return 'OrganizationalChart';\n  };\n  /**\n   * @param nodes\n   * @param nameTable\n   * @param layoutProp\n   * @param viewport\n   * @param uniqueId\n   * @param action\n   * @private\n   */\n\n\n  HierarchicalTree.prototype.updateLayout = function (nodes, nameTable, layoutProp, viewport, uniqueId, action) {\n    var layout = {\n      type: layoutProp.type,\n      nameTable: nameTable,\n      anchorX: 0,\n      anchorY: 0,\n      firstLevelNodes: [],\n      centerNode: null,\n      levels: [],\n      maxLevel: 0,\n      graphNodes: {},\n      orientation: layoutProp.orientation,\n      horizontalSpacing: layoutProp.horizontalSpacing,\n      verticalSpacing: layoutProp.verticalSpacing,\n      verticalAlignment: layoutProp.verticalAlignment,\n      horizontalAlignment: layoutProp.horizontalAlignment,\n      fixedNode: layoutProp.fixedNode,\n      getLayoutInfo: getFunction(layoutProp.getLayoutInfo),\n      layoutInfo: layoutProp.layoutInfo,\n      margin: layoutProp.margin,\n      bounds: layoutProp.bounds,\n      objects: [],\n      root: layoutProp.root\n    };\n    this.doLayout(layout, nodes, viewport, uniqueId, action);\n    return layout;\n  };\n\n  HierarchicalTree.prototype.doLayout = function (layout, nodes, viewport, uniqueId, action) {\n    var node;\n    var i;\n    var layoutInfo = {};\n    var shape;\n    var rootNodes = [];\n\n    if (layout.nameTable[layout.root]) {\n      layout.firstLevelNodes.push(layout.nameTable[layout.root]);\n    }\n\n    for (i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n\n      if (!node.excludeFromLayout) {\n        layoutInfo = layout.graphNodes[node.id] = this.setUpLayoutInfo(layout, node);\n        layoutInfo.tree.hasSubTree = false;\n\n        if (!layout.nameTable[layout.root]) {\n          if (!node.inEdges || !node.inEdges.length) {\n            var parentId = 'parentId';\n            var processId = 'processId';\n\n            if (!node[parentId] && !node[processId]) {\n              rootNodes.push(node);\n            }\n\n            if (node.data && String(node.data[uniqueId]) === layout.root) {\n              layout.firstLevelNodes.push(node);\n            }\n          }\n        }\n      }\n    }\n\n    if (layout.firstLevelNodes.length === 0) {\n      layout.firstLevelNodes = rootNodes;\n    } //Update relationship(parent and children)\n\n\n    for (i = 0; i < layout.firstLevelNodes.length; i++) {\n      node = layout.firstLevelNodes[i]; //let check: boolean;\n\n      this.updateEdges(layout, node, 1, action, nodes);\n    }\n\n    if (layout.firstLevelNodes.length > 0) {\n      layout.rootNode = layout.firstLevelNodes[0];\n      var x = 0;\n      var y = 0;\n      var minX = void 0;\n      var maxY = void 0;\n      var maxX = void 0;\n      var minY = void 0; //let j: number;\n\n      var bounds = void 0;\n\n      for (i = 0; i < layout.firstLevelNodes.length; i++) {\n        bounds = this.updateTree(layout, x, y, layout.firstLevelNodes[i], 0, layout.firstLevelNodes[i - 1]);\n        var rootInfo = layout.graphNodes[layout.firstLevelNodes[i].id];\n        bounds.y = Math.min(bounds.y, rootInfo.y);\n        bounds.x = Math.min(bounds.x, rootInfo.x);\n\n        if (layout.orientation.indexOf('Left') !== -1) {\n          y = bounds.right + layout.horizontalSpacing;\n        } else {\n          x = bounds.right + layout.horizontalSpacing;\n        }\n\n        if (i === 0) {\n          minX = bounds.x;\n          minY = bounds.y;\n          maxX = bounds.right;\n          maxY = bounds.bottom;\n        } else {\n          minX = Math.min(minX, bounds.x);\n          minY = Math.min(minY, bounds.y);\n          maxX = Math.max(maxX, bounds.right);\n          maxY = Math.max(maxY, bounds.bottom);\n        }\n      }\n\n      this.updateAnchor(layout, {\n        x: minX,\n        y: minY,\n        right: maxX,\n        bottom: maxY\n      }, viewport);\n\n      for (i = 0; i < layout.firstLevelNodes.length; i++) {\n        this.updateNodes(layout, layout.firstLevelNodes[i], 0);\n      }\n\n      for (i = 0; i < layout.firstLevelNodes.length; i++) {\n        this.updateConnectors(layout, layout.firstLevelNodes[i], 1);\n      }\n    }\n  };\n\n  HierarchicalTree.prototype.getBounds = function (node) {\n    var x = node.offsetX - node.actualSize.width * node.pivot.x;\n    var y = node.offsetY - node.actualSize.height * node.pivot.y;\n    return new Rect(x, y, node.actualSize.width, node.actualSize.height);\n  };\n\n  HierarchicalTree.prototype.updateTree = function (layout, x, y, shape, level, prev, dontupdate) {\n    //let dimensions: Dimensions;\n    var info = {};\n    var lev;\n    var obj; //let hasChild: number;\n\n    var dimensions = this.getDimensions(layout, shape, x, y, level);\n    info = layout.graphNodes[shape.id];\n    var firstChild; //Set maximum level of layout\n\n    layout.maxLevel = Math.max(layout.maxLevel, level);\n    lev = level;\n    var hasChild = this.hasChild(layout, shape);\n\n    if (!hasChild && !info.tree.assistants.length) {\n      //update leaf nodes\n      shape.treeBounds = this.updateLeafNode(layout, shape, prev, dimensions, level, dontupdate);\n      return shape.treeBounds;\n    } else {\n      var treeBounds = void 0;\n      var shapeBounds = void 0;\n      var levelBounds = void 0;\n      var d = void 0;\n      var asstBounds = void 0;\n      var space = void 0;\n      var bottom = void 0;\n      bottom = dimensions.y + dimensions.height + layout.verticalSpacing;\n\n      if (info.tree.assistants.length) {\n        //Vertically place assistants\n        obj = this.setDepthSpaceForAssitants(layout, shape, bottom, dimensions.height, level, layout.verticalSpacing);\n        lev = obj.level;\n        bottom = obj.bottom;\n      }\n\n      if (!info.tree.assistants.length && info.tree.orientation !== 'Horizontal') {\n        bottom = dimensions.y + dimensions.height + layout.verticalSpacing / 2;\n      }\n\n      if (info.tree.children.length) {\n        if (info.tree.orientation === 'Horizontal' && (info.tree.type !== 'Balanced' || info.tree.children.length === 1)) {\n          treeBounds = this.updateHorizontalTree(layout, shape, prev, dimensions.x, bottom, lev);\n        } else if (info.tree.type === 'Balanced') {\n          treeBounds = this.updateHorizontalTreeWithMultipleRows(layout, shape, prev, dimensions.x, bottom, lev);\n        } else {\n          treeBounds = this.updateVerticalTree(layout, shape, dimensions.x, bottom, lev, dontupdate);\n        }\n      }\n\n      if (!(info.y && info.y > dimensions.y)) {\n        info.y = dimensions.y;\n      }\n\n      if (info.mid) {\n        x = info.mid;\n      }\n\n      if (info.tree.assistants.length) {\n        //Set breadth space for assistants\n        space = x !== undefined ? x : dimensions.x;\n        asstBounds = this.setBreadthSpaceForAssistants(layout, shape, dimensions, space, bottom, level);\n\n        if (!hasChild) {\n          levelBounds = treeBounds = asstBounds;\n          x = (levelBounds.x + levelBounds.right) / 2 - dimensions.width / 2;\n          treeBounds = levelBounds;\n        }\n\n        d = asstBounds ? asstBounds.canMoveBy : undefined;\n      }\n\n      info.x = x;\n\n      if (!info.translate) {\n        info.treeWidth = treeBounds.right - treeBounds.x;\n      }\n\n      {\n        shapeBounds = {\n          x: x,\n          y: dimensions.y,\n          right: x + dimensions.width,\n          bottom: dimensions.y + dimensions.height\n        };\n      }\n      var translateInfo = {\n        layout: layout,\n        shape: shape,\n        shapeBounds: shapeBounds,\n        treeBounds: treeBounds,\n        dim: dimensions,\n        level: level\n      };\n      this.translateSubTree(translateInfo, d, prev !== undefined, dontupdate);\n\n      if (info.firstChild && typeof info.firstChild !== 'string') {\n        info.firstChild.x += info.subTreeTranslation;\n      }\n\n      shape.treeBounds = treeBounds;\n      return treeBounds;\n    }\n  };\n\n  HierarchicalTree.prototype.updateLeafNode = function (layout, shape, prev, dimensions, level, dontupdate) {\n    //let bounds: Bounds;\n    var info = layout.graphNodes[shape.id];\n    info.x = dimensions.x;\n\n    if (!(info.y && info.y > dimensions.y)) {\n      info.y = dimensions.y;\n      info.maxLevel = Math.max(level, info.maxLevel || 0);\n    } // eslint-disable-next-line max-len\n\n\n    var bounds = {\n      x: dimensions.x,\n      y: dimensions.y,\n      right: dimensions.x + dimensions.width,\n      bottom: dimensions.y + dimensions.height\n    };\n    info.maxLevel = Math.max(info.maxLevel || 0, level);\n    var translateInfo = {\n      layout: layout,\n      shape: shape,\n      shapeBounds: bounds,\n      treeBounds: bounds,\n      dim: dimensions,\n      level: level\n    };\n    this.translateSubTree(translateInfo, undefined, prev !== undefined, dontupdate);\n    return {\n      x: info.x,\n      y: info.y,\n      right: info.x + dimensions.width,\n      bottom: info.y + dimensions.height\n    };\n  };\n\n  HierarchicalTree.prototype.setUpLayoutInfo = function (layout, item) {\n    var info = {};\n    info.subTreeTranslation = 0;\n\n    if (layout.type === 'OrganizationalChart') {\n      info.tree = {\n        orientation: 'Vertical',\n        type: 'Alternate',\n        offset: 20,\n        enableRouting: true\n      };\n    } else {\n      info.tree = {\n        orientation: 'Horizontal',\n        type: 'Center',\n        enableRouting: true\n      };\n    }\n\n    info.tree.children = [];\n    info.tree.assistants = [];\n    info.tree.level = 0;\n    info.translate = true;\n    return info;\n  };\n\n  HierarchicalTree.prototype.translateSubTree = function (translateInfo, asstDif, translate, dontupdate) {\n    var layout = translateInfo.layout;\n    var shape = translateInfo.shape;\n    var shapeBounds = translateInfo.shapeBounds;\n    var treeBounds = translateInfo.treeBounds;\n    var level = translateInfo.level;\n    var dim = translateInfo.dim;\n    var info = layout.graphNodes[shape.id];\n    var firstChild = layout.nameTable[info.firstChild ? info.firstChild.child : info.tree.children[0]];\n    var firstChildInfo = firstChild ? layout.graphNodes[firstChild.id] : null;\n    var hasChild = this.hasChild(layout, shape);\n    var intersect = this.findIntersectingLevels(layout, shapeBounds, level, info.actualLevel);\n    var treeIntersect = this.findIntersectingLevels(layout, treeBounds, level, info.actualLevel);\n    var levelBounds = []; //const diff: number;\n\n    if (intersect.length && info.translate) {\n      info.intersect = intersect;\n      this.spaceLeftFromPrevSubTree(layout, shape, shapeBounds);\n      info.canMoveBy = info.diff;\n\n      if (asstDif !== undefined) {\n        info.canMoveBy = Math.min(asstDif, info.canMoveBy);\n      }\n\n      if (firstChild && firstChildInfo.canMoveBy !== undefined) {\n        if (firstChildInfo.canMoveBy >= info.canMoveBy) {\n          info.translated = true;\n        }\n\n        info.canMoveBy = Math.min(info.canMoveBy, firstChildInfo.canMoveBy);\n      }\n\n      if (translate) {\n        info.x -= info.canMoveBy;\n        info.subTreeTranslation -= info.canMoveBy;\n\n        if (hasChild) {\n          this.shiftSubordinates(layout, treeIntersect, info.canMoveBy);\n          treeBounds.x = Math.min(treeBounds.x, info.x);\n          treeBounds.right = Math.max(treeBounds.right, info.x + dim.width);\n          treeBounds.bottom = Math.max(treeBounds.bottom, info.y + dim.height);\n          treeBounds.x -= info.canMoveBy;\n          treeBounds.right -= info.canMoveBy;\n        }\n\n        if (firstChild && firstChildInfo.canMoveBy > info.canMoveBy) {\n          info.canMoveBy = firstChildInfo.canMoveBy - info.canMoveBy;\n        } else if (firstChild && info.canMoveBy !== undefined) {\n          info.canMoveBy = 0;\n        }\n      }\n    } else {\n      if (hasChild) {\n        treeBounds.x = Math.min(treeBounds.x, shapeBounds.x);\n        treeBounds.right = Math.max(treeBounds.right, shapeBounds.x + dim.width);\n        treeBounds.bottom = Math.max(treeBounds.bottom, info.y + dim.height);\n      }\n\n      if (!info.translate) {\n        info.canMoveBy = 0;\n        info.subTreeTranslation = 0;\n      }\n    }\n\n    if (!dontupdate) {\n      shapeBounds = {\n        x: info.x,\n        y: dim.y,\n        right: info.x + dim.width,\n        bottom: dim.y + dim.height\n      };\n      levelBounds.push({\n        rBounds: shapeBounds\n      });\n      this.updateRearBounds(layout, shape, levelBounds, level);\n    }\n  };\n\n  HierarchicalTree.prototype.updateRearBounds = function (layout, shape, levelBounds, level, intersect) {\n    var bnds;\n    var index;\n    var isLastLeaf = true;\n    var i;\n    var info = {}; //let firstLevel: Bounds;\n    //let lastLevel: Bounds;\n\n    var bottom;\n\n    if (shape) {\n      info = layout.graphNodes[shape.id];\n      intersect = info.intersect;\n      isLastLeaf = !info.tree.children.length && !info.tree.assistants.length;\n    }\n\n    var firstLevel = levelBounds[0].rBounds;\n    var lastLevel = levelBounds[levelBounds.length - 1].rBounds;\n\n    if (intersect && intersect.length) {\n      bnds = layout.levels[intersect[0]].rBounds;\n      bottom = bnds.bottom;\n\n      if (bnds.y < firstLevel.y) {\n        bnds.bottom = firstLevel.y;\n        levelBounds.splice(0, 0, {\n          rBounds: bnds\n        });\n      }\n\n      if (bottom > lastLevel.bottom) {\n        levelBounds.push({\n          rBounds: {\n            x: bnds.x,\n            right: bnds.right,\n            y: firstLevel.bottom,\n            bottom: bottom\n          }\n        });\n      } else {\n        bnds = layout.levels[intersect[intersect.length - 1]].rBounds;\n\n        if (isLastLeaf && bnds.bottom > lastLevel.bottom) {\n          bnds.y = lastLevel.bottom;\n          levelBounds.push({\n            rBounds: bnds\n          });\n        }\n      }\n\n      index = intersect[0];\n\n      for (i = levelBounds.length - 1; i >= 0; i--) {\n        layout.levels.splice(index, 0, levelBounds[i]);\n      }\n\n      index += levelBounds.length;\n      layout.levels.splice(index, intersect.length);\n    } else {\n      index = this.findLevel(layout, levelBounds[levelBounds.length - 1].rBounds, level);\n\n      for (i = levelBounds.length - 1; i >= 0; i--) {\n        layout.levels.splice(index, 0, levelBounds[i]);\n      }\n    }\n  };\n\n  HierarchicalTree.prototype.shiftSubordinates = function (layout, intersect, diff) {\n    var i; //Shift the sublevels by the distance diff\n\n    if (diff !== 0) {\n      for (i = 0; i < intersect.length; i++) {\n        if (layout.levels[intersect[i]].rBounds) {\n          layout.levels[intersect[i]].rBounds.x -= diff;\n          layout.levels[intersect[i]].rBounds.right -= diff;\n        }\n      }\n    }\n  };\n\n  HierarchicalTree.prototype.setDepthSpaceForAssitants = function (layout, shape, bottom, height, lev, vSpace) {\n    var info = layout.graphNodes[shape.id];\n    var asst = {};\n    var asstHeight;\n    var i;\n    var asstElement;\n    var max;\n    max = bottom; //Vertically place the assistants as alternate layout(alternatively at both right and left sides of parent)\n\n    for (i = 0; i < info.tree.assistants.length; i++) {\n      asst = layout.graphNodes[info.tree.assistants[i]];\n\n      if (asst) {\n        asst.tree.children = asst.tree.assistants = [];\n        asst.y = bottom;\n        asstElement = layout.nameTable[info.tree.assistants[i]];\n        asstHeight = asstElement.actualSize.height;\n\n        if (layout.orientation.indexOf('Left') !== -1) {\n          asstHeight = asstElement.actualSize.width;\n        }\n\n        max = bottom + asstHeight + vSpace / 2;\n        layout.maxLevel = lev + 1;\n\n        if (i % 2 === 1 && i !== info.tree.assistants.length - 1) {\n          bottom = max;\n          lev++;\n        }\n      }\n    }\n\n    return {\n      level: layout.maxLevel,\n      bottom: bottom + asstHeight + vSpace\n    };\n  };\n\n  HierarchicalTree.prototype.setBreadthSpaceForAssistants = function (layout, shape, dim, space, bottom, level) {\n    var asst = {};\n    var asstWidth; //let prevBounds: number;\n\n    var bounds;\n    var asstElement;\n    var i;\n    var info = layout.graphNodes[shape.id]; //let max: number = bottom;\n\n    var lev = level;\n    var left;\n    var diff;\n    var intersect;\n    var levelBounds = {\n      x: 0,\n      y: 0,\n      right: 0,\n      bottom: 0\n    };\n\n    for (i = 0; i < info.tree.assistants.length; i++) {\n      asst = layout.graphNodes[info.tree.assistants[i]]; //Arrange assistants at both left and right sides of parent(like alternate layout)\n      //Check - By default, distance to be left between parent and child nodes is assumed as 20.\n      //It can be modified/customized later.\n\n      if (asst) {\n        asstElement = layout.nameTable[info.tree.assistants[i]];\n        asstWidth = asstElement.actualSize.width;\n\n        if (layout.orientation.indexOf('Left') !== -1) {\n          asstWidth = asstElement.actualSize.height;\n        }\n\n        if (i % 2 === 0) {\n          left = space + dim.width / 2 - 20 - asstWidth;\n        } else {\n          left = space + dim.width / 2 + 20;\n        } //Check - What will happen if update leaf node is called? Since assistants don't have children\n\n\n        bounds = this.updateTree(layout, left, asst.y, layout.nameTable[info.tree.assistants[i]], lev + 1);\n\n        if (!this.hasChild(layout, shape)) {\n          if (i === 0) {\n            levelBounds = bounds;\n          } else {\n            this.uniteRects(levelBounds, bounds);\n          }\n        }\n\n        if (i % 2 === 0 && asst.prevBounds) {\n          if (diff === undefined) {\n            diff = asst.canMoveBy;\n          } else {\n            diff = Math.min(diff, asst.canMoveBy);\n          }\n        }\n\n        if (i % 2 === 1 || i === info.tree.assistants.length - 1) {\n          intersect = this.findIntersectingLevels(layout, bounds, lev + 1); //Update rightmost positions of known layout levels\n\n          this.updateRearBounds(layout, null, [{\n            rBounds: bounds\n          }], lev + 1, intersect);\n          lev++;\n        }\n      }\n    }\n\n    if (levelBounds) {\n      levelBounds.canMoveBy = diff;\n    }\n\n    return levelBounds;\n  };\n\n  HierarchicalTree.prototype.getDimensions = function (layout, shape, x, y, level) {\n    var width;\n    width = shape.actualSize.width;\n    var height;\n    height = shape.actualSize.height;\n\n    if (layout.orientation.indexOf('Left') !== -1) {\n      if (!level) {\n        //let temp: number;\n        var temp = x;\n        x = y;\n        y = temp;\n      }\n\n      height = shape.actualSize.width;\n      width = shape.actualSize.height;\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  };\n\n  HierarchicalTree.prototype.hasChild = function (layout, shape) {\n    //Check whether the node has children\n    var shape1 = layout.graphNodes[shape.id];\n    return shape1 ? shape1.tree.children && shape1.tree.children.length : 0;\n  };\n\n  HierarchicalTree.prototype.updateHorizontalTree = function (layout, shape, prev, x, y, level) {\n    //Get dimensions with respect to layout orientations\n    //let dimensions: Dimensions;\n    var dimensions = this.getDimensions(layout, shape, x, y, level);\n    var info = {};\n    info = layout.graphNodes[shape.id];\n    var side = info.tree.type; //let lev: number;\n\n    var lev = level;\n    var right = 0;\n    right = x;\n    var bottom = y;\n    var width;\n    var height;\n    var child;\n    var childBounds;\n    var childWidth;\n    var childHeight; //let prevBounds: Bounds;\n\n    var bounds;\n    var actBounds;\n    var maxLevel;\n    var translateSibilingsBy;\n    var canMoveBy;\n    var oldActBounds;\n    var i;\n    var childInfo;\n    var firstChildInfo;\n    var prevLayoutLevels = layout.levels.slice(0, layout.levels.length);\n\n    if (this.hasChild(layout, shape)) {\n      //let h: boolean;\n      var h = layout.orientation.indexOf('Left') !== -1 ? true : false;\n\n      for (i = 0; i < info.tree.children.length; i++) {\n        child = layout.nameTable[info.tree.children[i]];\n        width = child.actualSize.width;\n        height = child.actualSize.height;\n        childWidth = h ? height : width;\n        childHeight = h ? width : height;\n        var prevBounds = layout.levels[lev + 1] ? layout.levels[lev + 1].rBounds : null; //Update sub tree\n\n        childBounds = this.updateTree(layout, right, bottom, child, lev + 1, layout.nameTable[info.tree.children[i - 1]]);\n        childInfo = layout.graphNodes[child.id];\n        info.maxLevel = Math.max(info.maxLevel || 0, childInfo.maxLevel || 0);\n        actBounds = {\n          x: childInfo.x,\n          y: childInfo.y,\n          right: childInfo.x + childWidth,\n          bottom: childInfo.y + childHeight\n        };\n\n        if (i === 0) {\n          //Compare with previous(right most) subtree\n          bounds = {\n            x: Math.min(childInfo.x, childBounds.x),\n            y: Math.min(childInfo.y, childBounds.y),\n            right: childBounds.right,\n            bottom: childBounds.bottom\n          };\n          firstChildInfo = childInfo;\n        }\n\n        if (!oldActBounds) {\n          oldActBounds = actBounds;\n        } else {\n          oldActBounds.x = actBounds.x;\n          oldActBounds.y = actBounds.y;\n\n          if (actBounds.right > oldActBounds.right) {\n            oldActBounds.right = actBounds.right;\n          }\n\n          oldActBounds.bottom = actBounds.bottom; //oldActBounds = actBounds;\n        } //Compare with previous subtree if level of the child is greater than the level of previous sub tree\n        //Check - what will happen if level of second child is greater than current child\n\n\n        if (i === 0) {\n          info.firstChild = {\n            x: childInfo.x,\n            canMoveBy: childInfo.canMoveBy,\n            child: child.id\n          };\n        }\n\n        if (this.hasChild(layout, child)) {\n          if (!info.firstChild || info.firstChild.x >= childInfo.firstChild.x) {\n            if (childInfo.firstChild && info.firstChild.canMoveBy < childInfo.canMoveBy) {\n              canMoveBy = info.firstChild.canMoveBy;\n              childInfo.canMoveBy = canMoveBy;\n              layout.graphNodes[info.firstChild.child].canMoveBy = canMoveBy;\n              info.firstChild.canMoveBy = canMoveBy;\n            }\n\n            var canMoveValue = canMoveBy !== undefined ? canMoveBy : childInfo.canMoveBy;\n            info.firstChild = {\n              x: childInfo.firstChild.x,\n              canMoveBy: canMoveValue,\n              child: child.id\n            };\n          } else if (childInfo.firstChild && childInfo.translated && info.firstChild.canMoveBy > childInfo.canMoveBy) {\n            info.firstChild.canMoveBy = layout.graphNodes[info.firstChild.child].canMoveBy = childInfo.canMoveBy;\n          }\n        }\n\n        maxLevel = maxLevel ? Math.max(childInfo.maxLevel, maxLevel) : childInfo.maxLevel;\n        this.uniteRects(bounds, childBounds);\n\n        if (i !== 0 && !this.hasChild(layout, child) && childInfo.subTreeTranslation < 0) {\n          right = childBounds.right - childInfo.subTreeTranslation + layout.horizontalSpacing;\n        } else {\n          right = childBounds.right + layout.horizontalSpacing;\n        }\n      }\n\n      if (!isNaN(translateSibilingsBy)) {\n        firstChildInfo.canMoveBy = translateSibilingsBy;\n      }\n\n      info.mid = (firstChildInfo.x + oldActBounds.right) / 2 - dimensions.width / 2; //Set parent based on the chart type\n\n      if (side === 'Left') {\n        info.mid = actBounds.right - dimensions.width;\n      } else if (side === 'Right') {\n        info.mid = x;\n      }\n    }\n\n    return bounds;\n  };\n  /* eslint-disable */\n\n\n  HierarchicalTree.prototype.updateHorizontalTreeWithMultipleRows = function (layout, shape, prev, x, y, level) {\n    //declarations\n    var child;\n    var childInfo;\n    var childBounds;\n    var childWidth;\n    var childHeight;\n    var firstChildInfo;\n    var maxLevel;\n    var bounds;\n    var rowBounds;\n    var width;\n    var height;\n    var diff;\n    var translateSibilingsBy;\n    var fchild;\n    var maxRowWidth;\n    var j;\n    var i;\n    var k;\n    var max;\n    var leftCenter;\n    var rightCenter; //Get dimensions with respect to layout orientations\n\n    var dimensions = this.getDimensions(layout, shape, x, y, level);\n    var info = layout.graphNodes[shape.id];\n    var side = info.tree.type;\n    var lev = level;\n    var right = x;\n    var bottom = y;\n    var prevLayoutLevels = layout.levels.slice(0, layout.levels.length);\n    var minTranslation = 0;\n\n    if (this.hasChild(layout, shape)) {\n      var h = layout.orientation.indexOf('Left') !== -1 ? true : false;\n      var align = void 0;\n      var rows = this.splitChildrenInRows(layout, shape);\n      var unique = info.tree.children.length === 5 && rows[0].length === 3;\n      var leftTree = [];\n      var rightTree = [];\n\n      if (!unique) {\n        this.splitRows(rows, leftTree, rightTree);\n      } else {\n        rightTree = rows;\n      }\n\n      var treeInfo = {\n        leftTree: leftTree,\n        rows: rows,\n        rightTree: rightTree,\n        dimensions: dimensions\n      };\n      var rightMost = this.updateLeftTree(layout, treeInfo, shape, x, bottom, lev);\n      bounds = treeInfo.bounds;\n      var rightX = void 0;\n      var center = (rightMost || 0) + (rightMost !== undefined ? layout.horizontalSpacing / 2 : 0);\n\n      if (rightMost !== undefined) {\n        info.mid = center - dimensions.width / 2;\n        rightX = rightMost + layout.horizontalSpacing;\n      }\n\n      bottom = y;\n      var rightBounds = void 0;\n      rightBounds = [];\n\n      for (i = 0; i < rightTree.length; i++) {\n        if (rows[i].length % 2 === 1 && i === rightTree.length - 1 || unique) {\n          right = x;\n        } else {\n          right = rightX || x;\n        }\n\n        if (i !== 0) {\n          bottom = rightBounds[i - 1].bottom + layout.verticalSpacing;\n        }\n\n        for (j = 0; j < rightTree[i].length; j++) {\n          child = layout.nameTable[rightTree[i][j]];\n          width = child.actualSize.width;\n          height = child.actualSize.height;\n          childWidth = h ? height : width;\n          childHeight = h ? width : height; //Update sub tree\n\n          childInfo = layout.graphNodes[child.id];\n          childInfo.actualLevel = lev + 1 + i;\n\n          if (j === 0 && leftTree[i] && leftTree[i].length) {\n            childInfo.translate = false;\n          }\n\n          if (unique && i === 1) {\n            if (j === 0 && leftCenter + childWidth + layout.horizontalSpacing <= rightCenter) {\n              align = true;\n              right = leftCenter - childWidth / 2;\n            }\n\n            if (align && j === 1) {\n              right = rightCenter - childWidth / 2;\n            }\n          }\n\n          childBounds = this.updateTree(layout, right, bottom, child, lev + 1, layout.nameTable[rightTree[i][j - 1]]);\n\n          if (unique && j <= 2 && i === 0) {\n            if (j === 1) {\n              leftCenter = childBounds.x - layout.horizontalSpacing / 2;\n              rightCenter = childBounds.x + childWidth + layout.horizontalSpacing / 2;\n            }\n          }\n\n          if (j === 0) {\n            rightBounds[i] = {\n              x: childBounds.x,\n              y: childBounds.y,\n              right: childBounds.right,\n              bottom: childBounds.bottom\n            };\n          } else {\n            this.uniteRects(rightBounds[i], childBounds);\n          }\n\n          if (!bounds) {\n            bounds = {\n              x: rightBounds[i].x,\n              y: rightBounds[i].y,\n              right: rightBounds[i].right,\n              bottom: rightBounds[i].bottom\n            };\n          }\n\n          this.uniteRects(bounds, rightBounds[i]);\n          right = childBounds.right + layout.horizontalSpacing;\n\n          if (!info.firstChild || (i === rightTree.length - 1 && rows[i].length % 2 === 1 || unique) && j === 0 && childInfo.canMoveBy !== undefined && minTranslation > childInfo.canMoveBy) {\n            minTranslation = Math.min(minTranslation, childInfo.canMoveBy || 0);\n            info.firstChild = {\n              x: childInfo.x,\n              child: child.id,\n              canMoveBy: childInfo.canMoveBy\n            };\n          }\n\n          treeInfo.leftCenter = leftCenter;\n          treeInfo.rightCenter = rightCenter;\n          treeInfo.align = align;\n          treeInfo.level = lev;\n          treeInfo.rightBounds = rightBounds;\n          this.alignRowsToCenter(layout, i, shape, treeInfo, rightX);\n        }\n      }\n    }\n\n    return bounds;\n  };\n  /* eslint-enable */\n\n\n  HierarchicalTree.prototype.updateLeftTree = function (layout, treeInfo, shape, x, bottom, lev) {\n    var leftTree = treeInfo.leftTree;\n    var info = layout.graphNodes[shape.id];\n    var right;\n    var leftBounds = [];\n    var minTranslation;\n    var rightMost;\n    var childBounds;\n    var bounds;\n    var h = layout.orientation.indexOf('Left') !== -1 ? true : false; //Arrange left side\n\n    for (var i = 0; i < leftTree.length && leftTree[i].length; i++) {\n      right = x;\n\n      if (leftBounds[i - 1]) {\n        bottom = leftBounds[i - 1].bottom + layout.verticalSpacing;\n      }\n\n      for (var j = 0; j < leftTree[i].length; j++) {\n        var child = layout.nameTable[leftTree[i][j]];\n        var childWidth = h ? child.actualSize.height : child.actualSize.width;\n        var childHeight = h ? child.actualSize.width : child.actualSize.height; //Update sub tree\n\n        var childInfo = layout.graphNodes[child.id];\n        childInfo.actualLevel = lev + 1 + i;\n        childBounds = this.updateTree(layout, right, bottom, child, lev + 1, layout.nameTable[leftTree[i][j - 1]]);\n\n        if (j === 0) {\n          leftBounds[i] = {\n            x: childBounds.x,\n            y: childBounds.y,\n            right: childBounds.right,\n            bottom: childBounds.bottom\n          };\n        } else {\n          this.uniteRects(leftBounds[i], childBounds);\n        }\n\n        if (i === 0 && j === 0) {\n          minTranslation = childInfo.canMoveBy;\n          info.firstChild = {\n            x: childInfo.x,\n            child: child.id,\n            canMoveBy: childInfo.canMoveBy\n          };\n        } else if (j === 0 && childInfo.canMoveBy !== undefined && minTranslation > childInfo.canMoveBy) {\n          minTranslation = Math.min(minTranslation, childInfo.canMoveBy || 0);\n          info.firstChild = {\n            x: childInfo.x,\n            child: child.id,\n            canMoveBy: childInfo.canMoveBy\n          };\n        }\n\n        right = childBounds.right + layout.horizontalSpacing;\n      }\n\n      if (i === 0) {\n        rightMost = leftBounds[i].right;\n      } else {\n        rightMost = Math.max(rightMost, leftBounds[i].right);\n      }\n    } //Translate to same positions\n\n\n    for (var i = 0; i < leftTree.length && leftTree[i].length; i++) {\n      if (rightMost !== leftBounds[i].right) {\n        var diff = rightMost - leftBounds[i].right;\n\n        for (var j = 0; j < leftTree[i].length; j++) {\n          var element = layout.nameTable[leftTree[i][j]];\n          var elementInfo = layout.graphNodes[leftTree[i][j]];\n          elementInfo.x += diff;\n        } //leftBounds[i].x += diff;\n        //leftBounds[i].right += diff;\n\n      }\n\n      if (i === 0) {\n        bounds = {\n          x: leftBounds[0].x,\n          y: leftBounds[0].y,\n          right: leftBounds[0].right,\n          bottom: leftBounds[0].bottom\n        };\n      } else {\n        this.uniteRects(bounds, leftBounds[i]);\n      }\n    }\n\n    treeInfo.bounds = bounds;\n    return rightMost;\n  };\n\n  HierarchicalTree.prototype.alignRowsToCenter = function (layout, i, shape, treeInfo, rightX) {\n    var max;\n    var centered;\n    var diff;\n    var info = layout.graphNodes[shape.id];\n    var rows = treeInfo.rows;\n    var rightTree = treeInfo.rightTree;\n    var leftCenter = treeInfo.leftCenter;\n    var rightCenter = treeInfo.rightCenter;\n    var align = treeInfo.align;\n    var rightBounds = treeInfo.rightBounds;\n    var dimensions = treeInfo.dimensions;\n    var lev = treeInfo.level;\n    var unique = info.tree.children.length === 5 && rows[0].length === 3;\n\n    if (unique && i === 1) {\n      max = rightBounds[0].right - rightBounds[0].x >= rightBounds[1].right - rightBounds[1].x ? 0 : 1;\n    }\n\n    if (i === rows.length - 1) {\n      if (rows[i].length % 2 === 1 || unique && i === 1) {\n        centered = rightTree[i][Math.floor(rightTree[i].length / 2)]; //let centerObjct: INode;\n\n        var centerObjct = layout.nameTable[centered]; //let childDimension: Dimensions;\n\n        var centeredX = layout.graphNodes[centered].x;\n        var centeredY = layout.graphNodes[centered].y;\n        var childDimension = this.getDimensions(layout, centerObjct, centeredX, centeredY, lev + 1);\n        diff = undefined;\n\n        if (!align && unique) {\n          if (max === 1) {\n            i = 0;\n          }\n\n          diff = (rightBounds[max].x + rightBounds[max].right) / 2 - (rightBounds[i].x + rightBounds[i].right) / 2;\n\n          if (i === 0) {\n            info.mid += diff;\n          }\n        } else if (!unique && rightX !== undefined) {\n          diff = rightX - layout.horizontalSpacing / 2 - (centeredX + childDimension.width / 2);\n        }\n\n        if (diff !== undefined) {\n          this.updateRearBoundsOfTree(layout, rightTree[i], diff, dimensions);\n        }\n\n        if (unique) {\n          info.mid = (rightCenter + leftCenter) / 2 + (i === 0 ? diff : 0) - dimensions.width / 2;\n        }\n\n        if (info.mid === undefined && layout.graphNodes[centered]) {\n          info.mid = centeredX;\n        }\n\n        align = false;\n        i++;\n      }\n    }\n  };\n\n  HierarchicalTree.prototype.updateRearBoundsOfTree = function (layout, rightTree, diff, dimensions) {\n    for (var j = 0; j < rightTree.length; j++) {\n      var childInfo = layout.graphNodes[rightTree[j]]; //let child: INode = layout.nameTable[rightTree[j]];\n\n      childInfo.x += diff;\n      childInfo.canMoveBy += diff;\n\n      if (j === rightTree.length - 1) {\n        //removed child dimensions call calculation, since that is not used\n        var childBnds = {\n          x: childInfo.x,\n          y: childInfo.y,\n          right: childInfo.x + dimensions.width,\n          bottom: childInfo.y + dimensions.height\n        };\n        var intersect = this.findIntersectingLevels(layout, childBnds, childInfo.actualLevel);\n        this.updateRearBounds(layout, null, [{\n          rBounds: childBnds\n        }], childInfo.actualLevel, intersect);\n      }\n    }\n  };\n\n  HierarchicalTree.prototype.splitRows = function (rows, leftTree, rightTree) {\n    for (var i = 0; i < rows.length; i++) {\n      leftTree[i] = [];\n      rightTree[i] = [];\n      var half = void 0;\n      half = rows[i].length;\n\n      if (rows[i].length % 2 !== 1) {\n        half = Math.ceil(rows[i].length / 2);\n\n        for (var k = 0; k < half; k++) {\n          leftTree[i].push(rows[i][k]);\n        }\n      }\n\n      for (var j = leftTree[i].length; j < rows[i].length; j++) {\n        rightTree[i].push(rows[i][j]);\n      }\n    }\n  };\n\n  HierarchicalTree.prototype.updateVerticalTree = function (layout, shape, x, y, level, dontUpdate) {\n    //declarations\n    var child;\n    var childInfo;\n    var childBounds;\n    var childWidth;\n    var childHeight;\n    var prevBounds;\n    var bounds;\n    var actBounds;\n    var oddBounds;\n    var evenBounds; //let dimensions: Dimensions = this.getDimensions(layout, shape, x, y, level);\n\n    var info = layout.graphNodes[shape.id];\n    var firstChild = layout.nameTable[info.tree.children[0]];\n    var h = layout.orientation.indexOf('Left') !== -1 ? true : false;\n    var factor = info.tree.type === 'Left' ? -1 : 0;\n    var right = x;\n    var bottom = y;\n    var lev = level;\n    var i;\n    var intersect;\n    var type;\n    var levels = [];\n    var oddLevels = [];\n    var canMoveBy; //let diff: number;\n\n    for (i = 0; i < info.tree.children.length; i++) {\n      if (info.tree.type === 'Alternate') {\n        //arrange at both left and right\n        type = i % 2 === 0 && info.tree.children.length > 2 ? 'Left' : 'Right';\n        factor = i % 2 === 0 && info.tree.children.length > 2 ? -1 : 0;\n      }\n\n      right = x + this.findOffset(layout, shape, info, type);\n      child = layout.nameTable[info.tree.children[i]];\n      childWidth = h ? child.actualSize.height : child.actualSize.width;\n      childHeight = h ? child.actualSize.width : child.actualSize.height; //Update sub tree\n\n      childBounds = this.updateTree(layout, right + factor * childWidth, bottom, child, level + 1, undefined, true);\n      childInfo = layout.graphNodes[child.id];\n      actBounds = {\n        x: childInfo.x,\n        y: childInfo.y,\n        right: childInfo.x + childWidth,\n        bottom: childInfo.y + childHeight\n      };\n\n      if (i === 0) {\n        this.uniteRects(childBounds, actBounds);\n        bounds = childBounds;\n      } else {\n        this.uniteRects(bounds, childBounds);\n      } //Check and adjust the space left from previous subtree/sibling\n\n\n      if (childInfo.prevBounds && !(info.tree.type === 'Alternate' && i % 2 === 1 && info.tree.children.length > 2)) {\n        canMoveBy = canMoveBy !== undefined ? Math.min(childInfo.canMoveBy, canMoveBy) : childInfo.canMoveBy;\n      } //Max level of the subtree node\n\n\n      info.maxLevel = Math.max(info.maxLevel || 0, childInfo.maxLevel || 0);\n\n      if (!(info.tree.type === 'Alternate' && info.tree.children.length > 2 && i % 2 === 0)) {\n        if (info.tree.type === 'Alternate' && info.tree.children.length > 2) {\n          //alternate - arrange children with even index(0,2,4,6,..) at the next level\n          bottom = Math.max(childBounds.bottom, prevBounds.bottom) + layout.verticalSpacing / 2;\n        } else {\n          // left/right - arrange next child at the nect level(bottom)\n          bottom = childBounds.bottom + layout.verticalSpacing / 2;\n        }\n\n        level = info.maxLevel;\n        levels.push({\n          rBounds: actBounds\n        });\n\n        if (!evenBounds) {\n          evenBounds = {\n            x: childInfo.x,\n            y: childInfo.y,\n            right: childInfo.x + childWidth,\n            bottom: childInfo.y + childHeight\n          };\n        } else {\n          this.uniteRects(evenBounds, actBounds);\n        }\n\n        if (childInfo.levelBounds) {\n          levels = levels.concat(childInfo.levelBounds);\n        }\n      } else {\n        if (i !== 0) {\n          bottom = prevBounds.bottom + layout.verticalSpacing / 2;\n        }\n\n        oddLevels.push({\n          rBounds: actBounds\n        });\n\n        if (childInfo.levelBounds) {\n          oddLevels = oddLevels.concat(childInfo.levelBounds);\n        }\n      }\n\n      if (i === 0) {\n        info.firstChild = {\n          x: childInfo.x,\n          canMoveBy: childInfo.canMoveBy,\n          child: child.id\n        };\n      }\n\n      if (this.hasChild(layout, child)) {\n        if (!info.firstChild || info.firstChild.x >= childInfo.firstChild.x) {\n          if (childInfo.firstChild && info.firstChild.canMoveBy < childInfo.canMoveBy) {\n            var canMoveBy_1 = info.firstChild.canMoveBy;\n            childInfo.canMoveBy = canMoveBy_1;\n            layout.graphNodes[info.firstChild.child].canMoveBy = canMoveBy_1;\n            info.firstChild.canMoveBy = canMoveBy_1;\n          }\n\n          info.firstChild = {\n            x: childInfo.firstChild.x,\n            canMoveBy: canMoveBy !== undefined ? canMoveBy : childInfo.canMoveBy,\n            child: child.id\n          };\n        } else if (childInfo.firstChild && childInfo.translated && info.firstChild.canMoveBy > childInfo.canMoveBy) {\n          info.firstChild.canMoveBy = layout.graphNodes[info.firstChild.child].canMoveBy = childInfo.canMoveBy;\n        }\n      }\n\n      prevBounds = actBounds;\n    } //To set level bounds(right most position of levels)\n\n\n    if (!dontUpdate) {\n      if (info.tree.type === 'Alternate' && info.tree.children.length > 2) {\n        oddBounds = {\n          x: oddLevels[0].rBounds.x,\n          y: oddLevels[0].rBounds.y,\n          right: oddLevels[oddLevels.length - 1].rBounds.right,\n          bottom: oddLevels[oddLevels.length - 1].rBounds.bottom\n        };\n        intersect = this.findIntersectingLevels(layout, oddBounds, lev + 1);\n        this.updateRearBounds(layout, null, oddLevels, lev + 1, intersect);\n      }\n\n      intersect = this.findIntersectingLevels(layout, evenBounds || bounds, lev + 1);\n      this.updateRearBounds(layout, null, evenBounds ? levels : [{\n        rBounds: bounds\n      }], lev + 1, intersect);\n    } else {\n      info.levelBounds = levels;\n    }\n\n    if (!isNaN(canMoveBy)) {\n      layout.graphNodes[firstChild.id].canMoveBy = canMoveBy;\n    }\n\n    info.childBounds = bounds;\n    info.mid = x;\n    return bounds;\n  };\n\n  HierarchicalTree.prototype.splitChildrenInRows = function (layout, shape) {\n    //let info: LayoutInfo;\n    var info = layout.graphNodes[shape.id];\n    var column;\n    column = 4;\n    var rows = [];\n    var childNodes;\n    childNodes = info.tree.children.length;\n    var children = this.extend(info.tree.children);\n\n    if (info.tree.rows) {\n      //let count: number;\n      var count = info.tree.children.length; //let columns: number;\n\n      var columns = info.tree.rows;\n\n      if (columns % 2 === 0) {\n        column = columns;\n      } else {\n        column = columns - 1;\n      }\n    } else if (info.tree.children.length === 3 || info.tree.children.length === 4) {\n      column = 2;\n    } else if (info.tree.children.length === 5) {\n      column = 3;\n    }\n\n    while (childNodes > 0) {\n      rows[rows.length] = children.splice(0, column);\n      childNodes -= column;\n\n      if (childNodes < column) {\n        if (childNodes % 2 === 0) {\n          column = childNodes;\n        } else if (childNodes !== 1) {\n          column = childNodes - 1;\n        }\n\n        if (childNodes < column) {\n          column = childNodes;\n        }\n      }\n    }\n\n    return rows;\n  };\n\n  HierarchicalTree.prototype.extend = function (temp) {\n    var i;\n    var dummy = [];\n\n    for (i = 0; i < temp.length; i++) {\n      dummy[i] = temp[i];\n    }\n\n    return dummy;\n  };\n\n  HierarchicalTree.prototype.findOffset = function (layout, shape, info, type) {\n    var offset = 0;\n    var space = layout.orientation.indexOf('Left') !== -1 ? shape.actualSize.height : shape.actualSize.width;\n    var treeType = type ? type : info.tree.type;\n    offset = info.tree.offset || 20;\n\n    if (info.tree.type === 'Alternate') {\n      if (offset >= layout.horizontalSpacing) {\n        offset = layout.horizontalSpacing / 2;\n      }\n    }\n\n    switch (treeType) {\n      case 'Left':\n        offset = space / 2 - offset;\n        break;\n\n      case 'Right':\n        offset = offset + space / 2;\n        break;\n    }\n\n    return offset;\n  };\n\n  HierarchicalTree.prototype.uniteRects = function (rect1, rect2) {\n    //Unite two rects\n    rect1.x = Math.min(rect1.x, rect2.x);\n    rect1.right = Math.max(rect1.right, rect2.right);\n    rect1.bottom = Math.max(rect1.bottom, rect2.bottom);\n  };\n\n  HierarchicalTree.prototype.spaceLeftFromPrevSubTree = function (layout, shape, bounds) {\n    //let info: LayoutInfo;\n    var info = layout.graphNodes[shape.id];\n    var dif;\n    var prevBounds; //let intersect: number[]; let k: number;\n    //let space: number;\n\n    var space = layout.horizontalSpacing; //Find the minimum distance to move towards previous sub tree\n\n    for (var k = 0; k < info.intersect.length; k++) {\n      prevBounds = layout.levels[info.intersect[k]].rBounds;\n      dif = bounds.x - (prevBounds.right + space);\n\n      if (info.diff === undefined || dif < info.diff) {\n        info.diff = dif;\n        info.prevBounds = layout.levels[info.intersect[k]].rBounds;\n      }\n    }\n  };\n\n  HierarchicalTree.prototype.findIntersectingLevels = function (layout, bounds, level, actualLevel) {\n    //intersecting with exact Level\n    //let bnds: Bounds;\n    var bnds = {\n      x: bounds.x,\n      y: bounds.y,\n      right: bounds.right,\n      bottom: bounds.bottom\n    };\n    bnds.y -= layout.verticalSpacing / 2;\n    bnds.bottom += layout.verticalSpacing / 2; //let intersectingLevels: number[];\n\n    var intersectingLevels = [];\n    var rBounds;\n    var l;\n    l = actualLevel !== undefined ? actualLevel : level;\n    rBounds = layout.levels[l] ? layout.levels[l].rBounds : null; //Performance - We can consider only the intersecting levels\n\n    do {\n      if (rBounds && (bnds.y < rBounds.y && bnds.bottom > rBounds.y || bnds.y < rBounds.bottom && rBounds.bottom < bnds.bottom || bnds.y >= rBounds.y && bnds.bottom <= rBounds.bottom || bnds.y < rBounds.y && bnds.bottom > rBounds.bottom)) {\n        var index = 0;\n        intersectingLevels.splice(index, 0, l);\n      } else if (rBounds && rBounds.bottom < bnds.y) {\n        break;\n      }\n\n      l--;\n      rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n    } while (l >= 0);\n\n    l = (actualLevel !== undefined ? actualLevel : level) + 1;\n    rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n\n    do {\n      if (rBounds && (bnds.y < rBounds.y && bnds.bottom > rBounds.y || bnds.y < rBounds.bottom && rBounds.bottom < bnds.bottom || bnds.y >= rBounds.y && bnds.bottom <= rBounds.bottom || bnds.y < rBounds.y && bnds.bottom > rBounds.bottom)) {\n        intersectingLevels.push(l);\n      } else if (rBounds && rBounds.y > bnds.bottom) {\n        break;\n      }\n\n      l++;\n      rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n    } while (l <= layout.levels.length);\n\n    return intersectingLevels;\n  };\n\n  HierarchicalTree.prototype.findLevel = function (layout, bounds, level) {\n    //let bnds: Bounds;\n    var bnds = bounds;\n    var l;\n    l = 0;\n    var rBounds;\n    rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n\n    while (l < layout.levels.length) {\n      if (rBounds && bnds.bottom < rBounds.y) {\n        return l;\n      } else {\n        l++;\n      }\n\n      rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n    }\n\n    return l;\n  };\n\n  HierarchicalTree.prototype.getParentNode = function (layout, node) {\n    //Return the first parent node\n    return layout.nameTable[layout.nameTable[node.inEdges[0]].sourceID];\n  };\n\n  HierarchicalTree.prototype.updateEdges = function (layout, node, depth, action, nodes) {\n    //let layoutInfo: LayoutInfo;\n    var layoutInfo = layout.graphNodes[node.id];\n    var j;\n\n    if (node.outEdges && node.outEdges.length && (node.isExpanded || action === DiagramAction.Render)) {\n      for (j = 0; j < node.outEdges.length; j++) {\n        //let edge: INode;\n        var edge = layout.nameTable[layout.nameTable[node.outEdges[j]].targetID];\n\n        if (edge && !edge.excludeFromLayout) {\n          if (layoutInfo.tree.children.indexOf(edge.id) === -1) {\n            layoutInfo.tree.children.push(edge.id);\n          }\n\n          if (edge.outEdges && edge.outEdges.length && edge.isExpanded) {\n            layoutInfo.tree.hasSubTree = true;\n          }\n\n          this.updateEdges(layout, edge, depth + 1, action, nodes);\n        }\n      }\n    } //set level info\n\n\n    layoutInfo.tree.level = depth; //By default, orientation is horizontal for nested trees\n\n    if (layoutInfo.tree.hasSubTree) {\n      layoutInfo.tree.orientation = 'Horizontal';\n      layoutInfo.tree.type = 'Center';\n    } //Customizing assistants and children collection\n    //Performance-Instead of reading the method everytime, we can set once and can reuse that\n\n\n    if ((layout.getLayoutInfo || layout.layoutInfo) && layout.type === 'OrganizationalChart') {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      layout.getLayoutInfo ? layout.getLayoutInfo(node, layoutInfo.tree) : updateLayoutValue(layoutInfo.tree, layout.layoutInfo, nodes, node);\n\n      if (layoutInfo.tree.type === 'Balanced' && layoutInfo.tree.hasSubTree) {\n        layoutInfo.tree.type = 'Center';\n        layoutInfo.tree.orientation = 'Horizontal';\n      }\n    }\n\n    if (layout.level && layoutInfo.tree.type !== 'Alternate' && depth >= layout.level) {\n      layoutInfo.tree.hasSubTree = false;\n    }\n  };\n  /* eslint-disable */\n\n\n  HierarchicalTree.prototype.updateAnchor = function (layout, bounds, viewPort) {\n    var node;\n    var fixedNode;\n    var width = 0;\n    var height = 0;\n    var mod = 0;\n    var yValue = 0;\n    var viewPortBounds = new Rect(0, 0, viewPort.x, viewPort.y); //let layoutBounds: Rect;\n\n    var layoutBounds = layout.bounds ? layout.bounds : viewPortBounds;\n    var orientation = layout.orientation; //Anchor based on fixed nodes\n\n    if (layout.fixedNode) {\n      fixedNode = layout.nameTable[layout.fixedNode];\n      width = fixedNode.actualSize.width;\n      height = fixedNode.actualSize.height;\n      layout.anchorX = fixedNode.offsetX;\n      layout.anchorY = fixedNode.offsetY;\n      var pivot = fixedNode.pivot;\n      layout.anchorX += layout.orientation === 'RightToLeft' ? width * pivot.x : -width * pivot.x;\n      layout.anchorY += layout.orientation === 'BottomToTop' ? height * pivot.y : -height * pivot.y;\n      node = fixedNode;\n      mod = 0;\n\n      while (node.inEdges.length) {\n        node = this.getParentNode(layout, node);\n        mod += layout.graphNodes[node.id].subTreeTranslation || 0;\n      }\n\n      if (layout.orientation.indexOf('Left') !== -1) {\n        yValue = layout.graphNodes[fixedNode.id].y; // eslint-disable-next-line\n\n        orientation === 'LeftToRight' ? layout.anchorX -= yValue : layout.anchorX += yValue;\n        layout.anchorY -= layout.graphNodes[fixedNode.id].x + mod;\n      } else {\n        yValue = layout.graphNodes[fixedNode.id].y; // eslint-disable-next-line\n\n        layout.anchorX -= layout.graphNodes[fixedNode.id].x + mod;\n        orientation === 'TopToBottom' ? layout.anchorY -= yValue : layout.anchorY += yValue;\n      }\n    } else {\n      if (orientation === 'TopToBottom' || orientation === 'BottomToTop') {\n        switch (layout.horizontalAlignment) {\n          case 'Left':\n            layout.anchorX = layoutBounds.x - bounds.x + layout.margin.left;\n            break;\n\n          case 'Right':\n            layout.anchorX = layoutBounds.x + layoutBounds.width - layout.margin.right - bounds.right;\n            break;\n\n          case 'Auto':\n          case 'Center':\n            layout.anchorX = layoutBounds.x + layoutBounds.width / 2 - (bounds.x + bounds.right) / 2;\n            break;\n        }\n\n        switch (layout.verticalAlignment) {\n          case 'Auto':\n          case 'Top':\n            var top_1;\n            top_1 = layoutBounds.y + layout.margin.top;\n            layout.anchorY = orientation === 'TopToBottom' ? top_1 : bounds.bottom + top_1;\n            break;\n\n          case 'Bottom':\n            var bottom = void 0;\n            bottom = layoutBounds.y + layoutBounds.height - layout.margin.bottom;\n            layout.anchorY = orientation === 'TopToBottom' ? bottom - bounds.bottom : bottom;\n            break;\n\n          case 'Center':\n            var center = void 0;\n            center = layoutBounds.y + layoutBounds.height / 2;\n            layout.anchorY = layout.orientation === 'TopToBottom' ? center - (bounds.y + bounds.bottom) / 2 : center + (bounds.y + bounds.bottom) / 2;\n            break;\n        }\n      } else {\n        switch (layout.horizontalAlignment) {\n          case 'Auto':\n          case 'Left':\n            var left = void 0;\n            left = layoutBounds.x + layout.margin.left;\n            layout.anchorX = orientation === 'LeftToRight' ? left : bounds.bottom + left;\n            break;\n\n          case 'Right':\n            var right = void 0;\n            right = layoutBounds.x + layoutBounds.width - layout.margin.right;\n            layout.anchorX = orientation === 'LeftToRight' ? right - bounds.bottom : right;\n            break;\n\n          case 'Center':\n            var center = void 0;\n            center = layoutBounds.width / 2 + layoutBounds.x;\n            layout.anchorX = layout.orientation === 'LeftToRight' ? center - (bounds.y + bounds.bottom) / 2 : center + (bounds.y + bounds.bottom) / 2;\n            break;\n        }\n\n        switch (layout.verticalAlignment) {\n          case 'Top':\n            layout.anchorY = layoutBounds.y + layout.margin.top - bounds.x;\n            break;\n\n          case 'Auto':\n          case 'Center':\n            layout.anchorY = layoutBounds.y + layoutBounds.height / 2 - (bounds.right + bounds.x) / 2;\n            break;\n\n          case 'Bottom':\n            layout.anchorY = layoutBounds.y + layoutBounds.height - layout.margin.bottom - bounds.right;\n            break;\n        }\n      }\n    }\n  };\n  /* eslint-enable */\n\n\n  HierarchicalTree.prototype.updateConnectors = function (layout, node, level) {\n    var i; //let info: LayoutInfo;\n    //let nodeWidth: number; let nodeHeight: number; let targetWidth: number; let targetHeight: number;\n    //let length: number; let offsetLen: number; let points: PointModel[];\n    //let segments: ConnSegments;\n\n    var target;\n    var conn; //Route out edges\n\n    var info = layout.graphNodes[node.id];\n    var direction;\n\n    if (node.outEdges.length) {\n      for (i = 0; i < node.outEdges.length; i++) {\n        conn = layout.nameTable[node.outEdges[i]];\n        conn.points = [];\n        target = layout.nameTable[conn.targetID];\n\n        if (conn.visible) {\n          conn.visited = true;\n\n          if (layout.getConnectorSegments) {\n            var segments = layout.getConnectorSegments(conn);\n          } else {\n            if (info && info.tree.children.indexOf(conn.targetID) !== -1) {\n              conn.segments = [];\n\n              if (layout.type === 'OrganizationalChart' && conn.type === 'Orthogonal') {\n                this.updateSegments(layout, conn, node, target, i);\n              }\n            }\n          }\n\n          if (target && (target.isExpanded || this.hasChild(layout, target))) {\n            this.updateConnectors(layout, target, level + 1);\n          }\n        }\n      }\n    }\n\n    if (info && info.tree.assistants.length) {\n      //In-Edge routing of assistant nodes\n      for (i = 0; i < info.tree.assistants.length; i++) {\n        target = layout.nameTable[info.tree.assistants[i]];\n        conn = layout.nameTable[target.inEdges[0]];\n        this.get3Points(layout, node, target, conn);\n\n        if (target.isExpanded || this.hasChild(layout, target)) {\n          this.updateConnectors(layout, target, level + 1);\n        }\n      }\n    }\n  };\n\n  HierarchicalTree.prototype.updateSegments = function (layout, conn, node, target, i) {\n    var info = layout.graphNodes[node.id]; //Connector routing - Horizontal layout orientation\n\n    if (info.tree.assistants.length) {\n      //Route in-edge of child node, if the parent has assistant\n      this.updateSegmentsForHorizontalOrientation(layout, node, target, conn);\n    } else {\n      //Route in-edge of child node\n      if (info.tree.orientation === 'Horizontal' && info.tree.type === 'Balanced') {\n        this.updateSegmentsForBalancedTree(layout, conn, node, target, i);\n      } else {\n        if (info.tree.orientation === 'Horizontal') {\n          this.updateSegmentsForHorizontalOrientation(layout, node, target, conn);\n        } else {\n          if (info.tree.offset < 5) {\n            this.get5Points(layout, node, target, conn);\n          } else {\n            this.get3Points(layout, node, target, conn);\n          }\n        }\n      }\n    }\n  };\n\n  HierarchicalTree.prototype.updateSegmentsForBalancedTree = function (layout, connector, node, target, i) {\n    var info = layout.graphNodes[node.id];\n    var center;\n    var relative;\n\n    if (info.tree.children.length === 5 && i > 2) {\n      relative = info.tree.children[1];\n\n      if (isNaN(layout.graphNodes[relative].treeWidth)) {\n        layout.graphNodes[relative].treeWidth = layout.nameTable[relative].actualSize.width;\n      }\n\n      var factor = i !== 3 ? 1 : -1;\n\n      if (layout.orientation.indexOf('Left') !== -1) {\n        center = layout.nameTable[relative].offsetY - layout.graphNodes[relative].treeWidth / 2 - layout.verticalSpacing * factor / 2;\n      } else {\n        var center_1 = layout.nameTable[relative].offsetX + layout.graphNodes[relative].treeWidth / 2 + layout.horizontalSpacing * factor / 2;\n      }\n\n      this.getSegmentsForMultipleRows(layout, node, target, connector);\n    } else {\n      if (info.tree.children.length > 5) {\n        if (i < 4 || i < info.tree.rows) {\n          this.getSegmentsForMultipleRows(layout, node, target, connector);\n        } else {\n          this.updateSegmentsForHorizontalOrientation(layout, node, target, connector);\n        }\n      } else if (info.tree.children.length === 4) {\n        if (i < 2 || i < info.tree.rows) {\n          this.getSegmentsForMultipleRows(layout, node, target, connector);\n        } else {\n          this.updateSegmentsForHorizontalOrientation(layout, node, target, connector);\n        }\n      } else {\n        this.getSegmentsForMultipleRows(layout, node, target, connector);\n      }\n    }\n  };\n\n  HierarchicalTree.prototype.get3Points = function (layout, node, target, connector) {\n    var points = [];\n    var nodeBounds = this.getBounds(node);\n    var targetBounds = this.getBounds(target);\n\n    if (layout.orientation.indexOf('Top') !== -1) {\n      var startingPoint = layout.orientation.indexOf('Top') === 0 ? nodeBounds.bottomCenter : nodeBounds.topCenter;\n      var endPoint = node.offsetX > target.offsetX ? targetBounds.middleRight : targetBounds.middleLeft;\n      points.push(startingPoint, {\n        x: nodeBounds.bottomCenter.x,\n        y: endPoint.y\n      }, endPoint);\n    } else {\n      var startingPoint = layout.orientation.indexOf('Left') === 0 ? nodeBounds.middleRight : nodeBounds.middleLeft;\n      var endPoint = node.offsetY > target.offsetY ? targetBounds.bottomCenter : targetBounds.topCenter;\n      points.push(startingPoint, {\n        x: targetBounds.bottomCenter.x,\n        y: nodeBounds.middleRight.y\n      }, endPoint);\n    }\n\n    this.getSegmentsFromPoints(points, connector);\n  };\n\n  HierarchicalTree.prototype.get5Points = function (layout, node, target, connector) {\n    var points = []; //let layoutprop: Layout;\n\n    var nodeBounds = this.getBounds(node);\n    var targetBounds = this.getBounds(target); //let info: LayoutInfo = layout.graphNodes[node.id];\n\n    var startingPoint;\n    var endPoint;\n    var horizontalSpacing;\n    var verticalSpacing;\n\n    if (layout.orientation.indexOf('Top') !== -1) {\n      startingPoint = node.offsetY < target.offsetY ? nodeBounds.bottomCenter : nodeBounds.topCenter;\n      verticalSpacing = layout.verticalSpacing / 4 * (node.offsetY < target.offsetY ? 1 : -1);\n      horizontalSpacing = layout.horizontalSpacing / 2 * (node.offsetX > target.offsetX ? 1 : -1);\n      endPoint = node.offsetX > target.offsetX ? targetBounds.middleRight : targetBounds.middleLeft;\n      points.push(startingPoint, {\n        x: startingPoint.x,\n        y: startingPoint.y + verticalSpacing\n      }, {\n        x: endPoint.x + horizontalSpacing,\n        y: startingPoint.y + verticalSpacing\n      }, {\n        x: endPoint.x + horizontalSpacing,\n        y: endPoint.y\n      }, endPoint);\n    } else {\n      startingPoint = node.offsetX > target.offsetX ? nodeBounds.middleLeft : nodeBounds.middleRight;\n      endPoint = node.offsetY > target.offsetY ? targetBounds.bottomCenter : targetBounds.topCenter;\n      horizontalSpacing = layout.horizontalSpacing / 4 * (node.offsetX < target.offsetX ? 1 : -1);\n      verticalSpacing = layout.verticalSpacing / 2 * (node.offsetY > target.offsetY ? 1 : -1);\n      points.push(startingPoint, {\n        x: startingPoint.x + horizontalSpacing,\n        y: startingPoint.y\n      }, {\n        x: startingPoint.x + horizontalSpacing,\n        y: startingPoint.y + verticalSpacing\n      }, {\n        x: endPoint.x,\n        y: startingPoint.y + verticalSpacing\n      }, endPoint);\n    }\n\n    this.getSegmentsFromPoints(points, connector);\n  };\n\n  HierarchicalTree.prototype.getSegmentsFromPoints = function (points, connector) {\n    var segments = [];\n    var segment;\n\n    for (var i = 0; i < points.length - 2; i++) {\n      segment = new OrthogonalSegment(connector, 'segments', {\n        type: 'Orthogonal'\n      }, true);\n      segment.direction = Point.direction(points[i], points[i + 1]);\n      segment.length = Point.distancePoints(points[i], points[i + 1]);\n      segments.push(segment);\n    }\n\n    connector.segments = segments;\n  };\n\n  HierarchicalTree.prototype.getSegmentsForMultipleRows = function (layout, node, target, connector) {\n    //let points: PointModel[] = [];\n    var segments = [];\n    var point;\n    var segment;\n    var targetBounds = this.getBounds(target);\n    var nodeBounds = this.getBounds(node);\n\n    switch (layout.orientation) {\n      case 'TopToBottom':\n        point = {\n          x: nodeBounds.bottomCenter.x,\n          y: nodeBounds.bottomCenter.y + layout.verticalSpacing / 4\n        };\n        segment = new OrthogonalSegment(connector, 'segments', {\n          type: 'Orthogonal'\n        }, true);\n        segment.direction = Point.direction(nodeBounds.bottomCenter, point);\n        segment.length = Point.distancePoints(nodeBounds.bottomCenter, point);\n        segments.push(segment);\n        break;\n\n      case 'BottomToTop':\n        point = {\n          x: nodeBounds.bottomCenter.x,\n          y: nodeBounds.topCenter.y - layout.verticalSpacing / 4\n        };\n        segment = new OrthogonalSegment(connector, 'segments', {\n          type: 'Orthogonal'\n        }, true);\n        segment.direction = Point.direction(nodeBounds.topCenter, point);\n        segment.length = Point.distancePoints(nodeBounds.topCenter, point);\n        segments.push(segment);\n        break;\n\n      case 'LeftToRight':\n        point = {\n          x: nodeBounds.middleRight.x + layout.verticalSpacing / 4,\n          y: nodeBounds.middleRight.y\n        };\n        segment = new OrthogonalSegment(connector, 'segments', {\n          type: 'Orthogonal'\n        }, true);\n        segment.direction = Point.direction(nodeBounds.middleRight, point);\n        segment.length = Point.distancePoints(nodeBounds.middleRight, point);\n        segments.push(segment);\n\n        if (targetBounds.center.y !== nodeBounds.center.y) {\n          var point3 = {\n            x: nodeBounds.middleRight.x + layout.verticalSpacing / 4,\n            y: targetBounds.middleLeft.y\n          };\n          segment = new OrthogonalSegment(connector, 'segments', {\n            type: 'Orthogonal'\n          }, true);\n          segment.direction = Point.direction(point, point3);\n          segment.length = Point.distancePoints(point, point3);\n          segments.push(segment);\n        }\n\n        break;\n\n      case 'RightToLeft':\n        point = {\n          x: nodeBounds.middleLeft.x - layout.verticalSpacing / 4,\n          y: nodeBounds.middleRight.y\n        };\n        segment = new OrthogonalSegment(connector, 'segments', {\n          type: 'Orthogonal'\n        }, true);\n        segment.direction = Point.direction(nodeBounds.middleLeft, point);\n        segment.length = Point.distancePoints(nodeBounds.middleLeft, point);\n        segments.push(segment);\n\n        if (targetBounds.center.y !== nodeBounds.center.y) {\n          var point_1 = {\n            x: nodeBounds.middleLeft.x - layout.verticalSpacing / 4,\n            y: targetBounds.middleLeft.y\n          };\n          segment = new OrthogonalSegment(connector, 'segments', {\n            type: 'Orthogonal'\n          }, true);\n          segment.direction = Point.direction(point_1, point_1);\n          segment.length = Point.distancePoints(point_1, point_1);\n          segments.push(segment);\n        }\n\n        break;\n    }\n\n    connector.segments = segments;\n  };\n\n  HierarchicalTree.prototype.updateSegmentsForHorizontalOrientation = function (layout, node, target, connector) {\n    var points = [];\n    var point2;\n    var segment;\n    var segments = [];\n    var nodeBounds = this.getBounds(node);\n    var targetBounds = this.getBounds(target);\n\n    switch (layout.orientation) {\n      case 'TopToBottom':\n        point2 = {\n          x: nodeBounds.bottomCenter.x,\n          y: targetBounds.topCenter.y - layout.verticalSpacing / 2\n        };\n        segment = new OrthogonalSegment(connector, 'segments', {\n          type: 'Orthogonal'\n        }, true);\n        segment.direction = Point.direction(nodeBounds.bottomCenter, point2);\n        segment.length = Point.distancePoints(nodeBounds.bottomCenter, point2);\n        segments.push(segment);\n        break;\n\n      case 'BottomToTop':\n        point2 = {\n          x: nodeBounds.topCenter.x,\n          y: targetBounds.bottomCenter.y + layout.verticalSpacing / 2\n        };\n        segment = new OrthogonalSegment(connector, 'segments', {\n          type: 'Orthogonal'\n        }, true);\n        segment.direction = Point.direction(nodeBounds.topCenter, point2);\n        segment.length = Point.distancePoints(nodeBounds.topCenter, point2);\n        segments.push(segment);\n        break;\n\n      case 'LeftToRight':\n        point2 = {\n          x: targetBounds.middleLeft.x - layout.verticalSpacing / 2,\n          y: nodeBounds.middleRight.y\n        };\n        segment = new OrthogonalSegment(connector, 'segments', {\n          type: 'Orthogonal'\n        }, true);\n        segment.direction = Point.direction(nodeBounds.middleRight, point2);\n        segment.length = Point.distancePoints(nodeBounds.middleRight, point2);\n        segments.push(segment);\n\n        if (targetBounds.center.y !== nodeBounds.center.y) {\n          var point3 = {\n            x: targetBounds.middleLeft.x - layout.verticalSpacing / 2,\n            y: targetBounds.middleLeft.y\n          };\n          segment = new OrthogonalSegment(connector, 'segments', {\n            type: 'Orthogonal'\n          }, true);\n          segment.direction = Point.direction(point2, point3);\n          segment.length = Point.distancePoints(point2, point3);\n          segments.push(segment);\n        }\n\n        break;\n\n      case 'RightToLeft':\n        point2 = {\n          x: targetBounds.middleRight.x + layout.verticalSpacing / 2,\n          y: nodeBounds.middleRight.y\n        };\n        segment = new OrthogonalSegment(connector, 'segments', {\n          type: 'Orthogonal'\n        }, true);\n        segment.direction = Point.direction(nodeBounds.middleLeft, point2);\n        segment.length = Point.distancePoints(nodeBounds.middleLeft, point2);\n        segments.push(segment);\n\n        if (targetBounds.center.y !== nodeBounds.center.y) {\n          var point = {\n            x: targetBounds.middleRight.x + layout.verticalSpacing / 2,\n            y: targetBounds.middleLeft.y\n          };\n          segment = new OrthogonalSegment(connector, 'segments', {\n            type: 'Orthogonal'\n          }, true);\n          segment.direction = Point.direction(point2, point);\n          segment.length = Point.distancePoints(point2, point);\n          segments.push(segment);\n        }\n\n        break;\n    }\n\n    connector.segments = segments;\n    return points;\n  };\n\n  HierarchicalTree.prototype.updateNodes = function (layout, node, mod, update, dx, dy) {\n    var i;\n    var child;\n    var width;\n    var height;\n    var offsetX;\n    var offsetY;\n\n    if (node && !node.excludeFromLayout) {\n      width = node.actualSize.width;\n      height = node.actualSize.height;\n      offsetX = layout.anchorX;\n      offsetY = layout.anchorY;\n      /*Performance - instead of checking conditions for every node, we can make the layout related\n      conditions once and we can reuse them*/\n\n      if (layout.orientation === 'LeftToRight') {\n        offsetX += layout.graphNodes[node.id].y + width / 2;\n        offsetY += layout.graphNodes[node.id].x + mod + height / 2;\n      } else if (layout.orientation === 'RightToLeft') {\n        offsetX -= layout.graphNodes[node.id].y + width / 2;\n        offsetY += layout.graphNodes[node.id].x + mod + height / 2;\n      } else if (layout.orientation === 'TopToBottom') {\n        offsetX += layout.graphNodes[node.id].x + mod + width / 2;\n        offsetY += layout.graphNodes[node.id].y + height / 2;\n      } else {\n        offsetX += layout.graphNodes[node.id].x + mod + width / 2;\n        offsetY -= layout.graphNodes[node.id].y + height / 2;\n      }\n\n      if (layout.graphNodes) {\n        dx = dx ? dx : 0;\n        dy = dy ? dy : 0;\n        offsetX += dx;\n        offsetY += dy;\n\n        if (!this.isAnimation) {\n          node.offsetX = offsetX;\n          node.offsetY = offsetY;\n        }\n      }\n\n      var objects = {\n        id: node.id,\n        differenceX: offsetX - node.offsetX,\n        differenceY: offsetY - node.offsetY\n      };\n      layout.objects.push(objects);\n      var list = [];\n\n      if (this.hasChild(layout, node)) {\n        for (i = 0; i < layout.graphNodes[node.id].tree.children.length; i++) {\n          child = layout.nameTable[layout.graphNodes[node.id].tree.children[i]];\n          this.updateNodes(layout, child, mod + (layout.graphNodes[node.id].subTreeTranslation || 0), update, dx, dy);\n          list.push(child);\n        }\n      }\n\n      if (layout.graphNodes[node.id].tree.assistants.length) {\n        for (i = 0; i < layout.graphNodes[node.id].tree.assistants.length; i++) {\n          child = layout.nameTable[layout.graphNodes[node.id].tree.assistants[i]];\n          this.updateNodes(layout, child, mod + (layout.graphNodes[node.id].subTreeTranslation || 0), null, dx, dy);\n        }\n      }\n    }\n  };\n\n  return HierarchicalTree;\n}();\n\nexport { HierarchicalTree };","map":{"version":3,"sources":["/home/ubuntu*/Desktop/streamify/node_modules/@syncfusion/ej2-diagrams/src/diagram/layout/hierarchical-tree.js"],"names":["DiagramAction","Rect","OrthogonalSegment","getFunction","Point","updateLayoutValue","HierarchicalTree","isAnimation","prototype","destroy","getModuleName","updateLayout","nodes","nameTable","layoutProp","viewport","uniqueId","action","layout","type","anchorX","anchorY","firstLevelNodes","centerNode","levels","maxLevel","graphNodes","orientation","horizontalSpacing","verticalSpacing","verticalAlignment","horizontalAlignment","fixedNode","getLayoutInfo","layoutInfo","margin","bounds","objects","root","doLayout","node","i","shape","rootNodes","push","length","excludeFromLayout","id","setUpLayoutInfo","tree","hasSubTree","inEdges","parentId","processId","data","String","updateEdges","rootNode","x","y","minX","maxY","maxX","minY","updateTree","rootInfo","Math","min","indexOf","right","bottom","max","updateAnchor","updateNodes","updateConnectors","getBounds","offsetX","actualSize","width","pivot","offsetY","height","level","prev","dontupdate","info","lev","obj","dimensions","getDimensions","firstChild","hasChild","assistants","treeBounds","updateLeafNode","shapeBounds","levelBounds","d","asstBounds","space","setDepthSpaceForAssitants","children","updateHorizontalTree","updateHorizontalTreeWithMultipleRows","updateVerticalTree","mid","undefined","setBreadthSpaceForAssistants","canMoveBy","translate","treeWidth","translateInfo","dim","translateSubTree","subTreeTranslation","item","offset","enableRouting","asstDif","child","firstChildInfo","intersect","findIntersectingLevels","actualLevel","treeIntersect","spaceLeftFromPrevSubTree","diff","translated","shiftSubordinates","rBounds","updateRearBounds","bnds","index","isLastLeaf","firstLevel","lastLevel","splice","findLevel","vSpace","asst","asstHeight","asstElement","asstWidth","left","uniteRects","prevBounds","temp","shape1","side","childBounds","childWidth","childHeight","actBounds","translateSibilingsBy","oldActBounds","childInfo","prevLayoutLevels","slice","h","canMoveValue","isNaN","rowBounds","fchild","maxRowWidth","j","k","leftCenter","rightCenter","minTranslation","align","rows","splitChildrenInRows","unique","leftTree","rightTree","splitRows","treeInfo","rightMost","updateLeftTree","rightX","center","rightBounds","alignRowsToCenter","leftBounds","element","elementInfo","centered","floor","centerObjct","centeredX","centeredY","childDimension","updateRearBoundsOfTree","childBnds","half","ceil","dontUpdate","oddBounds","evenBounds","factor","oddLevels","findOffset","concat","canMoveBy_1","column","childNodes","extend","count","columns","dummy","treeType","rect1","rect2","dif","intersectingLevels","l","getParentNode","sourceID","depth","outEdges","isExpanded","Render","edge","targetID","viewPort","mod","yValue","viewPortBounds","layoutBounds","top_1","top","target","conn","direction","points","visible","visited","getConnectorSegments","segments","updateSegments","get3Points","updateSegmentsForHorizontalOrientation","updateSegmentsForBalancedTree","get5Points","connector","relative","center_1","getSegmentsForMultipleRows","nodeBounds","targetBounds","startingPoint","bottomCenter","topCenter","endPoint","middleRight","middleLeft","getSegmentsFromPoints","segment","distancePoints","point","point3","point_1","point2","update","dx","dy","differenceX","differenceY","list"],"mappings":"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","sourcesContent":["import { DiagramAction } from '../enum/enum';\nimport { Rect } from '../primitives/rect';\nimport { OrthogonalSegment } from '../objects/connector';\nimport { getFunction } from '../utility/base-util';\nimport { Point } from '../primitives/point';\nimport { updateLayoutValue } from '../utility/diagram-util';\n/**\n * Hierarchical Tree and Organizational Chart\n */\nvar HierarchicalTree = /** @class */ (function () {\n    /**\n     * Constructor for the organizational chart module.\n     *\n     * @private\n     */\n    function HierarchicalTree() {\n        /**\n         * Defines the layout animation\n         *\n         */\n        this.isAnimation = false;\n        //constructs the layout module\n    }\n    /**\n     * To destroy the organizational chart\n     *\n     * @returns {void}\n     * @private\n     */\n    HierarchicalTree.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    /**\n     * Get module name.\n     */\n    HierarchicalTree.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the layout\n         */\n        return 'OrganizationalChart';\n    };\n    /**\n     * @param nodes\n     * @param nameTable\n     * @param layoutProp\n     * @param viewport\n     * @param uniqueId\n     * @param action\n     * @private\n     */\n    HierarchicalTree.prototype.updateLayout = function (nodes, nameTable, layoutProp, viewport, uniqueId, action) {\n        var layout = {\n            type: layoutProp.type,\n            nameTable: nameTable, anchorX: 0, anchorY: 0,\n            firstLevelNodes: [], centerNode: null, levels: [], maxLevel: 0, graphNodes: {},\n            orientation: layoutProp.orientation,\n            horizontalSpacing: layoutProp.horizontalSpacing, verticalSpacing: layoutProp.verticalSpacing,\n            verticalAlignment: layoutProp.verticalAlignment, horizontalAlignment: layoutProp.horizontalAlignment,\n            fixedNode: layoutProp.fixedNode, getLayoutInfo: getFunction(layoutProp.getLayoutInfo),\n            layoutInfo: layoutProp.layoutInfo, margin: layoutProp.margin,\n            bounds: layoutProp.bounds, objects: [], root: layoutProp.root\n        };\n        this.doLayout(layout, nodes, viewport, uniqueId, action);\n        return layout;\n    };\n    HierarchicalTree.prototype.doLayout = function (layout, nodes, viewport, uniqueId, action) {\n        var node;\n        var i;\n        var layoutInfo = {};\n        var shape;\n        var rootNodes = [];\n        if (layout.nameTable[layout.root]) {\n            layout.firstLevelNodes.push(layout.nameTable[layout.root]);\n        }\n        for (i = 0; i < nodes.length; i++) {\n            node = nodes[i];\n            if (!node.excludeFromLayout) {\n                layoutInfo = layout.graphNodes[node.id] = this.setUpLayoutInfo(layout, node);\n                layoutInfo.tree.hasSubTree = false;\n                if (!layout.nameTable[layout.root]) {\n                    if (!node.inEdges || !node.inEdges.length) {\n                        var parentId = 'parentId';\n                        var processId = 'processId';\n                        if (!node[parentId] && !node[processId]) {\n                            rootNodes.push(node);\n                        }\n                        if (node.data && String(node.data[uniqueId]) === layout.root) {\n                            layout.firstLevelNodes.push(node);\n                        }\n                    }\n                }\n            }\n        }\n        if (layout.firstLevelNodes.length === 0) {\n            layout.firstLevelNodes = rootNodes;\n        }\n        //Update relationship(parent and children)\n        for (i = 0; i < layout.firstLevelNodes.length; i++) {\n            node = layout.firstLevelNodes[i];\n            //let check: boolean;\n            this.updateEdges(layout, node, 1, action, nodes);\n        }\n        if (layout.firstLevelNodes.length > 0) {\n            layout.rootNode = layout.firstLevelNodes[0];\n            var x = 0;\n            var y = 0;\n            var minX = void 0;\n            var maxY = void 0;\n            var maxX = void 0;\n            var minY = void 0;\n            //let j: number;\n            var bounds = void 0;\n            for (i = 0; i < layout.firstLevelNodes.length; i++) {\n                bounds = this.updateTree(layout, x, y, layout.firstLevelNodes[i], 0, layout.firstLevelNodes[i - 1]);\n                var rootInfo = layout.graphNodes[layout.firstLevelNodes[i].id];\n                bounds.y = Math.min(bounds.y, rootInfo.y);\n                bounds.x = Math.min(bounds.x, rootInfo.x);\n                if (layout.orientation.indexOf('Left') !== -1) {\n                    y = bounds.right + layout.horizontalSpacing;\n                }\n                else {\n                    x = bounds.right + layout.horizontalSpacing;\n                }\n                if (i === 0) {\n                    minX = bounds.x;\n                    minY = bounds.y;\n                    maxX = bounds.right;\n                    maxY = bounds.bottom;\n                }\n                else {\n                    minX = Math.min(minX, bounds.x);\n                    minY = Math.min(minY, bounds.y);\n                    maxX = Math.max(maxX, bounds.right);\n                    maxY = Math.max(maxY, bounds.bottom);\n                }\n            }\n            this.updateAnchor(layout, { x: minX, y: minY, right: maxX, bottom: maxY }, viewport);\n            for (i = 0; i < layout.firstLevelNodes.length; i++) {\n                this.updateNodes(layout, layout.firstLevelNodes[i], 0);\n            }\n            for (i = 0; i < layout.firstLevelNodes.length; i++) {\n                this.updateConnectors(layout, layout.firstLevelNodes[i], 1);\n            }\n        }\n    };\n    HierarchicalTree.prototype.getBounds = function (node) {\n        var x = node.offsetX - node.actualSize.width * node.pivot.x;\n        var y = node.offsetY - node.actualSize.height * node.pivot.y;\n        return new Rect(x, y, node.actualSize.width, node.actualSize.height);\n    };\n    HierarchicalTree.prototype.updateTree = function (layout, x, y, shape, level, prev, dontupdate) {\n        //let dimensions: Dimensions;\n        var info = {};\n        var lev;\n        var obj;\n        //let hasChild: number;\n        var dimensions = this.getDimensions(layout, shape, x, y, level);\n        info = layout.graphNodes[shape.id];\n        var firstChild;\n        //Set maximum level of layout\n        layout.maxLevel = Math.max(layout.maxLevel, level);\n        lev = level;\n        var hasChild = this.hasChild(layout, shape);\n        if (!hasChild && !info.tree.assistants.length) {\n            //update leaf nodes\n            shape.treeBounds = this.updateLeafNode(layout, shape, prev, dimensions, level, dontupdate);\n            return shape.treeBounds;\n        }\n        else {\n            var treeBounds = void 0;\n            var shapeBounds = void 0;\n            var levelBounds = void 0;\n            var d = void 0;\n            var asstBounds = void 0;\n            var space = void 0;\n            var bottom = void 0;\n            bottom = dimensions.y + dimensions.height + layout.verticalSpacing;\n            if (info.tree.assistants.length) {\n                //Vertically place assistants\n                obj = this.setDepthSpaceForAssitants(layout, shape, bottom, dimensions.height, level, layout.verticalSpacing);\n                lev = obj.level;\n                bottom = obj.bottom;\n            }\n            if (!info.tree.assistants.length && info.tree.orientation !== 'Horizontal') {\n                bottom = dimensions.y + dimensions.height + layout.verticalSpacing / 2;\n            }\n            if (info.tree.children.length) {\n                if (info.tree.orientation === 'Horizontal' && (info.tree.type !== 'Balanced' || info.tree.children.length === 1)) {\n                    treeBounds = this.updateHorizontalTree(layout, shape, prev, dimensions.x, bottom, lev);\n                }\n                else if (info.tree.type === 'Balanced') {\n                    treeBounds = this.updateHorizontalTreeWithMultipleRows(layout, shape, prev, dimensions.x, bottom, lev);\n                }\n                else {\n                    treeBounds = this.updateVerticalTree(layout, shape, dimensions.x, bottom, lev, dontupdate);\n                }\n            }\n            if (!(info.y && info.y > dimensions.y)) {\n                info.y = dimensions.y;\n            }\n            if (info.mid) {\n                x = info.mid;\n            }\n            if (info.tree.assistants.length) {\n                //Set breadth space for assistants\n                space = x !== undefined ? x : dimensions.x;\n                asstBounds = this.setBreadthSpaceForAssistants(layout, shape, dimensions, space, bottom, level);\n                if (!hasChild) {\n                    levelBounds = treeBounds = asstBounds;\n                    x = (levelBounds.x + levelBounds.right) / 2 - dimensions.width / 2;\n                    treeBounds = levelBounds;\n                }\n                d = asstBounds ? asstBounds.canMoveBy : undefined;\n            }\n            info.x = x;\n            if (!info.translate) {\n                info.treeWidth = treeBounds.right - treeBounds.x;\n            }\n            {\n                shapeBounds = { x: x, y: dimensions.y, right: x + dimensions.width, bottom: dimensions.y + dimensions.height };\n            }\n            var translateInfo = {\n                layout: layout, shape: shape, shapeBounds: shapeBounds, treeBounds: treeBounds,\n                dim: dimensions, level: level\n            };\n            this.translateSubTree(translateInfo, d, prev !== undefined, dontupdate);\n            if (info.firstChild && typeof info.firstChild !== 'string') {\n                info.firstChild.x += info.subTreeTranslation;\n            }\n            shape.treeBounds = treeBounds;\n            return treeBounds;\n        }\n    };\n    HierarchicalTree.prototype.updateLeafNode = function (layout, shape, prev, dimensions, level, dontupdate) {\n        //let bounds: Bounds;\n        var info = layout.graphNodes[shape.id];\n        info.x = dimensions.x;\n        if (!(info.y && info.y > dimensions.y)) {\n            info.y = dimensions.y;\n            info.maxLevel = Math.max(level, info.maxLevel || 0);\n        }\n        // eslint-disable-next-line max-len\n        var bounds = { x: dimensions.x, y: dimensions.y, right: dimensions.x + dimensions.width, bottom: dimensions.y + dimensions.height };\n        info.maxLevel = Math.max(info.maxLevel || 0, level);\n        var translateInfo = {\n            layout: layout, shape: shape, shapeBounds: bounds, treeBounds: bounds,\n            dim: dimensions, level: level\n        };\n        this.translateSubTree(translateInfo, undefined, prev !== undefined, dontupdate);\n        return { x: info.x, y: info.y, right: info.x + dimensions.width, bottom: info.y + dimensions.height };\n    };\n    HierarchicalTree.prototype.setUpLayoutInfo = function (layout, item) {\n        var info = {};\n        info.subTreeTranslation = 0;\n        if (layout.type === 'OrganizationalChart') {\n            info.tree = { orientation: 'Vertical', type: 'Alternate', offset: 20, enableRouting: true };\n        }\n        else {\n            info.tree = { orientation: 'Horizontal', type: 'Center', enableRouting: true };\n        }\n        info.tree.children = [];\n        info.tree.assistants = [];\n        info.tree.level = 0;\n        info.translate = true;\n        return info;\n    };\n    HierarchicalTree.prototype.translateSubTree = function (translateInfo, asstDif, translate, dontupdate) {\n        var layout = translateInfo.layout;\n        var shape = translateInfo.shape;\n        var shapeBounds = translateInfo.shapeBounds;\n        var treeBounds = translateInfo.treeBounds;\n        var level = translateInfo.level;\n        var dim = translateInfo.dim;\n        var info = layout.graphNodes[shape.id];\n        var firstChild = layout.nameTable[info.firstChild ? info.firstChild.child : info.tree.children[0]];\n        var firstChildInfo = firstChild ? layout.graphNodes[firstChild.id] : null;\n        var hasChild = this.hasChild(layout, shape);\n        var intersect = this.findIntersectingLevels(layout, shapeBounds, level, info.actualLevel);\n        var treeIntersect = this.findIntersectingLevels(layout, treeBounds, level, info.actualLevel);\n        var levelBounds = [];\n        //const diff: number;\n        if (intersect.length && info.translate) {\n            info.intersect = intersect;\n            this.spaceLeftFromPrevSubTree(layout, shape, shapeBounds);\n            info.canMoveBy = info.diff;\n            if (asstDif !== undefined) {\n                info.canMoveBy = Math.min(asstDif, info.canMoveBy);\n            }\n            if (firstChild && firstChildInfo.canMoveBy !== undefined) {\n                if (firstChildInfo.canMoveBy >= info.canMoveBy) {\n                    info.translated = true;\n                }\n                info.canMoveBy = Math.min(info.canMoveBy, firstChildInfo.canMoveBy);\n            }\n            if (translate) {\n                info.x -= info.canMoveBy;\n                info.subTreeTranslation -= info.canMoveBy;\n                if (hasChild) {\n                    this.shiftSubordinates(layout, treeIntersect, info.canMoveBy);\n                    treeBounds.x = Math.min(treeBounds.x, info.x);\n                    treeBounds.right = Math.max(treeBounds.right, info.x + dim.width);\n                    treeBounds.bottom = Math.max(treeBounds.bottom, info.y + dim.height);\n                    treeBounds.x -= info.canMoveBy;\n                    treeBounds.right -= info.canMoveBy;\n                }\n                if (firstChild && firstChildInfo.canMoveBy > info.canMoveBy) {\n                    info.canMoveBy = firstChildInfo.canMoveBy - info.canMoveBy;\n                }\n                else if (firstChild && info.canMoveBy !== undefined) {\n                    info.canMoveBy = 0;\n                }\n            }\n        }\n        else {\n            if (hasChild) {\n                treeBounds.x = Math.min(treeBounds.x, shapeBounds.x);\n                treeBounds.right = Math.max(treeBounds.right, shapeBounds.x + dim.width);\n                treeBounds.bottom = Math.max(treeBounds.bottom, info.y + dim.height);\n            }\n            if (!info.translate) {\n                info.canMoveBy = 0;\n                info.subTreeTranslation = 0;\n            }\n        }\n        if (!dontupdate) {\n            shapeBounds = { x: info.x, y: dim.y, right: info.x + dim.width, bottom: dim.y + dim.height };\n            levelBounds.push({ rBounds: shapeBounds });\n            this.updateRearBounds(layout, shape, levelBounds, level);\n        }\n    };\n    HierarchicalTree.prototype.updateRearBounds = function (layout, shape, levelBounds, level, intersect) {\n        var bnds;\n        var index;\n        var isLastLeaf = true;\n        var i;\n        var info = {};\n        //let firstLevel: Bounds;\n        //let lastLevel: Bounds;\n        var bottom;\n        if (shape) {\n            info = layout.graphNodes[shape.id];\n            intersect = info.intersect;\n            isLastLeaf = !info.tree.children.length && !info.tree.assistants.length;\n        }\n        var firstLevel = levelBounds[0].rBounds;\n        var lastLevel = levelBounds[levelBounds.length - 1].rBounds;\n        if (intersect && intersect.length) {\n            bnds = layout.levels[intersect[0]].rBounds;\n            bottom = bnds.bottom;\n            if (bnds.y < firstLevel.y) {\n                bnds.bottom = firstLevel.y;\n                levelBounds.splice(0, 0, { rBounds: bnds });\n            }\n            if (bottom > lastLevel.bottom) {\n                levelBounds.push({ rBounds: { x: bnds.x, right: bnds.right, y: firstLevel.bottom, bottom: bottom } });\n            }\n            else {\n                bnds = layout.levels[intersect[intersect.length - 1]].rBounds;\n                if (isLastLeaf && bnds.bottom > lastLevel.bottom) {\n                    bnds.y = lastLevel.bottom;\n                    levelBounds.push({ rBounds: bnds });\n                }\n            }\n            index = intersect[0];\n            for (i = levelBounds.length - 1; i >= 0; i--) {\n                layout.levels.splice(index, 0, levelBounds[i]);\n            }\n            index += levelBounds.length;\n            layout.levels.splice(index, intersect.length);\n        }\n        else {\n            index = this.findLevel(layout, levelBounds[levelBounds.length - 1].rBounds, level);\n            for (i = levelBounds.length - 1; i >= 0; i--) {\n                layout.levels.splice(index, 0, levelBounds[i]);\n            }\n        }\n    };\n    HierarchicalTree.prototype.shiftSubordinates = function (layout, intersect, diff) {\n        var i;\n        //Shift the sublevels by the distance diff\n        if (diff !== 0) {\n            for (i = 0; i < intersect.length; i++) {\n                if (layout.levels[intersect[i]].rBounds) {\n                    layout.levels[intersect[i]].rBounds.x -= diff;\n                    layout.levels[intersect[i]].rBounds.right -= diff;\n                }\n            }\n        }\n    };\n    HierarchicalTree.prototype.setDepthSpaceForAssitants = function (layout, shape, bottom, height, lev, vSpace) {\n        var info = layout.graphNodes[shape.id];\n        var asst = {};\n        var asstHeight;\n        var i;\n        var asstElement;\n        var max;\n        max = bottom;\n        //Vertically place the assistants as alternate layout(alternatively at both right and left sides of parent)\n        for (i = 0; i < info.tree.assistants.length; i++) {\n            asst = layout.graphNodes[info.tree.assistants[i]];\n            if (asst) {\n                asst.tree.children = asst.tree.assistants = [];\n                asst.y = bottom;\n                asstElement = layout.nameTable[info.tree.assistants[i]];\n                asstHeight = asstElement.actualSize.height;\n                if (layout.orientation.indexOf('Left') !== -1) {\n                    asstHeight = asstElement.actualSize.width;\n                }\n                max = bottom + asstHeight + vSpace / 2;\n                layout.maxLevel = lev + 1;\n                if (i % 2 === 1 && i !== info.tree.assistants.length - 1) {\n                    bottom = max;\n                    lev++;\n                }\n            }\n        }\n        return { level: layout.maxLevel, bottom: bottom + asstHeight + vSpace };\n    };\n    HierarchicalTree.prototype.setBreadthSpaceForAssistants = function (layout, shape, dim, space, bottom, level) {\n        var asst = {};\n        var asstWidth;\n        //let prevBounds: number;\n        var bounds;\n        var asstElement;\n        var i;\n        var info = layout.graphNodes[shape.id];\n        //let max: number = bottom;\n        var lev = level;\n        var left;\n        var diff;\n        var intersect;\n        var levelBounds = { x: 0, y: 0, right: 0, bottom: 0 };\n        for (i = 0; i < info.tree.assistants.length; i++) {\n            asst = layout.graphNodes[info.tree.assistants[i]];\n            //Arrange assistants at both left and right sides of parent(like alternate layout)\n            //Check - By default, distance to be left between parent and child nodes is assumed as 20.\n            //It can be modified/customized later.\n            if (asst) {\n                asstElement = layout.nameTable[info.tree.assistants[i]];\n                asstWidth = asstElement.actualSize.width;\n                if (layout.orientation.indexOf('Left') !== -1) {\n                    asstWidth = asstElement.actualSize.height;\n                }\n                if (i % 2 === 0) {\n                    left = space + dim.width / 2 - 20 - asstWidth;\n                }\n                else {\n                    left = space + dim.width / 2 + 20;\n                }\n                //Check - What will happen if update leaf node is called? Since assistants don't have children\n                bounds = this.updateTree(layout, left, asst.y, layout.nameTable[info.tree.assistants[i]], lev + 1);\n                if (!this.hasChild(layout, shape)) {\n                    if (i === 0) {\n                        levelBounds = bounds;\n                    }\n                    else {\n                        this.uniteRects(levelBounds, bounds);\n                    }\n                }\n                if (i % 2 === 0 && asst.prevBounds) {\n                    if (diff === undefined) {\n                        diff = asst.canMoveBy;\n                    }\n                    else {\n                        diff = Math.min(diff, asst.canMoveBy);\n                    }\n                }\n                if (i % 2 === 1 || i === info.tree.assistants.length - 1) {\n                    intersect = this.findIntersectingLevels(layout, bounds, lev + 1);\n                    //Update rightmost positions of known layout levels\n                    this.updateRearBounds(layout, null, [{ rBounds: bounds }], lev + 1, intersect);\n                    lev++;\n                }\n            }\n        }\n        if (levelBounds) {\n            levelBounds.canMoveBy = diff;\n        }\n        return levelBounds;\n    };\n    HierarchicalTree.prototype.getDimensions = function (layout, shape, x, y, level) {\n        var width;\n        width = shape.actualSize.width;\n        var height;\n        height = shape.actualSize.height;\n        if (layout.orientation.indexOf('Left') !== -1) {\n            if (!level) {\n                //let temp: number;\n                var temp = x;\n                x = y;\n                y = temp;\n            }\n            height = shape.actualSize.width;\n            width = shape.actualSize.height;\n        }\n        return { x: x, y: y, width: width, height: height };\n    };\n    HierarchicalTree.prototype.hasChild = function (layout, shape) {\n        //Check whether the node has children\n        var shape1 = layout.graphNodes[shape.id];\n        return shape1 ? shape1.tree.children && shape1.tree.children.length : 0;\n    };\n    HierarchicalTree.prototype.updateHorizontalTree = function (layout, shape, prev, x, y, level) {\n        //Get dimensions with respect to layout orientations\n        //let dimensions: Dimensions;\n        var dimensions = this.getDimensions(layout, shape, x, y, level);\n        var info = {};\n        info = layout.graphNodes[shape.id];\n        var side = info.tree.type;\n        //let lev: number;\n        var lev = level;\n        var right = 0;\n        right = x;\n        var bottom = y;\n        var width;\n        var height;\n        var child;\n        var childBounds;\n        var childWidth;\n        var childHeight;\n        //let prevBounds: Bounds;\n        var bounds;\n        var actBounds;\n        var maxLevel;\n        var translateSibilingsBy;\n        var canMoveBy;\n        var oldActBounds;\n        var i;\n        var childInfo;\n        var firstChildInfo;\n        var prevLayoutLevels = layout.levels.slice(0, layout.levels.length);\n        if (this.hasChild(layout, shape)) {\n            //let h: boolean;\n            var h = layout.orientation.indexOf('Left') !== -1 ? true : false;\n            for (i = 0; i < info.tree.children.length; i++) {\n                child = layout.nameTable[info.tree.children[i]];\n                width = child.actualSize.width;\n                height = child.actualSize.height;\n                childWidth = h ? height : width;\n                childHeight = h ? width : height;\n                var prevBounds = layout.levels[lev + 1] ? layout.levels[lev + 1].rBounds : null;\n                //Update sub tree\n                childBounds = this.updateTree(layout, right, bottom, child, lev + 1, layout.nameTable[info.tree.children[i - 1]]);\n                childInfo = layout.graphNodes[child.id];\n                info.maxLevel = Math.max(info.maxLevel || 0, childInfo.maxLevel || 0);\n                actBounds = { x: childInfo.x, y: childInfo.y, right: childInfo.x + childWidth, bottom: childInfo.y + childHeight };\n                if (i === 0) {\n                    //Compare with previous(right most) subtree\n                    bounds = {\n                        x: Math.min(childInfo.x, childBounds.x), y: Math.min(childInfo.y, childBounds.y),\n                        right: childBounds.right, bottom: childBounds.bottom\n                    };\n                    firstChildInfo = childInfo;\n                }\n                if (!oldActBounds) {\n                    oldActBounds = actBounds;\n                }\n                else {\n                    oldActBounds.x = actBounds.x;\n                    oldActBounds.y = actBounds.y;\n                    if (actBounds.right > oldActBounds.right) {\n                        oldActBounds.right = actBounds.right;\n                    }\n                    oldActBounds.bottom = actBounds.bottom;\n                    //oldActBounds = actBounds;\n                }\n                //Compare with previous subtree if level of the child is greater than the level of previous sub tree\n                //Check - what will happen if level of second child is greater than current child\n                if (i === 0) {\n                    info.firstChild = { x: childInfo.x, canMoveBy: childInfo.canMoveBy, child: child.id };\n                }\n                if (this.hasChild(layout, child)) {\n                    if (!info.firstChild || info.firstChild.x >= childInfo.firstChild.x) {\n                        if (childInfo.firstChild && info.firstChild.canMoveBy < childInfo.canMoveBy) {\n                            canMoveBy = info.firstChild.canMoveBy;\n                            childInfo.canMoveBy = canMoveBy;\n                            layout.graphNodes[info.firstChild.child].canMoveBy = canMoveBy;\n                            info.firstChild.canMoveBy = canMoveBy;\n                        }\n                        var canMoveValue = canMoveBy !== undefined ? canMoveBy : childInfo.canMoveBy;\n                        info.firstChild = { x: childInfo.firstChild.x, canMoveBy: canMoveValue, child: child.id };\n                    }\n                    else if (childInfo.firstChild && childInfo.translated && info.firstChild.canMoveBy > childInfo.canMoveBy) {\n                        info.firstChild.canMoveBy = layout.graphNodes[info.firstChild.child].canMoveBy = childInfo.canMoveBy;\n                    }\n                }\n                maxLevel = maxLevel ? Math.max(childInfo.maxLevel, maxLevel) : childInfo.maxLevel;\n                this.uniteRects(bounds, childBounds);\n                if (i !== 0 && !this.hasChild(layout, child) && childInfo.subTreeTranslation < 0) {\n                    right = childBounds.right - childInfo.subTreeTranslation + layout.horizontalSpacing;\n                }\n                else {\n                    right = childBounds.right + layout.horizontalSpacing;\n                }\n            }\n            if (!isNaN(translateSibilingsBy)) {\n                firstChildInfo.canMoveBy = translateSibilingsBy;\n            }\n            info.mid = (firstChildInfo.x + oldActBounds.right) / 2 - dimensions.width / 2;\n            //Set parent based on the chart type\n            if (side === 'Left') {\n                info.mid = actBounds.right - dimensions.width;\n            }\n            else if (side === 'Right') {\n                info.mid = x;\n            }\n        }\n        return bounds;\n    };\n    /* eslint-disable */\n    HierarchicalTree.prototype.updateHorizontalTreeWithMultipleRows = function (layout, shape, prev, x, y, level) {\n        //declarations\n        var child;\n        var childInfo;\n        var childBounds;\n        var childWidth;\n        var childHeight;\n        var firstChildInfo;\n        var maxLevel;\n        var bounds;\n        var rowBounds;\n        var width;\n        var height;\n        var diff;\n        var translateSibilingsBy;\n        var fchild;\n        var maxRowWidth;\n        var j;\n        var i;\n        var k;\n        var max;\n        var leftCenter;\n        var rightCenter;\n        //Get dimensions with respect to layout orientations\n        var dimensions = this.getDimensions(layout, shape, x, y, level);\n        var info = layout.graphNodes[shape.id];\n        var side = info.tree.type;\n        var lev = level;\n        var right = x;\n        var bottom = y;\n        var prevLayoutLevels = layout.levels.slice(0, layout.levels.length);\n        var minTranslation = 0;\n        if (this.hasChild(layout, shape)) {\n            var h = layout.orientation.indexOf('Left') !== -1 ? true : false;\n            var align = void 0;\n            var rows = this.splitChildrenInRows(layout, shape);\n            var unique = info.tree.children.length === 5 && rows[0].length === 3;\n            var leftTree = [];\n            var rightTree = [];\n            if (!unique) {\n                this.splitRows(rows, leftTree, rightTree);\n            }\n            else {\n                rightTree = rows;\n            }\n            var treeInfo = { leftTree: leftTree, rows: rows, rightTree: rightTree, dimensions: dimensions };\n            var rightMost = this.updateLeftTree(layout, treeInfo, shape, x, bottom, lev);\n            bounds = treeInfo.bounds;\n            var rightX = void 0;\n            var center = (rightMost || 0) + (rightMost !== undefined ? (layout.horizontalSpacing / 2) : 0);\n            if (rightMost !== undefined) {\n                info.mid = center - dimensions.width / 2;\n                rightX = rightMost + layout.horizontalSpacing;\n            }\n            bottom = y;\n            var rightBounds = void 0;\n            rightBounds = [];\n            for (i = 0; i < rightTree.length; i++) {\n                if (rows[i].length % 2 === 1 && i === rightTree.length - 1 || unique) {\n                    right = x;\n                }\n                else {\n                    right = rightX || x;\n                }\n                if (i !== 0) {\n                    bottom = rightBounds[i - 1].bottom + layout.verticalSpacing;\n                }\n                for (j = 0; j < rightTree[i].length; j++) {\n                    child = layout.nameTable[rightTree[i][j]];\n                    width = child.actualSize.width;\n                    height = child.actualSize.height;\n                    childWidth = h ? height : width;\n                    childHeight = h ? width : height;\n                    //Update sub tree\n                    childInfo = layout.graphNodes[child.id];\n                    childInfo.actualLevel = lev + 1 + i;\n                    if (j === 0 && leftTree[i] && leftTree[i].length) {\n                        childInfo.translate = false;\n                    }\n                    if (unique && i === 1) {\n                        if (j === 0 && leftCenter + childWidth + layout.horizontalSpacing <= rightCenter) {\n                            align = true;\n                            right = leftCenter - childWidth / 2;\n                        }\n                        if (align && j === 1) {\n                            right = rightCenter - childWidth / 2;\n                        }\n                    }\n                    childBounds = this.updateTree(layout, right, bottom, child, lev + 1, layout.nameTable[rightTree[i][j - 1]]);\n                    if (unique && j <= 2 && i === 0) {\n                        if (j === 1) {\n                            leftCenter = childBounds.x - layout.horizontalSpacing / 2;\n                            rightCenter = childBounds.x + childWidth + layout.horizontalSpacing / 2;\n                        }\n                    }\n                    if (j === 0) {\n                        rightBounds[i] = { x: childBounds.x, y: childBounds.y, right: childBounds.right, bottom: childBounds.bottom };\n                    }\n                    else {\n                        this.uniteRects(rightBounds[i], childBounds);\n                    }\n                    if (!bounds) {\n                        bounds = {\n                            x: rightBounds[i].x, y: rightBounds[i].y, right: rightBounds[i].right,\n                            bottom: rightBounds[i].bottom\n                        };\n                    }\n                    this.uniteRects(bounds, rightBounds[i]);\n                    right = childBounds.right + layout.horizontalSpacing;\n                    if (!info.firstChild || ((i === rightTree.length - 1 && rows[i].length % 2 === 1) || unique)\n                        && j === 0 && childInfo.canMoveBy !== undefined && minTranslation > childInfo.canMoveBy) {\n                        minTranslation = Math.min(minTranslation, childInfo.canMoveBy || 0);\n                        info.firstChild = { x: childInfo.x, child: child.id, canMoveBy: childInfo.canMoveBy };\n                    }\n                    treeInfo.leftCenter = leftCenter;\n                    treeInfo.rightCenter = rightCenter;\n                    treeInfo.align = align;\n                    treeInfo.level = lev;\n                    treeInfo.rightBounds = rightBounds;\n                    this.alignRowsToCenter(layout, i, shape, treeInfo, rightX);\n                }\n            }\n        }\n        return bounds;\n    };\n    /* eslint-enable */\n    HierarchicalTree.prototype.updateLeftTree = function (layout, treeInfo, shape, x, bottom, lev) {\n        var leftTree = treeInfo.leftTree;\n        var info = layout.graphNodes[shape.id];\n        var right;\n        var leftBounds = [];\n        var minTranslation;\n        var rightMost;\n        var childBounds;\n        var bounds;\n        var h = layout.orientation.indexOf('Left') !== -1 ? true : false;\n        //Arrange left side\n        for (var i = 0; i < leftTree.length && leftTree[i].length; i++) {\n            right = x;\n            if (leftBounds[i - 1]) {\n                bottom = leftBounds[i - 1].bottom + layout.verticalSpacing;\n            }\n            for (var j = 0; j < leftTree[i].length; j++) {\n                var child = layout.nameTable[leftTree[i][j]];\n                var childWidth = h ? child.actualSize.height : child.actualSize.width;\n                var childHeight = h ? child.actualSize.width : child.actualSize.height;\n                //Update sub tree\n                var childInfo = layout.graphNodes[child.id];\n                childInfo.actualLevel = lev + 1 + i;\n                childBounds = this.updateTree(layout, right, bottom, child, lev + 1, layout.nameTable[leftTree[i][j - 1]]);\n                if (j === 0) {\n                    leftBounds[i] = { x: childBounds.x, y: childBounds.y, right: childBounds.right, bottom: childBounds.bottom };\n                }\n                else {\n                    this.uniteRects(leftBounds[i], childBounds);\n                }\n                if (i === 0 && j === 0) {\n                    minTranslation = childInfo.canMoveBy;\n                    info.firstChild = { x: childInfo.x, child: child.id, canMoveBy: childInfo.canMoveBy };\n                }\n                else if (j === 0 && childInfo.canMoveBy !== undefined && minTranslation > childInfo.canMoveBy) {\n                    minTranslation = Math.min(minTranslation, childInfo.canMoveBy || 0);\n                    info.firstChild = { x: childInfo.x, child: child.id, canMoveBy: childInfo.canMoveBy };\n                }\n                right = childBounds.right + layout.horizontalSpacing;\n            }\n            if (i === 0) {\n                rightMost = leftBounds[i].right;\n            }\n            else {\n                rightMost = Math.max(rightMost, leftBounds[i].right);\n            }\n        }\n        //Translate to same positions\n        for (var i = 0; i < leftTree.length && leftTree[i].length; i++) {\n            if (rightMost !== leftBounds[i].right) {\n                var diff = rightMost - leftBounds[i].right;\n                for (var j = 0; j < leftTree[i].length; j++) {\n                    var element = layout.nameTable[leftTree[i][j]];\n                    var elementInfo = layout.graphNodes[leftTree[i][j]];\n                    elementInfo.x += diff;\n                }\n                //leftBounds[i].x += diff;\n                //leftBounds[i].right += diff;\n            }\n            if (i === 0) {\n                bounds = { x: leftBounds[0].x, y: leftBounds[0].y, right: leftBounds[0].right, bottom: leftBounds[0].bottom };\n            }\n            else {\n                this.uniteRects(bounds, leftBounds[i]);\n            }\n        }\n        treeInfo.bounds = bounds;\n        return rightMost;\n    };\n    HierarchicalTree.prototype.alignRowsToCenter = function (layout, i, shape, treeInfo, rightX) {\n        var max;\n        var centered;\n        var diff;\n        var info = layout.graphNodes[shape.id];\n        var rows = treeInfo.rows;\n        var rightTree = treeInfo.rightTree;\n        var leftCenter = treeInfo.leftCenter;\n        var rightCenter = treeInfo.rightCenter;\n        var align = treeInfo.align;\n        var rightBounds = treeInfo.rightBounds;\n        var dimensions = treeInfo.dimensions;\n        var lev = treeInfo.level;\n        var unique = info.tree.children.length === 5 && rows[0].length === 3;\n        if (unique && i === 1) {\n            max = (rightBounds[0].right - rightBounds[0].x) >= (rightBounds[1].right - rightBounds[1].x) ? 0 : 1;\n        }\n        if (i === rows.length - 1) {\n            if (rows[i].length % 2 === 1 || unique && i === 1) {\n                centered = rightTree[i][Math.floor(rightTree[i].length / 2)];\n                //let centerObjct: INode;\n                var centerObjct = layout.nameTable[centered];\n                //let childDimension: Dimensions;\n                var centeredX = layout.graphNodes[centered].x;\n                var centeredY = layout.graphNodes[centered].y;\n                var childDimension = this.getDimensions(layout, centerObjct, centeredX, centeredY, lev + 1);\n                diff = undefined;\n                if (!align && unique) {\n                    if (max === 1) {\n                        i = 0;\n                    }\n                    diff = (rightBounds[max].x + rightBounds[max].right) / 2 - (rightBounds[i].x + rightBounds[i].right) / 2;\n                    if (i === 0) {\n                        info.mid += diff;\n                    }\n                }\n                else if (!unique && rightX !== undefined) {\n                    diff = rightX - layout.horizontalSpacing / 2 - (centeredX + childDimension.width / 2);\n                }\n                if (diff !== undefined) {\n                    this.updateRearBoundsOfTree(layout, rightTree[i], diff, dimensions);\n                }\n                if (unique) {\n                    info.mid = (rightCenter + leftCenter) / 2 + (i === 0 ? diff : 0) - dimensions.width / 2;\n                }\n                if (info.mid === undefined && layout.graphNodes[centered]) {\n                    info.mid = centeredX;\n                }\n                align = false;\n                i++;\n            }\n        }\n    };\n    HierarchicalTree.prototype.updateRearBoundsOfTree = function (layout, rightTree, diff, dimensions) {\n        for (var j = 0; j < rightTree.length; j++) {\n            var childInfo = layout.graphNodes[rightTree[j]];\n            //let child: INode = layout.nameTable[rightTree[j]];\n            childInfo.x += diff;\n            childInfo.canMoveBy += diff;\n            if (j === rightTree.length - 1) {\n                //removed child dimensions call calculation, since that is not used\n                var childBnds = {\n                    x: childInfo.x, y: childInfo.y, right: childInfo.x +\n                        dimensions.width, bottom: childInfo.y + dimensions.height\n                };\n                var intersect = this.findIntersectingLevels(layout, childBnds, childInfo.actualLevel);\n                this.updateRearBounds(layout, null, [{ rBounds: childBnds }], childInfo.actualLevel, intersect);\n            }\n        }\n    };\n    HierarchicalTree.prototype.splitRows = function (rows, leftTree, rightTree) {\n        for (var i = 0; i < rows.length; i++) {\n            leftTree[i] = [];\n            rightTree[i] = [];\n            var half = void 0;\n            half = rows[i].length;\n            if (rows[i].length % 2 !== 1) {\n                half = Math.ceil(rows[i].length / 2);\n                for (var k = 0; k < half; k++) {\n                    leftTree[i].push(rows[i][k]);\n                }\n            }\n            for (var j = leftTree[i].length; j < rows[i].length; j++) {\n                rightTree[i].push(rows[i][j]);\n            }\n        }\n    };\n    HierarchicalTree.prototype.updateVerticalTree = function (layout, shape, x, y, level, dontUpdate) {\n        //declarations\n        var child;\n        var childInfo;\n        var childBounds;\n        var childWidth;\n        var childHeight;\n        var prevBounds;\n        var bounds;\n        var actBounds;\n        var oddBounds;\n        var evenBounds;\n        //let dimensions: Dimensions = this.getDimensions(layout, shape, x, y, level);\n        var info = layout.graphNodes[shape.id];\n        var firstChild = layout.nameTable[info.tree.children[0]];\n        var h = layout.orientation.indexOf('Left') !== -1 ? true : false;\n        var factor = info.tree.type === 'Left' ? -1 : 0;\n        var right = x;\n        var bottom = y;\n        var lev = level;\n        var i;\n        var intersect;\n        var type;\n        var levels = [];\n        var oddLevels = [];\n        var canMoveBy; //let diff: number;\n        for (i = 0; i < info.tree.children.length; i++) {\n            if (info.tree.type === 'Alternate') {\n                //arrange at both left and right\n                type = (i % 2 === 0 && info.tree.children.length > 2) ? 'Left' : 'Right';\n                factor = (i % 2 === 0 && info.tree.children.length > 2) ? -1 : 0;\n            }\n            right = x + this.findOffset(layout, shape, info, type);\n            child = layout.nameTable[info.tree.children[i]];\n            childWidth = h ? child.actualSize.height : child.actualSize.width;\n            childHeight = h ? child.actualSize.width : child.actualSize.height;\n            //Update sub tree\n            childBounds = this.updateTree(layout, right + factor * childWidth, bottom, child, level + 1, undefined, true);\n            childInfo = layout.graphNodes[child.id];\n            actBounds = { x: childInfo.x, y: childInfo.y, right: childInfo.x + childWidth, bottom: childInfo.y + childHeight };\n            if (i === 0) {\n                this.uniteRects(childBounds, actBounds);\n                bounds = childBounds;\n            }\n            else {\n                this.uniteRects(bounds, childBounds);\n            }\n            //Check and adjust the space left from previous subtree/sibling\n            if (childInfo.prevBounds && !(info.tree.type === 'Alternate' && i % 2 === 1 && info.tree.children.length > 2)) {\n                canMoveBy = canMoveBy !== undefined ? Math.min(childInfo.canMoveBy, canMoveBy) : childInfo.canMoveBy;\n            }\n            //Max level of the subtree node\n            info.maxLevel = Math.max(info.maxLevel || 0, childInfo.maxLevel || 0);\n            if (!(info.tree.type === 'Alternate' && info.tree.children.length > 2 && i % 2 === 0)) {\n                if (info.tree.type === 'Alternate' && info.tree.children.length > 2) {\n                    //alternate - arrange children with even index(0,2,4,6,..) at the next level\n                    bottom = Math.max(childBounds.bottom, prevBounds.bottom) + layout.verticalSpacing / 2;\n                }\n                else {\n                    // left/right - arrange next child at the nect level(bottom)\n                    bottom = childBounds.bottom + layout.verticalSpacing / 2;\n                }\n                level = info.maxLevel;\n                levels.push({ rBounds: actBounds });\n                if (!evenBounds) {\n                    evenBounds = {\n                        x: childInfo.x, y: childInfo.y, right: childInfo.x + childWidth,\n                        bottom: childInfo.y + childHeight\n                    };\n                }\n                else {\n                    this.uniteRects(evenBounds, actBounds);\n                }\n                if (childInfo.levelBounds) {\n                    levels = levels.concat(childInfo.levelBounds);\n                }\n            }\n            else {\n                if (i !== 0) {\n                    bottom = prevBounds.bottom + layout.verticalSpacing / 2;\n                }\n                oddLevels.push({ rBounds: actBounds });\n                if (childInfo.levelBounds) {\n                    oddLevels = oddLevels.concat(childInfo.levelBounds);\n                }\n            }\n            if (i === 0) {\n                info.firstChild = { x: childInfo.x, canMoveBy: childInfo.canMoveBy, child: child.id };\n            }\n            if (this.hasChild(layout, child)) {\n                if (!info.firstChild || info.firstChild.x >= childInfo.firstChild.x) {\n                    if (childInfo.firstChild && info.firstChild.canMoveBy < childInfo.canMoveBy) {\n                        var canMoveBy_1 = info.firstChild.canMoveBy;\n                        childInfo.canMoveBy = canMoveBy_1;\n                        layout.graphNodes[info.firstChild.child].canMoveBy = canMoveBy_1;\n                        info.firstChild.canMoveBy = canMoveBy_1;\n                    }\n                    info.firstChild = {\n                        x: childInfo.firstChild.x, canMoveBy: canMoveBy !== undefined ? canMoveBy : childInfo.canMoveBy,\n                        child: child.id\n                    };\n                }\n                else if (childInfo.firstChild && childInfo.translated && info.firstChild.canMoveBy > childInfo.canMoveBy) {\n                    info.firstChild.canMoveBy = layout.graphNodes[info.firstChild.child].canMoveBy = childInfo.canMoveBy;\n                }\n            }\n            prevBounds = actBounds;\n        }\n        //To set level bounds(right most position of levels)\n        if (!dontUpdate) {\n            if (info.tree.type === 'Alternate' && info.tree.children.length > 2) {\n                oddBounds = {\n                    x: oddLevels[0].rBounds.x, y: oddLevels[0].rBounds.y,\n                    right: oddLevels[oddLevels.length - 1].rBounds.right, bottom: oddLevels[oddLevels.length - 1].rBounds.bottom\n                };\n                intersect = this.findIntersectingLevels(layout, oddBounds, lev + 1);\n                this.updateRearBounds(layout, null, oddLevels, lev + 1, intersect);\n            }\n            intersect = this.findIntersectingLevels(layout, evenBounds || bounds, lev + 1);\n            this.updateRearBounds(layout, null, evenBounds ? levels : [{ rBounds: bounds }], lev + 1, intersect);\n        }\n        else {\n            info.levelBounds = levels;\n        }\n        if (!isNaN(canMoveBy)) {\n            layout.graphNodes[firstChild.id].canMoveBy = canMoveBy;\n        }\n        info.childBounds = bounds;\n        info.mid = x;\n        return bounds;\n    };\n    HierarchicalTree.prototype.splitChildrenInRows = function (layout, shape) {\n        //let info: LayoutInfo;\n        var info = layout.graphNodes[shape.id];\n        var column;\n        column = 4;\n        var rows = [];\n        var childNodes;\n        childNodes = info.tree.children.length;\n        var children = this.extend(info.tree.children);\n        if (info.tree.rows) {\n            //let count: number;\n            var count = info.tree.children.length;\n            //let columns: number;\n            var columns = info.tree.rows;\n            if (columns % 2 === 0) {\n                column = columns;\n            }\n            else {\n                column = columns - 1;\n            }\n        }\n        else if (info.tree.children.length === 3 || info.tree.children.length === 4) {\n            column = 2;\n        }\n        else if (info.tree.children.length === 5) {\n            column = 3;\n        }\n        while (childNodes > 0) {\n            rows[rows.length] = children.splice(0, column);\n            childNodes -= column;\n            if (childNodes < column) {\n                if (childNodes % 2 === 0) {\n                    column = childNodes;\n                }\n                else if (childNodes !== 1) {\n                    column = childNodes - 1;\n                }\n                if (childNodes < column) {\n                    column = childNodes;\n                }\n            }\n        }\n        return rows;\n    };\n    HierarchicalTree.prototype.extend = function (temp) {\n        var i;\n        var dummy = [];\n        for (i = 0; i < temp.length; i++) {\n            dummy[i] = temp[i];\n        }\n        return dummy;\n    };\n    HierarchicalTree.prototype.findOffset = function (layout, shape, info, type) {\n        var offset = 0;\n        var space = (layout.orientation.indexOf('Left') !== -1) ? shape.actualSize.height :\n            shape.actualSize.width;\n        var treeType = type ? type : info.tree.type;\n        offset = info.tree.offset || 20;\n        if (info.tree.type === 'Alternate') {\n            if (offset >= layout.horizontalSpacing) {\n                offset = layout.horizontalSpacing / 2;\n            }\n        }\n        switch (treeType) {\n            case 'Left':\n                offset = space / 2 - offset;\n                break;\n            case 'Right':\n                offset = offset + space / 2;\n                break;\n        }\n        return offset;\n    };\n    HierarchicalTree.prototype.uniteRects = function (rect1, rect2) {\n        //Unite two rects\n        rect1.x = Math.min(rect1.x, rect2.x);\n        rect1.right = Math.max(rect1.right, rect2.right);\n        rect1.bottom = Math.max(rect1.bottom, rect2.bottom);\n    };\n    HierarchicalTree.prototype.spaceLeftFromPrevSubTree = function (layout, shape, bounds) {\n        //let info: LayoutInfo;\n        var info = layout.graphNodes[shape.id];\n        var dif;\n        var prevBounds; //let intersect: number[]; let k: number;\n        //let space: number;\n        var space = layout.horizontalSpacing;\n        //Find the minimum distance to move towards previous sub tree\n        for (var k = 0; k < info.intersect.length; k++) {\n            prevBounds = layout.levels[info.intersect[k]].rBounds;\n            dif = bounds.x - (prevBounds.right + space);\n            if (info.diff === undefined || dif < info.diff) {\n                info.diff = dif;\n                info.prevBounds = layout.levels[info.intersect[k]].rBounds;\n            }\n        }\n    };\n    HierarchicalTree.prototype.findIntersectingLevels = function (layout, bounds, level, actualLevel) {\n        //intersecting with exact Level\n        //let bnds: Bounds;\n        var bnds = { x: bounds.x, y: bounds.y, right: bounds.right, bottom: bounds.bottom };\n        bnds.y -= layout.verticalSpacing / 2;\n        bnds.bottom += layout.verticalSpacing / 2;\n        //let intersectingLevels: number[];\n        var intersectingLevels = [];\n        var rBounds;\n        var l;\n        l = actualLevel !== undefined ? actualLevel : level;\n        rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n        //Performance - We can consider only the intersecting levels\n        do {\n            if (rBounds && ((bnds.y < rBounds.y && bnds.bottom > rBounds.y)\n                || (bnds.y < rBounds.bottom && rBounds.bottom < bnds.bottom) ||\n                bnds.y >= rBounds.y &&\n                    bnds.bottom <= rBounds.bottom || bnds.y < rBounds.y && bnds.bottom > rBounds.bottom)) {\n                var index = 0;\n                intersectingLevels.splice(index, 0, l);\n            }\n            else if (rBounds && rBounds.bottom < bnds.y) {\n                break;\n            }\n            l--;\n            rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n        } while (l >= 0);\n        l = (actualLevel !== undefined ? actualLevel : level) + 1;\n        rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n        do {\n            if (rBounds && ((bnds.y < rBounds.y && bnds.bottom > rBounds.y) ||\n                (bnds.y < rBounds.bottom && rBounds.bottom < bnds.bottom) ||\n                bnds.y >= rBounds.y && bnds.bottom <= rBounds.bottom || bnds.y < rBounds.y && bnds.bottom > rBounds.bottom)) {\n                intersectingLevels.push(l);\n            }\n            else if (rBounds && rBounds.y > bnds.bottom) {\n                break;\n            }\n            l++;\n            rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n        } while (l <= layout.levels.length);\n        return intersectingLevels;\n    };\n    HierarchicalTree.prototype.findLevel = function (layout, bounds, level) {\n        //let bnds: Bounds;\n        var bnds = bounds;\n        var l;\n        l = 0;\n        var rBounds;\n        rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n        while (l < layout.levels.length) {\n            if (rBounds && bnds.bottom < rBounds.y) {\n                return l;\n            }\n            else {\n                l++;\n            }\n            rBounds = layout.levels[l] ? layout.levels[l].rBounds : null;\n        }\n        return l;\n    };\n    HierarchicalTree.prototype.getParentNode = function (layout, node) {\n        //Return the first parent node\n        return layout.nameTable[layout.nameTable[node.inEdges[0]].sourceID];\n    };\n    HierarchicalTree.prototype.updateEdges = function (layout, node, depth, action, nodes) {\n        //let layoutInfo: LayoutInfo;\n        var layoutInfo = layout.graphNodes[node.id];\n        var j;\n        if (node.outEdges && node.outEdges.length && (node.isExpanded || (action === DiagramAction.Render))) {\n            for (j = 0; j < node.outEdges.length; j++) {\n                //let edge: INode;\n                var edge = layout.nameTable[layout.nameTable[node.outEdges[j]].targetID];\n                if (edge && !edge.excludeFromLayout) {\n                    if (layoutInfo.tree.children.indexOf(edge.id) === -1) {\n                        layoutInfo.tree.children.push(edge.id);\n                    }\n                    if (edge.outEdges && edge.outEdges.length && edge.isExpanded) {\n                        layoutInfo.tree.hasSubTree = true;\n                    }\n                    this.updateEdges(layout, edge, depth + 1, action, nodes);\n                }\n            }\n        }\n        //set level info\n        layoutInfo.tree.level = depth;\n        //By default, orientation is horizontal for nested trees\n        if (layoutInfo.tree.hasSubTree) {\n            layoutInfo.tree.orientation = 'Horizontal';\n            layoutInfo.tree.type = 'Center';\n        }\n        //Customizing assistants and children collection\n        //Performance-Instead of reading the method everytime, we can set once and can reuse that\n        if ((layout.getLayoutInfo || layout.layoutInfo) && layout.type === 'OrganizationalChart') {\n            // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n            layout.getLayoutInfo ?\n                layout.getLayoutInfo(node, layoutInfo.tree) : updateLayoutValue(layoutInfo.tree, layout.layoutInfo, nodes, node);\n            if (layoutInfo.tree.type === 'Balanced' && layoutInfo.tree.hasSubTree) {\n                layoutInfo.tree.type = 'Center';\n                layoutInfo.tree.orientation = 'Horizontal';\n            }\n        }\n        if (layout.level && layoutInfo.tree.type !== 'Alternate' && depth >= layout.level) {\n            layoutInfo.tree.hasSubTree = false;\n        }\n    };\n    /* eslint-disable */\n    HierarchicalTree.prototype.updateAnchor = function (layout, bounds, viewPort) {\n        var node;\n        var fixedNode;\n        var width = 0;\n        var height = 0;\n        var mod = 0;\n        var yValue = 0;\n        var viewPortBounds = new Rect(0, 0, viewPort.x, viewPort.y); //let layoutBounds: Rect;\n        var layoutBounds = layout.bounds ? layout.bounds : viewPortBounds;\n        var orientation = layout.orientation;\n        //Anchor based on fixed nodes\n        if (layout.fixedNode) {\n            fixedNode = layout.nameTable[layout.fixedNode];\n            width = fixedNode.actualSize.width;\n            height = fixedNode.actualSize.height;\n            layout.anchorX = fixedNode.offsetX;\n            layout.anchorY = fixedNode.offsetY;\n            var pivot = fixedNode.pivot;\n            layout.anchorX += layout.orientation === 'RightToLeft' ? width * pivot.x : -width * pivot.x;\n            layout.anchorY += layout.orientation === 'BottomToTop' ? height * pivot.y : -height * pivot.y;\n            node = fixedNode;\n            mod = 0;\n            while (node.inEdges.length) {\n                node = this.getParentNode(layout, node);\n                mod += layout.graphNodes[node.id].subTreeTranslation || 0;\n            }\n            if (layout.orientation.indexOf('Left') !== -1) {\n                yValue = layout.graphNodes[fixedNode.id].y;\n                // eslint-disable-next-line\n                orientation === 'LeftToRight' ? layout.anchorX -= yValue : layout.anchorX += yValue;\n                layout.anchorY -= layout.graphNodes[fixedNode.id].x + mod;\n            }\n            else {\n                yValue = layout.graphNodes[fixedNode.id].y;\n                // eslint-disable-next-line\n                layout.anchorX -= layout.graphNodes[fixedNode.id].x + mod;\n                orientation === 'TopToBottom' ? layout.anchorY -= yValue : layout.anchorY += yValue;\n            }\n        }\n        else {\n            if (orientation === 'TopToBottom' || orientation === 'BottomToTop') {\n                switch (layout.horizontalAlignment) {\n                    case 'Left':\n                        layout.anchorX = (layoutBounds.x - bounds.x) + layout.margin.left;\n                        break;\n                    case 'Right':\n                        layout.anchorX = layoutBounds.x + layoutBounds.width - layout.margin.right - bounds.right;\n                        break;\n                    case 'Auto':\n                    case 'Center':\n                        layout.anchorX = layoutBounds.x + layoutBounds.width / 2 - (bounds.x + bounds.right) / 2;\n                        break;\n                }\n                switch (layout.verticalAlignment) {\n                    case 'Auto':\n                    case 'Top':\n                        var top_1;\n                        top_1 = layoutBounds.y + layout.margin.top;\n                        layout.anchorY = orientation === 'TopToBottom' ? top_1 : bounds.bottom + top_1;\n                        break;\n                    case 'Bottom':\n                        var bottom = void 0;\n                        bottom = layoutBounds.y + layoutBounds.height - layout.margin.bottom;\n                        layout.anchorY = orientation === 'TopToBottom' ? bottom - bounds.bottom : bottom;\n                        break;\n                    case 'Center':\n                        var center = void 0;\n                        center = layoutBounds.y + layoutBounds.height / 2;\n                        layout.anchorY = layout.orientation === 'TopToBottom' ?\n                            center - (bounds.y + bounds.bottom) / 2 : center + (bounds.y + bounds.bottom) / 2;\n                        break;\n                }\n            }\n            else {\n                switch (layout.horizontalAlignment) {\n                    case 'Auto':\n                    case 'Left':\n                        var left = void 0;\n                        left = layoutBounds.x + layout.margin.left;\n                        layout.anchorX = orientation === 'LeftToRight' ? left : bounds.bottom + left;\n                        break;\n                    case 'Right':\n                        var right = void 0;\n                        right = layoutBounds.x + layoutBounds.width - layout.margin.right;\n                        layout.anchorX = orientation === 'LeftToRight' ? right - bounds.bottom : right;\n                        break;\n                    case 'Center':\n                        var center = void 0;\n                        center = layoutBounds.width / 2 + layoutBounds.x;\n                        layout.anchorX = layout.orientation === 'LeftToRight' ?\n                            center - (bounds.y + bounds.bottom) / 2 : center + (bounds.y + bounds.bottom) / 2;\n                        break;\n                }\n                switch (layout.verticalAlignment) {\n                    case 'Top':\n                        layout.anchorY = layoutBounds.y + layout.margin.top - bounds.x;\n                        break;\n                    case 'Auto':\n                    case 'Center':\n                        layout.anchorY = layoutBounds.y + layoutBounds.height / 2 - (bounds.right + bounds.x) / 2;\n                        break;\n                    case 'Bottom':\n                        layout.anchorY = layoutBounds.y + layoutBounds.height - layout.margin.bottom - bounds.right;\n                        break;\n                }\n            }\n        }\n    };\n    /* eslint-enable */\n    HierarchicalTree.prototype.updateConnectors = function (layout, node, level) {\n        var i;\n        //let info: LayoutInfo;\n        //let nodeWidth: number; let nodeHeight: number; let targetWidth: number; let targetHeight: number;\n        //let length: number; let offsetLen: number; let points: PointModel[];\n        //let segments: ConnSegments;\n        var target;\n        var conn;\n        //Route out edges\n        var info = layout.graphNodes[node.id];\n        var direction;\n        if (node.outEdges.length) {\n            for (i = 0; i < node.outEdges.length; i++) {\n                conn = layout.nameTable[node.outEdges[i]];\n                conn.points = [];\n                target = layout.nameTable[conn.targetID];\n                if (conn.visible) {\n                    conn.visited = true;\n                    if (layout.getConnectorSegments) {\n                        var segments = layout.getConnectorSegments(conn);\n                    }\n                    else {\n                        if (info && info.tree.children.indexOf(conn.targetID) !== -1) {\n                            conn.segments = [];\n                            if (layout.type === 'OrganizationalChart' && conn.type === 'Orthogonal') {\n                                this.updateSegments(layout, conn, node, target, i);\n                            }\n                        }\n                    }\n                    if (target && (target.isExpanded || this.hasChild(layout, target))) {\n                        this.updateConnectors(layout, target, level + 1);\n                    }\n                }\n            }\n        }\n        if (info && info.tree.assistants.length) {\n            //In-Edge routing of assistant nodes\n            for (i = 0; i < info.tree.assistants.length; i++) {\n                target = layout.nameTable[info.tree.assistants[i]];\n                conn = layout.nameTable[target.inEdges[0]];\n                this.get3Points(layout, node, target, conn);\n                if (target.isExpanded || this.hasChild(layout, target)) {\n                    this.updateConnectors(layout, target, level + 1);\n                }\n            }\n        }\n    };\n    HierarchicalTree.prototype.updateSegments = function (layout, conn, node, target, i) {\n        var info = layout.graphNodes[node.id];\n        //Connector routing - Horizontal layout orientation\n        if (info.tree.assistants.length) {\n            //Route in-edge of child node, if the parent has assistant\n            this.updateSegmentsForHorizontalOrientation(layout, node, target, conn);\n        }\n        else {\n            //Route in-edge of child node\n            if (info.tree.orientation === 'Horizontal' && info.tree.type === 'Balanced') {\n                this.updateSegmentsForBalancedTree(layout, conn, node, target, i);\n            }\n            else {\n                if (info.tree.orientation === 'Horizontal') {\n                    this.updateSegmentsForHorizontalOrientation(layout, node, target, conn);\n                }\n                else {\n                    if (info.tree.offset < 5) {\n                        this.get5Points(layout, node, target, conn);\n                    }\n                    else {\n                        this.get3Points(layout, node, target, conn);\n                    }\n                }\n            }\n        }\n    };\n    HierarchicalTree.prototype.updateSegmentsForBalancedTree = function (layout, connector, node, target, i) {\n        var info = layout.graphNodes[node.id];\n        var center;\n        var relative;\n        if (info.tree.children.length === 5 && i > 2) {\n            relative = info.tree.children[1];\n            if (isNaN(layout.graphNodes[relative].treeWidth)) {\n                layout.graphNodes[relative].treeWidth = layout.nameTable[relative].actualSize.width;\n            }\n            var factor = i !== 3 ? 1 : -1;\n            if (layout.orientation.indexOf('Left') !== -1) {\n                center = layout.nameTable[relative].offsetY - layout.graphNodes[relative].treeWidth / 2 -\n                    (layout.verticalSpacing * factor / 2);\n            }\n            else {\n                var center_1 = layout.nameTable[relative].offsetX +\n                    layout.graphNodes[relative].treeWidth / 2 + (layout.horizontalSpacing * factor) / 2;\n            }\n            this.getSegmentsForMultipleRows(layout, node, target, connector);\n        }\n        else {\n            if (info.tree.children.length > 5) {\n                if (i < 4 || i < info.tree.rows) {\n                    this.getSegmentsForMultipleRows(layout, node, target, connector);\n                }\n                else {\n                    this.updateSegmentsForHorizontalOrientation(layout, node, target, connector);\n                }\n            }\n            else if (info.tree.children.length === 4) {\n                if (i < 2 || i < info.tree.rows) {\n                    this.getSegmentsForMultipleRows(layout, node, target, connector);\n                }\n                else {\n                    this.updateSegmentsForHorizontalOrientation(layout, node, target, connector);\n                }\n            }\n            else {\n                this.getSegmentsForMultipleRows(layout, node, target, connector);\n            }\n        }\n    };\n    HierarchicalTree.prototype.get3Points = function (layout, node, target, connector) {\n        var points = [];\n        var nodeBounds = this.getBounds(node);\n        var targetBounds = this.getBounds(target);\n        if (layout.orientation.indexOf('Top') !== -1) {\n            var startingPoint = layout.orientation.indexOf('Top') === 0 ? nodeBounds.bottomCenter :\n                nodeBounds.topCenter;\n            var endPoint = node.offsetX > target.offsetX ? targetBounds.middleRight : targetBounds.middleLeft;\n            points.push(startingPoint, { x: nodeBounds.bottomCenter.x, y: endPoint.y }, endPoint);\n        }\n        else {\n            var startingPoint = layout.orientation.indexOf('Left') === 0 ? nodeBounds.middleRight :\n                nodeBounds.middleLeft;\n            var endPoint = node.offsetY > target.offsetY ? targetBounds.bottomCenter : targetBounds.topCenter;\n            points.push(startingPoint, { x: targetBounds.bottomCenter.x, y: nodeBounds.middleRight.y }, endPoint);\n        }\n        this.getSegmentsFromPoints(points, connector);\n    };\n    HierarchicalTree.prototype.get5Points = function (layout, node, target, connector) {\n        var points = [];\n        //let layoutprop: Layout;\n        var nodeBounds = this.getBounds(node);\n        var targetBounds = this.getBounds(target);\n        //let info: LayoutInfo = layout.graphNodes[node.id];\n        var startingPoint;\n        var endPoint;\n        var horizontalSpacing;\n        var verticalSpacing;\n        if (layout.orientation.indexOf('Top') !== -1) {\n            startingPoint = (node.offsetY < target.offsetY) ? nodeBounds.bottomCenter : nodeBounds.topCenter;\n            verticalSpacing = layout.verticalSpacing / 4 * ((node.offsetY < target.offsetY) ? 1 : -1);\n            horizontalSpacing = layout.horizontalSpacing / 2 * ((node.offsetX > target.offsetX) ? 1 : -1);\n            endPoint = (node.offsetX > target.offsetX) ? targetBounds.middleRight : targetBounds.middleLeft;\n            points.push(startingPoint, { x: startingPoint.x, y: startingPoint.y + verticalSpacing }, { x: endPoint.x + horizontalSpacing, y: startingPoint.y + verticalSpacing }, { x: endPoint.x + horizontalSpacing, y: endPoint.y }, endPoint);\n        }\n        else {\n            startingPoint = (node.offsetX > target.offsetX) ? nodeBounds.middleLeft : nodeBounds.middleRight;\n            endPoint = node.offsetY > target.offsetY ? targetBounds.bottomCenter : targetBounds.topCenter;\n            horizontalSpacing = layout.horizontalSpacing / 4 * ((node.offsetX < target.offsetX) ? 1 : -1);\n            verticalSpacing = layout.verticalSpacing / 2 * ((node.offsetY > target.offsetY) ? 1 : -1);\n            points.push(startingPoint, { x: startingPoint.x + horizontalSpacing, y: startingPoint.y }, { x: startingPoint.x + horizontalSpacing, y: startingPoint.y + verticalSpacing }, { x: endPoint.x, y: startingPoint.y + verticalSpacing }, endPoint);\n        }\n        this.getSegmentsFromPoints(points, connector);\n    };\n    HierarchicalTree.prototype.getSegmentsFromPoints = function (points, connector) {\n        var segments = [];\n        var segment;\n        for (var i = 0; i < points.length - 2; i++) {\n            segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n            segment.direction = Point.direction(points[i], points[i + 1]);\n            segment.length = Point.distancePoints(points[i], points[i + 1]);\n            segments.push(segment);\n        }\n        connector.segments = segments;\n    };\n    HierarchicalTree.prototype.getSegmentsForMultipleRows = function (layout, node, target, connector) {\n        //let points: PointModel[] = [];\n        var segments = [];\n        var point;\n        var segment;\n        var targetBounds = this.getBounds(target);\n        var nodeBounds = this.getBounds(node);\n        switch (layout.orientation) {\n            case 'TopToBottom':\n                point = { x: nodeBounds.bottomCenter.x, y: (nodeBounds.bottomCenter.y + layout.verticalSpacing / 4) };\n                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                segment.direction = Point.direction(nodeBounds.bottomCenter, point);\n                segment.length = Point.distancePoints(nodeBounds.bottomCenter, point);\n                segments.push(segment);\n                break;\n            case 'BottomToTop':\n                point = { x: nodeBounds.bottomCenter.x, y: (nodeBounds.topCenter.y - layout.verticalSpacing / 4) };\n                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                segment.direction = Point.direction(nodeBounds.topCenter, point);\n                segment.length = Point.distancePoints(nodeBounds.topCenter, point);\n                segments.push(segment);\n                break;\n            case 'LeftToRight':\n                point = { x: (nodeBounds.middleRight.x + layout.verticalSpacing / 4), y: nodeBounds.middleRight.y };\n                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                segment.direction = Point.direction(nodeBounds.middleRight, point);\n                segment.length = Point.distancePoints(nodeBounds.middleRight, point);\n                segments.push(segment);\n                if (targetBounds.center.y !== nodeBounds.center.y) {\n                    var point3 = { x: (nodeBounds.middleRight.x + layout.verticalSpacing / 4), y: targetBounds.middleLeft.y };\n                    segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                    segment.direction = Point.direction(point, point3);\n                    segment.length = Point.distancePoints(point, point3);\n                    segments.push(segment);\n                }\n                break;\n            case 'RightToLeft':\n                point = { x: (nodeBounds.middleLeft.x - layout.verticalSpacing / 4), y: nodeBounds.middleRight.y };\n                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                segment.direction = Point.direction(nodeBounds.middleLeft, point);\n                segment.length = Point.distancePoints(nodeBounds.middleLeft, point);\n                segments.push(segment);\n                if (targetBounds.center.y !== nodeBounds.center.y) {\n                    var point_1 = { x: (nodeBounds.middleLeft.x - layout.verticalSpacing / 4), y: targetBounds.middleLeft.y };\n                    segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                    segment.direction = Point.direction(point_1, point_1);\n                    segment.length = Point.distancePoints(point_1, point_1);\n                    segments.push(segment);\n                }\n                break;\n        }\n        connector.segments = segments;\n    };\n    HierarchicalTree.prototype.updateSegmentsForHorizontalOrientation = function (layout, node, target, connector) {\n        var points = [];\n        var point2;\n        var segment;\n        var segments = [];\n        var nodeBounds = this.getBounds(node);\n        var targetBounds = this.getBounds(target);\n        switch (layout.orientation) {\n            case 'TopToBottom':\n                point2 = { x: nodeBounds.bottomCenter.x, y: (targetBounds.topCenter.y - layout.verticalSpacing / 2) };\n                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                segment.direction = Point.direction(nodeBounds.bottomCenter, point2);\n                segment.length = Point.distancePoints(nodeBounds.bottomCenter, point2);\n                segments.push(segment);\n                break;\n            case 'BottomToTop':\n                point2 = { x: nodeBounds.topCenter.x, y: (targetBounds.bottomCenter.y + layout.verticalSpacing / 2) };\n                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                segment.direction = Point.direction(nodeBounds.topCenter, point2);\n                segment.length = Point.distancePoints(nodeBounds.topCenter, point2);\n                segments.push(segment);\n                break;\n            case 'LeftToRight':\n                point2 = { x: (targetBounds.middleLeft.x - layout.verticalSpacing / 2), y: nodeBounds.middleRight.y };\n                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                segment.direction = Point.direction(nodeBounds.middleRight, point2);\n                segment.length = Point.distancePoints(nodeBounds.middleRight, point2);\n                segments.push(segment);\n                if (targetBounds.center.y !== nodeBounds.center.y) {\n                    var point3 = { x: (targetBounds.middleLeft.x - layout.verticalSpacing / 2), y: targetBounds.middleLeft.y };\n                    segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                    segment.direction = Point.direction(point2, point3);\n                    segment.length = Point.distancePoints(point2, point3);\n                    segments.push(segment);\n                }\n                break;\n            case 'RightToLeft':\n                point2 = { x: (targetBounds.middleRight.x + layout.verticalSpacing / 2), y: nodeBounds.middleRight.y };\n                segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                segment.direction = Point.direction(nodeBounds.middleLeft, point2);\n                segment.length = Point.distancePoints(nodeBounds.middleLeft, point2);\n                segments.push(segment);\n                if (targetBounds.center.y !== nodeBounds.center.y) {\n                    var point = { x: (targetBounds.middleRight.x + layout.verticalSpacing / 2), y: targetBounds.middleLeft.y };\n                    segment = new OrthogonalSegment(connector, 'segments', { type: 'Orthogonal' }, true);\n                    segment.direction = Point.direction(point2, point);\n                    segment.length = Point.distancePoints(point2, point);\n                    segments.push(segment);\n                }\n                break;\n        }\n        connector.segments = segments;\n        return points;\n    };\n    HierarchicalTree.prototype.updateNodes = function (layout, node, mod, update, dx, dy) {\n        var i;\n        var child;\n        var width;\n        var height;\n        var offsetX;\n        var offsetY;\n        if (node && !node.excludeFromLayout) {\n            width = node.actualSize.width;\n            height = node.actualSize.height;\n            offsetX = layout.anchorX;\n            offsetY = layout.anchorY;\n            /*Performance - instead of checking conditions for every node, we can make the layout related\n            conditions once and we can reuse them*/\n            if (layout.orientation === 'LeftToRight') {\n                offsetX += layout.graphNodes[node.id].y + width / 2;\n                offsetY += layout.graphNodes[node.id].x + mod + height / 2;\n            }\n            else if (layout.orientation === 'RightToLeft') {\n                offsetX -= layout.graphNodes[node.id].y + width / 2;\n                offsetY += layout.graphNodes[node.id].x + mod + height / 2;\n            }\n            else if (layout.orientation === 'TopToBottom') {\n                offsetX += layout.graphNodes[node.id].x + mod + width / 2;\n                offsetY += layout.graphNodes[node.id].y + height / 2;\n            }\n            else {\n                offsetX += layout.graphNodes[node.id].x + mod + width / 2;\n                offsetY -= layout.graphNodes[node.id].y + height / 2;\n            }\n            if (layout.graphNodes) {\n                dx = dx ? dx : 0;\n                dy = dy ? dy : 0;\n                offsetX += dx;\n                offsetY += dy;\n                if (!this.isAnimation) {\n                    node.offsetX = offsetX;\n                    node.offsetY = offsetY;\n                }\n            }\n            var objects = { id: node.id, differenceX: offsetX - node.offsetX, differenceY: offsetY - node.offsetY };\n            layout.objects.push(objects);\n            var list = [];\n            if (this.hasChild(layout, node)) {\n                for (i = 0; i < layout.graphNodes[node.id].tree.children.length; i++) {\n                    child = layout.nameTable[layout.graphNodes[node.id].tree.children[i]];\n                    this.updateNodes(layout, child, mod + (layout.graphNodes[node.id].subTreeTranslation || 0), update, dx, dy);\n                    list.push(child);\n                }\n            }\n            if (layout.graphNodes[node.id].tree.assistants.length) {\n                for (i = 0; i < layout.graphNodes[node.id].tree.assistants.length; i++) {\n                    child = layout.nameTable[layout.graphNodes[node.id].tree.assistants[i]];\n                    this.updateNodes(layout, child, mod + (layout.graphNodes[node.id].subTreeTranslation || 0), null, dx, dy);\n                }\n            }\n        }\n    };\n    return HierarchicalTree;\n}());\nexport { HierarchicalTree };\n"]},"metadata":{},"sourceType":"module"}